<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="关于React的Container&amp;Presentational Component模型结构分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>关于React的Container&amp;Presentational Component模型结构分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/oeh1wsqop/",
				"appid": "1613049289050283", 
				"title": "关于React的Container&amp;Presentational Component模型结构分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/taly8stynj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ibcku2coijf/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f&text=%e5%85%b3%e4%ba%8eReact%e7%9a%84Container%26Presentational%20Component%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f&text=%e5%85%b3%e4%ba%8eReact%e7%9a%84Container%26Presentational%20Component%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f&title=%e5%85%b3%e4%ba%8eReact%e7%9a%84Container%26Presentational%20Component%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f&is_video=false&description=%e5%85%b3%e4%ba%8eReact%e7%9a%84Container%26Presentational%20Component%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%85%b3%e4%ba%8eReact%e7%9a%84Container%26Presentational%20Component%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f&title=%e5%85%b3%e4%ba%8eReact%e7%9a%84Container%26Presentational%20Component%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f&title=%e5%85%b3%e4%ba%8eReact%e7%9a%84Container%26Presentational%20Component%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f&title=%e5%85%b3%e4%ba%8eReact%e7%9a%84Container%26Presentational%20Component%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2foeh1wsqop%2f&title=%e5%85%b3%e4%ba%8eReact%e7%9a%84Container%26Presentational%20Component%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">关于React的Container&amp;Presentational Component模型结构分析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-29" itemprop="datePublished">2019-01-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e之前翻译了两篇关于Container\x26amp;Presentational Component模型的文章，一篇是\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007786080\x22\x3e基础的Container和Component的定义\x3c\/a\x3e，另外一篇是\x3ca href=\x22https:\/\/medium.com\/@dan_abramov\/smart-and-dumb-components-7ca2f9a7c7d0#.tbdzewheo\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e进阶版\x3c\/a\x3e，因为翻译的太烂，感觉有很多错误，所以只放原文链接。\x3c\/p\x3e\n\x3cp\x3e在这里我想讨论一下我自己对这个模型的一些想法。\x3c\/p\x3e\n\x3cp\x3e注：便于书写，下面统一把Container\x26amp;Presentational Components模型翻译为\x3cstrong\x3e容器\x26amp;展示组件模型\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e注：下面图片中的components文件夹指的是都是Presentational Components文件夹。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e基于容器\x26amp;展示组件模型的目录结构\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eRound 1:\x3c\/h2\x3e\n\x3cp\x3e刚接触React和这个模型的时候，我认为项目的结构应该是这样子的：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVG95U?w=435\x26amp;h=320\x22 src=\x22https:\/\/static.alili.tech\/img\/bVG95U?w=435\x26amp;h=320\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eContainers下面一个jsx文件就代表一个页面，负责和后台交互，负责和Redux进行connect，负责传递数据给component。在Router里面放入对应页面的Container\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eComponents下面每个jsx文件就代表页面里面所有的渲染的内容，负责渲染，和把从container拿到的数据放到页面上\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e顶多把一些基础的component分离出来，便于以后进行复用\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e可是才用两天，就知道这么搞有多么坑了。容器组件模型的目的就是\x3cstrong\x3e复用性，可读性，可维护性\x3c\/strong\x3e，然而虽然我们很成功的把后台交互和页面展示分离开了，但是看到这么多代码放在一起，我没有感觉到任何\x3cstrong\x3e复用性，可读性，可维护性\x3c\/strong\x3e，那么多代码，而且都混合了业务逻辑，你让我怎么复用，理解，维护？！\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHaeq?w=240\x26amp;h=192\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHaeq?w=240\x26amp;h=192\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eRound 2:\x3c\/h2\x3e\n\x3cp\x3e痛定思痛，决定改一下，针对之前的问题，面向Component做出修改。基本的想法是这样子的：尽量拆分component，避免把所有的东西都放到一个文件里面; 拆出可复用的组件，便于组件的复用；拆分逻辑复杂的模块，增加模块的可读性和可维护性；所以关键字就是“拆、拆、拆”，拆出大好前程，拆出一片蓝天...\x3c\/p\x3e\n\x3cp\x3e所以结构成了这样...\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHamb?w=555\x26amp;h=448\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHamb?w=555\x26amp;h=448\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e整个代码结构复杂很多，不过主要的改变就是把基础组件分离出来(Sidebar, Form之类)，每一个页面也精细化。我们可以更清晰的看出每个文件负责的功能，同时像Sidebar, Form这些组件都可以被多个不同的父组件调用。\x3c\/p\x3e\n\x3cp\x3e当然，这不是结束，虽然上面的方法解决了我们\x3cstrong\x3e可读性，可复用性，可维护性\x3c\/strong\x3e，但是也只针对Component的组件，\x3cstrong\x3e在container中，依然会有很多的代码堆积在哪里\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e而且还有一个很严重的问题，先看一个代码逻辑结构图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHcm4?w=474\x26amp;h=328\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHcm4?w=474\x26amp;h=328\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e我们现在的数据是通过Container来进行管理的，所以如果Images需要图片数据，那么就需要通过Container-\x26gt;Top-\x26gt;Slide-\x26gt;Images这样进行数据的传递，然而这些图片数据跟中间的组件没有任何关系，但是他们还必须把数据传递给下一级，就像公交车上，从后门递公交卡到前门刷一样，中间的人的心理OS其实是：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHcaP?w=219\x26amp;h=230\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHcaP?w=219\x26amp;h=230\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e当然代码是没有情感的，不会觉得厌烦，但是由于中间每一层都需要传递数据给下层，一旦某些数据发生改变，就造成了\x3cstrong\x3e中间层级的重新render，浪费了浏览器性能的同时，增大了调试的难度\x3c\/strong\x3e，而且接收数据的组件还要考虑“中间那些牲口们有没有动我的数据”？！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eRound 3:\x3c\/h2\x3e\n\x3cp\x3e所以，为什么一定要让顶级的container作为唯一的数据来源呢？\x3c\/p\x3e\n\x3cp\x3e读了\x3ca href=\x22https:\/\/medium.com\/@dan_abramov\/smart-and-dumb-components-7ca2f9a7c7d0#.f8yr4ndk4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这篇文章\x3c\/a\x3e就知道，Container是可以包含多个Container和Presentational Component的，所以我们可以适当的提升一些组件成为container。如果老板一个人直接管理很多员工，绝对会乱七八糟的，这个情况下，leader这个角色就应运而生，我们修改一下文件的结构：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHcsU?w=819\x26amp;h=640\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHcsU?w=819\x26amp;h=640\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e现在，代码的逻辑结构就变成这样子：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHcPO?w=543\x26amp;h=440\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHcPO?w=543\x26amp;h=440\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e作为\x3cstrong\x3e老板的index.jsx\x3c\/strong\x3e，现在主要负责：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e页面的基础配置，比如页面的title，比如页面整体内容结构的配置\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e页面全局的数据的获取和修改\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e作为\x3cstrong\x3eleader的Top, Content\x3c\/strong\x3e，现在主要负责:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e和index.jsx进行沟通，获取基础配置和数据\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e负责整合需要的container和component\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e获取和处理自己对应模块的数据，并传递给下一层级\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e作为\x3cstrong\x3epresentational component的组件\x3c\/strong\x3e，就负责获取数据并进行渲染\x3c\/p\x3e\n\x3cp\x3e这么做的好处是，分离了原来顶层container的繁重的任务，使代码更加清晰。同时减少了从数据源到叶子结点的层级，减少了中间层级的数量和不必要的重复渲染。\x3c\/p\x3e\n\x3cp\x3e当然，或许你会觉得之前举的那个栗子，只有index.js下面有一层container，或许中间节点还是太多。其实container里面可以包含container，根据需要，可以创建很多container在不同的层级上。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eRound 4\x3c\/h2\x3e\n\x3cp\x3eView-Container-Presentational Component模型？这个名字是我自己编的，其实是对上面说的结构的一个分离。我也看到过有人说\x3ca href=\x22https:\/\/www.zhihu.com\/question\/53376712\/answer\/134868475?group_id=790720199480463360#comment-200493710\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePage-Module-Component模型\x3c\/a\x3e，反正大概思路都是一样的。\x3c\/p\x3e\n\x3cp\x3e其实和上面的差不多，但是作为一个大老板来说，肯定不能和一堆下级员工混在一起，位置看起来有点混乱不说，\x22客人\x22(比如Router)来了，还不容易认。所以，我觉得应该给老板一个包间，让老板们在自己的包间中，听候客人的调遣。所以做出一点改动：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHcI8?w=817\x26amp;h=640\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHcI8?w=817\x26amp;h=640\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eOkay，这就是我的最终方案，相比于最早的结构，这个结构更清晰，每个模块负责的功能也更明确，代码可读性、可复用性和可维护性更高。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHcJ8?w=224\x26amp;h=204\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHcJ8?w=224\x26amp;h=204\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e最后自问自答环节\x3c\/h2\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eContainer和Presentational Component的区别？\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3eContainer通常会负责和服务端的沟通，还有一些业务逻辑的处理。他们通常只负责获取数据，处理数据，处理状态，但\x3cstrong\x3e一般\x3c\/strong\x3e不知道如何去展示页面。\x3c\/p\x3e\n\x3cp\x3ePresentational Component通常不知道数据如何获取，也不知道这些数据是做什么用的，更不知道怎么去操作这些数据，他们\x3cstrong\x3e一般\x3c\/strong\x3e只负责页面的渲染，把领导给的数据放到对应的位置。\x3c\/p\x3e\n\x3cp\x3e当然一切都不是绝对的，容器组件模型只是一个指导思想，并不是一个硬性的规定，你可以按照自己的需要来进行改变。而且我在上面给了两个\x3cstrong\x3e一般\x3c\/strong\x3e，也是说明这些不是绝对的。Container当然可以负责页面的展示，老板虽然大部分负责方向和管理，但谁规定老板就不能写代码的？！同样，Component也可以负责获取数据，举个栗子，一个地图的component，或者一个天气预报的component，他们可以从固定的地方获取数据，并把数据渲染出来。\x3c\/p\x3e\n\x3chr\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eContainer可以包含Presentational Component？Presentational Component是否可以包含Container?\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3eContainer可以包含Container和Component。\x3c\/p\x3e\n\x3cp\x3e但是Component一般不包含Container，虽然\x3ca href=\x22https:\/\/medium.com\/@dan_abramov\/smart-and-dumb-components-7ca2f9a7c7d0#.f8yr4ndk4\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这篇文章\x3c\/a\x3e的作者最后改口说，Component也可以包含Container，但是个人觉得应该保证component的纯净性，如果包含Container，那么就不再纯净，或许在复用的时候，会出现偏差的情况。\x3c\/p\x3e\n\x3cp\x3e当然像我之前所说，一切都不是硬性规定，或许也只是因为我接触的少所以没有想到Presentational component需要包含container的情况，一切都根据自己的需要进行调整。\x3c\/p\x3e\n\x3chr\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e如何知道什么时候要用container，什么时候要用Presentational component?\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e一般Presentational component应该是纯净(Pure)的，也就是说父级传给他的数据不变，那么渲染出来的结果也不应该发生任何变化。所以当一个组件需要业务逻辑处理，业务数据获取，那么可以考虑使用container。如果不需要这些东西，那么考虑使用Presentational component。当然，像之前所说的地图，天气预报，按照逻辑他们也属于component，但是他们也获取数据，处理数据。\x3c\/p\x3e\n\x3cp\x3e当不知道该使用container还是Presentational component的时候，那么或许你在这个时候并不需要去决定这个问题。这种情况下，可以直接使用container来写，当你的container变得越来越复杂，代码量越来越多，逻辑越来越不清晰的时候，你就可以考虑分离处更多的container和Presentational component来。\x3c\/p\x3e\n\x3chr\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e如果这篇文章指导的方向有错误，里面有很多的问题，该怎么办？\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e欢迎指出和讨论，一切问题都会认真回答，虚心接受。\x3c\/p\x3e\n\x3cp\x3e如果我也答不出来，那我会当作没看到...\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHcOv?w=224\x26amp;h=225\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHcOv?w=224\x26amp;h=225\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>关于React的Container&amp;Presentational Component模型结构分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007875199">https://segmentfault.com/a/1190000007875199</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/oeh1wsqop/" target="_blank">https://alili.tech/archive/oeh1wsqop/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/t42iv2yle7e/">2016-我的前端之路:工具化与工程化<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/xlhryjzdso/">2016年总结--成长<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/4wvjfeus9ur/">2016年末总结，我的前端之路<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/w7062tmcw3/">3D 视差效果<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/5jt1iw1t77b/">AlloyTouch实战--60行代码搞定QQ看点资料卡<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/kquf0fxkw2j/">ES6，你不得不学！<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/r5b6g4133jh/">Emmet-前端开发神器<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/5dbaikv4emi/">FreeCodeCamp中级算法题答案<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/iuyeljg6lm/">JSONP是什么<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/23ftsgrtzzc/">JS中的观察者模式(发布订阅)<aside class="dates">2019-01-29</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>