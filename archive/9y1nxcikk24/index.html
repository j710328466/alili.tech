<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue源码解析－事件机制"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue源码解析－事件机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9y1nxcikk24/",
				"appid": "1613049289050283", 
				"title": "vue源码解析－事件机制 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-12T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/givlb1h7m0m/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hu3fihohisk/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f&text=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f&text=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f&is_video=false&description=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9y1nxcikk24%2f&title=vue%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90%ef%bc%8d%e4%ba%8b%e4%bb%b6%e6%9c%ba%e5%88%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue源码解析－事件机制</h1><div class="meta"><div class="postdate"><time datetime="2019-01-12" itemprop="datePublished">2019-01-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e上一章没什么经验。直接写了组件机制。感觉涉及到的东西非常的多，不是很方便讲。今天看了下vue的关于事件的机制。有一些些体会。写出来。大家一起纠正，分享。源码都是基于最新的Vue.js v2.3.0。下面我们来看看vue中的事件机制：\x3cbr\x3e  老样子还是先上一段贯穿全局的代码，常见的事件机制demo都会包含在这段代码中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;app\x26quot;\x3e\n  \x3cdiv id=\x26quot;test1\x26quot; @click=\x26quot;click1\x26quot;\x3eclick1\x3c\/div\x3e\n  \x3cdiv id=\x26quot;test2\x26quot; @click.stop=\x26quot;click2\x26quot;\x3eclick2\x3c\/div\x3e\n  \x3cmy-component v-on:click.native=\x26quot;nativeclick\x26quot; v-on:componenton=\x26quot;parentOn\x26quot;\x3e\n  \x3c\/my-component\x3e\n\x3c\/div\x3e\n\x3c\/body\x3e\n\x3cscript src=\x26quot;vue.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript type=\x26quot;text\/javascript\x26quot;\x3e\nvar Child = {\n  template: \x27\x3cdiv\x3eA custom component!\x3c\/div\x3e\x27\n} \nVue.component(\x27my-component\x27, {\n  name: \x27my-component\x27,\n  template: \x27\x3cdiv\x3eA custom component!\x3cdiv @click.stop=\x26quot;toParent\x26quot;\x3etest click\x3c\/div\x3e\x3c\/div\x3e\x27,\n  components: {\n    Child:Child\n  },\n  created(){\n    console.log(this);\n  },\n  methods: {\n    toParent(){\n      this.$emit(\x27componenton\x27,\x27toParent\x27)\n    }\n  },\n  mounted(){\n    console.log(this);\n  }\n})\n  new Vue({\n  el: \x27#app\x27,\n  data: function () {\n    return {\n      heihei:{name:3333},\n      a:1\n    }\n  },\n  components: {\n    Child:Child\n  },\n  methods: {\n    click1(){\n      alert(\x27click1\x27)\n    },\n    click2(){\n      alert(\x27click2\x27)\n    },\n    nativeclick(){\n      alert(\x27nativeclick\x27)\n    },\n    parentOn(value){\n      alert(value)\n    }\n  }\n})\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22test1\x22\x3c\/span\x3e @\x3cspan class=\x22hljs-attr\x22\x3eclick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22click1\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eclick1\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22test2\x22\x3c\/span\x3e @\x3cspan class=\x22hljs-attr\x22\x3eclick.stop\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22click2\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eclick2\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emy-component\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-on:click.native\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22nativeclick\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-on:componenton\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22parentOn\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3emy-component\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22vue.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\/javascript\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Child = {\n  \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;A custom component!\x26lt;\/div\x26gt;\x27\x3c\/span\x3e\n} \nVue.component(\x3cspan class=\x22hljs-string\x22\x3e\x27my-component\x27\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27my-component\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;A custom component!\x26lt;div @click.stop=\x22toParent\x22\x26gt;test click\x26lt;\/div\x26gt;\x26lt;\/div\x26gt;\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ecomponents\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eChild\x3c\/span\x3e:Child\n  },\n  created(){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n    toParent(){\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$emit(\x3cspan class=\x22hljs-string\x22\x3e\x27componenton\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27toParent\x27\x3c\/span\x3e)\n    }\n  },\n  mounted(){\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  }\n})\n  \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-attr\x22\x3eheihei\x3c\/span\x3e:{\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e3333\x3c\/span\x3e},\n      \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    }\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3ecomponents\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3eChild\x3c\/span\x3e:Child\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n    click1(){\n      alert(\x3cspan class=\x22hljs-string\x22\x3e\x27click1\x27\x3c\/span\x3e)\n    },\n    click2(){\n      alert(\x3cspan class=\x22hljs-string\x22\x3e\x27click2\x27\x3c\/span\x3e)\n    },\n    nativeclick(){\n      alert(\x3cspan class=\x22hljs-string\x22\x3e\x27nativeclick\x27\x3c\/span\x3e)\n    },\n    parentOn(value){\n      alert(value)\n    }\n  }\n})\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的demo中一共有四个事件。基本涵盖了vue中最经典的事件的四种情况\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e普通html元素上的事件\x3c\/h2\x3e\n\x3cp\x3e好吧。想想我们还是一个个来看。如果懂vue组件相关的机制会更容易懂。那么首先我们看看最简单的第一、二个(两个事件只差了个修饰符)：\x3cbr\x3e\x3ccode\x3e\x26lt;div id=\x22test1\x22 @click=\x22click1\x22\x26gt;click1\x26lt;\/div\x26gt;\x3c\/code\x3e\x3cbr\x3e这是简单到不能在简单的一个点击事件。\x3cbr\x3e我们来看看建立这么一个简单的点击事件，vue中发生了什么。\x3cbr\x3e1:new Vue()中调用了initState(vue):看代码\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initState (vm) {\n  vm._watchers = [];\n  var opts = vm.$options;\n  if (opts.props) { initProps(vm, opts.props); }\n  if (opts.methods) { initMethods(vm, opts.methods); }\/\/初始化事件\n  if (opts.data) {\n    initData(vm);\n  } else {\n    observe(vm._data = {}, true \/* asRootData *\/);\n  }\n  if (opts.computed) { initComputed(vm, opts.computed); }\n  if (opts.watch) { initWatch(vm, opts.watch); }\n}\n\n\/\/接着看看initMethods\nfunction initMethods (vm, methods) {\n  var props = vm.$options.props;\n  for (var key in methods) {\n    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);\/\/调用了bind方法，我们再看看bind\n    {\n      if (methods[key] == null) {\n        warn(\n          \x26quot;method \\\x26quot;\x26quot; \x2b key \x2b \x26quot;\\\x26quot; has an undefined value in the component definition. \x26quot; \x2b\n          \x26quot;Did you reference the function correctly?\x26quot;,\n          vm\n        );\n      }\n      if (props \x26amp;\x26amp; hasOwn(props, key)) {\n        warn(\n          (\x26quot;method \\\x26quot;\x26quot; \x2b key \x2b \x26quot;\\\x26quot; has already been defined as a prop.\x26quot;),\n          vm\n        );\n      }\n    }\n  }\n}\n\n\/\/我们接着看看bind\n\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l \x3e 1\n        ? fn.apply(ctx, arguments)\/\/通过返回函数修饰了事件的回调函数。绑定了事件回调函数的this。并且让参数自定义。更加的灵活\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  \/\/ record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitState\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm\x3c\/span\x3e) \x3c\/span\x3e{\n  vm._watchers = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e opts = vm.$options;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.props) { initProps(vm, opts.props); }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.methods) { initMethods(vm, opts.methods); }\x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化事件\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.data) {\n    initData(vm);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    observe(vm._data = {}, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* asRootData *\/\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.computed) { initComputed(vm, opts.computed); }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (opts.watch) { initWatch(vm, opts.watch); }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/接着看看initMethods\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitMethods\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm, methods\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e props = vm.$options.props;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e methods) {\n    vm[key] = methods[key] == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e ? noop : bind(methods[key], vm);\x3cspan class=\x22hljs-comment\x22\x3e\/\/调用了bind方法，我们再看看bind\x3c\/span\x3e\n    {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (methods[key] == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        warn(\n          \x3cspan class=\x22hljs-string\x22\x3e\x22method \\\x22\x22\x3c\/span\x3e \x2b key \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\\\x22 has an undefined value in the component definition. \x22\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x22Did you reference the function correctly?\x22\x3c\/span\x3e,\n          vm\n        );\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (props \x26amp;\x26amp; hasOwn(props, key)) {\n        warn(\n          (\x3cspan class=\x22hljs-string\x22\x3e\x22method \\\x22\x22\x3c\/span\x3e \x2b key \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\\\x22 has already been defined as a prop.\x22\x3c\/span\x3e),\n          vm\n        );\n      }\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/我们接着看看bind\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebind\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3efn, ctx\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eboundFn\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e l = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e l\n      ? l \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n        ? fn.apply(ctx, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e\/\/通过返回函数修饰了事件的回调函数。绑定了事件回调函数的this。并且让参数自定义。更加的灵活\x3c\/span\x3e\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ record original fn length\x3c\/span\x3e\n  boundFn._length = fn.length;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e boundFn\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总的来说。vue初始化的时候，将method中的方法代理到vue[key]的同时修饰了事件的回调函数。绑定了作用域。\x3c\/p\x3e\n\x3cp\x3e2:vue进入compile环节需要将该div变成ast(抽象语法树）。当编译到该div时经过核心函数genHandler：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function genHandler (\n  name,\n  handler\n) {\n  if (!handler) {\n    return \x27function(){}\x27\n  }\n\n  if (Array.isArray(handler)) {\n    return (\x26quot;[\x26quot; \x2b (handler.map(function (handler) { return genHandler(name, handler); }).join(\x27,\x27)) \x2b \x26quot;]\x26quot;)\n  }\n\n  var isMethodPath = simplePathRE.test(handler.value);\n  var isFunctionExpression = fnExpRE.test(handler.value);\n\n  if (!handler.modifiers) {\n    return isMethodPath || isFunctionExpression\/\/假如没有修饰符。直接返回回调函数\n      ? handler.value\n      : (\x26quot;function($event){\x26quot; \x2b (handler.value) \x2b \x26quot;}\x26quot;) \/\/ inline statement\n  } else {\n    var code = \x27\x27;\n    var genModifierCode = \x27\x27;\n    var keys = [];\n    for (var key in handler.modifiers) {\n      if (modifierCode[key]) {\n        genModifierCode \x2b= modifierCode[key];\/\/处理修饰符数组，例如.stop就在回调函数里加入event.stopPropagation()再返回。实现修饰的目的\n        \/\/ left\/right\n        if (keyCodes[key]) {\n          keys.push(key);\n        }\n      } else {\n        keys.push(key);\n      }\n    }\n    if (keys.length) {\n      code \x2b= genKeyFilter(keys);\n    }\n    \/\/ Make sure modifiers like prevent and stop get executed after key filtering\n    if (genModifierCode) {\n      code \x2b= genModifierCode;\n    }\n    var handlerCode = isMethodPath\n      ? handler.value \x2b \x27($event)\x27\n      : isFunctionExpression\n        ? (\x26quot;(\x26quot; \x2b (handler.value) \x2b \x26quot;)($event)\x26quot;)\n        : handler.value;\n    return (\x26quot;function($event){\x26quot; \x2b code \x2b handlerCode \x2b \x26quot;}\x26quot;)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3egenHandler\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\n  name,\n  handler\n\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!handler) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27function(){}\x27\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Array.isArray(handler)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22[\x22\x3c\/span\x3e \x2b (handler.map(function (handler) { \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e genHandler(name, handler); }).\x3cspan class=\x22hljs-keyword\x22\x3ejoin\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27,\x27\x3c\/span\x3e)) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22]\x22\x3c\/span\x3e)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isMethodPath = simplePathRE.test(handler.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isFunctionExpression = fnExpRE.test(handler.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!handler.modifiers) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e isMethodPath || isFunctionExpression\x3cspan class=\x22hljs-comment\x22\x3e\/\/假如没有修饰符。直接返回回调函数\x3c\/span\x3e\n      ? handler.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\n      : (\x3cspan class=\x22hljs-string\x22\x3e\x22function($event){\x22\x3c\/span\x3e \x2b (handler.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22}\x22\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ inline statement\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e code = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e genModifierCode = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e keys = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e handler.modifiers) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (modifierCode[key]) {\n        genModifierCode \x2b= modifierCode[key];\x3cspan class=\x22hljs-comment\x22\x3e\/\/处理修饰符数组，例如.stop就在回调函数里加入event.stopPropagation()再返回。实现修饰的目的\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ left\/right\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (keyCodes[key]) {\n          keys.push(key);\n        }\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        keys.push(key);\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (keys.length) {\n      code \x2b= genKeyFilter(keys);\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Make sure modifiers like prevent and stop get executed after key filtering\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (genModifierCode) {\n      code \x2b= genModifierCode;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e handlerCode = isMethodPath\n      ? handler.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27($event)\x27\x3c\/span\x3e\n      : isFunctionExpression\n        ? (\x3cspan class=\x22hljs-string\x22\x3e\x22(\x22\x3c\/span\x3e \x2b (handler.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22)($event)\x22\x3c\/span\x3e)\n        : handler.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x22function($event){\x22\x3c\/span\x3e \x2b code \x2b handlerCode \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22}\x22\x3c\/span\x3e)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3egenHandler函数简单明了，如果事件函数有修饰符。就处理完修饰符，添加修饰符对应的函数语句。再返回。这个过程还会单独对native修饰符做特殊处理。这个等会说。compile完后自然就render。我们看看render函数中这块区域长什么样子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22_c(\x27div\x27,{attrs:{\x26quot;id\x26quot;:\x26quot;test1\x26quot;},on:{\x26quot;click\x26quot;:click1\x22}}\x22,[_v(\x26quot;click1\x26quot;)]),_v(\x26quot; \x26quot;),_c(\x27div\x27,{attrs:{\x26quot;id\x26quot;:\x26quot;test2\x26quot;},on:{\x26quot;click\x26quot;:function($event){$event.stopPropagation();click2($event)\x22}}\x22}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xquery\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e_c(\x3cspan class=\x22hljs-string\x22\x3e\x27div\x27\x3c\/span\x3e,{attrs:{\x3cspan class=\x22hljs-string\x22\x3e\x22id\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22test1\x22\x3c\/span\x3e},on:{\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e:click1\x22}}\x22,[_v(\x3cspan class=\x22hljs-string\x22\x3e\x22click1\x22\x3c\/span\x3e)]),_v(\x3cspan class=\x22hljs-string\x22\x3e\x22 \x22\x3c\/span\x3e),_c(\x3cspan class=\x22hljs-string\x22\x3e\x27div\x27\x3c\/span\x3e,{attrs:{\x3cspan class=\x22hljs-string\x22\x3e\x22id\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x22test2\x22\x3c\/span\x3e},on:{\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e:function($event){$event.stopPropagation();click2($event)\x22}}\x22}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一目了然。最后在虚拟dom－》真实dom的时候。会调用核心函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add$1 (\n  event,\n  handler,\n  once$$1,\n  capture,\n  passive\n) {\n  if (once$$1) {\n    var oldHandler = handler;\n    var _target = target$1; \/\/ save current target element in closure\n    handler = function (ev) {\n      var res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, handler, capture, _target);\n      }\n    };\n  }\n  target$1.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { capture: capture, passive: passive }\/\/此处绑定点击事件\n      : capture\n  );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3efunction add\x3cspan class=\x22hljs-variable\x22\x3e$1\x3c\/span\x3e (\n  event,\n  handler,\n  once$\x3cspan class=\x22hljs-variable\x22\x3e$1\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-keyword\x22\x3ecapture\x3c\/span\x3e,\n  passive\n) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (once$\x3cspan class=\x22hljs-variable\x22\x3e$1\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldHandler = handler;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _target = target\x3cspan class=\x22hljs-variable\x22\x3e$1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ save current target element in closure\x3c\/span\x3e\n    handler = function (ev) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = arguments.length === 1\n        ? oldHandler(ev)\n        : oldHandler.apply(null, arguments);\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (res !== null) {\n        remove\x3cspan class=\x22hljs-variable\x22\x3e$2\x3c\/span\x3e(event, handler, \x3cspan class=\x22hljs-keyword\x22\x3ecapture\x3c\/span\x3e, _target);\n      }\n    };\n  }\n  target\x3cspan class=\x22hljs-variable\x22\x3e$1\x3c\/span\x3e.addEventListener(\n    event,\n    handler,\n    supportsPassive\n      ? { \x3cspan class=\x22hljs-keyword\x22\x3ecapture\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ecapture\x3c\/span\x3e, passive: passive }\x3cspan class=\x22hljs-comment\x22\x3e\/\/此处绑定点击事件\x3c\/span\x3e\n      : \x3cspan class=\x22hljs-keyword\x22\x3ecapture\x3c\/span\x3e\n  );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e组件上的事件\x3c\/h2\x3e\n\x3cp\x3e好了下面就是接下来的组件上的点击事件了。可以预感到他走的和普通的html元素应该是不同的道路。事实也是如此：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cmy-component v-on:click.native=\x26quot;nativeclick\x26quot; v-on:componenton=\x26quot;parentOn\x26quot;\x3e\n  \x3c\/my-component\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode\x3e\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3emy\x3c\/span\x3e-component v-\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e:click.native=\x3cspan class=\x22hljs-string\x22\x3e\x22nativeclick\x22\x3c\/span\x3e v-\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e:componenton=\x3cspan class=\x22hljs-string\x22\x3e\x22parentOn\x22\x3c\/span\x3e\x26gt;\n  \x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3emy\x3c\/span\x3e-component\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最简单的一个例子。两个事件的区别就是一个有.native的修饰符。我们来看看官方.native的作用：在原生dom上绑定事件。好吧。很简单。我们跟随源码看看有何不同。这里可以往回看看我少的可怜的上一章组件机制。vue中的组件都是扩展的vue的一个新实例。在compile结束的时候你还是可以发现他也是类似的一个样子。如下图：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22_c(\x27my-component\x27,{on:{\x26quot;componenton\x26quot;:parentOn},nativeOn:{\x26quot;click\x26quot;:function($event){nativeclick($event)\x22}}\x22\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e_c(\x3cspan class=\x22hljs-string\x22\x3e\x27my-component\x27\x3c\/span\x3e,{on:{\x3cspan class=\x22hljs-string\x22\x3e\x22componenton\x22\x3c\/span\x3e:parentOn},nativeOn:{\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e($event)\x3c\/span\x3e\x3c\/span\x3e{nativeclick($event)\x22}}\x22\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到加了.native修饰符的会被放入nativeOn的数组中。等待后续特殊处理。等不及了。我们直接来看看特殊处理。render函数在执行时。如果遇到组件。看过上一章的可以知道。会执行\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (isUndef(Ctor)) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n\n  \/\/ plain options object: turn it into a constructor\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  \/\/ if at this stage it\x27s not a constructor or an async component factory,\n  \/\/ reject.\n  if (typeof Ctor !== \x27function\x27) {\n    {\n      warn((\x26quot;Invalid Component definition: \x26quot; \x2b (String(Ctor))), context);\n    }\n    return\n  }\n\n  \/\/ async component\n  if (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    if (Ctor === undefined) {\n      \/\/ return nothing if this is indeed an async component\n      \/\/ wait for the callback to trigger parent update.\n      return\n    }\n  }\n\n  \/\/ resolve constructor options in case global mixins are applied after\n  \/\/ component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  \/\/ transform component v-model data into props \x26amp; events\n  if (isDef(data.model)) {\n    transformModel(Ctor.options, data);\n  }\n\n  \/\/ extract props\n  var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n  \/\/ functional component\n  if (isTrue(Ctor.options.functional)) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  \/\/ extract listeners, since these needs to be treated as\n  \/\/ child component listeners instead of DOM listeners\n  var listeners = data.on;\/\/listeners缓存data.on的函数。这里就是componenton事件\n  \/\/ replace with listeners with .native modifier\n  data.on = data.nativeOn;\/\/正常的data.on会被native修饰符的事件所替换\n\n  if (isTrue(Ctor.options.abstract)) {\n    \/\/ abstract components do not keep anything\n    \/\/ other than props \x26amp; listeners\n    data = {};\n  }\n\n  \/\/ merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  \/\/ return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\x26quot;vue-component-\x26quot; \x2b (Ctor.cid) \x2b (name ? (\x26quot;-\x26quot; \x2b name) : \x27\x27)),\n    data, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lasso\x22\x3e\x3ccode\x3efunction createComponent (\n  Ctor,\n  \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e,\n  context,\n  children,\n  \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e\n) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(Ctor)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e baseCtor = context.$options._base;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ plain options object: turn it into a constructor\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if at this stage it\x27s not a constructor or an async component factory,\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ reject.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeof Ctor !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n    {\n      warn((\x3cspan class=\x22hljs-string\x22\x3e\x22Invalid Component definition: \x22\x3c\/span\x3e \x2b (\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e(Ctor))), context);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ async component\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(Ctor.cid)) {\n    Ctor = resolveAsyncComponent(Ctor, baseCtor, context);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Ctor === undefined) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return nothing if this is indeed an async component\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ wait for the callback to trigger parent update.\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ resolve constructor options in case global mixins are applied after\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ component constructor creation\x3c\/span\x3e\n  resolveConstructorOptions(Ctor);\n\n  \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e || {};\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ transform component v-model data into props \x26amp; events\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.model)) {\n    transformModel(Ctor.options, \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e);\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ extract props\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e propsData = extractPropsFromVNodeData(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e, Ctor, \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ functional component\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isTrue(Ctor.options.functional)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e createFunctionalComponent(Ctor, propsData, \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e, context, children)\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ extract listeners, since these needs to be treated as\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ child component listeners instead of DOM listeners\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e listeners = \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e;\x3cspan class=\x22hljs-comment\x22\x3e\/\/listeners缓存data.on的函数。这里就是componenton事件\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ replace with listeners with .native modifier\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e.nativeOn;\x3cspan class=\x22hljs-comment\x22\x3e\/\/正常的data.on会被native修饰符的事件所替换\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isTrue(Ctor.options.abstract)) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ abstract components do not keep anything\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ other than props \x26amp; listeners\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e = {};\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ merge component management hooks onto the placeholder node\x3c\/span\x3e\n  mergeHooks(\x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ return a placeholder vnode\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e name = Ctor.options.name || \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e vnode = \x3cspan class=\x22hljs-literal\x22\x3enew\x3c\/span\x3e VNode(\n    (\x3cspan class=\x22hljs-string\x22\x3e\x22vue-component-\x22\x3c\/span\x3e \x2b (Ctor.cid) \x2b (name ? (\x3cspan class=\x22hljs-string\x22\x3e\x22-\x22\x3c\/span\x3e \x2b name) : \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)),\n    \x3cspan class=\x22hljs-built_in\x22\x3edata\x3c\/span\x3e, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3etag\x3c\/span\x3e, children: children }\n  );\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e整段代码关于事件核心操作：\x3c\/p\x3e\n\x3cp\x3evar listeners = data.on;\/\/listeners缓存data.on的函数。这里就是componenton事件\x3cbr\x3e  \/\/ replace with listeners with .native modifier\x3cbr\x3e  data.on = data.nativeOn;\/\/正常的data.on会被native修饰符的事件所替换\x3c\/p\x3e\n\x3cp\x3e经过这两句话。.native修饰符的事件会被放在data.on上面。接下来data.on上的事件（这里就是nativeclick）会按普通的html事件往下走。最后执行target.add(\x27\x27,\x27\x27\x27)挂上原生的事件。而先前的data.on上的被缓存在listeneners的事件就没着么愉快了。接下来他会在组件init的时候。它会进入一下分支：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initEvents (vm) {\n  vm._events = Object.create(null);\n  vm._hasHookEvent = false;\n  \/\/ init parent attached events\n  var listeners = vm.$options._parentListeners;\n  if (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\nfunction updateComponentListeners (\n  vm,\n  listeners,\n  oldListeners\n) {\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);\n}\n\nfunction add (event, fn, once$$1) {\n  if (once$$1) {\n    target.$once(event, fn);\n  } else {\n    target.$on(event, fn);\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitEvents\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(vm)\x3c\/span\x3e \x3c\/span\x3e{\n  vm._events = Object.create(\x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e);\n  vm._hasHookEvent = \x3cspan class=\x22hljs-keyword\x22\x3efalse\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ init parent attached events\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e listeners = vm.$options._parentListeners;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (listeners) {\n    updateComponentListeners(vm, listeners);\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateComponentListeners\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(\n  vm,\n  listeners,\n  oldListeners\n)\x3c\/span\x3e \x3c\/span\x3e{\n  target = vm;\n  updateListeners(listeners, oldListeners || {}, add, remove$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, vm);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(event, fn, once$$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (once$$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    target.$once(event, fn);\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    target.$on(event, fn);\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e发现组件上的没有.native的修饰符调用的是$on方法。这个好熟悉。进入到\x3ccode\x3e$on,$emit\x3c\/code\x3e大致想到是一个典型的观察者模式的事件。看看相关\x3ccode\x3e$on,$emit\x3c\/code\x3e代码。我加点注解：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype.$on = function (event, fn) {\n    var this$1 = this;\n\n    var vm = this;\n    if (Array.isArray(event)) {\n      for (var i = 0, l = event.length; i \x3c l; i\x2b\x2b) {\n        this$1.$on(event[i], fn);\n      }\n    } else {\n      (vm._events[event] || (vm._events[event] = [])).push(fn);\/\/存入事件\n      \/\/ optimize hook:event cost by using a boolean flag marked at registration\n      \/\/ instead of a hash lookup\n      if (hookRE.test(event)) {\n        vm._hasHookEvent = true;\n      }\n    }\n    return vm\n  };\n\nVue.prototype.$emit = function (event) {\n    var vm = this;\n    console.log(vm);\n    {\n      var lowerCaseEvent = event.toLowerCase();\n      if (lowerCaseEvent !== event \x26amp;\x26amp; vm._events[lowerCaseEvent]) {\n        tip(\n          \x26quot;Event \\\x26quot;\x26quot; \x2b lowerCaseEvent \x2b \x26quot;\\\x26quot; is emitted in component \x26quot; \x2b\n          (formatComponentName(vm)) \x2b \x26quot; but the handler is registered for \\\x26quot;\x26quot; \x2b event \x2b \x26quot;\\\x26quot;. \x26quot; \x2b\n          \x26quot;Note that HTML attributes are case-insensitive and you cannot use \x26quot; \x2b\n          \x26quot;v-on to listen to camelCase events when using in-DOM templates. \x26quot; \x2b\n          \x26quot;You should probably use \\\x26quot;\x26quot; \x2b (hyphenate(event)) \x2b \x26quot;\\\x26quot; instead of \\\x26quot;\x26quot; \x2b event \x2b \x26quot;\\\x26quot;.\x26quot;\n        );\n      }\n    }\n    var cbs = vm._events[event];\n    console.log(cbs);\n    if (cbs) {\n      cbs = cbs.length \x3e 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i \x3c l; i\x2b\x2b) {\n        cbs[i].apply(vm, args);／／当emit的时候调用该事件。注意上面说的vue在初始化的守候。用bind修饰了事件函数。所以组件上挂载的事件都是在父作用域中的\n      }\n    }\n    return vm\n  };\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3eVue.prototype.$\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e = function (\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e, fn) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e$\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Array.isArray(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.length; i \x26lt; l; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e$\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e$\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e[i], fn);\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      (vm._events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e] || (vm._events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e] = [])).push(fn);\x3cspan class=\x22hljs-comment\x22\x3e\/\/存入事件\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ optimize hook:event cost by using a boolean flag marked at registration\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ instead of a hash lookup\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hookRE.test(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e)) {\n        vm._hasHookEvent = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vm\n  };\n\nVue.prototype.$emit = function (\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n    console.log(vm);\n    {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e lowerCaseEvent = \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e.toLowerCase();\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (lowerCaseEvent !== \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e \x26amp;\x26amp; vm._events[lowerCaseEvent]) {\n        tip(\n          \x3cspan class=\x22hljs-string\x22\x3e\x22Event \\\x22\x22\x3c\/span\x3e \x2b lowerCaseEvent \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\\\x22 is emitted in component \x22\x3c\/span\x3e \x2b\n          (formatComponentName(vm)) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 but the handler is registered for \\\x22\x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\\\x22. \x22\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x22Note that HTML attributes are case-insensitive and you cannot use \x22\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x22v-on to listen to camelCase events when using in-DOM templates. \x22\x3c\/span\x3e \x2b\n          \x3cspan class=\x22hljs-string\x22\x3e\x22You should probably use \\\x22\x22\x3c\/span\x3e \x2b (hyphenate(\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e)) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\\\x22 instead of \\\x22\x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22\\\x22.\x22\x3c\/span\x3e\n        );\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cbs = vm._events[\x3cspan class=\x22hljs-keyword\x22\x3eevent\x3c\/span\x3e];\n    console.log(cbs);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cbs) {\n      cbs = cbs.length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e ? toArray(cbs) : cbs;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = toArray(arguments, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = cbs.length; i \x26lt; l; i\x2b\x2b) {\n        cbs[i].apply(vm, args);／／当emit的时候调用该事件。注意上面说的vue在初始化的守候。用bind修饰了事件函数。所以组件上挂载的事件都是在父作用域中的\n      }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vm\n  };\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看了上面的\x3cspan class=\x22MathJax_Preview\x22\x3e\x3c\/span\x3e\x3cspan class=\x22MathJax\x22 id=\x22MathJax-Element-1-Frame\x22 tabindex=\x220\x22 style=\x22\x22\x3e\x3cnobr\x3e\x3cspan class=\x22math\x22 id=\x22MathJax-Span-1\x22 role=\x22math\x22 style=\x22width: 1.55em; display: inline-block;\x22\x3e\x3cspan style=\x22display: inline-block; position: relative; width: 1.267em; height: 0px; font-size: 121%;\x22\x3e\x3cspan style=\x22position: absolute; clip: rect(1.873em, 1001.21em, 2.786em, -1000em); top: -2.479em; left: 0em;\x22\x3e\x3cspan class=\x22mrow\x22 id=\x22MathJax-Span-2\x22\x3e\x3cspan class=\x22mi\x22 id=\x22MathJax-Span-3\x22 style=\x22font-family: STIXGeneral-Italic;\x22\x3eo\x3c\/span\x3e\x3cspan class=\x22mi\x22 id=\x22MathJax-Span-4\x22 style=\x22font-family: STIXGeneral-Italic;\x22\x3en\x3c\/span\x3e\x3cspan class=\x22mo\x22 id=\x22MathJax-Span-5\x22 style=\x22font-family: STIXGeneral-Regular;\x22\x3e,\x3c\/span\x3e\x3c\/span\x3e\x3cspan style=\x22display: inline-block; width: 0px; height: 2.479em;\x22\x3e\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3cspan style=\x22display: inline-block; overflow: hidden; vertical-align: -0.237em; border-left: 0px solid; width: 0px; height: 0.838em;\x22\x3e\x3c\/span\x3e\x3c\/span\x3e\x3c\/nobr\x3e\x3c\/span\x3e\x3cscript type=\x22math\/tex\x22 id=\x22MathJax-Element-1\x22\x3eon,\x3c\/script\x3eemit用法下面这个demo也就瞬间秒解了（一个经常用的非父子组件通信）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var bus = new Vue()\n\/\/ 触发组件 A 中的事件\nbus.$emit(\x27id-selected\x27, 1)\n\/\/ 在组件 B 创建的钩子中监听事件\nbus.$on(\x27id-selected\x27, function (id) {\n  \/\/ ...\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bus = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 触发组件 A 中的事件\x3c\/span\x3e\nbus.$emit(\x3cspan class=\x22hljs-string\x22\x3e\x27id-selected\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在组件 B 创建的钩子中监听事件\x3c\/span\x3e\nbus.$on(\x3cspan class=\x22hljs-string\x22\x3e\x27id-selected\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(id)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e是不是豁然开朗。\x3c\/p\x3e\n\x3cp\x3e又到了愉快的总结时间了。segementfault的编辑器真难用。内容多就卡。哎。烦。卡的时间够看好多肥皂剧了。\x3cbr\x3e总的来说。vue对于事件有两个底层的处理逻辑。\x3cbr\x3e1:普通html元素和在组件上挂了.native修饰符的事件。最终EventTarget.addEventListener() 挂载事件\x3cbr\x3e2:组件上的，vue实例上的事件会调用原型上的\x3ccode\x3e$on,$emit\x3c\/code\x3e（包括一些其他api \x3ccode\x3e$off,$once\x3c\/code\x3e等等）\x3c\/p\x3e\n\x3cp\x3e荆轲刺秦王。下次见\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue源码解析－事件机制</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009750348">https://segmentfault.com/a/1190000009750348</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9y1nxcikk24/" target="_blank">https://alili.tech/archive/9y1nxcikk24/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/sj57jxyoook/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（上）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/qsw902j95k/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（下）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/nnpmjlot58j/">IndexedDB使用与出坑指南<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/alvlbas9oai/">JS事件模型<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/u0pzym8k36o/">JS练习实例--编写经典小游戏俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/khwpyk5yz8q/">JavaScript 事件代理和委托<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/kuocl6lc3n/">JavaScript 版俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/n8bk54lyrf/">Promise学习:基础入门<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/7bk7u30qncb/">Redux 入坑进阶 - 源码解析<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/853kqfmqmf7/">Snap.svg 基本知识入门<aside class="dates">2019-02-03</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>