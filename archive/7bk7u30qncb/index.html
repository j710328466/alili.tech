<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Redux 入坑进阶 - 源码解析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Redux 入坑进阶 - 源码解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/7bk7u30qncb/",
				"appid": "1613049289050283", 
				"title": "Redux 入坑进阶 - 源码解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-03T02:30:40"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/853kqfmqmf7/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/n8bk54lyrf/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f&text=Redux%20%e5%85%a5%e5%9d%91%e8%bf%9b%e9%98%b6%20-%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f&text=Redux%20%e5%85%a5%e5%9d%91%e8%bf%9b%e9%98%b6%20-%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f&title=Redux%20%e5%85%a5%e5%9d%91%e8%bf%9b%e9%98%b6%20-%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f&is_video=false&description=Redux%20%e5%85%a5%e5%9d%91%e8%bf%9b%e9%98%b6%20-%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Redux%20%e5%85%a5%e5%9d%91%e8%bf%9b%e9%98%b6%20-%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f&title=Redux%20%e5%85%a5%e5%9d%91%e8%bf%9b%e9%98%b6%20-%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f&title=Redux%20%e5%85%a5%e5%9d%91%e8%bf%9b%e9%98%b6%20-%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f&title=Redux%20%e5%85%a5%e5%9d%91%e8%bf%9b%e9%98%b6%20-%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7bk7u30qncb%2f&title=Redux%20%e5%85%a5%e5%9d%91%e8%bf%9b%e9%98%b6%20-%20%e6%ba%90%e7%a0%81%e8%a7%a3%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Redux 入坑进阶 - 源码解析</h1><div class="meta"><div class="postdate"><time datetime="2019-02-03" itemprop="datePublished">2019-02-03</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\n\x3cp\x3e原文链接：\x3ca href=\x22https:\/\/github.com\/ecmadao\/Coding-Guide\/blob\/master\/Notes\/React\/Redux\/Redux%E5%85%A5%E5%9D%91%E8%BF%9B%E9%98%B6-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/ecmadao\/Co...\x3c\/a\x3e\x3cbr\x3e转载请注明出处\x3c\/p\x3e\n\x3cp\x3e本文不涉及redux的使用方法，因此可能更适合使用过redux的玩家翻阅?\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e预热\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3eredux 函数内部包含了大量\x3ca href=\x22https:\/\/llh911001.gitbooks.io\/mostly-adequate-guide-chinese\/content\/ch4.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e柯里化函数\x3c\/a\x3e以及\x3ca href=\x22https:\/\/llh911001.gitbooks.io\/mostly-adequate-guide-chinese\/content\/ch5.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e代码组合\x3c\/a\x3e思想\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e柯里化函数（\x3ccode\x3ecurry\x3c\/code\x3e）\x3c\/h4\x3e\n\x3cp\x3e通俗的来讲，可以用一句话概括柯里化函数：返回函数的函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ example\nconst funcA = (a) =\x3e {\n  return const funcB = (b) =\x3e {\n    return a \x2b b\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ example\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e funcA = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e funcB = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eb\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a \x2b b\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述的\x3ccode\x3efuncA\x3c\/code\x3e函数接收一个参数，并返回同样接收一个参数的\x3ccode\x3efuncB\x3c\/code\x3e函数。\x3c\/p\x3e\n\x3cp\x3e柯里化函数有什么好处呢？\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e避免了给一个函数传入大量的参数--我们可以通过柯里化来构建类似上例的函数嵌套，将参数的代入分离开，更有利于调试\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e降低耦合度和代码冗余，便于复用\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e举个栗子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 已知listA, listB两个Array，都由int组成，需要筛选出两个Array的交集\nconst listA = [1, 2, 3, 4, 5];\nconst listB = [2, 3, 4];\n\nconst checkIfDataExist = (list) =\x3e {\n  return (target) =\x3e {\n    return list.some(value =\x3e value === target)\n  };\n};\n\/\/ 调用一次checkIfDataExist函数，并将listA作为参数传入，来构建一个新的函数。\n\/\/ 而新函数的作用则是：检查传入的参数是否存在于listA里\nconst ifDataExist = checkIfDataExist(listA);\n\n\/\/ 使用新函数来对listB里的每一个元素进行筛选\nconst intersectionList = listB.filter(value =\x3e ifDataExist(value));\nconsole.log(intersectionList); \/\/ [2, 3, 4]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 已知listA, listB两个Array，都由int组成，需要筛选出两个Array的交集\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e listA = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e];\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e listB = [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e];\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e checkIfDataExist = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3elist\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e list.some(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e =\x26gt;\x3c\/span\x3e value === target)\n  };\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用一次checkIfDataExist函数，并将listA作为参数传入，来构建一个新的函数。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 而新函数的作用则是：检查传入的参数是否存在于listA里\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ifDataExist = checkIfDataExist(listA);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用新函数来对listB里的每一个元素进行筛选\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e intersectionList = listB.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3evalue\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ifDataExist(value));\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(intersectionList); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [2, 3, 4]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e代码组合（\x3ccode\x3ecompose\x3c\/code\x3e）\x3c\/h4\x3e\n\x3cp\x3e代码组合就像是数学中的结合律：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const compose = (f, g) =\x3e {\n  return (x) =\x3e {\n    return f(g(x));\n  };\n};\n\/\/ 还可以再简洁点\nconst compose = (f, g) =\x3e (x) =\x3e f(g(x));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e compose = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ef, g\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e f(g(x));\n  };\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 还可以再简洁点\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e compose = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ef, g\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e (x) =\x26gt; f(g(x));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过这样函数之间的组合，可以大大增加可读性，效果远大于嵌套一大堆的函数调用，并且我们可以随意更改函数的调用顺序\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eRedux\x3c\/h2\x3e\n\x3ch4\x3e\x3ccode\x3ecombineReducers\x3c\/code\x3e\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 回顾一下combineReducers的使用格式\n\n\/\/ 两个reducer\nconst todos = (state = INIT.todos, action) =\x3e {\n  \/\/ ....\n};\nconst filterStatus = (state = INIT.filterStatus, action) =\x3e {\n  \/\/ ...\n};\n\nconst appReducer = combineReducers({\n  todos,\n  filterStatus\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 回顾一下combineReducers的使用格式\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 两个reducer\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e todos = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate = INIT.todos, action\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ....\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e filterStatus = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estate = INIT.filterStatus, action\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e appReducer = combineReducers({\n  todos,\n  filterStatus\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cp\x3e还记得\x3ccode\x3ecombineReducers\x3c\/code\x3e的黑魔法吗？即：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e传入的Object参数中，对象的\x3ccode\x3ekey\x3c\/code\x3e与\x3ccode\x3evalue\x3c\/code\x3e所代表的\x3ccode\x3ereducer function\x3c\/code\x3e同名\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e各个\x3ccode\x3ereducer function\x3c\/code\x3e的名称和需要传入该reducer的\x3ccode\x3estate\x3c\/code\x3e参数同名\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e源码标注解读（省略部分）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default function combineReducers(reducers) {\n  \/\/ 第一次筛选，参数reducers为Object\n  \/\/ 筛选掉reducers中不是function的键值对\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {}\n  for (var i = 0; i \x3c reducerKeys.length; i\x2b\x2b) {\n    var key = reducerKeys[i];\n    if (typeof reducers[key] === \x27function\x27) {\n      finalReducers[key] = reducers[key]\n    }\n  }\n\n  var finalReducerKeys = Object.keys(finalReducers)\n\n  \/\/ 二次筛选，判断reducer中传入的值是否合法（!== undefined）\n  \/\/ 获取筛选完之后的所有key\n  var sanityError\n  try {\n    \/\/ assertReducerSanity函数用于遍历finalReducers中的reducer，检查传入reducer的state是否合法\n    assertReducerSanity(finalReducers)\n  } catch (e) {\n    sanityError = e\n  }\n  \n  \/\/ 返回一个function。该方法接收state和action作为参数\n  return function combination(state = {}, action) {\n    \/\/ 如果之前的判断reducers中有不法值，则抛出错误\n    if (sanityError) {\n      throw sanityError\n    }\n    \/\/ 如果不是production环境则抛出warning\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action)\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    var hasChanged = false\n    var nextState = {}\n    \/\/ 遍历所有的key和reducer，分别将reducer对应的key所代表的state，代入到reducer中进行函数调用\n    for (var i = 0; i \x3c finalReducerKeys.length; i\x2b\x2b) {\n      var key = finalReducerKeys[i]\n      var reducer = finalReducers[key]\n      \/\/ 这也就是为什么说combineReducers黑魔法--要求传入的Object参数中，reducer function的名称和要和state同名的原因\n      var previousStateForKey = state[key]\n      var nextStateForKey = reducer(previousStateForKey, action)\n      \/\/ 如果reducer返回undefined则抛出错误\n      if (typeof nextStateForKey === \x27undefined\x27) {\n        var errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      \/\/ 将reducer返回的值填入nextState\n      nextState[key] = nextStateForKey\n      \/\/ 如果任一state有更新则hasChanged为true\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    return hasChanged ? nextState : state\n  }\n}\n\n\/\/ 检查传入reducer的state是否合法\nfunction assertReducerSanity(reducers) {\n  Object.keys(reducers).forEach(key =\x3e {\n    var reducer = reducers[key]\n    \/\/ 遍历全部reducer，并给它传入(undefined, action)\n    \/\/ 当第一个参数传入undefined时，则为各个reducer定义的默认参数\n    var initialState = reducer(undefined, { type: ActionTypes.INIT })\n    \n    \/\/ ActionTypes.INIT几乎不会被定义，所以会通过switch的default返回reducer的默认参数。如果没有指定默认参数，则返回undefined，抛出错误\n    if (typeof initialState === \x27undefined\x27) {\n      throw new Error(\n        `Reducer \x26quot;${key}\x26quot; returned undefined during initialization. ` \x2b\n        `If the state passed to the reducer is undefined, you must ` \x2b\n        `explicitly return the initial state. The initial state may ` \x2b\n        `not be undefined.`\n      )\n    }\n\n    var type = \x27@@redux\/PROBE_UNKNOWN_ACTION_\x27 \x2b Math.random().toString(36).substring(7).split(\x27\x27).join(\x27.\x27)\n    if (typeof reducer(undefined, { type }) === \x27undefined\x27) {\n      throw new Error(\n        `Reducer \x26quot;${key}\x26quot; returned undefined when probed with a random type. ` \x2b\n        `Don\x27t try to handle ${ActionTypes.INIT} or other actions in \x26quot;redux\/*\x26quot; ` \x2b\n        `namespace. They are considered private. Instead, you must return the ` \x2b\n        `current state for any unknown actions, unless it is undefined, ` \x2b\n        `in which case you must return the initial state, regardless of the ` \x2b\n        `action type. The initial state may not be undefined.`\n      )\n    }\n  })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecombineReducers\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ereducers\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一次筛选，参数reducers为Object\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 筛选掉reducers中不是function的键值对\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reducerKeys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(reducers);\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e finalReducers = {}\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; reducerKeys.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = reducerKeys[i];\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e reducers[key] === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      finalReducers[key] = reducers[key]\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e finalReducerKeys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(finalReducers)\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 二次筛选，判断reducer中传入的值是否合法（!== undefined）\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取筛选完之后的所有key\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sanityError\n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ assertReducerSanity函数用于遍历finalReducers中的reducer，检查传入reducer的state是否合法\x3c\/span\x3e\n    assertReducerSanity(finalReducers)\n  } \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e (e) {\n    sanityError = e\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回一个function。该方法接收state和action作为参数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecombination\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estate = {}, action\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果之前的判断reducers中有不法值，则抛出错误\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sanityError) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e sanityError\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果不是production环境则抛出warning\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e hasChanged = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nextState = {}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 遍历所有的key和reducer，分别将reducer对应的key所代表的state，代入到reducer中进行函数调用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; finalReducerKeys.length; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = finalReducerKeys[i]\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reducer = finalReducers[key]\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这也就是为什么说combineReducers黑魔法--要求传入的Object参数中，reducer function的名称和要和state同名的原因\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e previousStateForKey = state[key]\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nextStateForKey = reducer(previousStateForKey, action)\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果reducer返回undefined则抛出错误\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e nextStateForKey === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e errorMessage = getUndefinedStateErrorMessage(key, action)\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(errorMessage)\n      }\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将reducer返回的值填入nextState\x3c\/span\x3e\n      nextState[key] = nextStateForKey\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果任一state有更新则hasChanged为true\x3c\/span\x3e\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hasChanged ? nextState : state\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检查传入reducer的state是否合法\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eassertReducerSanity\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ereducers\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(reducers).forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ekey\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reducer = reducers[key]\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 遍历全部reducer，并给它传入(undefined, action)\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当第一个参数传入undefined时，则为各个reducer定义的默认参数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e initialState = reducer(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: ActionTypes.INIT })\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ActionTypes.INIT几乎不会被定义，所以会通过switch的default返回reducer的默认参数。如果没有指定默认参数，则返回undefined，抛出错误\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e initialState === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n        \x3cspan class=\x22hljs-string\x22\x3e`Reducer \x22\x3cspan class=\x22hljs-subst\x22\x3e${key}\x3c\/span\x3e\x22 returned undefined during initialization. `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`If the state passed to the reducer is undefined, you must `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`explicitly return the initial state. The initial state may `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`not be undefined.`\x3c\/span\x3e\n      )\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e type = \x3cspan class=\x22hljs-string\x22\x3e\x27@@redux\/PROBE_UNKNOWN_ACTION_\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random().toString(\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e).substring(\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e).split(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e).join(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e reducer(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e, { type }) === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n        \x3cspan class=\x22hljs-string\x22\x3e`Reducer \x22\x3cspan class=\x22hljs-subst\x22\x3e${key}\x3c\/span\x3e\x22 returned undefined when probed with a random type. `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`Don\x27t try to handle \x3cspan class=\x22hljs-subst\x22\x3e${ActionTypes.INIT}\x3c\/span\x3e or other actions in \x22redux\/*\x22 `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`namespace. They are considered private. Instead, you must return the `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`current state for any unknown actions, unless it is undefined, `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`in which case you must return the initial state, regardless of the `\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e`action type. The initial state may not be undefined.`\x3c\/span\x3e\n      )\n    }\n  })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3ccode\x3ecreateStore\x3c\/code\x3e\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 回顾下使用方法\nconst store = createStore(reducers, state, enhance);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 回顾下使用方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = createStore(reducers, state, enhance);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e源码标注解读（省略部分）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 对于未知的action.type，reducer必须返回默认的参数state。这个ActionTypes.INIT就可以用来监测当reducer传入未知type的action时，返回的state是否合法\nexport var ActionTypes = {\n  INIT: \x27@@redux\/INIT\x27\n}\n\nexport default function createStore(reducer, initialState, enhancer) {\n  \/\/ 检查你的state和enhance参数有没有传反\n  if (typeof initialState === \x27function\x27 \x26amp;\x26amp; typeof enhancer === \x27undefined\x27) {\n    enhancer = initialState\n    initialState = undefined\n  }\n  \/\/ 如果有传入合法的enhance，则通过enhancer再调用一次createStore\n  if (typeof enhancer !== \x27undefined\x27) {\n    if (typeof enhancer !== \x27function\x27) {\n      throw new Error(\x27Expected the enhancer to be a function.\x27)\n    }\n    return enhancer(createStore)(reducer, initialState)\n  }\n\n  if (typeof reducer !== \x27function\x27) {\n    throw new Error(\x27Expected the reducer to be a function.\x27)\n  }\n\n  var currentReducer = reducer\n  var currentState = initialState\n  var currentListeners = []\n  var nextListeners = currentListeners\n  var isDispatching = false \/\/ 是否正在分发事件\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n\n  \/\/ 我们在action middleware中经常使用的getState()方法，返回当前state\n  function getState() {\n    return currentState\n  }\n\n  \/\/ 注册listener，同时返回一个取消事件注册的方法。当调用store.dispatch的时候调用listener\n  function subscribe(listener) {\n    if (typeof listener !== \x27function\x27) {\n      throw new Error(\x27Expected listener to be a function.\x27)\n    }\n\n    var isSubscribed = true\n\n    ensureCanMutateNextListeners()\n    nextListeners.push(listener)\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return\n      }\n\n      isSubscribed = false\n      \/\/ 从nextListeners中去除掉当前listener\n      ensureCanMutateNextListeners()\n      var index = nextListeners.indexOf(listener)\n      nextListeners.splice(index, 1)\n    }\n  }\n\n  \/\/ dispatch方法接收的action是个对象，而不是方法。\n  \/\/ 这个对象实际上就是我们自定义action的返回值，因为dispatch的时候，已经调用过我们的自定义action了，比如 dispatch(addTodo())\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error(\n        \x27Actions must be plain objects. \x27 \x2b\n        \x27Use custom middleware for async actions.\x27\n      )\n    }\n\n    if (typeof action.type === \x27undefined\x27) {\n      throw new Error(\n        \x27Actions may not have an undefined \x26quot;type\x26quot; property. \x27 \x2b\n        \x27Have you misspelled a constant?\x27\n      )\n    }\n    \/\/ 调用dispatch的时候只能一个个调用，通过dispatch判断调用的状态\n    if (isDispatching) {\n      throw new Error(\x27Reducers may not dispatch actions.\x27)\n    }\n\n    try {\n      isDispatching = true\n      currentState = currentReducer(currentState, action)\n    } finally {\n      isDispatching = false\n    }\n    \/\/ 遍历调用各个linster\n    var listeners = currentListeners = nextListeners\n    for (var i = 0; i \x3c listeners.length; i\x2b\x2b) {\n      listeners[i]()\n    }\n\n    return action\n  }\n  \/\/ Replaces the reducer currently used by the store to calculate the state.\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== \x27function\x27) {\n      throw new Error(\x27Expected the nextReducer to be a function.\x27)\n    }\n\n    currentReducer = nextReducer\n    dispatch({ type: ActionTypes.INIT })\n  }\n  \/\/ 当create store的时候，reducer会接受一个type为ActionTypes.INIT的action，使reducer返回他们默认的state，这样可以快速的形成默认的state的结构\n  dispatch({ type: ActionTypes.INIT })\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对于未知的action.type，reducer必须返回默认的参数state。这个ActionTypes.INIT就可以用来监测当reducer传入未知type的action时，返回的state是否合法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ActionTypes = {\n  \x3cspan class=\x22hljs-attr\x22\x3eINIT\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27@@redux\/INIT\x27\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateStore\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ereducer, initialState, enhancer\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检查你的state和enhance参数有没有传反\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e initialState === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e enhancer === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n    enhancer = initialState\n    initialState = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果有传入合法的enhance，则通过enhancer再调用一次createStore\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e enhancer !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e enhancer !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Expected the enhancer to be a function.\x27\x3c\/span\x3e)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e enhancer(createStore)(reducer, initialState)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e reducer !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Expected the reducer to be a function.\x27\x3c\/span\x3e)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e currentReducer = reducer\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e currentState = initialState\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e currentListeners = []\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nextListeners = currentListeners\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isDispatching = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是否正在分发事件\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eensureCanMutateNextListeners\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice()\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我们在action middleware中经常使用的getState()方法，返回当前state\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetState\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e currentState\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注册listener，同时返回一个取消事件注册的方法。当调用store.dispatch的时候调用listener\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esubscribe\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e listener !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Expected listener to be a function.\x27\x3c\/span\x3e)\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isSubscribed = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n\n    ensureCanMutateNextListeners()\n    nextListeners.push(listener)\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eunsubscribe\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isSubscribed) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n      }\n\n      isSubscribed = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从nextListeners中去除掉当前listener\x3c\/span\x3e\n      ensureCanMutateNextListeners()\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index = nextListeners.indexOf(listener)\n      nextListeners.splice(index, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dispatch方法接收的action是个对象，而不是方法。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个对象实际上就是我们自定义action的返回值，因为dispatch的时候，已经调用过我们的自定义action了，比如 dispatch(addTodo())\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edispatch\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eaction\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isPlainObject(action)) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n        \x3cspan class=\x22hljs-string\x22\x3e\x27Actions must be plain objects. \x27\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e\x27Use custom middleware for async actions.\x27\x3c\/span\x3e\n      )\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e action.type === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n        \x3cspan class=\x22hljs-string\x22\x3e\x27Actions may not have an undefined \x22type\x22 property. \x27\x3c\/span\x3e \x2b\n        \x3cspan class=\x22hljs-string\x22\x3e\x27Have you misspelled a constant?\x27\x3c\/span\x3e\n      )\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用dispatch的时候只能一个个调用，通过dispatch判断调用的状态\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDispatching) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Reducers may not dispatch actions.\x27\x3c\/span\x3e)\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n      isDispatching = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      currentState = currentReducer(currentState, action)\n    } \x3cspan class=\x22hljs-keyword\x22\x3efinally\x3c\/span\x3e {\n      isDispatching = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 遍历调用各个linster\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e listeners = currentListeners = nextListeners\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; listeners.length; i\x2b\x2b) {\n      listeners[i]()\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e action\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Replaces the reducer currently used by the store to calculate the state.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereplaceReducer\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enextReducer\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e nextReducer !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Expected the nextReducer to be a function.\x27\x3c\/span\x3e)\n    }\n\n    currentReducer = nextReducer\n    dispatch({ \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: ActionTypes.INIT })\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当create store的时候，reducer会接受一个type为ActionTypes.INIT的action，使reducer返回他们默认的state，这样可以快速的形成默认的state的结构\x3c\/span\x3e\n  dispatch({ \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: ActionTypes.INIT })\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3ccode\x3ethunkMiddleware\x3c\/code\x3e\x3c\/h4\x3e\n\x3cp\x3e源码及其简单简直给跪...\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 返回以 dispatch 和 getState 作为参数的action\nexport default function thunkMiddleware({ dispatch, getState }) {\n  return next =\x3e action =\x3e {\n    if (typeof action === \x27function\x27) {\n      return action(dispatch, getState);\n    }\n\n    return next(action);\n  };\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回以 dispatch 和 getState 作为参数的action\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ethunkMiddleware\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e{ dispatch, getState }\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enext\x3c\/span\x3e =\x26gt;\x3c\/span\x3e action =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e action === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e action(dispatch, getState);\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e next(action);\n  };\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3ccode\x3eapplyMiddleware\x3c\/code\x3e\x3c\/h4\x3e\n\x3cp\x3e先复习下用法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ usage\nimport {createStore, applyMiddleware} from \x27redux\x27;\nimport thunkMiddleware from \x27redux-thunk\x27;\n\nconst store = createStore(\n      reducers,\n      state,\n      applyMiddleware(thunkMiddleware)\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ usage\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {createStore, applyMiddleware} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27redux\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e thunkMiddleware \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27redux-thunk\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = createStore(\n      reducers,\n      state,\n      applyMiddleware(thunkMiddleware)\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eapplyMiddleware\x3c\/code\x3e首先接收\x3ccode\x3ethunkMiddleware\x3c\/code\x3e作为参数，两者组合成为一个新的函数（\x3ccode\x3eenhance\x3c\/code\x3e），之后在\x3ccode\x3ecreateStore\x3c\/code\x3e内部，因为\x3ccode\x3eenhance\x3c\/code\x3e的存在，将会变成返回\x3ccode\x3eenhancer(createStore)(reducer, initialState)\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e源码标注解读（省略部分）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 定义一个代码组合的方法\n\/\/ 传入一些function作为参数，返回其链式调用的形态。例如，\n\/\/ compose(f, g, h) 最终返回 (...args) =\x3e f(g(h(...args)))\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg =\x3e arg\n  } else {\n    const last = funcs[funcs.length - 1]\n    const rest = funcs.slice(0, -1)\n    return (...args) =\x3e rest.reduceRight((composed, f) =\x3e f(composed), last(...args))\n  }\n}\n\nexport default function applyMiddleware(...middlewares) {\n  \/\/ 最终返回一个以createStore为参数的匿名函数\n  \/\/ 这个函数返回另一个以reducer, initialState, enhancer为参数的匿名函数\n  return (createStore) =\x3e (reducer, initialState, enhancer) =\x3e {\n    var store = createStore(reducer, initialState, enhancer)\n    var dispatch\n    var chain = []\n\n    var middlewareAPI = {\n      getState: store.getState,\n      dispatch: (action) =\x3e dispatch(action)\n    }\n    \/\/ 每个 middleware 都以 middlewareAPI 作为参数进行注入，返回一个新的链。此时的返回值相当于调用 thunkMiddleware 返回的函数： (next) =\x3e (action) =\x3e {} ，接收一个next作为其参数\n    chain = middlewares.map(middleware =\x3e middleware(middlewareAPI))\n    \/\/ 并将链代入进 compose 组成一个函数的调用链\n    \/\/ compose(...chain) 返回形如(...args) =\x3e f(g(h(...args)))，f\/g\/h都是chain中的函数对象。\n    \/\/ 在目前只有 thunkMiddleware 作为 middlewares 参数的情况下，将返回 (next) =\x3e (action) =\x3e {}\n    \/\/ 之后以 store.dispatch 作为参数进行注入\n    dispatch = compose(...chain)(store.dispatch)\n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义一个代码组合的方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 传入一些function作为参数，返回其链式调用的形态。例如，\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ compose(f, g, h) 最终返回 (...args) =\x26gt; f(g(h(...args)))\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecompose\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e...funcs\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (funcs.length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3earg\x3c\/span\x3e =\x26gt;\x3c\/span\x3e arg\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e last = funcs[funcs.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e rest = funcs.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e...args\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e rest.reduceRight(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ecomposed, f\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e f(composed), last(...args))\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eapplyMiddleware\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e...middlewares\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最终返回一个以createStore为参数的匿名函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这个函数返回另一个以reducer, initialState, enhancer为参数的匿名函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ecreateStore\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e (reducer, initialState, enhancer) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e store = createStore(reducer, initialState, enhancer)\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dispatch\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e chain = []\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e middlewareAPI = {\n      \x3cspan class=\x22hljs-attr\x22\x3egetState\x3c\/span\x3e: store.getState,\n      \x3cspan class=\x22hljs-attr\x22\x3edispatch\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eaction\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e dispatch(action)\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 每个 middleware 都以 middlewareAPI 作为参数进行注入，返回一个新的链。此时的返回值相当于调用 thunkMiddleware 返回的函数： (next) =\x26gt; (action) =\x26gt; {} ，接收一个next作为其参数\x3c\/span\x3e\n    chain = middlewares.map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3emiddleware\x3c\/span\x3e =\x26gt;\x3c\/span\x3e middleware(middlewareAPI))\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 并将链代入进 compose 组成一个函数的调用链\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ compose(...chain) 返回形如(...args) =\x26gt; f(g(h(...args)))，f\/g\/h都是chain中的函数对象。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在目前只有 thunkMiddleware 作为 middlewares 参数的情况下，将返回 (next) =\x26gt; (action) =\x26gt; {}\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 之后以 store.dispatch 作为参数进行注入\x3c\/span\x3e\n    dispatch = compose(...chain)(store.dispatch)\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      ...store,\n      dispatch\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一脸懵逼？没关系，来结合实际使用总结一下：\x3c\/p\x3e\n\x3cp\x3e当我们搭配\x3ccode\x3eredux-thunk\x3c\/code\x3e这个库的时候，在\x3ccode\x3eredux\x3c\/code\x3e配合\x3ccode\x3ecomponents\x3c\/code\x3e时，通常这么写\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import thunkMiddleware from \x27redux-thunk\x27;\nimport { createStore, applyMiddleware, combineReducer } from \x27redux\x27;\nimport * as reducers from \x27.\/reducers.js\x27;\n\nconst appReducer = combineReducer(reducers);\nconst store = createStore(appReducer, initialState, applyMiddleware(thunkMiddleware));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e thunkMiddleware \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27redux-thunk\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { createStore, applyMiddleware, combineReducer } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27redux\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e * \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e reducers \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/reducers.js\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e appReducer = combineReducer(reducers);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = createStore(appReducer, initialState, applyMiddleware(thunkMiddleware));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e还记得当\x3ccode\x3ecreateStore\x3c\/code\x3e收到的参数中有\x3ccode\x3eenhance\x3c\/code\x3e时会怎么做吗？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ createStore.js\nif (typeof enhancer !== \x27undefined\x27) {\n  if (typeof enhancer !== \x27function\x27) {\n    throw new Error(\x27Expected the enhancer to be a function.\x27)\n  }\n  return enhancer(createStore)(reducer, initialState)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ createStore.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e enhancer !== \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e enhancer !== \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Expected the enhancer to be a function.\x27\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e enhancer(createStore)(reducer, initialState)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是说，会变成下面的情况\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22applyMiddleware(thunkMiddleware)(createStore)(reducer, initialState)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eapplyMiddleware(thunkMiddleware)(createStore)(reducer, initialState)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3ccode\x3eapplyMiddleware(thunkMiddleware)\x3c\/code\x3e\x3cbr\x3e\x3ccode\x3eapplyMiddleware\x3c\/code\x3e接收\x3ccode\x3ethunkMiddleware\x3c\/code\x3e作为参数，返回形如\x3ccode\x3e(createStore) =\x26gt; (reducer, initialState, enhancer) =\x26gt; {}\x3c\/code\x3e的函数。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3ccode\x3eapplyMiddleware(thunkMiddleware)(createStore)\x3c\/code\x3e\x3cbr\x3e  以 createStore 作为参数，调用上一步返回的函数\x3ccode\x3e(reducer, initialState, enhancer) =\x26gt; {}\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3ccode\x3eapplyMiddleware(thunkMiddleware)(createStore)(reducer, initialState)\x3c\/code\x3e\x3cbr\x3e  以（reducer, initialState）为参数进行调用。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e在这个函数内部，\x3ccode\x3ethunkMiddleware\x3c\/code\x3e被调用，其作用是监测\x3ccode\x3etype\x3c\/code\x3e是\x3ccode\x3efunction\x3c\/code\x3e的\x3ccode\x3eaction\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e因此，如果\x3ccode\x3edispatch\x3c\/code\x3e的\x3ccode\x3eaction\x3c\/code\x3e返回的是一个\x3ccode\x3efunction\x3c\/code\x3e，则证明是中间件，则将\x3ccode\x3e(dispatch, getState)\x3c\/code\x3e作为参数代入其中，进行\x3ccode\x3eaction\x3c\/code\x3e 内部下一步的操作。否则的话，认为只是一个普通的\x3ccode\x3eaction\x3c\/code\x3e，将通过\x3ccode\x3enext\x3c\/code\x3e(也就是\x3ccode\x3edispatch\x3c\/code\x3e)进一步分发。\x3c\/p\x3e\n\x3cp\x3e也就是说，\x3ccode\x3eapplyMiddleware(thunkMiddleware)\x3c\/code\x3e作为\x3ccode\x3eenhance\x3c\/code\x3e，最终起了这样的作用：\x3c\/p\x3e\n\x3cp\x3e对\x3ccode\x3edispatch\x3c\/code\x3e调用的\x3ccode\x3eaction\x3c\/code\x3e(例如，\x3ccode\x3edispatch(addNewTodo(todo)))\x3c\/code\x3e进行检查，如果\x3ccode\x3eaction\x3c\/code\x3e在第一次调用之后返回的是\x3ccode\x3efunction\x3c\/code\x3e，则将\x3ccode\x3e(dispatch, getState)\x3c\/code\x3e作为参数注入到\x3ccode\x3eaction\x3c\/code\x3e返回的方法中，否则就正常对\x3ccode\x3eaction\x3c\/code\x3e进行分发，这样一来我们的中间件就完成喽~\x3c\/p\x3e\n\x3cp\x3e因此，当\x3ccode\x3eaction\x3c\/code\x3e内部需要获取\x3ccode\x3estate\x3c\/code\x3e，或者需要进行异步操作，在操作完成之后进行事件调用分发的话，我们就可以让\x3ccode\x3eaction\x3c\/code\x3e 返回一个以\x3ccode\x3e(dispatch, getState)\x3c\/code\x3e为参数的\x3ccode\x3efunction\x3c\/code\x3e而不是通常的\x3ccode\x3eObject\x3c\/code\x3e，\x3ccode\x3eenhance\x3c\/code\x3e就会对其进行检测以便正确的处理。\x3c\/p\x3e\n\x3ch4\x3e\x3ccode\x3ebindActionCreator\x3c\/code\x3e\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e这个方法感觉比较少见，我个人也很少用到\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e在传统写法下，当我们要把 state 和 action 注入到子组件中时，一般会这么做：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { connect } from \x27react-redux\x27;\nimport {addTodo, deleteTodo} from \x27.\/action.js\x27;\n\nclass TodoComponect extends Component {\n  render() {\n    return (\n      \x3cChildComponent \n        deleteTodo={this.props.deleteTodo}\n        addTodo={this.props.addTodo}\n      \/\x3e\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {\n    state\n  }\n}\nfunction mapDispatchToProps(dispatch) {\n  return {\n    deleteTodo: (id) =\x3e {\n      dispatch(deleteTodo(id));\n    },\n    addTodo: (todo) =\x3e {\n      dispatch(addTodo(todo));\n    }\n  }\n}\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoComponect);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { connect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-redux\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {addTodo, deleteTodo} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/action.js\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoComponect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eChildComponent\x3c\/span\x3e \n        \x3cspan class=\x22hljs-attr\x22\x3edeleteTodo\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.deleteTodo}\x3c\/span\x3e\n        \x3cspan class=\x22hljs-attr\x22\x3eaddTodo\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.addTodo}\x3c\/span\x3e\n      \/\x26gt;\x3c\/span\x3e\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {\n    state\n  }\n}\nfunction mapDispatchToProps(dispatch) {\n  return {\n    deleteTodo: (id) =\x26gt; {\n      dispatch(deleteTodo(id));\n    },\n    addTodo: (todo) =\x26gt; {\n      dispatch(addTodo(todo));\n    }\n  }\n}\nexport default connect(mapStateToProps, mapDispatchToProps)(TodoComponect);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用\x3ccode\x3ebindActionCreators\x3c\/code\x3e可以把 action 转为同名 key 的对象，但使用 dispatch 把每个 action 包围起来调用\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e惟一使用 bindActionCreators 的场景是当你需要把 action creator 往下传到一个组件上，却不想让这个组件觉察到 Redux 的存在，而且不希望把 Redux store 或 dispatch 传给它。\x3c\/em\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { bindActionCreators } from \x27redux\x27;\nimport { connect } from \x27react-redux\x27;\nimport {addTodo, deleteTodo} as TodoActions from \x27.\/action.js\x27;\n\nclass TodoComponect extends React.Component {\n  \n  \/\/ 在本组件内的应用\n  addTodo(todo) {\n    let action = TodoActions.addTodo(todo);\n    this.props.dispatch(action);\n  }\n  \n  deleteTodo(id) {\n    let action = TodoActions.deleteTodo(id);\n    this.props.dispatch(action);\n  }\n  \n  render() {\n    let dispatch = this.props.dispatch;\n    \/\/ 传递给子组件\n    let boundActionCreators = bindActionCreators(TodoActions, dispatch);\n    return (\n      \x3cChildComponent \n        {...boundActionCreators}\n      \/\x3e\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {\n    state\n  }\n}\nexport default connect(mapStateToProps)(TodoComponect)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { bindActionCreators } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27redux\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { connect } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-redux\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {addTodo, deleteTodo} \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e TodoActions \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/action.js\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoComponect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在本组件内的应用\x3c\/span\x3e\n  addTodo(todo) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e action = TodoActions.addTodo(todo);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dispatch(action);\n  }\n  \n  deleteTodo(id) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e action = TodoActions.deleteTodo(id);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dispatch(action);\n  }\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dispatch = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.dispatch;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 传递给子组件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e boundActionCreators = bindActionCreators(TodoActions, dispatch);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eChildComponent\x3c\/span\x3e \n        {\x3cspan class=\x22hljs-attr\x22\x3e...boundActionCreators\x3c\/span\x3e}\n      \/\x26gt;\x3c\/span\x3e\n    )\n  }\n}\n\nfunction mapStateToProps(state) {\n  return {\n    state\n  }\n}\nexport default connect(mapStateToProps)(TodoComponect)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\n\x3ccode\x3ebindActionCreator\x3c\/code\x3e源码解析\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function bindActionCreator(actionCreator, dispatch) {\n  return (...args) =\x3e dispatch(actionCreator(...args))\n}\n\n\/\/ bindActionCreators期待一个Object作为actionCreators传入，里面是 key: action\nexport default function bindActionCreators(actionCreators, dispatch) {\n  \/\/ 如果只是传入一个action，则通过bindActionCreator返回被绑定到dispatch的函数\n  if (typeof actionCreators === \x27function\x27) {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n\n  if (typeof actionCreators !== \x27object\x27 || actionCreators === null) {\n    throw new Error(\n      `bindActionCreators expected an object or a function, instead received ${actionCreators === null ? \x27null\x27 : typeof actionCreators}. ` \x2b\n      `Did you write \x26quot;import ActionCreators from\x26quot; instead of \x26quot;import * as ActionCreators from\x26quot;?`\n    )\n  }\n\n  \/\/ 遍历并通过bindActionCreator分发绑定至dispatch\n  var keys = Object.keys(actionCreators)\n  var boundActionCreators = {}\n  for (var i = 0; i \x3c keys.length; i\x2b\x2b) {\n    var key = keys[i]\n    var actionCreator = actionCreators[key]\n    if (typeof actionCreator === \x27function\x27) {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  return boundActionCreators\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebindActionCreator\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eactionCreator, dispatch\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e...args\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e dispatch(actionCreator(...args))\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ bindActionCreators期待一个Object作为actionCreators传入，里面是 key: action\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebindActionCreators\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eactionCreators, dispatch\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果只是传入一个action，则通过bindActionCreator返回被绑定到dispatch的函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e actionCreators === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bindActionCreator(actionCreators, dispatch)\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e actionCreators !== \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || actionCreators === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n      \x3cspan class=\x22hljs-string\x22\x3e`bindActionCreators expected an object or a function, instead received \x3cspan class=\x22hljs-subst\x22\x3e${actionCreators === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e ? \x3cspan class=\x22hljs-string\x22\x3e\x27null\x27\x3c\/span\x3e : \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e actionCreators}\x3c\/span\x3e. `\x3c\/span\x3e \x2b\n      \x3cspan class=\x22hljs-string\x22\x3e`Did you write \x22import ActionCreators from\x22 instead of \x22import * as ActionCreators from\x22?`\x3c\/span\x3e\n    )\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 遍历并通过bindActionCreator分发绑定至dispatch\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e keys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(actionCreators)\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e boundActionCreators = {}\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; keys.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key = keys[i]\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e actionCreator = actionCreators[key]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e actionCreator === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e boundActionCreators\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3ereact-redux\x3c\/h2\x3e\n\x3ch4\x3e\x3ccode\x3eProvider\x3c\/code\x3e\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Provider extends Component {\n  getChildContext() {\n    \/\/ 将其声明为 context 的属性之一\n    return { store: this.store }\n  }\n\n  constructor(props, context) {\n    super(props, context)\n    \/\/ 接收 redux 的 store 作为 props\n    this.store = props.store\n  }\n\n  render() {\n    return Children.only(this.props.children)\n  }\n}\n\nif (process.env.NODE_ENV !== \x27production\x27) {\n  Provider.prototype.componentWillReceiveProps = function (nextProps) {\n    const { store } = this\n    const { store: nextStore } = nextProps\n\n    if (store !== nextStore) {\n      warnAboutReceivingStore()\n    }\n  }\n}\n\nProvider.propTypes = {\n  store: storeShape.isRequired,\n  children: PropTypes.element.isRequired\n}\nProvider.childContextTypes = {\n  store: storeShape.isRequired\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eProvider\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  getChildContext() {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将其声明为 context 的属性之一\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props, context) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props, context)\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接收 redux 的 store 作为 props\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store = props.store\n  }\n\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Children.only(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children)\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n  Provider.prototype.componentWillReceiveProps = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enextProps\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { store } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e: nextStore } = nextProps\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (store !== nextStore) {\n      warnAboutReceivingStore()\n    }\n  }\n}\n\nProvider.propTypes = {\n  \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e: storeShape.isRequired,\n  \x3cspan class=\x22hljs-attr\x22\x3echildren\x3c\/span\x3e: PropTypes.element.isRequired\n}\nProvider.childContextTypes = {\n  \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e: storeShape.isRequired\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3ccode\x3econnect\x3c\/code\x3e\x3c\/h4\x3e\n\x3cp\x3e传入\x3ccode\x3emapStateToProps\x3c\/code\x3e,\x3ccode\x3emapDispatchToProps\x3c\/code\x3e,\x3ccode\x3emergeProps\x3c\/code\x3e,\x3ccode\x3eoptions\x3c\/code\x3e。\x3cbr\x3e首先获取传入的参数，如果没有则以默认值代替\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const defaultMapStateToProps = state =\x3e ({}) \/\/ eslint-disable-line no-unused-vars\nconst defaultMapDispatchToProps = dispatch =\x3e ({ dispatch })\nconst { pure = true, withRef = false } = options\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaultMapStateToProps = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3estate\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({}) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ eslint-disable-line no-unused-vars\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaultMapDispatchToProps = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edispatch\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({ dispatch })\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { pure = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, withRef = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e } = options\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e之后，通过\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const finalMergeProps = mergeProps || defaultMergeProps\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e finalMergeProps = mergeProps || defaultMergeProps\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e选择合并\x3ccode\x3estateProps\x3c\/code\x3e,\x3ccode\x3edispatchProps\x3c\/code\x3e,\x3ccode\x3eparentProps\x3c\/code\x3e的方式，默认的合并方式 \x3ccode\x3edefaultMergeProps\x3c\/code\x3e 为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const defaultMergeProps = (stateProps, dispatchProps, parentProps) =\x3e ({\n  ...parentProps,\n  ...stateProps,\n  ...dispatchProps\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaultMergeProps = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3estateProps, dispatchProps, parentProps\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e ({\n  ...parentProps,\n  ...stateProps,\n  ...dispatchProps\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e返回一个以 Component 作为参数的函数。在这个函数内部，生成了一个叫做\x3ccode\x3eConnect\x3c\/code\x3e的 Component\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ...\n  return function wrapWithConnect(WrappedComponent) {\n    const connectDisplayName = `Connect(${getDisplayName(WrappedComponent)})`\n    \/\/ 检查参数合法性\n    function checkStateShape(props, methodName) {}\n    \/\/ 合并props\n    function computeMergedProps(stateProps, dispatchProps, parentProps) {\n      const mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps)\n      if (process.env.NODE_ENV !== \x27production\x27) {\n        checkStateShape(mergedProps, \x27mergeProps\x27)\n      }\n      return mergedProps\n    }\n    \n    \/\/ start of Connect\n    class Connect extends Component {\n      constructor(props, context) {\n        super(props, context);\n        this.store = props.store || context.store\n        \n        const storeState = this.store.getState()\n        this.state = { storeState }\n        this.clearCache()\n      }\n      \n      computeStateProps(store, props) {\n        \/\/ 调用configureFinalMapState，使用传入的mapStateToProps方法（或默认方法），将state map进props\n      }\n      configureFinalMapState(store, props) {}\n      \n      computeDispatchProps(store, props) {\n        \/\/ 调用configureFinalMapDispatch，使用传入的mapDispatchToProps方法（或默认方法），将action使用dispatch封装map进props\n      }\n      configureFinalMapDispatch(store, props) {}\n      \n      \/\/ 判断是否更新props\n      updateStatePropsIfNeeded() {}\n      updateDispatchPropsIfNeeded() {}\n      updateMergedPropsIfNeeded() {}\n      \n      componentDidMount() {\n        \/\/ 内部调用this.store.subscribe(this.handleChange.bind(this))\n        this.trySubscribe()\n      }\n      handleChange() {\n        const storeState = this.store.getState()\n        const prevStoreState = this.state.storeState\n        \/\/ 对数据进行监听，发送改变时调用\n        this.setState({ storeState })\n      }\n      \n      \/\/ 取消监听，清除缓存\n      componentWillUnmount() {\n        this.tryUnsubscribe()\n        this.clearCache()\n      }\n      \n      render() {\n        this.renderedElement = createElement(WrappedComponent,\n            this.mergedProps\n        )\n        return this.renderedElement\n      }\n    }\n    \/\/ end of Connect\n    \n    Connect.displayName = connectDisplayName\n    Connect.WrappedComponent = WrappedComponent\n    Connect.contextTypes = {\n      store: storeShape\n    }\n    Connect.propTypes = {\n      store: storeShape\n    }\n    \n    return hoistStatics(Connect, WrappedComponent)\n  }\n\/\/ ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewrapWithConnect\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e connectDisplayName = \x3cspan class=\x22hljs-string\x22\x3e`Connect(\x3cspan class=\x22hljs-subst\x22\x3e${getDisplayName(WrappedComponent)}\x3c\/span\x3e)`\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检查参数合法性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckStateShape\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops, methodName\x3c\/span\x3e) \x3c\/span\x3e{}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 合并props\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecomputeMergedProps\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estateProps, dispatchProps, parentProps\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n        checkStateShape(mergedProps, \x3cspan class=\x22hljs-string\x22\x3e\x27mergeProps\x27\x3c\/span\x3e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e mergedProps\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ start of Connect\x3c\/span\x3e\n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConnect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props, context) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props, context);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store = props.store || context.store\n        \n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e storeState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store.getState()\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { storeState }\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.clearCache()\n      }\n      \n      computeStateProps(store, props) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用configureFinalMapState，使用传入的mapStateToProps方法（或默认方法），将state map进props\x3c\/span\x3e\n      }\n      configureFinalMapState(store, props) {}\n      \n      computeDispatchProps(store, props) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用configureFinalMapDispatch，使用传入的mapDispatchToProps方法（或默认方法），将action使用dispatch封装map进props\x3c\/span\x3e\n      }\n      configureFinalMapDispatch(store, props) {}\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断是否更新props\x3c\/span\x3e\n      updateStatePropsIfNeeded() {}\n      updateDispatchPropsIfNeeded() {}\n      updateMergedPropsIfNeeded() {}\n      \n      componentDidMount() {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 内部调用this.store.subscribe(this.handleChange.bind(this))\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.trySubscribe()\n      }\n      handleChange() {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e storeState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store.getState()\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e prevStoreState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.storeState\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对数据进行监听，发送改变时调用\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ storeState })\n      }\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 取消监听，清除缓存\x3c\/span\x3e\n      componentWillUnmount() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tryUnsubscribe()\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.clearCache()\n      }\n      \n      render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderedElement = createElement(WrappedComponent,\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.mergedProps\n        )\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderedElement\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ end of Connect\x3c\/span\x3e\n    \n    Connect.displayName = connectDisplayName\n    Connect.WrappedComponent = WrappedComponent\n    Connect.contextTypes = {\n      \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e: storeShape\n    }\n    Connect.propTypes = {\n      \x3cspan class=\x22hljs-attr\x22\x3estore\x3c\/span\x3e: storeShape\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hoistStatics(Connect, WrappedComponent)\n  }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们看见，在connect的最后，返回了使用\x3ccode\x3ehoistStatics\x3c\/code\x3e包装的\x3ccode\x3eConnect\x3c\/code\x3e和\x3ccode\x3eWrappedComponent\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/mridgway\/hoist-non-react-statics\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehoistStatics\x3c\/a\x3e是什么鬼？\x3ca href=\x22https:\/\/github.com\/reactjs\/react-redux\/issues\/276\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e为什么使用它?\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eCopies non-react specific statics from a child component to a parent component. Similar to Object.assign, but with React static keywords blacklisted from being overridden.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e也就是说，它类似于\x3ccode\x3eObject.assign\x3c\/code\x3e，作用是将子组件中的 static 方法复制进父组件，但不会覆盖组件中的关键字方法(如 componentDidMount)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import hoistNonReactStatic from \x27hoist-non-react-statics\x27;\n\nhoistNonReactStatic(targetComponent, sourceComponent);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e hoistNonReactStatic \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27hoist-non-react-statics\x27\x3c\/span\x3e;\n\nhoistNonReactStatic(targetComponent, sourceComponent);\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Redux 入坑进阶 - 源码解析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006947061">https://segmentfault.com/a/1190000006947061</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/7bk7u30qncb/" target="_blank">https://alili.tech/archive/7bk7u30qncb/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/sj57jxyoook/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（上）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/qsw902j95k/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（下）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/nnpmjlot58j/">IndexedDB使用与出坑指南<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/alvlbas9oai/">JS事件模型<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/u0pzym8k36o/">JS练习实例--编写经典小游戏俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/khwpyk5yz8q/">JavaScript 事件代理和委托<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/kuocl6lc3n/">JavaScript 版俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/n8bk54lyrf/">Promise学习:基础入门<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/853kqfmqmf7/">Snap.svg 基本知识入门<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/aweotn3vwpj/">Vue.js实践：一个Node.js&#43;mongoDB&#43;Vue.js的博客内容管理系统<aside class="dates">2019-02-03</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>