<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="react进阶系列：高阶组件详解（一）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>react进阶系列：高阶组件详解（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/bdc11l693cl/",
				"appid": "1613049289050283", 
				"title": "react进阶系列：高阶组件详解（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-11T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/8e1l5a5tyto/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/9k39w40hf4/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f&text=react%e8%bf%9b%e9%98%b6%e7%b3%bb%e5%88%97%ef%bc%9a%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%e8%af%a6%e8%a7%a3%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f&text=react%e8%bf%9b%e9%98%b6%e7%b3%bb%e5%88%97%ef%bc%9a%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%e8%af%a6%e8%a7%a3%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f&title=react%e8%bf%9b%e9%98%b6%e7%b3%bb%e5%88%97%ef%bc%9a%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%e8%af%a6%e8%a7%a3%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f&is_video=false&description=react%e8%bf%9b%e9%98%b6%e7%b3%bb%e5%88%97%ef%bc%9a%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%e8%af%a6%e8%a7%a3%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=react%e8%bf%9b%e9%98%b6%e7%b3%bb%e5%88%97%ef%bc%9a%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%e8%af%a6%e8%a7%a3%ef%bc%88%e4%b8%80%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f&title=react%e8%bf%9b%e9%98%b6%e7%b3%bb%e5%88%97%ef%bc%9a%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%e8%af%a6%e8%a7%a3%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f&title=react%e8%bf%9b%e9%98%b6%e7%b3%bb%e5%88%97%ef%bc%9a%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%e8%af%a6%e8%a7%a3%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f&title=react%e8%bf%9b%e9%98%b6%e7%b3%bb%e5%88%97%ef%bc%9a%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%e8%af%a6%e8%a7%a3%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fbdc11l693cl%2f&title=react%e8%bf%9b%e9%98%b6%e7%b3%bb%e5%88%97%ef%bc%9a%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%e8%af%a6%e8%a7%a3%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">react进阶系列：高阶组件详解（一）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-11" itemprop="datePublished">2019-01-11</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e很多人写文章喜欢把问题复杂化，因此当我学习高阶组件的时候，查阅到的很多文章都给人一种高阶组件高深莫测的感觉。但是事实上却未必。\x3c\/p\x3e\n\x3cp\x3e有一个词叫做“封装”。相信写代码这么久了，大家对这个词所表达的含义都不会陌生。我们通常会将功能相同或者相似的代码提取出来封装成为一个可共用的函数或者对象，这也是我们从初学者慢慢进阶的必经之路。而高阶组件就是一个封装行为。\x3c\/p\x3e\n\x3cp\x3e但是高阶组件的封装与我们通常所使用的不太一样，如果完全一样也就不是那么难理解了。好在我们有一个常用的口头语“\x3ccode\x3e包一层\x3c\/code\x3e“刚好可以用来简单解释高阶组件的不同。在普通组件外面包一层逻辑，就是高阶组件。\x3c\/p\x3e\n\x3cp\x3e关于”包一层“，可以通过一个非常简单的例子来理解。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27;\n\nclass Div extends Component {\n    componentDidMount() {\n        console.log(\x27这是新增的能力\x27);\n    }\n    render () {\n        return (\n            \x3cdiv\x3e{ this.props.children }\x3c\/div\x3e\n        )\n    }\n}\n\nexport default Div;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDiv\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    componentDidMount() {\n        console.log(\x27这是新增的能力\x27);\n    }\n    render () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x26lt;div\x26gt;{ \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children }\x26lt;\/div\x26gt;\n        )\n    }\n}\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eDiv\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上面的例子中，我们把html的DIV标签作为基础元件。对他新增了一个输出一条提示信息的能力。而新的Div组件，就可以理解为div标签的高阶组件。到这里希望大家已经理解了包一层的具体含义。\x3c\/p\x3e\n\x3cp\x3e为了更加透彻的理解“包一层”的概念，我们需要来回顾一下new与构造函数之间的关系。在前面我有文章提到过为什么构造函数中this在运行时会指向new出来的实例，不知道还有没有人记得。我将那段代码复制过来。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别\nvar Person = function(name, age) {\n    this.name = name;\n    this.age = age;\n    this.getName = function() {\n        return this.name;\n    }\n}\n\n\/\/ 将构造函数以参数形式传入\nfunction New(func) {\n\n    \/\/ 声明一个中间对象，该对象为最终返回的实例\n    var res = {};\n    if (func.prototype !== null) {\n\n        \/\/ 将实例的原型指向构造函数的原型\n        res.__proto__ = func.prototype;\n    }\n\n    \/\/ ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象\n    var ret = func.apply(res, Array.prototype.slice.call(arguments, 1));\n\n    \/\/ 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象\n    if ((typeof ret === \x26quot;object\x26quot; || typeof ret === \x26quot;function\x26quot;) \x26amp;\x26amp; ret !== null) {\n        return ret;\n    }\n\n    \/\/ 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象\n    return res;\n}\n\n\/\/ 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res\nvar p1 = New(Person, \x27tom\x27, 20);\nconsole.log(p1.getName());\n\n\/\/ 当然，这里也可以判断出实例的类型了\nconsole.log(p1 instanceof Person); \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Person = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n    }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将构造函数以参数形式传入\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eNew\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efunc\x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明一个中间对象，该对象为最终返回的实例\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e res = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (func.prototype !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将实例的原型指向构造函数的原型\x3c\/span\x3e\n        res.__proto__ = func.prototype;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向res，即为实例对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = func.apply(res, \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e));\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e ret === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e ret === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e) \x26amp;\x26amp; ret !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e ret;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p1 = New(Person, \x3cspan class=\x22hljs-string\x22\x3e\x27tom\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(p1.getName());\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当然，这里也可以判断出实例的类型了\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(p1 \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Person); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上面的例子中，首先我们定义了一个本质上与普通函数没区别的构造函数，然后将该构造函数作为参数传入New函数中。我在New函数中进行了一些的逻辑处理，让New函数的返回值为一个实例，正因为New的内部逻辑，让构造函数中的this能够指向返回的实例。这个例子就是一个“包一层”的案例。如果因为基础不够扎实导致你对上面的例子确实理解不了，我们还可以简单粗暴的把上面的例子分成三个步骤来记忆。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e创建一个普通函数（因为new的存在所以变成构造函数）\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e创建一个new方法\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e在new方法中，创建一个中间实例res\x3c\/li\x3e\n\x3cli\x3e对中间实例res经过逻辑处理之后返回res\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e使用new方法创建实例\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e而恰好，高阶组件的创建逻辑与使用，与这里的new方法\x3cstrong\x3e完全一致\x3c\/strong\x3e。因为new方法其实就是构造函数的”高阶组件“。按照这个步骤，我们来尝试一步一步创建一个高阶组件。\x3c\/p\x3e\n\x3cp\x3e第一步，创建一个最简单的基础组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Basic extends Component {\n    render() {\n        return (\n            \x3cdiv\x3e{ this.props.children }\x3c\/div\x3e\n        )\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBasic\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e{ this.props.children }\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n        )\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第二步，根据上栗new方法的步骤，来创建高阶组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/Addsss.jsx\nimport React from \x27react\x27;\n\n\/\/ 基础组件作为高阶组件的参数传入\nfunction Addsss(Container) {\n\n    \/\/ 创建一个中间组件，该中间组件会在添加了逻辑之后返回\n    return class Asss extends React.Component {\n        componentDidMount() {}\n        render() {\n            return (\n                \/\/ 高阶组件往基础组件中传入了一个name属性，这是高阶组件赋予基础组件的新能力，当然，根据实际需求还可以添加更为复杂的新能力\n                \x3cContainer name=\x26quot;asper\x26quot;\x3e{ this.props.children }\x3c\/Container\x3e\n            )\n        }\n    }\n}\n\nexport default Addsss;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/Addsss.jsx\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 基础组件作为高阶组件的参数传入\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAddsss\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eContainer\x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个中间组件，该中间组件会在添加了逻辑之后返回\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAsss\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n        componentDidMount() {}\n        render() {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 高阶组件往基础组件中传入了一个name属性，这是高阶组件赋予基础组件的新能力，当然，根据实际需求还可以添加更为复杂的新能力\x3c\/span\x3e\n                \x26lt;Container name=\x3cspan class=\x22hljs-string\x22\x3e\x22asper\x22\x3c\/span\x3e\x26gt;{ \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children }\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/Container\x26gt;\n            )\n        }\n    }\n}\n\nexport default Addsss;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e高阶组件在基础组件中调用，并将高阶组件的运行结果返回给模块外部。因此基础组件的代码调整如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/basic.jsx\nimport React, { Component } from \x27react\x27;\nimport Addsss from \x27.\/Addsss\x27;\n\nclass Basic extends Component {\n    componentDidMount() {\n        \/\/ 在基础组件中试图访问高阶组件传入的新参数\n        console.log(this.props.name);\n    }\n    render() {\n        return (\n            \x3cdiv className={this.props.name}\x3e{ this.props.children }\x3c\/div\x3e\n        )\n    }\n}\n\n\/\/ 这里相当于执行了一次new操作，返回了一个实例，其实运行结果真是高阶组件中的中间组件\nexport default Addsss(Basic);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/basic.jsx\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Addsss \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/Addsss\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBasic\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    componentDidMount() {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在基础组件中试图访问高阶组件传入的新参数\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.name);\n    }\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.name}\x3c\/span\x3e\x26gt;\x3c\/span\x3e{ this.props.children }\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n        )\n    }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里相当于执行了一次new操作，返回了一个实例，其实运行结果真是高阶组件中的中间组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e Addsss(Basic);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们看到其实在基础组件中，对外抛出的接口是Addsss(Basic)，这是高阶组件里定义的函数运行的结果。也就是说，其实基础组件中返回的是高阶组件中定义的Asss中间组件。这和new的思路几乎完全一致。\x3c\/p\x3e\n\x3cp\x3e所以我们可以简单理解为：react组件的高阶组件，就是在基础react组件外面包一层，给该基础组件赋予新的能力。\x3c\/p\x3e\n\x3cp\x3e当然，想要熟练使用高阶组件并不是一件容易的事情，我们还需要更多的思考他。在下面一篇文章中我将会以实际的案例来分析高阶组件的使用场景与他到底给我们带来了哪些便利。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV0emY?w=800\x26amp;h=300\x22 src=\x22https:\/\/static.alili.tech\/img\/bV0emY?w=800\x26amp;h=300\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>react进阶系列：高阶组件详解（一）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009937019">https://segmentfault.com/a/1190000009937019</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/bdc11l693cl/" target="_blank">https://alili.tech/archive/bdc11l693cl/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>