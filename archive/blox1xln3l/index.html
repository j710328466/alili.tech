<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="《JavaScript 闯关记》之原型及原型链"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>《JavaScript 闯关记》之原型及原型链 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/blox1xln3l/",
				"appid": "1613049289050283", 
				"title": "《JavaScript 闯关记》之原型及原型链 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/c2tpjhydfm/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hs6kypgssw5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f&text=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e5%8e%9f%e5%9e%8b%e5%8f%8a%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f&text=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e5%8e%9f%e5%9e%8b%e5%8f%8a%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e5%8e%9f%e5%9e%8b%e5%8f%8a%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f&is_video=false&description=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e5%8e%9f%e5%9e%8b%e5%8f%8a%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e5%8e%9f%e5%9e%8b%e5%8f%8a%e5%8e%9f%e5%9e%8b%e9%93%be&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e5%8e%9f%e5%9e%8b%e5%8f%8a%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e5%8e%9f%e5%9e%8b%e5%8f%8a%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e5%8e%9f%e5%9e%8b%e5%8f%8a%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fblox1xln3l%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e5%8e%9f%e5%9e%8b%e5%8f%8a%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">《JavaScript 闯关记》之原型及原型链</h1><div class="meta"><div class="postdate"><time datetime="2019-01-29" itemprop="datePublished">2019-01-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e原型链是一种机制，指的是 JavaScript 每个对象都有一个内置的 \x3ccode\x3e__proto__\x3c\/code\x3e 属性指向创建它的构造函数的 \x3ccode\x3eprototype\x3c\/code\x3e（原型）属性。原型链的作用是为了实现对象的继承，要理解原型链，需要先从\x3cstrong\x3e函数对象\x3c\/strong\x3e、\x3ccode\x3econstructor\x3c\/code\x3e、\x3ccode\x3enew\x3c\/code\x3e、\x3ccode\x3eprototype\x3c\/code\x3e、\x3ccode\x3e__proto__\x3c\/code\x3e 这五个概念入手。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e函数对象\x3c\/h2\x3e\n\x3cp\x3e前面讲过，在 JavaScript 里，函数即对象，程序可以随意操控它们。比如，可以把函数赋值给变量，或者作为参数传递给其他函数，也可以给它们设置属性，甚至调用它们的方法。下面示例代码对「普通对象」和「函数对象」进行了区分。\x3c\/p\x3e\n\x3cp\x3e普通对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var o1 = {};\nvar o2 = new Object();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o1 = {};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function f1(){};\nvar f2 = function(){};\nvar f3 = new Function(\x27str\x27,\x27console.log(str)\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f2 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27str\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27console.log(str)\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e简单的说，凡是使用 \x3ccode\x3efunction\x3c\/code\x3e 关键字或 \x3ccode\x3eFunction\x3c\/code\x3e 构造函数创建的对象都是函数对象。而且，只有函数对象才拥有  \x3ccode\x3eprototype\x3c\/code\x3e （原型）属性。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e\n\x3ccode\x3econstructor\x3c\/code\x3e 构造函数\x3c\/h2\x3e\n\x3cp\x3e函数还有一种用法，就是把它作为构造函数使用。像 \x3ccode\x3eObject\x3c\/code\x3e 和 \x3ccode\x3eArray\x3c\/code\x3e 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而自定义对象类型的属性和方法。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = function(){\n        console.log(this.name);\n    };\n}\n\nvar person1 = new Person(\x26quot;Stone\x26quot;, 28, \x26quot;Software Engineer\x26quot;);\nvar person2 = new Person(\x26quot;Sophie\x26quot;, 29, \x26quot;English Teacher\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age, job\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.job = job;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    };\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22Sophie\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e29\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22English Teacher\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个例子中，我们创建了一个自定义构造函数 \x3ccode\x3ePerson()\x3c\/code\x3e，并通过该构造函数创建了两个普通对象 \x3ccode\x3eperson1\x3c\/code\x3e 和 \x3ccode\x3eperson2\x3c\/code\x3e，这两个普通对象均包含3个属性和1个方法。\x3c\/p\x3e\n\x3cp\x3e你应该注意到函数名 \x3ccode\x3ePerson\x3c\/code\x3e 使用的是大写字母 \x3ccode\x3eP\x3c\/code\x3e。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他面向对象语言，主要是为了区别于 JavaScript 中的其他函数；因为构造函数本身也是函数，只不过可以用来创建对象而已。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e\n\x3ccode\x3enew\x3c\/code\x3e 操作符\x3c\/h2\x3e\n\x3cp\x3e要创建 \x3ccode\x3ePerson\x3c\/code\x3e 的新实例，必须使用 \x3ccode\x3enew\x3c\/code\x3e 操作符。以这种方式调用构造函数实际上会经历以下4个步骤：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e创建一个新对象；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将构造函数的作用域赋给新对象（因此 \x3ccode\x3ethis\x3c\/code\x3e 就指向了这个新对象）；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行构造函数中的代码（为这个新对象添加属性）；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e返回新对象。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e将构造函数当作函数\x3c\/h3\x3e\n\x3cp\x3e构造函数与其他函数的唯一区别，就在于调用它们的方式不同。不过，构造函数毕竟也是函数，不存在定义构造函数的特殊语法。任何函数，只要通过 \x3ccode\x3enew\x3c\/code\x3e 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过 \x3ccode\x3enew\x3c\/code\x3e 操作符来调用，那它跟普通函数也不会有什么两样。例如，前面例子中定义的 \x3ccode\x3ePerson()\x3c\/code\x3e 函数可以通过下列任何一种方式来调用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 当作构造函数使用\nvar person = new Person(\x26quot;Stone\x26quot;, 28, \x26quot;Software Engineer\x26quot;);\nperson.sayName(); \/\/ \x26quot;Stone\x26quot;\n\n\/\/ 作为普通函数调用\nPerson(\x26quot;Sophie\x26quot;, 29, \x26quot;English Teacher\x26quot;); \/\/ 添加到 window\nwindow.sayName(); \/\/ \x26quot;Sophie\x26quot;\n\n\/\/ 在另一个对象的作用域中调用\nvar o = new Object();\nPerson.call(o, \x26quot;Tommy\x26quot;, 3, \x26quot;Baby\x26quot;);\no.sayName(); \/\/ \x26quot;Tommy\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当作构造函数使用\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e);\nperson.sayName(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Stone\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 作为普通函数调用\x3c\/span\x3e\nPerson(\x3cspan class=\x22hljs-string\x22\x3e\x22Sophie\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e29\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22English Teacher\x22\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加到 window\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.sayName(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Sophie\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在另一个对象的作用域中调用\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e();\nPerson.call(o, \x3cspan class=\x22hljs-string\x22\x3e\x22Tommy\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Baby\x22\x3c\/span\x3e);\no.sayName(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Tommy\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子中的前两行代码展示了构造函数的典型用法，即使用 \x3ccode\x3enew\x3c\/code\x3e 操作符来创建一个新对象。接下来的两行代码展示了不使用 \x3ccode\x3enew\x3c\/code\x3e 操作符调用 \x3ccode\x3ePerson()\x3c\/code\x3e 会出现什么结果，属性和方法都被添加给 \x3ccode\x3ewindow\x3c\/code\x3e 对象了。当在全局作用域中调用一个函数时，\x3ccode\x3ethis\x3c\/code\x3e 对象总是指向 \x3ccode\x3eGlobal\x3c\/code\x3e 对象（在浏览器中就是 \x3ccode\x3ewindow\x3c\/code\x3e 对象）。因此，在调用完函数之后，可以通过 \x3ccode\x3ewindow\x3c\/code\x3e 对象来调用 \x3ccode\x3esayName()\x3c\/code\x3e 方法，并且还返回了 \x3ccode\x3e\x22Sophie\x22\x3c\/code\x3e 。最后，也可以使用 \x3ccode\x3ecall()\x3c\/code\x3e（或者 \x3ccode\x3eapply()\x3c\/code\x3e）在某个特殊对象的作用域中调用 \x3ccode\x3ePerson()\x3c\/code\x3e 函数。这里是在对象 \x3ccode\x3eo\x3c\/code\x3e 的作用域中调用的，因此调用后 \x3ccode\x3eo\x3c\/code\x3e 就拥有了所有属性和 \x3ccode\x3esayName()\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e构造函数的问题\x3c\/h3\x3e\n\x3cp\x3e构造函数模式虽然好用，但也并非没有缺点。使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，\x3ccode\x3eperson1\x3c\/code\x3e 和 \x3ccode\x3eperson2\x3c\/code\x3e 都有一个名为 \x3ccode\x3esayName()\x3c\/code\x3e 的方法，但那两个方法不是同一个 \x3ccode\x3eFunction\x3c\/code\x3e 的实例。因为 JavaScript 中的函数是对象，因此每定义一个函数，也就是实例化了一个对象。从逻辑角度讲，此时的构造函数也可以这样定义。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = new Function(\x26quot;console.log(this.name)\x26quot;); \/\/ 与声明函数在逻辑上是等价的\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age, job\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.job = job;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sayName = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22console.log(this.name)\x22\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 与声明函数在逻辑上是等价的\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从这个角度上来看构造函数，更容易明白每个 \x3ccode\x3ePerson\x3c\/code\x3e 实例都包含一个不同的 \x3ccode\x3eFunction\x3c\/code\x3e 实例（\x3ccode\x3esayName()\x3c\/code\x3e 方法）。说得明白些，以这种方式创建函数，虽然创建 \x3ccode\x3eFunction\x3c\/code\x3e 新实例的机制仍然是相同的，但是不同实例上的同名函数是不相等的，以下代码可以证明这一点。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(person1.sayName == person2.sayName);  \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.sayName == person2.sayName);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然而，创建两个完成同样任务的 \x3ccode\x3eFunction\x3c\/code\x3e 实例的确没有必要；况且有 \x3ccode\x3ethis\x3c\/code\x3e 对象在，根本不用在执行代码前就把函数绑定到特定对象上面。因此，大可像下面这样，通过把函数定义转移到构造函数外部来解决这个问题。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = sayName;\n}\n\nfunction sayName(){\n    console.log(this.name);\n}\n\nvar person1 = new Person(\x26quot;Stone\x26quot;, 28, \x26quot;Software Engineer\x26quot;);\nvar person2 = new Person(\x26quot;Sophie\x26quot;, 29, \x26quot;English Teacher\x26quot;);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age, job\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.job = job;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sayName = sayName;\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esayName\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22Sophie\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e29\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22English Teacher\x22\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个例子中，我们把 \x3ccode\x3esayName()\x3c\/code\x3e 函数的定义转移到了构造函数外部。而在构造函数内部，我们将 \x3ccode\x3esayName\x3c\/code\x3e 属性设置成等于全局的 \x3ccode\x3esayName\x3c\/code\x3e 函数。这样一来，由于 \x3ccode\x3esayName\x3c\/code\x3e 包含的是一个指向函数的指针，因此 \x3ccode\x3eperson1\x3c\/code\x3e 和 \x3ccode\x3eperson2\x3c\/code\x3e 对象就共享了在全局作用域中定义的同一个 \x3ccode\x3esayName()\x3c\/code\x3e 函数。这样做确实解决了两个函数做同一件事的问题，可是新问题又来了，在全局作用域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实。而更让人无法接受的是，如果对象需要定义很多方法，那么就要定义很多个全局函数，于是我们这个自定义的引用类型就丝毫没有封装性可言了。好在，这些问题可以通过使用原型来解决。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e\n\x3ccode\x3eprototype\x3c\/code\x3e 原型\x3c\/h2\x3e\n\x3cp\x3e我们创建的每个函数都有一个 \x3ccode\x3eprototype\x3c\/code\x3e（原型）属性。使用原型的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型中，如下面的例子所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\n\nPerson.prototype.name = \x26quot;Stone\x26quot;;\nPerson.prototype.age = 28;\nPerson.prototype.job = \x26quot;Software Engineer\x26quot;;\nPerson.prototype.sayName = function(){\n    console.log(this.name);\n};\n\nvar person1 = new Person();\nperson1.sayName();   \/\/ \x26quot;Stone\x26quot;\n\nvar person2 = new Person();\nperson2.sayName();   \/\/ \x26quot;Stone\x26quot;\n\nconsole.log(person1.sayName == person2.sayName);  \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\nPerson.prototype.name = \x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e;\nPerson.prototype.age = \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e;\nPerson.prototype.job = \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e;\nPerson.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\nperson1.sayName();   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Stone\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\nperson2.sayName();   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Stone\x22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.sayName == person2.sayName);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在此，我们将 \x3ccode\x3esayName()\x3c\/code\x3e 方法和所有属性直接添加到了 \x3ccode\x3ePerson\x3c\/code\x3e 的 \x3ccode\x3eprototype\x3c\/code\x3e 属性中，构造函数变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。但与前面的例子不同的是，新对象的这些属性和方法是由所有实例共享的。换句话说，\x3ccode\x3eperson1\x3c\/code\x3e 和 \x3ccode\x3eperson2\x3c\/code\x3e 访问的都是同一组属性和同一个 \x3ccode\x3esayName()\x3c\/code\x3e 函数。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e理解原型对象\x3c\/h3\x3e\n\x3cp\x3e在默认情况下，所有原型对象都会自动获得一个 \x3ccode\x3econstructor\x3c\/code\x3e（构造函数）属性，这个属性包含一个指向 \x3ccode\x3eprototype\x3c\/code\x3e 属性所在函数的指针。就拿前面的例子来说，\x3ccode\x3ePerson.prototype.constructor\x3c\/code\x3e 指向 \x3ccode\x3ePerson\x3c\/code\x3e。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。\x3c\/p\x3e\n\x3cp\x3e虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。来看下面的例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\n\nPerson.prototype.name = \x26quot;Stone\x26quot;;\nPerson.prototype.age = 28;\nPerson.prototype.job = \x26quot;Software Engineer\x26quot;;\nPerson.prototype.sayName = function(){\n    console.log(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.name = \x26quot;Sophie\x26quot;;\nconsole.log(person1.name);     \/\/ \x26quot;Sophie\x26quot;，来自实例\nconsole.log(person2.name);     \/\/ \x26quot;Stone\x26quot;，来自原型\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\nPerson.prototype.name = \x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e;\nPerson.prototype.age = \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e;\nPerson.prototype.job = \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e;\nPerson.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\nperson1.name = \x3cspan class=\x22hljs-string\x22\x3e\x22Sophie\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.name);     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Sophie\x22，来自实例\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person2.name);     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Stone\x22，来自原型\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个例子中，\x3ccode\x3eperson1\x3c\/code\x3e 的 \x3ccode\x3ename\x3c\/code\x3e 被一个新值给屏蔽了。但无论访问 \x3ccode\x3eperson1.name\x3c\/code\x3e 还是访问 \x3ccode\x3eperson2.name\x3c\/code\x3e 都能够正常地返回值，即分别是 \x3ccode\x3e\x22Sophie\x22\x3c\/code\x3e（来自对象实例）和 \x3ccode\x3e\x22Stone\x22\x3c\/code\x3e（来自原型）。当访问 \x3ccode\x3eperson1.name\x3c\/code\x3e 时，需要读取它的值，因此就会在这个实例上搜索一个名为 \x3ccode\x3ename\x3c\/code\x3e 的属性。这个属性确实存在，于是就返回它的值而不必再搜索原型了。当访问 \x3ccode\x3eperson2. name\x3c\/code\x3e 时，并没有在实例上发现该属性，因此就会继续搜索原型，结果在那里找到了 \x3ccode\x3ename\x3c\/code\x3e 属性。\x3c\/p\x3e\n\x3cp\x3e当为对象实例添加一个属性时，这个属性就会\x3cstrong\x3e屏蔽\x3c\/strong\x3e原型中保存的同名属性；换句话说，添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为 \x3ccode\x3enull\x3c\/code\x3e ，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。不过，使用 \x3ccode\x3edelete\x3c\/code\x3e 操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\n\nPerson.prototype.name = \x26quot;Stone\x26quot;;\nPerson.prototype.age = 28;\nPerson.prototype.job = \x26quot;Software Engineer\x26quot;;\nPerson.prototype.sayName = function(){\n    console.log(this.name);\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.name = \x26quot;Sophie\x26quot;;\nconsole.log(person1.name);     \/\/ \x26quot;Sophie\x26quot;，来自实例\nconsole.log(person2.name);     \/\/ \x26quot;Stone\x26quot;，来自原型\n\ndelete person1.name;\nconsole.log(person1.name);     \/\/ \x26quot;Stone\x26quot;，来自原型\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\nPerson.prototype.name = \x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e;\nPerson.prototype.age = \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e;\nPerson.prototype.job = \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e;\nPerson.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\nperson1.name = \x3cspan class=\x22hljs-string\x22\x3e\x22Sophie\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.name);     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Sophie\x22，来自实例\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person2.name);     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Stone\x22，来自原型\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e person1.name;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.name);     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22Stone\x22，来自原型\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个修改后的例子中，我们使用 \x3ccode\x3edelete\x3c\/code\x3e 操作符删除了 \x3ccode\x3eperson1.name\x3c\/code\x3e，之前它保存的 \x3ccode\x3e\x22Sophie\x22\x3c\/code\x3e 值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 \x3ccode\x3ename\x3c\/code\x3e 属性的连接。因此，接下来再调用 \x3ccode\x3eperson1.name\x3c\/code\x3e 时，返回的就是原型中 \x3ccode\x3ename\x3c\/code\x3e 属性的值了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e更简单的原型语法\x3c\/h3\x3e\n\x3cp\x3e前面例子中每添加一个属性和方法就要敲一遍 \x3ccode\x3ePerson.prototype\x3c\/code\x3e。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\n\nPerson.prototype = {\n    name : \x26quot;Stone\x26quot;,\n    age : 28,\n    job: \x26quot;Software Engineer\x26quot;,\n    sayName : function () {\n        console.log(this.name);\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\nPerson.prototype = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ejob\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3esayName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在上面的代码中，我们将 \x3ccode\x3ePerson.prototype\x3c\/code\x3e 设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外：\x3ccode\x3econstructor\x3c\/code\x3e 属性不再指向 \x3ccode\x3ePerson\x3c\/code\x3e 了。前面曾经介绍过，每创建一个函数，就会同时创建它的 \x3ccode\x3eprototype\x3c\/code\x3e 对象，这个对象也会自动获得 \x3ccode\x3econstructor\x3c\/code\x3e 属性。而我们在这里使用的语法，本质上完全重写了默认的 \x3ccode\x3eprototype\x3c\/code\x3e 对象，因此 \x3ccode\x3econstructor\x3c\/code\x3e 属性也就变成了新对象的 \x3ccode\x3econstructor\x3c\/code\x3e 属性（指向 \x3ccode\x3eObject\x3c\/code\x3e 构造函数），不再指向 \x3ccode\x3ePerson\x3c\/code\x3e 函数。此时，尽管 \x3ccode\x3einstanceof\x3c\/code\x3e 操作符还能返回正确的结果，但通过 \x3ccode\x3econstructor\x3c\/code\x3e 已经无法确定对象的类型了，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var friend = new Person();\n\nconsole.log(friend instanceof Object);        \/\/ true\nconsole.log(friend instanceof Person);        \/\/ true\nconsole.log(friend.constructor === Person);    \/\/ false\nconsole.log(friend.constructor === Object);    \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e friend = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(friend \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e);        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(friend \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Person);        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(friend.constructor === Person);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(friend.constructor === \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在此，用 \x3ccode\x3einstanceof\x3c\/code\x3e 操作符测试 \x3ccode\x3eObject\x3c\/code\x3e 和 \x3ccode\x3ePerson\x3c\/code\x3e 仍然返回 \x3ccode\x3etrue\x3c\/code\x3e，但 \x3ccode\x3econstructor\x3c\/code\x3e 属性则等于 \x3ccode\x3eObject\x3c\/code\x3e 而不等于 \x3ccode\x3ePerson\x3c\/code\x3e 了。如果 \x3ccode\x3econstructor\x3c\/code\x3e 的值真的很重要，可以像下面这样特意将它设置回适当的值。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\n\nPerson.prototype = {\n    constructor : Person,\n    name : \x26quot;Stone\x26quot;,\n    age : 28,\n    job: \x26quot;Software Engineer\x26quot;,\n    sayName : function () {\n        console.log(this.name);\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\nPerson.prototype = {\n    \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e : Person,\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ejob\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3esayName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码特意包含了一个 \x3ccode\x3econstructor\x3c\/code\x3e 属性，并将它的值设置为 \x3ccode\x3ePerson\x3c\/code\x3e ，从而确保了通过该属性能够访问到适当的值。\x3c\/p\x3e\n\x3cp\x3e注意，以这种方式重设 \x3ccode\x3econstructor\x3c\/code\x3e 属性会导致它的 \x3ccode\x3e[[Enumerable]]\x3c\/code\x3e 特性被设置为 \x3ccode\x3etrue\x3c\/code\x3e。默认情况下，原生的 \x3ccode\x3econstructor\x3c\/code\x3e 属性是不可枚举的，因此如果你使用兼容 ECMAScript 5 的 JavaScript 引擎，可以试一试 \x3ccode\x3eObject.defineProperty()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\n\nPerson.prototype = {\n    name : \x26quot;Stone\x26quot;,\n    age : 28,\n    job : \x26quot;Software Engineer\x26quot;,\n    sayName : function () {\n        console.log(this.name);\n    }\n}; \n\n\/\/ 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器\nObject.defineProperty(Person.prototype, \x26quot;constructor\x26quot;, {\n    enumerable: false,\n    value: Person\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\nPerson.prototype = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ejob\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3esayName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n}; \n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重设构造函数，只适用于 ECMAScript 5 兼容的浏览器\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(Person.prototype, \x3cspan class=\x22hljs-string\x22\x3e\x22constructor\x22\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: Person\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e原型的动态性\x3c\/h3\x3e\n\x3cp\x3e由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来，即使是先创建了实例后修改原型也照样如此。请看下面的例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var friend = new Person();\n\nPerson.prototype.sayHi = function(){\n    console.log(\x26quot;hi\x26quot;);\n};\n\nfriend.sayHi();   \/\/ \x26quot;hi\x26quot;（没有问题！）\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e friend = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\nPerson.prototype.sayHi = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22hi\x22\x3c\/span\x3e);\n};\n\nfriend.sayHi();   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22hi\x22（没有问题！）\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码先创建了 \x3ccode\x3ePerson\x3c\/code\x3e 的一个实例，并将其保存在 \x3ccode\x3efriend\x3c\/code\x3e 中。然后，下一条语句在 \x3ccode\x3ePerson.prototype\x3c\/code\x3e 中添加了一个方法 \x3ccode\x3esayHi()\x3c\/code\x3e。即使 \x3ccode\x3eperson\x3c\/code\x3e 实例是在添加新方法之前创建的，但它仍然可以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 \x3ccode\x3efriend.sayHi()\x3c\/code\x3e 时，首先会在实例中搜索名为 \x3ccode\x3esayHi\x3c\/code\x3e 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 \x3ccode\x3esayHi\x3c\/code\x3e 属性并返回保存在那里的函数。\x3c\/p\x3e\n\x3cp\x3e尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的 \x3ccode\x3e[[Prototype]]\x3c\/code\x3e 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数。看下面的例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\n\nvar friend = new Person();\n\nPerson.prototype = {\n    constructor: Person,\n    name : \x26quot;Stone\x26quot;,\n    age : 28,\n    job : \x26quot;Software Engineer\x26quot;,\n    sayName : function () {\n        console.log(this.name);\n    }\n};\n\nfriend.sayName();   \/\/ Uncaught TypeError: friend.sayName is not a function\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e friend = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\nPerson.prototype = {\n    \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: Person,\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ejob\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3esayName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n};\n\nfriend.sayName();   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Uncaught TypeError: friend.sayName is not a function\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个例子中，我们先创建了 \x3ccode\x3ePerson\x3c\/code\x3e 的一个实例，然后又重写了其原型对象。然后在调用 \x3ccode\x3efriend.sayName()\x3c\/code\x3e 时发生了错误，因为 \x3ccode\x3efriend\x3c\/code\x3e 指向的是重写前的原型对象，其中并不包含以该名字命名的属性。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e原生对象的原型\x3c\/h3\x3e\n\x3cp\x3e原型的重要性不仅体现在创建自定义类型方面，就连所有原生的引用类型，都是采用这种模式创建的。所有原生引用类型（\x3ccode\x3eObject\x3c\/code\x3e、\x3ccode\x3eArray\x3c\/code\x3e、\x3ccode\x3eString\x3c\/code\x3e，等等）都在其构造函数的原型上定义了方法。例如，在 \x3ccode\x3eArray.prototype\x3c\/code\x3e 中可以找到 \x3ccode\x3esort()\x3c\/code\x3e 方法，而在 \x3ccode\x3eString.prototype\x3c\/code\x3e 中可以找到 \x3ccode\x3esubstring()\x3c\/code\x3e 方法，如下所示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(typeof Array.prototype.sort);       \/\/ \x26quot;function\x26quot;\nconsole.log(typeof String.prototype.substring); \/\/ \x26quot;function\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.sort);       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22function\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e.prototype.substring); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22function\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。下面的代码就给基本包装类型 \x3ccode\x3eString\x3c\/code\x3e 添加了一个名为 \x3ccode\x3estartsWith()\x3c\/code\x3e 的方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22String.prototype.startsWith = function (text) {\n    return this.indexOf(text) === 0;\n};\n\nvar msg = \x26quot;Hello world!\x26quot;;\nconsole.log(msg.startsWith(\x26quot;Hello\x26quot;));   \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e.prototype.startsWith = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3etext\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.indexOf(text) === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e msg = \x3cspan class=\x22hljs-string\x22\x3e\x22Hello world!\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(msg.startsWith(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello\x22\x3c\/span\x3e));   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里新定义的 \x3ccode\x3estartsWith()\x3c\/code\x3e 方法会在传入的文本位于一个字符串开始时返回 \x3ccode\x3etrue\x3c\/code\x3e。既然方法被添加给了 \x3ccode\x3eString.prototype\x3c\/code\x3e ，那么当前环境中的所有字符串就都可以调用它。由于 \x3ccode\x3emsg\x3c\/code\x3e 是字符串，而且后台会调用 \x3ccode\x3eString\x3c\/code\x3e 基本包装函数创建这个字符串，因此通过 \x3ccode\x3emsg\x3c\/code\x3e 就可以调用 \x3ccode\x3estartsWith()\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3cp\x3e尽管可以这样做，但我们不推荐在产品化的程序中修改原生对象的原型。如果因某个实现中缺少某个方法，就在原生对象的原型中添加这个方法，那么当在另一个支持该方法的实现中运行代码时，就可能会导致命名冲突。而且，这样做也可能会意外地重写原生方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e原型对象的问题\x3c\/h3\x3e\n\x3cp\x3e原型模式也不是没有缺点。首先，它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。\x3c\/p\x3e\n\x3cp\x3e原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。来看下面的例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\n\nPerson.prototype = {\n    constructor: Person,\n    name : \x26quot;Stone\x26quot;,\n    age : 28,\n    job : \x26quot;Software Engineer\x26quot;,\n    friends : [\x26quot;ZhangSan\x26quot;, \x26quot;LiSi\x26quot;],\n    sayName : function () {\n        console.log(this.name);\n    }\n};\n\nvar person1 = new Person();\nvar person2 = new Person();\n\nperson1.friends.push(\x26quot;WangWu\x26quot;);\n\nconsole.log(person1.friends);    \/\/ \x26quot;ZhangSan,LiSi,WangWu\x26quot;\nconsole.log(person2.friends);    \/\/ \x26quot;ZhangSan,LiSi,WangWu\x26quot;\nconsole.log(person1.friends === person2.friends);  \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\nPerson.prototype = {\n    \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e: Person,\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ejob\x3c\/span\x3e : \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efriends\x3c\/span\x3e : [\x3cspan class=\x22hljs-string\x22\x3e\x22ZhangSan\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22LiSi\x22\x3c\/span\x3e],\n    \x3cspan class=\x22hljs-attr\x22\x3esayName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\nperson1.friends.push(\x3cspan class=\x22hljs-string\x22\x3e\x22WangWu\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.friends);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22ZhangSan,LiSi,WangWu\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person2.friends);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22ZhangSan,LiSi,WangWu\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.friends === person2.friends);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在此，\x3ccode\x3ePerson.prototype\x3c\/code\x3e 对象有一个名为 \x3ccode\x3efriends\x3c\/code\x3e 的属性，该属性包含一个字符串数组。然后，创建了 \x3ccode\x3ePerson\x3c\/code\x3e 的两个实例。接着，修改了 \x3ccode\x3eperson1.friends\x3c\/code\x3e 引用的数组，向数组中添加了一个字符串。由于 \x3ccode\x3efriends\x3c\/code\x3e 数组存在于 \x3ccode\x3ePerson.prototype\x3c\/code\x3e 而非 \x3ccode\x3eperson1\x3c\/code\x3e 中，所以刚刚提到的修改也会通过 \x3ccode\x3eperson2.friends\x3c\/code\x3e（与 \x3ccode\x3eperson1.friends\x3c\/code\x3e 指向同一个数组）反映出来。假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部属性的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e构造函数和原型结合\x3c\/h3\x3e\n\x3cp\x3e所以，构造函数用于定义实例属性，而原型用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。下面的代码重写了前面的例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name, age, job){\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = [\x26quot;ZhangSan\x26quot;, \x26quot;LiSi\x26quot;];\n}\n\nPerson.prototype = {\n    constructor : Person,\n    sayName : function(){\n        console.log(this.name);\n    }\n}\n\nvar person1 = new Person(\x26quot;Stone\x26quot;, 28, \x26quot;Software Engineer\x26quot;);\nvar person2 = new Person(\x26quot;Sophie\x26quot;, 29, \x26quot;English Teacher\x26quot;);\n\nperson1.friends.push(\x26quot;WangWu\x26quot;);\nconsole.log(person1.friends);    \/\/ \x26quot;ZhangSan,LiSi,WangWu\x26quot;\nconsole.log(person2.friends);    \/\/ \x26quot;ZhangSan,LiSi\x26quot;\nconsole.log(person1.friends === person2.friends);    \/\/ false\nconsole.log(person1.sayName === person2.sayName);    \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, age, job\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.job = job;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.friends = [\x3cspan class=\x22hljs-string\x22\x3e\x22ZhangSan\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22LiSi\x22\x3c\/span\x3e];\n}\n\nPerson.prototype = {\n    \x3cspan class=\x22hljs-attr\x22\x3econstructor\x3c\/span\x3e : Person,\n    \x3cspan class=\x22hljs-attr\x22\x3esayName\x3c\/span\x3e : \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22Stone\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22Software Engineer\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22Sophie\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e29\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22English Teacher\x22\x3c\/span\x3e);\n\nperson1.friends.push(\x3cspan class=\x22hljs-string\x22\x3e\x22WangWu\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.friends);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22ZhangSan,LiSi,WangWu\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person2.friends);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22ZhangSan,LiSi\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.friends === person2.friends);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person1.sayName === person2.sayName);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 \x3ccode\x3econstructor\x3c\/code\x3e 和方法 \x3ccode\x3esayName()\x3c\/code\x3e 则是在原型中定义的。而修改了 \x3ccode\x3eperson1.friends\x3c\/code\x3e（向其中添加一个新字符串），并不会影响到 \x3ccode\x3eperson2.friends\x3c\/code\x3e，因为它们分别引用了不同的数组。\x3c\/p\x3e\n\x3cp\x3e这种构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e\x3ccode\x3e__proto__\x3c\/code\x3e\x3c\/h2\x3e\n\x3cp\x3e为什么在构造函数的 \x3ccode\x3eprototype\x3c\/code\x3e 中定义了属性和方法，它的实例中就能访问呢？\x3c\/p\x3e\n\x3cp\x3e那是因为当调用构造函数创建一个新实例后，该实例的内部将包含一个指针 \x3ccode\x3e__proto__\x3c\/code\x3e，指向构造函数的原型。Firefox、Safari 和 Chrome 的每个对象上都有这个属性 ，而在其他浏览器中是完全不可见的（为了确保浏览器兼容性问题，不要直接使用 \x3ccode\x3e__proto__\x3c\/code\x3e 属性，此处只为解释原型链而演示）。让我们来看下面代码和图片：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007869509?w=936\x26amp;h=606\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007869509?w=936\x26amp;h=606\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e图中展示了 \x3ccode\x3ePerson\x3c\/code\x3e 构造函数、\x3ccode\x3ePerson\x3c\/code\x3e 的原型属性以及 \x3ccode\x3ePerson\x3c\/code\x3e 现有的两个实例之间的关系。在此，\x3ccode\x3ePerson.prototype.constructor\x3c\/code\x3e 指回了 \x3ccode\x3ePerson\x3c\/code\x3e。\x3ccode\x3ePerson.prototype\x3c\/code\x3e 中除了包含 \x3ccode\x3econstructor\x3c\/code\x3e 属性之外，还包括后来添加的其他属性。此外，要格外注意的是，虽然这两个实例都不包含属性和方法，但我们却可以调用 \x3ccode\x3eperson1.sayName()\x3c\/code\x3e。这是因为内部指针 \x3ccode\x3e__proto__\x3c\/code\x3e 指向 \x3ccode\x3ePerson.prototype\x3c\/code\x3e，而在 \x3ccode\x3ePerson.prototype\x3c\/code\x3e 中能找到 \x3ccode\x3esayName()\x3c\/code\x3e 方法。\x3c\/p\x3e\n\x3cp\x3e我们来证实一下，\x3ccode\x3e__proto__\x3c\/code\x3e 是不是真的指向 \x3ccode\x3ePerson.prototype\x3c\/code\x3e 的？如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person.__proto__ === Person.prototype); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e既然，\x3ccode\x3e__proto__\x3c\/code\x3e 确实是指向 \x3ccode\x3ePerson.prototype\x3c\/code\x3e，那么使用 \x3ccode\x3enew\x3c\/code\x3e 操作符创建对象的过程可以演变为，为实例对象的 \x3ccode\x3e__proto__\x3c\/code\x3e 赋值的过程。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(){}\n\n\/\/ var person = new Person(); \n\/\/ 上一行代码等同于以下过程 ==\x3e \nvar person = {};\nperson.__proto__ = Person.prototype;\nPerson.call(person);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ var person = new Person(); \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上一行代码等同于以下过程 ==\x26gt; \x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person = {};\nperson.__proto__ = Person.prototype;\nPerson.call(person);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子中，我先创建了一个空对象 \x3ccode\x3eperson\x3c\/code\x3e，然后把 \x3ccode\x3eperson.__proto__\x3c\/code\x3e 指向了 \x3ccode\x3ePerson\x3c\/code\x3e 的原型对象，便继承了 \x3ccode\x3ePerson\x3c\/code\x3e 原型对象中的所有属性和方法，最后又以 \x3ccode\x3eperson\x3c\/code\x3e 为作用域执行了 \x3ccode\x3ePerson\x3c\/code\x3e 函数，\x3ccode\x3eperson\x3c\/code\x3e 便就拥有了 \x3ccode\x3ePerson\x3c\/code\x3e 的所有属性和方法。这个过程和 \x3ccode\x3evar person = new Person();\x3c\/code\x3e 完全一样。\x3c\/p\x3e\n\x3cp\x3e简单来说，当我们访问一个对象的属性时，如果这个属性不存在，那么就会去 \x3ccode\x3e__proto__\x3c\/code\x3e 里找，这个 \x3ccode\x3e__proto__\x3c\/code\x3e 又会有自己的 \x3ccode\x3e__proto__\x3c\/code\x3e，于是就这样一直找下去，直到找到为止。在找不到的情况下，搜索过程总是要一环一环地前行到原型链末端才会停下来。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e原型链\x3c\/h2\x3e\n\x3cp\x3eJavaScript 中描述了\x3cstrong\x3e原型链\x3c\/strong\x3e的概念，并将原型链作为实现继承的主要方法。其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如下图所示：（图源：\x3ca href=\x22https:\/\/segmentfault.com\/q\/1010000005182807?_ea=1284630\x22\x3esegmentfault.com\x3c\/a\x3e，作者：\x3ca href=\x22https:\/\/segmentfault.com\/u\/manxisuo\x22 target=\x22_blank\x22\x3emanxisuo\x3c\/a\x3e）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007869510?w=590\x26amp;h=512\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007869510?w=590\x26amp;h=512\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。\x3c\/p\x3e\n\x3cp\x3e上面这段话比较绕口，代码更容易理解，让我们来看看实现原型链的基本模式。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Father(){\n    this.value = true;\n}\nFather.prototype.getValue = function(){\n    return this.value;\n};\n\nfunction Son(){\n    this.value2 = false;\n}\n\n\/\/ 继承了 Father\nSon.prototype = new Father();\n\nSon.prototype.getValue2 = function (){\n    return this.value2;\n};\n\nvar son = new Son();\nconsole.log(son.getValue());  \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFather\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\nFather.prototype.getValue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value;\n};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSon\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value2 = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继承了 Father\x3c\/span\x3e\nSon.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Father();\n\nSon.prototype.getValue2 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value2;\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e son = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Son();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(son.getValue());  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码定义了两个类型：\x3ccode\x3eFather\x3c\/code\x3e 和 \x3ccode\x3eSon\x3c\/code\x3e。每个类型分别有一个属性和一个方法。它们的主要区别是 \x3ccode\x3eSon\x3c\/code\x3e 继承了 \x3ccode\x3eFather\x3c\/code\x3e，而继承是通过创建 \x3ccode\x3eFather\x3c\/code\x3e 的实例，并将该实例赋给 \x3ccode\x3eSon.prototype\x3c\/code\x3e 实现的。实现的本质是重写原型对象，代之以一个新类型的实例。换句话说，原来存在于 \x3ccode\x3eFather\x3c\/code\x3e 的实例中的所有属性和方法，现在也存在于 \x3ccode\x3eSon.prototype\x3c\/code\x3e 中了。在确立了继承关系之后，我们给 \x3ccode\x3eSon.prototype\x3c\/code\x3e 添加了一个方法，这样就在继承了 \x3ccode\x3eFather\x3c\/code\x3e 的属性和方法的基础上又添加了一个新方法。\x3c\/p\x3e\n\x3cp\x3e我们再用 \x3ccode\x3e__proto__\x3c\/code\x3e 重写上面代码，更便于大家的理解：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Father(){\n    this.value = true;\n}\nFather.prototype.getValue = function(){\n    return this.value;\n};\n\nfunction Son(){\n    this.value2 = false;\n}\n\n\/\/ 继承了 Father\n\/\/ Son.prototype = new Father(); ==\x3e\nSon.prototype = {};\nSon.prototype.__proto__ = Father.prototype;\nFather.call(Son.prototype);\n\nSon.prototype.getValue2 = function (){\n    return this.value2;\n};\n\n\/\/ var son = new Son(); ==\x3e\nvar son = {};\nson.__proto__ = Son.prototype;\nSon.call(son);\n\nconsole.log(son.getValue()); \/\/ true\nconsole.log(son.getValue === son.__proto__.__proto__.getValue); \/\/ true \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFather\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\nFather.prototype.getValue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value;\n};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eSon\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value2 = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继承了 Father\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Son.prototype = new Father(); ==\x26gt;\x3c\/span\x3e\nSon.prototype = {};\nSon.prototype.__proto__ = Father.prototype;\nFather.call(Son.prototype);\n\nSon.prototype.getValue2 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value2;\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ var son = new Son(); ==\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e son = {};\nson.__proto__ = Son.prototype;\nSon.call(son);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(son.getValue()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(son.getValue === son.__proto__.__proto__.getValue); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从以上代码可以看出，实例 \x3ccode\x3eson\x3c\/code\x3e 调用 \x3ccode\x3egetValue()\x3c\/code\x3e 方法，实际是经过了 \x3ccode\x3eson.__proto__.__proto__.getValue\x3c\/code\x3e 的过程的，其中 \x3ccode\x3eson.__proto__\x3c\/code\x3e 等于 \x3ccode\x3eSon.prototype\x3c\/code\x3e，而 \x3ccode\x3eSon.prototype.__proto__\x3c\/code\x3e 又等于 \x3ccode\x3eFather.prototype\x3c\/code\x3e，所以 \x3ccode\x3eson.__proto__.__proto__.getValue\x3c\/code\x3e 其实就是 \x3ccode\x3eFather.prototype.getValue\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e事实上，前面例子中展示的原型链还少一环。我们知道，所有引用类型默然都继承了 \x3ccode\x3eObeject\x3c\/code\x3e，而这个继承也是通过原型链实现的。大家要记住，所有函数的默认原型都是 \x3ccode\x3eObject\x3c\/code\x3e 的实例，因此默认原型都会包含一个内部指针 \x3ccode\x3e__proto__\x3c\/code\x3e，指向 \x3ccode\x3eObject.prototype\x3c\/code\x3e。这也正是所有自定义类型都会继承 \x3ccode\x3etoString()\x3c\/code\x3e、\x3ccode\x3evalueOf()\x3c\/code\x3e 等默认方法的根本原因。\x3c\/p\x3e\n\x3cp\x3e下图展示了原型链实现继承的全部过程。（图源：\x3ca href=\x22https:\/\/segmentfault.com\/q\/1010000005182807?_ea=1284630\x22\x3esegmentfault.com\x3c\/a\x3e，作者：\x3ca href=\x22https:\/\/segmentfault.com\/u\/manxisuo\x22 target=\x22_blank\x22\x3emanxisuo\x3c\/a\x3e）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007869511?w=772\x26amp;h=800\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007869511?w=772\x26amp;h=800\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上图中，\x3ccode\x3ep\x3c\/code\x3e 指 \x3ccode\x3eprototype\x3c\/code\x3e 属性，\x3ccode\x3e[p]\x3c\/code\x3e 即 \x3ccode\x3e__proto__\x3c\/code\x3e 指对象的原型，\x3ccode\x3e[p]\x3c\/code\x3e 形成的链（虚线部分）就是\x3cstrong\x3e原型链\x3c\/strong\x3e。从图中可以得出以下信息：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eObject.prototype\x3c\/code\x3e 是顶级对象，所有对象都继承自它。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eObject.prototype.__proto__ === null\x3c\/code\x3e ，说明原型链到 \x3ccode\x3eObject.prototype\x3c\/code\x3e 终止。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eFunction.__proto__\x3c\/code\x3e 指向 \x3ccode\x3eFunction.prototype\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e关卡\x3c\/h2\x3e\n\x3cp\x3e根据描述写出对应的代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 挑战一\n\/\/ 1.定义一个构造函数 Animal，它有一个 name 属性，以及一个 eat() 原型方法。\n\/\/ 2.eat() 的方法体为：console.log(this.name \x2b \x26quot; is eating something.\x26quot;)。\n\/\/ 3.new 一个 Animal 的实例 tiger，然后调用 eat() 方法。\n\/\/ 4.用 __proto__ 模拟 new Animal() 的过程，然后调用 eat() 方法。\n\nvar Animal = function(name){\n    \/\/ 待补充的代码\n};\n\nvar tiger = new Animal(\x26quot;tiger\x26quot;);\n\/\/ 待补充的代码\n\nvar tiger2 = {};\n\/\/ 待补充的代码\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挑战一\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1.定义一个构造函数 Animal，它有一个 name 属性，以及一个 eat() 原型方法。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2.eat() 的方法体为：console.log(this.name \x2b \x22 is eating something.\x22)。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3.new 一个 Animal 的实例 tiger，然后调用 eat() 方法。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4.用 __proto__ 模拟 new Animal() 的过程，然后调用 eat() 方法。\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Animal = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 待补充的代码\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tiger = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Animal(\x3cspan class=\x22hljs-string\x22\x3e\x22tiger\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 待补充的代码\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tiger2 = {};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 待补充的代码\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 挑战二\n\/\/ 1.定义一个构造函数 Bird，它继承自 Animal，它有一个 name 属性，以及一个 fly() 原型方法。\n\/\/ 2.fly() 的方法体为：console.log(this.name \x2b \x26quot; want to fly higher.\x26quot;);。\n\/\/ 3.new 一个 Bird 的实例 pigeon，然后调用 eat() 和 fly() 方法。\n\/\/ 4.用 __proto__ 模拟 new Bird() 的过程，然后用代码解释 pigeon2 为何能调用 eat() 方法。\n\nvar Bird = function(name){\n      \/\/ 待补充的代码\n}\n\nvar pigeon = new Bird(\x26quot;pigeon\x26quot;);\n\/\/ 待补充的代码\n\nvar pigeon2 = {};\n\/\/ 待补充的代码\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挑战二\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1.定义一个构造函数 Bird，它继承自 Animal，它有一个 name 属性，以及一个 fly() 原型方法。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2.fly() 的方法体为：console.log(this.name \x2b \x22 want to fly higher.\x22);。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3.new 一个 Bird 的实例 pigeon，然后调用 eat() 和 fly() 方法。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4.用 __proto__ 模拟 new Bird() 的过程，然后用代码解释 pigeon2 为何能调用 eat() 方法。\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Bird = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 待补充的代码\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e pigeon = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Bird(\x3cspan class=\x22hljs-string\x22\x3e\x22pigeon\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 待补充的代码\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e pigeon2 = {};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 待补充的代码\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 挑战三\n\/\/ 1.定义一个构造函数 Swallow，它继承自 Bird，它有一个 name 属性，以及一个 nesting() 原型方法。\n\/\/ 2.nesting() 的方法体为：console.log(this.name \x2b \x26quot; is nesting now.\x26quot;);。\n\/\/ 3.new 一个 Swallow 的实例 yanzi，然后调用 eat()、fly() 和 nesting() 方法。\n\/\/ 4.用 __proto__ 模拟 new Swallow() 的过程，然后用代码解释 yanzi2 为何能调用 eat() 方法。\n\nvar Swallow = function(name){\n      \/\/ 待补充的代码\n}\n\nvar yanzi = new Swallow(\x26quot;yanzi\x26quot;);\n\/\/ 待补充的代码\n\nvar yanzi2 = {};\n\/\/ 待补充的代码\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挑战三\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1.定义一个构造函数 Swallow，它继承自 Bird，它有一个 name 属性，以及一个 nesting() 原型方法。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2.nesting() 的方法体为：console.log(this.name \x2b \x22 is nesting now.\x22);。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3.new 一个 Swallow 的实例 yanzi，然后调用 eat()、fly() 和 nesting() 方法。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4.用 __proto__ 模拟 new Swallow() 的过程，然后用代码解释 yanzi2 为何能调用 eat() 方法。\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Swallow = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 待补充的代码\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e yanzi = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Swallow(\x3cspan class=\x22hljs-string\x22\x3e\x22yanzi\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 待补充的代码\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e yanzi2 = {};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 待补充的代码\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e更多\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。  \x3cbr\x3e关注 \x3ca href=\x22https:\/\/github.com\/stone0090\/javascript-lessons\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/stone0090\/javascript-lessons\x3c\/a\x3e，获取最新动态。\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>《JavaScript 闯关记》之原型及原型链</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007869506">https://segmentfault.com/a/1190000007869506</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/blox1xln3l/" target="_blank">https://alili.tech/archive/blox1xln3l/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/dc9tmbt89lc/">CSS3 巧妙实现聊天气泡<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/awfhylei7vr/">Element 一套优雅的 Vue 2 组件库是如何开发的<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/5n6e7oj31zb/">Ionic2入坑基础教程和安装指南<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/k9uktrr2ck/">JavaScript arguments 对象全面介绍<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/d31ygsiurr7/">JavaScript 版俄罗斯方块——重构<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/f1goxj498pc/">JavaScript中this绑定详解<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/fpk9tyls8sb/">Markcook2.0，使用Vue2.0和Vuex2.0进行完全重构升级<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/rnj4z8l02t/">N3-components - 强劲的 Vue UI组件库<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/7njdijhy2um/">Node.js &#43; React Native 毕设：农业物联网监测系统的开发手记<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/f8zzbybr4tl/">Redux、Flux、Vuex<aside class="dates">2019-02-02</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>