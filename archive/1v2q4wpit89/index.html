<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/1v2q4wpit89/",
				"appid": "1613049289050283", 
				"title": "React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-17T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/e4rpuyrcaps/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/btjef8xeot/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f&text=React%20%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%9c%a8%20React%20%e9%87%8c%e9%9d%a2%ef%bc%8c%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%2c%20%e4%bd%86%e6%98%af%e4%bd%a0%e4%bc%9a%e5%8f%91%e7%8e%b0%e4%bb%96%e4%bb%ac%e7%a1%ae%e5%ae%9e%e5%be%88%e6%9c%89%e7%94%a8%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f&text=React%20%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%9c%a8%20React%20%e9%87%8c%e9%9d%a2%ef%bc%8c%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%2c%20%e4%bd%86%e6%98%af%e4%bd%a0%e4%bc%9a%e5%8f%91%e7%8e%b0%e4%bb%96%e4%bb%ac%e7%a1%ae%e5%ae%9e%e5%be%88%e6%9c%89%e7%94%a8%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f&title=React%20%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%9c%a8%20React%20%e9%87%8c%e9%9d%a2%ef%bc%8c%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%2c%20%e4%bd%86%e6%98%af%e4%bd%a0%e4%bc%9a%e5%8f%91%e7%8e%b0%e4%bb%96%e4%bb%ac%e7%a1%ae%e5%ae%9e%e5%be%88%e6%9c%89%e7%94%a8%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f&is_video=false&description=React%20%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%9c%a8%20React%20%e9%87%8c%e9%9d%a2%ef%bc%8c%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%2c%20%e4%bd%86%e6%98%af%e4%bd%a0%e4%bc%9a%e5%8f%91%e7%8e%b0%e4%bb%96%e4%bb%ac%e7%a1%ae%e5%ae%9e%e5%be%88%e6%9c%89%e7%94%a8%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%9c%a8%20React%20%e9%87%8c%e9%9d%a2%ef%bc%8c%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%2c%20%e4%bd%86%e6%98%af%e4%bd%a0%e4%bc%9a%e5%8f%91%e7%8e%b0%e4%bb%96%e4%bb%ac%e7%a1%ae%e5%ae%9e%e5%be%88%e6%9c%89%e7%94%a8%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f&title=React%20%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%9c%a8%20React%20%e9%87%8c%e9%9d%a2%ef%bc%8c%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%2c%20%e4%bd%86%e6%98%af%e4%bd%a0%e4%bc%9a%e5%8f%91%e7%8e%b0%e4%bb%96%e4%bb%ac%e7%a1%ae%e5%ae%9e%e5%be%88%e6%9c%89%e7%94%a8%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f&title=React%20%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%9c%a8%20React%20%e9%87%8c%e9%9d%a2%ef%bc%8c%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%2c%20%e4%bd%86%e6%98%af%e4%bd%a0%e4%bc%9a%e5%8f%91%e7%8e%b0%e4%bb%96%e4%bb%ac%e7%a1%ae%e5%ae%9e%e5%be%88%e6%9c%89%e7%94%a8%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f&title=React%20%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%9c%a8%20React%20%e9%87%8c%e9%9d%a2%ef%bc%8c%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%2c%20%e4%bd%86%e6%98%af%e4%bd%a0%e4%bc%9a%e5%8f%91%e7%8e%b0%e4%bb%96%e4%bb%ac%e7%a1%ae%e5%ae%9e%e5%be%88%e6%9c%89%e7%94%a8%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f1v2q4wpit89%2f&title=React%20%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%a2%e8%af%95%e9%a2%98%ef%bc%88%e5%9c%a8%20React%20%e9%87%8c%e9%9d%a2%ef%bc%8c%e4%bd%a0%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e4%b9%9f%e5%8f%af%e4%bb%a5%e4%b8%8d%e7%9f%a5%e9%81%93%e7%9a%84%e4%ba%8b%2c%20%e4%bd%86%e6%98%af%e4%bd%a0%e4%bc%9a%e5%8f%91%e7%8e%b0%e4%bb%96%e4%bb%ac%e7%a1%ae%e5%ae%9e%e5%be%88%e6%9c%89%e7%94%a8%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-17" itemprop="datePublished">2019-01-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3eReact 常见的面试题\x3c\/h2\x3e\n\x3cblockquote\x3e（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用）\x3c\/blockquote\x3e\n\x3chr\x3e\n\x3cp\x3e根据记录，问这些问题可能不是深入了解他们在使用 React 方面的经验的最佳方式。\x3cbr\x3e之所以标题是《 React 常见的面试题》，其实只是想起一个比《在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用》要简单明了的标题而已。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVLVYg?w=800\x26amp;h=800\x22 src=\x22https:\/\/static.alili.tech\/img\/bVLVYg?w=800\x26amp;h=800\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e原文链接：\x3ca href=\x22https:\/\/tylermcginnis.com\/react-interview-questions\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Interview Questions\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者： Tyler.Google Developer Expert and a partner at React Training where we teach React online\x3c\/p\x3e\n\x3cp\x3e翻译：\x3ca href=\x22http:\/\/johannlai.com\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJohann Lai\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e当你调用 \x3cstrong\x3esetState\x3c\/strong\x3e 的时候，发生了什么事？\x3c\/h2\x3e\n\x3cp\x3e当调用 \x3ccode\x3esetState\x3c\/code\x3e 时，React会做的第一件事情是将传递给 \x3ccode\x3esetState\x3c\/code\x3e 的对象合并到组件的当前状态。这将启动一个称为和解（reconciliation）的过程。和解（reconciliation）的最终目标是以最有效的方式，根据这个新的状态来更新UI。 为此，React将构建一个新的 \x3ccode\x3eReact\x3c\/code\x3e 元素树（您可以将其视为 UI 的对象表示）。\x3cbr\x3e一旦有了这个树，为了弄清 UI 如何响应新的状态而改变，React 会将这个新树与上一个元素树相比较（\x3cstrong\x3ediff\x3c\/strong\x3e）。   \x3c\/p\x3e\n\x3cp\x3e通过这样做， React 将会知道发生的确切变化，并且通过了解发生什么变化，只需在绝对必要的情况下进行更新即可最小化 UI 的占用空间。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e在 React 当中  Element 和  Component 有何区别？\x3c\/h2\x3e\n\x3cp\x3e简单地说，一个 \x3cstrong\x3eReact  element\x3c\/strong\x3e 描述了你想在屏幕上看到什么。换个说法就是，一个 \x3cstrong\x3eReact  element\x3c\/strong\x3e  是一些 UI 的对象表示。\x3c\/p\x3e\n\x3cp\x3e一个 \x3cstrong\x3eReact Component\x3c\/strong\x3e 是一个函数或一个类，它可以接受输入并返回一个 \x3cstrong\x3eReact  element\x3c\/strong\x3e t（通常是通过 JSX ，它被转化成一个 createElement 调用）。\x3c\/p\x3e\n\x3cp\x3e有关更多信息，请查看 \x3ca href=\x22https:\/\/tylermcginnis.com\/react-elements-vs-react-components\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Elements vs React Components\x3c\/a\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e什么时候在功能组件( Class Component  )上使用类组件(  Functional Component )？\x3c\/h2\x3e\n\x3cp\x3e如果您的组件具有状态( state )或生命周期方法，请使用 Class 组件。否则，使用功能组件\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e什么是 React 的 refs ，为什么它们很重要？\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3erefs\x3c\/strong\x3e 就像是一个逃生舱口，允许您直接访问DOM元素或组件实例。为了使用它们，您可以向组件添加一个 \x3cstrong\x3eref\x3c\/strong\x3e 属性，该属性的值是一个回调函数，它将接收底层的 DOM 元素或组件的已挂接实例，作为其第一个参数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class UnControlledForm extends Component {\n  handleSubmit = () =\x3e {\n    console.log(\x26quot;Input Value: \x26quot;, this.input.value)\n  }\n  render () {\n    return (\n      \x3cform onSubmit={this.handleSubmit}\x3e\n        \x3cinput\n          type=\x27text\x27\n          ref={(input) =\x3e this.input = input} \/\x3e\n        \x3cbutton type=\x27submit\x27\x3eSubmit\x3c\/button\x3e\n      \x3c\/form\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eUnControlledForm\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  handleSubmit = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Input Value: \x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.value)\n  }\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonSubmit\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleSubmit}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e\n          \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27text\x27\x3c\/span\x3e\n          \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{(input)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e this.input = input} \/\x26gt;\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27submit\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3eSubmit\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    )\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上注意到我们的输入字段有一个 \x3cstrong\x3eref\x3c\/strong\x3e 属性，其值是一个函数。该函数接收我们然后放在实例上的实际的 DOM 元素，以便在 \x3cem\x3ehandleSubmit\x3c\/em\x3e 函数内部访问它。经常误解的是，您需要使用类组件才能使用\x3cstrong\x3eref\x3c\/strong\x3e ，但 \x3cstrong\x3eref\x3c\/strong\x3e 也可以通过利用 \x3ccode\x3eJavaScript\x3c\/code\x3e 中的\x3cstrong\x3e闭包\x3c\/strong\x3e与 功能组件( functional components )一起使用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function CustomForm ({handleSubmit}) {\n  let inputElement\n  return (\n    \x3cform onSubmit={() =\x3e handleSubmit(inputElement.value)}\x3e\n      \x3cinput\n        type=\x27text\x27\n        ref={(input) =\x3e inputElement = input} \/\x3e\n      \x3cbutton type=\x27submit\x27\x3eSubmit\x3c\/button\x3e\n    \x3c\/form\x3e\n  )\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCustomForm\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e{handleSubmit}\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e inputElement\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonSubmit\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e handleSubmit(inputElement.value)}\x26gt;\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e\n        \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27text\x27\x3c\/span\x3e\n        \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{(input)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e inputElement = input} \/\x26gt;\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27submit\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3eSubmit\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  )\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eReact 中的 \x3cstrong\x3ekeys\x3c\/strong\x3e 是什么，为什么它们很重要？\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3ekeys\x3c\/strong\x3e 是什么帮助 React 跟踪哪些项目已更改、添加或从列表中删除。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  return (\n    \x3cul\x3e\n      {this.state.todoItems.map(({task, uid}) =\x3e {\n        return \x3cli key={uid}\x3e{task}\x3c\/li\x3e\n      })}\n    \x3c\/ul\x3e\n  )\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      {this.state.todoItems.map(({task, uid}) =\x26gt; {\n        return \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{uid}\x3c\/span\x3e\x26gt;\x3c\/span\x3e{task}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      })}\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  )\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每个\x3cstrong\x3ekeys\x3c\/strong\x3e 在兄弟元素之间是独一无二的。我们已经谈过几次关于和解（reconciliation）的过程，而且这个和解过程（reconciliation）中的一部分正在执行一个新的元素树与最前一个的差异。\x3cstrong\x3ekeys\x3c\/strong\x3e 使处理列表时更加高效，因为 React 可以使用子元素上的 \x3cstrong\x3ekeys\x3c\/strong\x3e 快速知道元素是新的还是在比较树时才被移动。\x3c\/p\x3e\n\x3cp\x3e而且 \x3cstrong\x3ekeys\x3c\/strong\x3e 不仅使这个过程更有效率，而且没有\x3cstrong\x3ekeys\x3c\/strong\x3e，React 不知道哪个本地状态对应于移动中的哪个项目。所以当你 map 的时候，不要忽略了 \x3cstrong\x3ekeys\x3c\/strong\x3e 。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e看下面的代码: 如果您在 \x26lt;Twitter \/\x26gt; 下创建了一个 React 元素，\x26lt;Twitter \/\x26gt;的组件定义将如何？\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cTwitter username=\x27tylermcginnis33\x27\x3e\n  {(user) =\x3e user === null\n    ? \x3cLoading \/\x3e\n    : \x3cBadge info={user} \/\x3e}\n\x3c\/Twitter\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x26lt;Twitter username=\x3cspan class=\x22hljs-string\x22\x3e\x27tylermcginnis33\x27\x3c\/span\x3e\x26gt;\n  {(user) =\x26gt; user === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    ? \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eLoading\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    : \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eBadge\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3einfo\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{user}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e}\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eTwitter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component, PropTypes } from \x27react\x27\nimport fetchUser from \x27twitter\x27\n\/\/ fetchUser接收用户名返回 promise\n\/\/ 当得到 用户的数据的时候 ，返回resolve 状态\n\nclass Twitter extends Component {\n  \/\/ 在这里写下你的代码\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component, PropTypes } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e fetchUser \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27twitter\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ fetchUser接收用户名返回 promise\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当得到 用户的数据的时候 ，返回resolve 状态\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTwitter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在这里写下你的代码\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你不熟悉渲染回调模式（render callback pattern），这将看起来有点奇怪。在这种模式中，一个组件接收一个函数作为它的 child。注意上面包含在 \x26lt;Twitter\x26gt;标签内的内容。\x3cem\x3eTwitter\x3c\/em\x3e 组件的 child 是一个函数，而不是你曾经习以为常的一个组件。 这意味着在实现 \x3cem\x3eTwitter\x3c\/em\x3e 组件时，我们需要将 \x3cem\x3eprops.children\x3c\/em\x3e 作为一个函数来处理。 \x3c\/p\x3e\n\x3cp\x3e以下是我的答案。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n    import React, { Component, PropTypes } from \x27react\x27\n    import fetchUser from \x27twitter\x27\n    \n    class Twitter extends Component {\n      state = {\n        user: null,\n      }\n      static propTypes = {\n        username: PropTypes.string.isRequired,\n      }\n      componentDidMount () {\n        fetchUser(this.props.username)\n          .then((user) =\x3e this.setState({user}))\n      }\n      render () {\n        return this.props.children(this.state.user)\n      }\n    }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component, PropTypes } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e fetchUser \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27twitter\x27\x3c\/span\x3e\n    \n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTwitter\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n      state = {\n        \x3cspan class=\x22hljs-attr\x22\x3euser\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e propTypes = {\n        \x3cspan class=\x22hljs-attr\x22\x3eusername\x3c\/span\x3e: PropTypes.string.isRequired,\n      }\n      componentDidMount () {\n        fetchUser(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.username)\n          .then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3euser\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({user}))\n      }\n      render () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.user)\n      }\n    }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e值得注意的是\x3c\/strong\x3e，正如我上面提到的，我通过调用它并传递给 user 来把 props.children 处理为为一个函数。\x3c\/p\x3e\n\x3cp\x3e这种模式的好处是我们已经将我们的父组件与我们的子组件分离了。父组件管理状态，父组件的消费者可以决定以何种方式将从父级接收的参数应用于他们的 UI。\x3c\/p\x3e\n\x3cp\x3e为了演示这一点，我们假设在另一个文件中，我们要渲染一个 \x3cem\x3eProfile\x3c\/em\x3e 而不是一个 \x3cem\x3eBadge,\x3c\/em\x3e，因为我们使用渲染回调模式，所以我们可以轻松地交换 UI ，而不用改变我们对父（Twitter）组件的实现。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cTwitter username=\x27tylermcginnis33\x27\x3e\n  {(user) =\x3e user === null\n    ? \x3cLoading \/\x3e\n    : \x3cProfile info={user} \/\x3e}\n\x3c\/Twitter\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x26lt;Twitter username=\x3cspan class=\x22hljs-string\x22\x3e\x27tylermcginnis33\x27\x3c\/span\x3e\x26gt;\n  {(user) =\x26gt; user === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    ? \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eLoading\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n    : \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eProfile\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3einfo\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{user}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e}\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eTwitter\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e受控组件( controlled component )与不受控制的组件( uncontrolled component )有什么区别？\x3c\/h2\x3e\n\x3cp\x3eReact 的很大一部分是这样的想法，即组件负责控制和管理自己的状态。\x3c\/p\x3e\n\x3cp\x3e当我们将 native HTML 表单元素（ input, select, textarea 等）投入到组合中时会发生什么？我们是否应该使用 React 作为“单一的真理来源”，就像我们习惯使用React一样？ 或者我们是否允许表单数据存在 DOM 中，就像我们习惯使用HTML表单元素一样？ 这两个问题是受控（controlled） VS 不受控制（uncontrolled）组件的核心。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e受控\x3c\/strong\x3e组件是React控制的组件，也是表单数据的唯一真理来源。\x3c\/p\x3e\n\x3cp\x3e如下所示，\x3cem\x3eusername\x3c\/em\x3e 不存在于 DOM 中，而是以我们的组件状态存在。每当我们想要更新 \x3cem\x3eusername\x3c\/em\x3e 时，我们就像以前一样调用setState。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ControlledForm extends Component {\n  state = {\n    username: \x27\x27\n  }\n  updateUsername = (e) =\x3e {\n    this.setState({\n      username: e.target.value,\n    })\n  }\n  handleSubmit = () =\x3e {}\n  render () {\n    return (\n      \x3cform onSubmit={this.handleSubmit}\x3e\n        \x3cinput\n          type=\x27text\x27\n          value={this.state.username}\n          onChange={this.updateUsername} \/\x3e\n        \x3cbutton type=\x27submit\x27\x3eSubmit\x3c\/button\x3e\n      \x3c\/form\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eControlledForm\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  state = {\n    \x3cspan class=\x22hljs-attr\x22\x3eusername\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e\n  }\n  updateUsername = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      \x3cspan class=\x22hljs-attr\x22\x3eusername\x3c\/span\x3e: e.target.value,\n    })\n  }\n  handleSubmit = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {}\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonSubmit\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleSubmit}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e\n          \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27text\x27\x3c\/span\x3e\n          \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.state.username}\x3c\/span\x3e\n          \x3cspan class=\x22hljs-attr\x22\x3eonChange\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.updateUsername}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27submit\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3eSubmit\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    )\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不受控制( uncontrolled component )的组件是您的表单数据由 DOM 处理，而不是您的 React 组件。\x3c\/p\x3e\n\x3cp\x3e我们使用 \x3cstrong\x3erefs\x3c\/strong\x3e 来完成这个。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class UnControlledForm extends Component {\n  handleSubmit = () =\x3e {\n    console.log(\x26quot;Input Value: \x26quot;, this.input.value)\n  }\n  render () {\n    return (\n      \x3cform onSubmit={this.handleSubmit}\x3e\n        \x3cinput\n          type=\x27text\x27\n          ref={(input) =\x3e this.input = input} \/\x3e\n        \x3cbutton type=\x27submit\x27\x3eSubmit\x3c\/button\x3e\n      \x3c\/form\x3e\n    )\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eUnControlledForm\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  handleSubmit = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Input Value: \x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.value)\n  }\n  render () {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonSubmit\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.handleSubmit}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e\n          \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27text\x27\x3c\/span\x3e\n          \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{(input)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e this.input = input} \/\x26gt;\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x27submit\x27\x3c\/span\x3e\x26gt;\x3c\/span\x3eSubmit\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eform\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    )\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然不受控制的组件通常更容易实现，因为您只需使用引用从DOM获取值，但是通常建议您通过不受控制的组件来支持受控组件。\x3c\/p\x3e\n\x3cp\x3e主要原因是受控组件\x3cstrong\x3e支持即时字段验证\x3c\/strong\x3e，允许您有条件地禁用\/启用按钮，强制输入格式，并且更多的是 『the React way』。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e在哪个生命周期事件中你会发出 AJAX 请求，为什么？\x3c\/h2\x3e\n\x3cp\x3eAJAX 请求应该在 \x3ccode\x3ecomponentDidMount\x3c\/code\x3e 生命周期事件中。 有几个原因:\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3eFiber，是下一次实施React的和解算法，将有能力根据需要启动和停止渲染，以获得性能优势。其中一个取舍之一是 \x3ccode\x3ecomponentWillMount\x3c\/code\x3e，而在其他的生命周期事件中出发 AJAX 请求，将是具有 “非确定性的”。 这意味着 React 可以在需要时感觉到不同的时间开始调用 componentWillMount。这显然是AJAX请求的不好的方式。\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e-您不能保证在组件挂载之前，AJAX请求将无法 resolve。如果这样做，那意味着你会尝试在一个未挂载的组件上设置 StState，这不仅不会起作用，反而会对你大喊大叫。 在 \x3ccode\x3ecomponentDidMount\x3c\/code\x3e 中执行 AJAX 将保证至少有一个要更新的组件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3eshouldComponentUpdate 应该做什么，为什么它很重要？\x3c\/h2\x3e\n\x3cp\x3e上面我们讨论了 reconciliation ，什么是 React 在 setState 被调用时所做的。在生命周期方法 shouldComponentUpdate 中，允许我们选择退出某些组件（和他们的子组件）的 reconciliation  过程。\x3c\/p\x3e\n\x3cp\x3e我们为什么要这样做？\x3c\/p\x3e\n\x3cp\x3e如上所述，“和解（ reconciliation ）的最终目标是以最有效的方式，根据新的状态更新用户界面”。如果我们知道我们的用户界面（UI）的某一部分不会改变，那么没有理由让 React 很麻烦地试图去弄清楚它是否应该渲染。通过从 shouldComponentUpdate 返回 false，React 将假定当前组件及其所有子组件将保持与当前组件相同。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e您如何告诉React 构建（build）生产模式，该做什么？\x3c\/h2\x3e\n\x3cp\x3e通常，您将使用Webpack的 \x3cem\x3eDefinePlugin\x3c\/em\x3e 方法将 \x3cstrong\x3eNODE_ENV\x3c\/strong\x3e 设置为 production。这将剥离像 propType 验证和额外的警告。除此之外，还有一个好主意，可以减少你的代码，因为React使用 Uglify 的 dead-code 来消除开发代码和注释，这将大大减少你的包的大小。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e为什么要使用 React.Children.map（props.children，（）=\x26gt;） 而不是 props.children.map（（）=\x26gt;）\x3c\/h2\x3e\n\x3cp\x3e因为不能保证props.children将是一个数组。 \x3c\/p\x3e\n\x3cp\x3e以此代码为例，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cParent\x3e\n  \x3ch1\x3eWelcome.\x3c\/h1\x3e\n\x3c\/Parent\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x26lt;Parent\x26gt;\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eWelcome.\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/Parent\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在父组件内部，如果我们尝试使用 props.children.map 映射孩子，则会抛出错误，因为 props.children 是一个对象，而不是一个数组。\x3c\/p\x3e\n\x3cp\x3e如果有多个子元素，React 只会使props.children成为一个数组。就像下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cParent\x3e\n  \x3ch1\x3eWelcome.\x3c\/h1\x3e\n  \x3ch2\x3eprops.children will now be an array\x3c\/h2\x3e\n\x3c\/Parent\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x26lt;Parent\x26gt;\n  \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eWelcome.\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  \x26lt;h2\x26gt;props.children will now be an array\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/h2\x26gt;\n\x26lt;\/\x3c\/span\x3eParent\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这就是为什么你喜欢 \x3ccode\x3eReact.Children.map\x3c\/code\x3e，因为它的实现考虑到 \x3ccode\x3eprops.children\x3c\/code\x3e 可能是一个数组或一个对象。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e描述事件在React中的处理方式。\x3c\/h2\x3e\n\x3cp\x3e为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递\x3ccode\x3eSyntheticEvent\x3c\/code\x3e 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。\x3c\/p\x3e\n\x3cp\x3e这些 \x3ccode\x3eSyntheticEvent\x3c\/code\x3e 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新DOM时，React 不需要担心跟踪事件监听器。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3ecreateElement 和 cloneElement 有什么区别？\x3c\/h2\x3e\n\x3cp\x3ecreateElement 是 JSX 被转载到的，是 React 用来创建 React Elements 的内容(一些 UI 的对象表示)cloneElement用于克隆元素并传递新的 props。他们钉住了这两个?的命名。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e可以选择性地传递给 setState 的第二个参数是什么，它的目的是什么？\x3c\/h2\x3e\n\x3cp\x3e一个回调函数，当setState结束并\x3ccode\x3ere-rendered\x3c\/code\x3e该组件时将被调用。一些没有说出来的东西是 setState 是\x3cstrong\x3e异步\x3c\/strong\x3e的，这就是为什么它需要一个第二个回调函数。通常最好使用另一个生命周期方法，而不是依赖这个回调函数，但是很高兴知道它存在。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.setState(\n  { username: \x27tylermcginnis33\x27 },\n  () =\x3e console.log(\x27setState has finished and the component has re-rendered.\x27)\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\n  { \x3cspan class=\x22hljs-attr\x22\x3eusername\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27tylermcginnis33\x27\x3c\/span\x3e },\n  () =\x26gt; \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27setState has finished and the component has re-rendered.\x27\x3c\/span\x3e)\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e这段代码有什么问题？\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.setState((prevState, props) =\x3e {\n  return {\n    streak: prevState.streak \x2b props.count\n  }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(prevState, props)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    streak: prevState.streak \x2b props.count\n  }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e没毛病。但是这种写法很少被使用，并不是众所周知的，就是你也可以传递一个函数给setState，它接收到先前的状态和道具并返回一个新的状态，正如我们在上面所做的那样。它不仅没有什么问题，而且如果您根据以前的状态（state）设置状态，推荐使用这种写法。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 常见的面试题（在 React 里面，你可以知道也可以不知道的事, 但是你会发现他们确实很有用）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009001924">https://segmentfault.com/a/1190000009001924</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/1v2q4wpit89/" target="_blank">https://alili.tech/archive/1v2q4wpit89/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/dgic8s5qnlg/">CSS五种方式实现Footer置底<aside class="dates">2019-01-25</aside></a></li><li><a href="/archive/z94br1a9g2o/">React的10种有效的设计模式<aside class="dates">2019-01-25</aside></a></li><li><a href="/archive/xe4kfnhxlfo/">Seneca ：NodeJS 微服务框架入门指南<aside class="dates">2019-01-25</aside></a></li><li><a href="/archive/ffpl5ftnw2u/">Unable to preventDefault inside passive event listener<aside class="dates">2019-01-25</aside></a></li><li><a href="/archive/twqwd2wscy/">Vue源码详细解析:transclude,compile,link,依赖,批处理...一网打尽，全解析!<aside class="dates">2019-01-25</aside></a></li><li><a href="/archive/i1zivpsjdl/">chart.js 中文文档 翻译<aside class="dates">2019-01-25</aside></a></li><li><a href="/archive/ik09416kg2/">flex-box 速记表<aside class="dates">2019-01-25</aside></a></li><li><a href="/archive/ic5ys9tnr1n/">riotjs 2.2.4<aside class="dates">2019-01-25</aside></a></li><li><a href="/archive/wd1i4kdw4jq/">vuejs2.0运用原生js实现简单的拖拽元素功能<aside class="dates">2019-01-25</aside></a></li><li><a href="/archive/l7r8ye5804/">一道JS面试题所引发的&#34;血案&#34;，透过现象寻本质，再从本质看现象<aside class="dates">2019-01-25</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>