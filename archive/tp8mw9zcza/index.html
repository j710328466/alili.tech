<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 函数式编程介绍"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 函数式编程介绍 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/tp8mw9zcza/",
				"appid": "1613049289050283", 
				"title": "JavaScript 函数式编程介绍 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-22T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qp9cw53ffvb/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/2c17f8uofa/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f&text=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%8b%e7%bb%8d"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f&text=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%8b%e7%bb%8d"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%8b%e7%bb%8d"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f&is_video=false&description=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%8b%e7%bb%8d"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%8b%e7%bb%8d&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%8b%e7%bb%8d"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%8b%e7%bb%8d"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%8b%e7%bb%8d"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftp8mw9zcza%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e4%bb%8b%e7%bb%8d"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 函数式编程介绍</h1><div class="meta"><div class="postdate"><time datetime="2019-01-22" itemprop="datePublished">2019-01-22</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3ch1\x3e\x3ca href=\x22#javascript-函数式编程介绍\x22\x3e\x3c\/a\x3eJavaScript 函数式编程介绍\x3c\/h1\x3e\n\x3cblockquote\x3e\n\x3cp\x3e探索函数式编程，通过它让你的程序更具有可读性和易于调试\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/05461992b5df47b90841e7008cd1234a4eb87359\/68747470733a2f2f6f70656e736f757263652e636f6d2f73697465732f64656661756c742f66696c65732f7374796c65732f696d6167652d66756c6c2d73697a652f7075626c69632f6c6561642d696d616765732f6275732d726f636b65742e706e673f69746f6b3d7851714b524d6c61\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t014849e46b6e5198d8.png\x22 alt=\x22An introduction to functional programming in JavaScript\x22 title=\x22An introduction to functional programming in JavaScript\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3eImage credits : Steve Jurvetson via \x3ca href=\x22https:\/\/www.flickr.com\/photos\/jurvetson\/882193732\/\x22\x3eFlickr\x3c\/a\x3e (CC-BY-2.0)\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e当 Brendan Eich 在 1995 年创造 JavaScript 时，他原本打算\x3ca href=\x22https:\/\/brendaneich.com\/2008\/04\/popularity\/\x22\x3e将 Scheme 移植到浏览器里\x3c\/a\x3e 。Scheme 作为 Lisp 的方言，是一种函数式编程语言。而当 Eich 被告知新的语言应该是一种可以与 Java 相比的脚本语言后，他最终确立了一种拥有 C 风格语法的语言（也和 Java 一样），但将函数视作一等公民。而 Java 直到版本 8 才从技术上将函数视为一等公民，虽然你可以用匿名类来模拟它。这个特性允许 JavaScript 通过函数式范式编程。\x3c\/p\x3e\n\x3cp\x3eJavaScript 是一个多范式语言，允许你自由地混合和使用面向对象式、过程式和函数式的编程范式。最近，函数式编程越来越火热。在诸如 \x3ca href=\x22https:\/\/angular-2-training-book.rangle.io\/handout\/change-detection\/change_detection_strategy_onpush.html\x22\x3eAngular\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/optimizing-performance.html#the-power-of-not-mutating-data\x22\x3eReact\x3c\/a\x3e 这样的框架中，通过使用不可变数据结构可以切实提高性能。不可变是函数式编程的核心原则，它以及纯函数使得编写和调试程序变得更加容易。使用函数来代替程序的循环可以提高程序的可读性并使它更加优雅。总之，函数式编程拥有很多优点。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#什么不是函数式编程\x22\x3e\x3c\/a\x3e什么不是函数式编程\x3c\/h3\x3e\n\x3cp\x3e在讨论什么是函数式编程前，让我们先排除那些不属于函数式编程的东西。实际上它们是你需要丢弃的语言组件（再见，老朋友）：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e循环：\x3cul\x3e\n\x3cli\x3e\x3ccode\x3ewhile\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3edo...while\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3efor\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3efor...of\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3efor...in\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e用 \x3ccode\x3evar\x3c\/code\x3e 或者 \x3ccode\x3elet\x3c\/code\x3e 来声明变量\x3c\/li\x3e\n\x3cli\x3e没有返回值的函数\x3c\/li\x3e\n\x3cli\x3e改变对象的属性 (比如: \x3ccode\x3eo.x = 5;\x3c\/code\x3e)\x3c\/li\x3e\n\x3cli\x3e改变数组本身的方法：\x3cul\x3e\n\x3cli\x3e\x3ccode\x3ecopyWithin\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3efill\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3epop\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3epush\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3ereverse\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eshift\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3esort\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3esplice\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eunshift\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e改变映射本身的方法：\x3cul\x3e\n\x3cli\x3e\x3ccode\x3eclear\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3edelete\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eset\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e改变集合本身的方法：\x3cul\x3e\n\x3cli\x3e\x3ccode\x3eadd\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eclear\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3edelete\x3c\/code\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e脱离这些特性应该如何编写程序呢？这是我们将在后面探索的问题。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#纯函数\x22\x3e\x3c\/a\x3e纯函数\x3c\/h3\x3e\n\x3cp\x3e你的程序中包含函数不一定意味着你正在进行函数式编程。函数式范式将纯函数pure function和非纯函数impure function区分开。鼓励你编写纯函数。纯函数必须满足下面的两个属性：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e引用透明：函数在传入相同的参数后永远返回相同的返回值。这意味着该函数不依赖于任何可变状态。\x3c\/li\x3e\n\x3cli\x3e无副作用：函数不能导致任何副作用。副作用可能包括 I\/O（比如向终端或者日志文件写入），改变一个不可变的对象，对变量重新赋值等等。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们来看一些例子。首先，\x3ccode\x3emultiply\x3c\/code\x3e 就是一个纯函数的例子，它在传入相同的参数后永远返回相同的返回值，并且不会导致副作用。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs ada\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emultiply\x3c\/span\x3e(a, b) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3ea\x3c\/span\x3e * b;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e下面是非纯函数的例子。\x3ccode\x3ecanRide\x3c\/code\x3e 函数依赖捕获的 \x3ccode\x3eheightRequirement\x3c\/code\x3e 变量。被捕获的变量不一定导致一个函数是非纯函数，除非它是一个可变的变量（或者可以被重新赋值）。这种情况下使用 \x3ccode\x3elet\x3c\/code\x3e 来声明这个变量，意味着可以对它重新赋值。\x3ccode\x3emultiply\x3c\/code\x3e 函数是非纯函数，因为它会导致在 console 上输出。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e heightRequirement = \x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Impure because it relies on a mutable (reassignable) variable.\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecanRide\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eheight\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e height \x26gt;= heightRequirement;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Impure because it causes a side-effect by logging to the console.\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emultiply\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea, b\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Arguments: \x27\x3c\/span\x3e, a, b);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e a * b;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e下面的列表包含着 JavaScript 内置的非纯函数。你可以指出它们不满足两个属性中的哪个吗？\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ccode\x3econsole.log\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eelement.addEventListener\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eMath.random\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3eDate.now\x3c\/code\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ccode\x3e$.ajax\x3c\/code\x3e (这里 \x3ccode\x3e$\x3c\/code\x3e 代表你使用的 Ajax 库)\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e理想的程序中所有的函数都是纯函数，但是从上面的函数列表可以看出，任何有意义的程序都将包含非纯函数。大多时候我们需要进行 AJAX 调用，检查当前日期或者获取一个随机数。一个好的经验法则是遵循 80\/20 规则：函数中有 80％ 应该是纯函数，剩下的 20％ 的必要性将不可避免地是非纯函数。\x3c\/p\x3e\n\x3cp\x3e使用纯函数有几个优点：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e它们很容易导出和调试，因为它们不依赖于可变的状态。\x3c\/li\x3e\n\x3cli\x3e返回值可以被缓存或者“记忆”来避免以后重复计算。\x3c\/li\x3e\n\x3cli\x3e它们很容易测试，因为没有需要模拟（mock）的依赖（比如日志，AJAX，数据库等等）。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e你编写或者使用的函数返回空（换句话说它没有返回值），那代表它是非纯函数。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#不变性\x22\x3e\x3c\/a\x3e不变性\x3c\/h3\x3e\n\x3cp\x3e让我们回到捕获变量的概念上。来看看 \x3ccode\x3ecanRide\x3c\/code\x3e 函数。我们认为它是一个非纯函数，因为 \x3ccode\x3eheightRequirement\x3c\/code\x3e 变量可以被重新赋值。下面是一个构造出来的例子来说明如何用不可预测的值来对它重新赋值。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e heightRequirement = \x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecanRide\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eheight\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e height \x26gt;= heightRequirement;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Every half second, set heightRequirement to a random number between 0 and 200.\x3c\/span\x3e\nsetInterval(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e heightRequirement = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.floor(\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random() * \x3cspan class=\x22hljs-number\x22\x3e201\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mySonsHeight = \x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Every half second, check if my son can ride.\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Sometimes it will be true and sometimes it will be false.\x3c\/span\x3e\nsetInterval(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(canRide(mySonsHeight)), \x3cspan class=\x22hljs-number\x22\x3e500\x3c\/span\x3e);\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我要再次强调被捕获的变量不一定会使函数成为非纯函数。我们可以通过只是简单地改变 \x3ccode\x3eheightRequirement\x3c\/code\x3e 的声明方式来使 \x3ccode\x3ecanRide\x3c\/code\x3e 函数成为纯函数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e heightRequirement = \x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecanRide\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(height)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e height \x26gt;= heightRequirement;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e通过用 \x3ccode\x3econst\x3c\/code\x3e 来声明变量意味着它不能被再次赋值。如果尝试对它重新赋值，运行时引擎将抛出错误；那么，如果用对象来代替数字来存储所有的“常量”怎么样？\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e constants = {\n  heightRequirement: \x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ... other constants go here\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecanRide\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(height)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e height \x26gt;= constants.heightRequirement;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我们用了 \x3ccode\x3econst\x3c\/code\x3e ，所以这个变量不能被重新赋值，但是还有一个问题：这个对象可以被改变。下面的代码展示了，为了真正使其不可变，你不仅需要防止它被重新赋值，你也需要不可变的数据结构。JavaScript 语言提供了 \x3ccode\x3eObject.freeze\x3c\/code\x3e 方法来阻止对象被改变。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ CASE 1: 对象的属性是可变的，并且变量可以被再次赋值。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e o1 = { \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27bar\x27\x3c\/span\x3e };\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 改变对象的属性\x3c\/span\x3e\no1.foo = \x3cspan class=\x22hljs-string\x22\x3e\x27something different\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对变量再次赋值\x3c\/span\x3e\no1 = { \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22I\x27m a completely new object\x22\x3c\/span\x3e };\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ CASE 2: 对象的属性还是可变的，但是变量不能被再次赋值。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e o2 = { \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27baz\x27\x3c\/span\x3e };\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 仍然能改变对象\x3c\/span\x3e\no2.foo = \x3cspan class=\x22hljs-string\x22\x3e\x27Something different, yet again\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不能对变量再次赋值\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ o2 = { message: \x27I will cause an error if you uncomment me\x27 }; \/\/ Error!\x3c\/span\x3e\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ CASE 3: 对象的属性是不可变的，但是变量可以被再次赋值。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e o3 = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.freeze({ \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Can\x27t mutate me\x22\x3c\/span\x3e });\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不能改变对象的属性\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ o3.foo = \x27Come on, uncomment me. I dare ya!\x27; \/\/ Error!\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 还是可以对变量再次赋值\x3c\/span\x3e\no3 = { \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22I\x27m some other object, and I\x27m even mutable -- so take that!\x22\x3c\/span\x3e };\n\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ CASE 4: 对象的属性是不可变的，并且变量不能被再次赋值。这是我们想要的！！！！！！！！\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e o4 = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.freeze({ \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27never going to change me\x27\x3c\/span\x3e });\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不能改变对象的属性\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ o4.foo = \x27talk to the hand\x27 \/\/ Error!\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不能对变量再次赋值\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ o4 = { message: \x22ain\x27t gonna happen, sorry\x22 }; \/\/ Error\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不变性适用于所有的数据结构，包括数组、映射和集合。它意味着不能调用例如 \x3ccode\x3eArray.prototype.push\x3c\/code\x3e 等会导致本身改变的方法，因为它会改变已经存在的数组。可以通过创建一个含有原来元素和新加元素的新数组，而不是将新元素加入一个已经存在的数组。其实所有会导致数组本身被修改的方法都可以通过一个返回修改好的新数组的函数代替。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e a = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.freeze([\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e]);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of: a.push(7, 8, 9);\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e b = a.concat(\x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of: a.pop();\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e c = a.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of: a.unshift(1, 2, 3);\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e d = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e].concat(a);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of: a.shift();\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e e = a.slice(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of: a.sort(myCompareFunction);\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e f = R.sort(myCompareFunction, a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ R = Ramda\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of: a.reverse();\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e g = R.reverse(a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ R = Ramda\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 留给读者的练习:\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ copyWithin\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ fill\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ splice\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Map\x22\x3e映射\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Set\x22\x3e集合\x3c\/a\x3e 也很相似。可以通过返回一个新的修改好的映射或者集合来代替使用会修改其本身的函数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs vhdl\x22\x3econst \x3cspan class=\x22hljs-keyword\x22\x3emap\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eMap\x3c\/span\x3e([\n  [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e\x27one\x3c\/span\x3e\x27],\n  [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e\x27two\x3c\/span\x3e\x27],\n  [\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e\x27three\x3c\/span\x3e\x27]\n]);\n\n\/\/ Instead \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3emap\x3c\/span\x3e.set(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e\x27four\x3c\/span\x3e\x27);\nconst map2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eMap\x3c\/span\x3e([...\x3cspan class=\x22hljs-keyword\x22\x3emap\x3c\/span\x3e, [\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e\x27four\x3c\/span\x3e\x27]]);\n\n\/\/ Instead \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3emap\x3c\/span\x3e.delete(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\nconst map3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eMap\x3c\/span\x3e([...\x3cspan class=\x22hljs-keyword\x22\x3emap\x3c\/span\x3e].filter(([key]) =\x26gt; key !== \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e));\n\n\/\/ Instead \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3emap\x3c\/span\x3e.clear();\nconst map4 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eMap\x3c\/span\x3e();\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cpre\x3e\x3ccode class=\x22hljs dart\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e([\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27C\x27\x3c\/span\x3e]);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of: set.add(\x27D\x27);\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e set2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e([...\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27D\x27\x3c\/span\x3e]);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of: set.delete(\x27B\x27);\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e set3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e([...\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e].filter(key =\x26gt; key !== \x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e));\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Instead of: set.clear();\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e set4 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSet\x3c\/span\x3e();\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e我想提一句如果你在使用 TypeScript（我非常喜欢 TypeScript），你可以用 \x3ccode\x3eReadonly\x26lt;T\x26gt;\x3c\/code\x3e、\x3ccode\x3eReadonlyArray\x26lt;T\x26gt;\x3c\/code\x3e、\x3ccode\x3eReadonlyMap\x26lt;K, V\x26gt;\x3c\/code\x3e 和 \x3ccode\x3eReadonlySet\x26lt;T\x26gt;\x3c\/code\x3e 接口来在编译期检查你是否尝试更改这些对象，有则抛出编译错误。如果在对一个对象字面量或者数组调用 \x3ccode\x3eObject.freeze\x3c\/code\x3e，编译器会自动推断它是只读的。由于映射和集合在其内部表达，所以在这些数据结构上调用 \x3ccode\x3eObject.freeze\x3c\/code\x3e 不起作用。但是你可以轻松地告诉编译器它们是只读的变量。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/d19e25eb5615d10a2363300a8bc9a8c56e1dfeda\/68747470733a2f2f6f70656e736f757263652e636f6d2f73697465732f64656661756c742f66696c65732f753132383635312f747970657363726970742d726561646f6e6c792e706e67\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t0190bd1616e7f0659f.png\x22 alt=\x22TypeScript Readonly Interfaces\x22 title=\x22TypeScript Readonly Interfaces\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3eTypeScript 只读接口\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e好，所以我们可以通过创建新的对象来代替修改原来的对象，但是这样不会导致性能损失吗？当然会。确保在你自己的应用中做了性能测试。如果你需要提高性能，可以考虑使用 \x3ca href=\x22https:\/\/facebook.github.io\/immutable-js\/\x22\x3eImmutable.js\x3c\/a\x3e。Immutable.js 用\x3ca href=\x22https:\/\/en.wikipedia.org\/wiki\/Persistent_data_structure\x22\x3e持久的数据结构\x3c\/a\x3e 实现了\x3ca href=\x22https:\/\/facebook.github.io\/immutable-js\/docs\/#\/List\x22\x3e链表\x3c\/a\x3e、\x3ca href=\x22https:\/\/facebook.github.io\/immutable-js\/docs\/#\/Stack\x22\x3e堆栈\x3c\/a\x3e、\x3ca href=\x22https:\/\/facebook.github.io\/immutable-js\/docs\/#\/Map\x22\x3e映射\x3c\/a\x3e、\x3ca href=\x22https:\/\/facebook.github.io\/immutable-js\/docs\/#\/Set\x22\x3e集合\x3c\/a\x3e和其他数据结构。使用了如同 Clojure 和 Scala 这样的函数式语言中相同的技术。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs prolog\x22\x3e\/\/ \x3cspan class=\x22hljs-symbol\x22\x3eUse\x3c\/span\x3e in place of \x3cspan class=\x22hljs-string\x22\x3e`[]`\x3c\/span\x3e.\nconst list1 = \x3cspan class=\x22hljs-symbol\x22\x3eImmutable\x3c\/span\x3e.\x3cspan class=\x22hljs-symbol\x22\x3eList\x3c\/span\x3e([\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27C\x27\x3c\/span\x3e]);\nconst list2 = list1.push(\x3cspan class=\x22hljs-string\x22\x3e\x27D\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27E\x27\x3c\/span\x3e);\n\nconsole.log([...list1]); \/\/ [\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27C\x27\x3c\/span\x3e]\nconsole.log([...list2]); \/\/ [\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27C\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27D\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27E\x27\x3c\/span\x3e]\n\n\n\/\/ \x3cspan class=\x22hljs-symbol\x22\x3eUse\x3c\/span\x3e in place of \x3cspan class=\x22hljs-string\x22\x3e`new Map()`\x3c\/span\x3e\nconst map1 = \x3cspan class=\x22hljs-symbol\x22\x3eImmutable\x3c\/span\x3e.\x3cspan class=\x22hljs-symbol\x22\x3eMap\x3c\/span\x3e([\n  [\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e],\n  [\x3cspan class=\x22hljs-string\x22\x3e\x27two\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e],\n  [\x3cspan class=\x22hljs-string\x22\x3e\x27three\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\n]);\nconst map2 = map1.set(\x3cspan class=\x22hljs-string\x22\x3e\x27four\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n\nconsole.log([...map1]); \/\/ [[\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], [\x3cspan class=\x22hljs-string\x22\x3e\x27two\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e], [\x3cspan class=\x22hljs-string\x22\x3e\x27three\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]]\nconsole.log([...map2]); \/\/ [[\x3cspan class=\x22hljs-string\x22\x3e\x27one\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e], [\x3cspan class=\x22hljs-string\x22\x3e\x27two\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e], [\x3cspan class=\x22hljs-string\x22\x3e\x27three\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e], [\x3cspan class=\x22hljs-string\x22\x3e\x27four\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e]]\n\n\n\/\/ \x3cspan class=\x22hljs-symbol\x22\x3eUse\x3c\/span\x3e in place of \x3cspan class=\x22hljs-string\x22\x3e`new Set()`\x3c\/span\x3e\nconst set1 = \x3cspan class=\x22hljs-symbol\x22\x3eImmutable\x3c\/span\x3e.\x3cspan class=\x22hljs-symbol\x22\x3eSet\x3c\/span\x3e([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e]);\nconst set2 = set1.add(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e);\n\nconsole.log([...set1]); \/\/ [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e]\nconsole.log([...set2]); \/\/ [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e]\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e\x3ca href=\x22#函数组合\x22\x3e\x3c\/a\x3e函数组合\x3c\/h3\x3e\n\x3cp\x3e记不记得在中学时我们学过一些像 \x3ccode\x3e(f ∘ g)(x)\x3c\/code\x3e 的东西？你那时可能想，“我什么时候会用到这些？”，好了，现在就用到了。你准备好了吗？\x3ccode\x3ef ∘ g\x3c\/code\x3e读作 “函数 f 和函数 g 组合”。对它的理解有两种等价的方式，如等式所示： \x3ccode\x3e(f ∘ g)(x) = f(g(x))\x3c\/code\x3e。你可以认为 \x3ccode\x3ef ∘ g\x3c\/code\x3e 是一个单独的函数，或者视作将调用函数 \x3ccode\x3eg\x3c\/code\x3e 的结果作为参数传给函数 \x3ccode\x3ef\x3c\/code\x3e。注意这些函数是从右向左依次调用的，先执行 \x3ccode\x3eg\x3c\/code\x3e，接下来执行 \x3ccode\x3ef\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e关于函数组合的几个要点:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e我们可以组合任意数量的函数（不仅限于 2 个）。\x3c\/li\x3e\n\x3cli\x3e组合函数的一个方式是简单地把一个函数的输出作为下一个函数的输入（比如 \x3ccode\x3ef(g(x))\x3c\/code\x3e）。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ h(x) = x \x2b 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ number -\x26gt; number\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eh\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ g(x) = x^2\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ number -\x26gt; number\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eg\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x * x;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ f(x) = convert x to string\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ number -\x26gt; string\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x.toString();\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ y = (f ∘ g ∘ h)(1)\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e y = f(g(h(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)));\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(y); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x274\x27\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ca href=\x22http:\/\/ramdajs.com\/\x22\x3eRamda\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/github.com\/lodash\/lodash\/wiki\/FP-Guide\x22\x3elodash\x3c\/a\x3e 之类的库提供了更优雅的方式来组合函数。我们可以在更多的在数学意义上处理函数组合，而不是简单地将一个函数的返回值传递给下一个函数。我们可以创建一个由这些函数组成的单一复合函数(就是 \x3ccode\x3e(f ∘ g)(x)\x3c\/code\x3e)。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ h(x) = x \x2b 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ number -\x26gt; number\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eh\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ g(x) = x^2\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ number -\x26gt; number\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eg\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x * x;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ f(x) = convert x to string\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ number -\x26gt; string\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ex\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e x.toString();\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ R = Ramda\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ composite = (f ∘ g ∘ h)\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e composite = R.compose(f, g, h);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Execute single function to get the result.\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e y = composite(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(y); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x274\x27\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e好了，我们可以在 JavaScript 中组合函数了。接下来呢？好，如果你已经入门了函数式编程，理想中你的程序将只有函数的组合。代码里没有循环（\x3ccode\x3efor\x3c\/code\x3e, \x3ccode\x3efor...of\x3c\/code\x3e, \x3ccode\x3efor...in\x3c\/code\x3e, \x3ccode\x3ewhile\x3c\/code\x3e, \x3ccode\x3edo\x3c\/code\x3e），基本没有。你可能觉得那是不可能的。并不是这样。我们下面的两个话题是：递归和高阶函数。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#递归\x22\x3e\x3c\/a\x3e递归\x3c\/h3\x3e\n\x3cp\x3e假设你想实现一个计算数字的阶乘的函数。 让我们回顾一下数学中阶乘的定义：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3en! = n * (n-1) * (n-2) * ... * 1\x3c\/code\x3e.\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3en!\x3c\/code\x3e 是从 \x3ccode\x3en\x3c\/code\x3e 到 \x3ccode\x3e1\x3c\/code\x3e 的所有整数的乘积。我们可以编写一个循环轻松地计算出结果。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs matlab\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eiterativeFactorial\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(n)\x3c\/span\x3e {\x3c\/span\x3e\n  let product = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (let \x3cspan class=\x22hljs-built_in\x22\x3ei\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \x3cspan class=\x22hljs-built_in\x22\x3ei\x3c\/span\x3e \x26lt;= n; \x3cspan class=\x22hljs-built_in\x22\x3ei\x3c\/span\x3e\x2b\x2b) {\n    product *= i;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e product;\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意 \x3ccode\x3eproduct\x3c\/code\x3e 和 \x3ccode\x3ei\x3c\/code\x3e 都在循环中被反复重新赋值。这是解决这个问题的标准过程式方法。如何用函数式的方法解决这个问题呢？我们需要消除循环，确保没有变量被重新赋值。递归是函数式程序员的最有力的工具之一。递归需要我们将整体问题分解为类似整体问题的子问题。\x3c\/p\x3e\n\x3cp\x3e计算阶乘是一个很好的例子，为了计算 \x3ccode\x3en!\x3c\/code\x3e 我们需要将 n 乘以所有比它小的正整数。它的意思就相当于：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3en! = n * (n-1)!\x3c\/code\x3e \x3c\/p\x3e\n\x3cp\x3e啊哈！我们发现了一个解决 \x3ccode\x3e(n-1)!\x3c\/code\x3e 的子问题，它类似于整个问题 \x3ccode\x3en!\x3c\/code\x3e。还有一个需要注意的地方就是基础条件。基础条件告诉我们何时停止递归。 如果我们没有基础条件，那么递归将永远持续。 实际上，如果有太多的递归调用，程序会抛出一个堆栈溢出错误。啊哈！\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs actionscript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erecursiveFactorial\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(n)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Base case -- stop the recursion\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (n === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 0! is defined to be 1.\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e n * recursiveFactorial(n - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e然后我们来计算 \x3ccode\x3erecursiveFactorial(20000)\x3c\/code\x3e 因为……，为什么不呢？当我们这样做的时候，我们得到了这个结果：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/320f1d143ad5548fe4df2bd57b09a9ce39eef483\/68747470733a2f2f6f70656e736f757263652e636f6d2f73697465732f64656661756c742f66696c65732f753132383635312f737461636b2d6f766572666c6f772e706e67\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t0160734898dc95fb83.png\x22 alt=\x22Stack overflow error\x22 title=\x22Stack overflow error\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e堆栈溢出错误\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e这里发生了什么？我们得到一个堆栈溢出错误！这不是无穷的递归导致的。我们已经处理了基础条件(\x3ccode\x3en === 0\x3c\/code\x3e 的情况)。那是因为浏览器的堆栈大小是有限的，而我们的代码使用了越过了这个大小的堆栈。每次对 \x3ccode\x3erecursiveFactorial\x3c\/code\x3e 的调用导致了新的帧被压入堆栈中，就像一个盒子压在另一个盒子上。每当 \x3ccode\x3erecursiveFactorial\x3c\/code\x3e 被调用，一个新的盒子被放在最上面。下图展示了在计算 \x3ccode\x3erecursiveFactorial(3)\x3c\/code\x3e 时堆栈的样子。注意在真实的堆栈中，堆栈顶部的帧将存储在执行完成后应该返回的内存地址，但是我选择用变量 \x3ccode\x3er\x3c\/code\x3e 来表示返回值，因为 JavaScript 开发者一般不需要考虑内存地址。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/c6dc6bc971ee1125ce70a87808965c54d6a540c3\/68747470733a2f2f6f70656e736f757263652e636f6d2f73697465732f64656661756c742f66696c65732f753132383635312f737461636b2d6672616d65732e706e67\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01239568dee9da00ea.png\x22 alt=\x22The stack for recursively calculating 3! (three factorial)\x22 title=\x22The stack for recursively calculating 3! (three factorial)\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e递归计算 3! 的堆栈（三次乘法）\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e你可能会想象当计算 \x3ccode\x3en = 20000\x3c\/code\x3e 时堆栈会更高。我们可以做些什么优化它吗？当然可以。作为 ES2015 (又名 ES6) 标准的一部分，有一个优化用来解决这个问题。它被称作尾调用优化proper tail calls optimization（PTC）。当递归函数做的最后一件事是调用自己并返回结果的时候，它使得浏览器删除或者忽略堆栈帧。实际上，这个优化对于相互递归函数也是有效的，但是为了简单起见，我们还是来看单一递归函数。\x3c\/p\x3e\n\x3cp\x3e你可能会注意到，在递归函数调用之后，还要进行一次额外的计算（\x3ccode\x3en * r\x3c\/code\x3e）。那意味着浏览器不能通过 PTC 来优化递归；然而，我们可以通过重写函数使最后一步变成递归调用以便优化。一个窍门是将中间结果（在这里是 \x3ccode\x3eproduct\x3c\/code\x3e）作为参数传递给函数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Optimized for tail call optimization.\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efactorial\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3en, product = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (n === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e product;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e factorial(n - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, product * n)\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e让我们来看看优化后的计算 \x3ccode\x3efactorial(3)\x3c\/code\x3e 时的堆栈。如下图所示，堆栈不会增长到超过两层。原因是我们把必要的信息都传到了递归函数中（比如 \x3ccode\x3eproduct\x3c\/code\x3e）。所以，在 \x3ccode\x3eproduct\x3c\/code\x3e 被更新后，浏览器可以丢弃掉堆栈中原先的帧。你可以在图中看到每次最上面的帧下沉变成了底部的帧，原先底部的帧被丢弃，因为不再需要它了。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/19339200bea064a781685dc9cc833bf910bf4638\/68747470733a2f2f6f70656e736f757263652e636f6d2f73697465732f64656661756c742f66696c65732f753132383635312f6f7074696d697a65642d737461636b2d6672616d65732e706e67\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01733df7df81734897.png\x22 alt=\x22The optimized stack for recursively calculating 3! (three factorial) using PTC\x22 title=\x22The optimized stack for recursively calculating 3! (three factorial) using PTC\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e递归计算 3! 的堆栈（三次乘法）使用 PTC\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e现在选一个浏览器运行吧，假设你在使用 Safari，你会得到 \x3ccode\x3eInfinity\x3c\/code\x3e（它是比在 JavaScript 中能表达的最大值更大的数）。但是我们没有得到堆栈溢出错误，那很不错！现在在其他的浏览器中呢怎么样呢？Safari 可能现在乃至将来是实现 PTC 的唯一一个浏览器。看看下面的兼容性表格：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/camo.githubusercontent.com\/7fd78cc2834a1f222736ee55a09e7bd00f4c330e\/68747470733a2f2f6f70656e736f757263652e636f6d2f73697465732f64656661756c742f66696c65732f753132383635312f7074632d636f6d7061746962696c6974792e706e67\x22\x3e\x3cimg src=\x22https:\/\/p0.ssl.qhimg.com\/t01727bc2bff74161c1.png\x22 alt=\x22PTC compatibility\x22 title=\x22PTC compatibility\x22\x3e\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3ePTC 兼容性\x3c\/em\x3e\x3c\/p\x3e\n\x3cp\x3e其他浏览器提出了一种被称作\x3ca href=\x22https:\/\/github.com\/tc39\/proposal-ptc-syntax#syntactic-tail-calls-stc\x22\x3e语法级尾调用\x3c\/a\x3esyntactic tail calls（STC）的竞争标准。“语法级”意味着你需要用新的语法来标识你想要执行尾递归优化的函数。即使浏览器还没有广泛支持，但是把你的递归函数写成支持尾递归优化的样子还是一个好主意。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#高阶函数\x22\x3e\x3c\/a\x3e高阶函数\x3c\/h3\x3e\n\x3cp\x3e我们已经知道 JavaScript 将函数视作一等公民，可以把函数像其他值一样传递。所以，把一个函数传给另一个函数也很常见。我们也可以让函数返回一个函数。就是它！我们有高阶函数。你可能已经很熟悉几个在 \x3ccode\x3eArray.prototype\x3c\/code\x3e 中的高阶函数。比如 \x3ccode\x3efilter\x3c\/code\x3e、\x3ccode\x3emap\x3c\/code\x3e 和 \x3ccode\x3ereduce\x3c\/code\x3e 就在其中。对高阶函数的一种理解是：它是接受（一般会调用）一个回调函数参数的函数。让我们来看看一些内置的高阶函数的例子：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3econst vehicles = [\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Honda\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27CR-V\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e24045\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Honda\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Accord\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27sedan\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e22455\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Mazda\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Mazda 6\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27sedan\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e24195\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Mazda\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27CX-9\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e31520\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Toyota\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x274Runner\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e34210\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Toyota\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Sequoia\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e45560\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Toyota\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Tacoma\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27truck\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e24320\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Ford\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27F-150\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27truck\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e27110\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Ford\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Fusion\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27sedan\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e22120\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Ford\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Explorer\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e31660\x3c\/span\x3e }\n];\n\nconst averageSUVPrice = vehicles\n  .filter(v =\x26gt; v.type === \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e)\n  .map(v =\x26gt; v.price)\n  .reduce((sum, price, i, array) =\x26gt; sum \x2b price \/ array.length, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\nconsole.log(averageSUVPrice); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 33399\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e注意我们在一个数组对象上调用其方法，这是面向对象编程的特性。如果我们想要更函数式一些，我们可以用 Rmmda 或者 lodash\/fp 提供的函数。注意如果我们使用 \x3ccode\x3eR.compose\x3c\/code\x3e 的话，需要倒转函数的顺序，因为它从右向左依次调用函数（从底向上）；然而，如果我们想从左向右调用函数就像上面的例子，我们可以用 \x3ccode\x3eR.pipe\x3c\/code\x3e。下面两个例子用了 Rmmda。注意 Rmmda 有一个 \x3ccode\x3emean\x3c\/code\x3e 函数用来代替 \x3ccode\x3ereduce\x3c\/code\x3e 。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs groovy\x22\x3econst vehicles = [\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Honda\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27CR-V\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e24045\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Honda\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Accord\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27sedan\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e22455\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Mazda\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Mazda 6\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27sedan\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e24195\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Mazda\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27CX-9\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e31520\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Toyota\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x274Runner\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e34210\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Toyota\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Sequoia\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e45560\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Toyota\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Tacoma\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27truck\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e24320\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Ford\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27F-150\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27truck\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e27110\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Ford\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Fusion\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27sedan\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e22120\x3c\/span\x3e },\n  { \x3cspan class=\x22hljs-string\x22\x3emake:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Ford\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3emodel:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27Explorer\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3etype:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3eprice:\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e31660\x3c\/span\x3e }\n];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Using `pipe` executes the functions from top-to-bottom. \x3c\/span\x3e\nconst averageSUVPrice1 = R.pipe(\n  R.filter(v =\x26gt; v.type === \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e),\n  R.map(v =\x26gt; v.price),\n  R.mean\n)(vehicles);\n\nconsole.log(averageSUVPrice1); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 33399\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Using `compose` executes the functions from bottom-to-top.\x3c\/span\x3e\nconst averageSUVPrice2 = R.compose(\n  R.mean,\n  R.map(v =\x26gt; v.price),\n  R.filter(v =\x26gt; v.type === \x3cspan class=\x22hljs-string\x22\x3e\x27suv\x27\x3c\/span\x3e)\n)(vehicles);\n\nconsole.log(averageSUVPrice2); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 33399\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e使用函数式方法的优点是清楚地分开了数据（\x3ccode\x3evehicles\x3c\/code\x3e）和逻辑（函数 \x3ccode\x3efilter\x3c\/code\x3e，\x3ccode\x3emap\x3c\/code\x3e 和 \x3ccode\x3ereduce\x3c\/code\x3e）。面向对象的代码相比之下把数据和函数用以方法的对象的形式混合在了一起。\x3c\/p\x3e\n\x3ch3\x3e\x3ca href=\x22#柯里化\x22\x3e\x3c\/a\x3e柯里化\x3c\/h3\x3e\n\x3cp\x3e不规范地说，柯里化currying是把一个接受 \x3ccode\x3en\x3c\/code\x3e 个参数的函数变成 \x3ccode\x3en\x3c\/code\x3e 个每个接受单个参数的函数的过程。函数的 \x3ccode\x3earity\x3c\/code\x3e 是它接受参数的个数。接受一个参数的函数是 \x3ccode\x3eunary\x3c\/code\x3e，两个的是 \x3ccode\x3ebinary\x3c\/code\x3e，三个的是 \x3ccode\x3eternary\x3c\/code\x3e，\x3ccode\x3en\x3c\/code\x3e 个的是 \x3ccode\x3en-ary\x3c\/code\x3e。那么，我们可以把柯里化定义成将一个 \x3ccode\x3en-ary\x3c\/code\x3e 函数转换成 \x3ccode\x3en\x3c\/code\x3e 个 \x3ccode\x3eunary\x3c\/code\x3e 函数的过程。让我们通过简单的例子开始，一个计算两个向量点积的函数。回忆一下线性代数，两个向量 \x3ccode\x3e[a, b, c]\x3c\/code\x3e 和 \x3ccode\x3e[x, y, z]\x3c\/code\x3e 的点积是 \x3ccode\x3eax \x2b by \x2b cz\x3c\/code\x3e。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edot\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evector1, vector2\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vector1.reduce(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3esum, element, index\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e sum \x2b= element * vector2[index], \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e v1 = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-5\x3c\/span\x3e];\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e v2 = [\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e];\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(dot(v1, v2)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1(4) \x2b 3(-2) \x2b (-5)(-1) = 4 - 6 \x2b 5 = 3\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e\x3ccode\x3edot\x3c\/code\x3e 函数是 binary，因为它接受两个参数；然而我们可以将它手动转换成两个 unary 函数，就像下面的例子。注意 \x3ccode\x3ecurriedDot\x3c\/code\x3e 是一个 unary 函数，它接受一个向量并返回另一个接受第二个向量的 unary 函数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecurriedDot\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evector1\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evector2\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vector1.reduce(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3esum, element, index\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e sum \x2b= element * vector2[index], \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  }\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Taking the dot product of any vector with [1, 1, 1]\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ is equivalent to summing up the elements of the other vector.\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sumElements = curriedDot([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sumElements([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-5\x3c\/span\x3e])); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -1\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sumElements([\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e])); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e很幸运，我们不需要把每一个函数都手动转换成柯里化以后的形式。\x3ca href=\x22http:\/\/ramdajs.com\/docs\/#curry\x22\x3eRamda\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/lodash.com\/docs\/4.17.4#curry\x22\x3elodash\x3c\/a\x3e 等库可以为我们做这些工作。实际上，它们是柯里化的混合形式。你既可以每次传递一个参数，也可以像原来一样一次传递所有参数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edot\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3evector1, vector2\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vector1.reduce(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3esum, element, index\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e sum \x2b= element * vector2[index], \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e v1 = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-5\x3c\/span\x3e];\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e v2 = [\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Use Ramda to do the currying for us!\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e curriedDot = R.curry(dot);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sumElements = curriedDot([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sumElements(v1)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -1\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sumElements(v2)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ This works! You can still call the curried function with two arguments.\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(curriedDot(v1, v2)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eRamda 和 lodash 都允许你“跳过”一些变量之后再指定它们。它们使用置位符来做这些工作。因为点积的计算可以交换两项。传入向量的顺序不影响结果。让我们换一个例子来阐述如何使用一个置位符。Ramda 使用双下划线作为其置位符。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e giveMe3 = R.curry(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem1, item2, item3\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`\n    1: \x3cspan class=\x22hljs-subst\x22\x3e${item1}\x3c\/span\x3e\n    2: \x3cspan class=\x22hljs-subst\x22\x3e${item2}\x3c\/span\x3e\n    3: \x3cspan class=\x22hljs-subst\x22\x3e${item3}\x3c\/span\x3e\n  `\x3c\/span\x3e;\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e giveMe2 = giveMe3(R.__, R.__, \x3cspan class=\x22hljs-string\x22\x3e\x27French Hens\x27\x3c\/span\x3e);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Specify the third argument.\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e giveMe1 = giveMe2(\x3cspan class=\x22hljs-string\x22\x3e\x27Partridge in a Pear Tree\x27\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ This will go in the first slot.\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = giveMe1(\x3cspan class=\x22hljs-string\x22\x3e\x27Turtle Doves\x27\x3c\/span\x3e);               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Finally fill in the second argument.\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1: Partridge in a Pear Tree\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2: Turtle Doves\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3: French Hens\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e在我们结束探讨柯里化之前最后的议题是偏函数应用partial application。偏函数应用和柯里化经常同时出场，尽管它们实际上是不同的概念。一个柯里化的函数还是柯里化的函数，即使没有给它任何参数。偏函数应用，另一方面是仅仅给一个函数传递部分参数而不是所有参数。柯里化是偏函数应用常用的方法之一，但是不是唯一的。\x3c\/p\x3e\n\x3cp\x3eJavaScript 拥有一个内置机制可以不依靠柯里化来做偏函数应用。那就是 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Function\/bind\x22\x3efunction.prototype.bind\x3c\/a\x3e 方法。这个方法的一个特殊之处在于，它要求你将 \x3ccode\x3ethis\x3c\/code\x3e 作为第一个参数传入。 如果你不进行面向对象编程，那么你可以通过传入 \x3ccode\x3enull\x3c\/code\x3e 来忽略 \x3ccode\x3ethis\x3c\/code\x3e。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs typescript\x22\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egiveMe3\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eitem1, item2, item3\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e`\n    1: \x3cspan class=\x22hljs-subst\x22\x3e${item1}\x3c\/span\x3e\n    2: \x3cspan class=\x22hljs-subst\x22\x3e${item2}\x3c\/span\x3e\n    3: \x3cspan class=\x22hljs-subst\x22\x3e${item3}\x3c\/span\x3e\n  `\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e giveMe2 = giveMe3.bind(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27rock\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e giveMe1 = giveMe2.bind(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27paper\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = giveMe1(\x3cspan class=\x22hljs-string\x22\x3e\x27scissors\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1: rock\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2: paper\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3: scissors\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3ch3\x3e\x3ca href=\x22#总结\x22\x3e\x3c\/a\x3e总结\x3c\/h3\x3e\n\x3cp\x3e我希望你享受探索 JavaScript 中函数式编程的过程。对一些人来说，它可能是一个全新的编程范式，但我希望你能尝试它。你会发现你的程序更易于阅读和调试。不变性还将允许你优化 Angular 和 React 的性能。\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e这篇文章基于 Matt 在 OpenWest 的演讲 \x3ca href=\x22https:\/\/www.openwest.org\/schedule\/#talk-5\x22\x3eJavaScript the Good-er Parts\x3c\/a\x3e. \x3ca href=\x22https:\/\/www.openwest.org\/\x22\x3eOpenWest\x3c\/a\x3e 将在 6\/12-15 ,2017 在 Salt Lake City, Utah 举行。\x3c\/em\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e作者简介：\x3c\/p\x3e\n\x3cp\x3eMatt Banz - Matt 于 2008 年五月在犹他大学获得了数学学位毕业。一个月后他得到了一份 web 开发者的工作，他从那时起就爱上了它！在 2013 年，他在北卡罗莱纳州立大学获得了计算机科学硕士学位。他在 LDS 商学院和戴维斯学区社区教育计划教授 Web 课程。他现在是就职于 Motorola Solutions 公司的高级前端开发者。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3evia: \x3ca href=\x22https:\/\/opensource.com\/article\/17\/6\/functional-javascript\x22\x3ehttps:\/\/opensource.com\/article\/17\/6\/functional-javascript\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e作者：\x3ca href=\x22https:\/\/opensource.com\/users\/battmanz\x22\x3eMatt Banz\x3c\/a\x3e 译者：\x3ca href=\x22https:\/\/github.com\/trnhoe\x22\x3etrnhoe\x3c\/a\x3e 校对：\x3ca href=\x22https:\/\/github.com\/wxy\x22\x3ewxy\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文由 \x3ca href=\x22https:\/\/github.com\/LCTT\/TranslateProject\x22\x3eLCTT\x3c\/a\x3e 原创编译，\x3ca href=\x22https:\/\/linux.cn\/\x22\x3eLinux中国\x3c\/a\x3e 荣誉推出\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 函数式编程介绍</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/an-introduction-to-functional-programming-in-javascript">https://www.zcfy.cc/article/an-introduction-to-functional-programming-in-javascript</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/tp8mw9zcza/" target="_blank">https://alili.tech/archive/tp8mw9zcza/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/t42iv2yle7e/">2016-我的前端之路:工具化与工程化<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/xlhryjzdso/">2016年总结--成长<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/4wvjfeus9ur/">2016年末总结，我的前端之路<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/w7062tmcw3/">3D 视差效果<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/5jt1iw1t77b/">AlloyTouch实战--60行代码搞定QQ看点资料卡<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/kquf0fxkw2j/">ES6，你不得不学！<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/r5b6g4133jh/">Emmet-前端开发神器<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/5dbaikv4emi/">FreeCodeCamp中级算法题答案<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/iuyeljg6lm/">JSONP是什么<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/23ftsgrtzzc/">JS中的观察者模式(发布订阅)<aside class="dates">2019-01-29</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>