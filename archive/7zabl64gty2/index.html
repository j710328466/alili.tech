<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React还是Vue？"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React还是Vue？ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/7zabl64gty2/",
				"appid": "1613049289050283", 
				"title": "React还是Vue？ | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-15T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/4mzh4sak5x/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dpnfbqw178m/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f&text=React%e8%bf%98%e6%98%afVue%ef%bc%9f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f&text=React%e8%bf%98%e6%98%afVue%ef%bc%9f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f&title=React%e8%bf%98%e6%98%afVue%ef%bc%9f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f&is_video=false&description=React%e8%bf%98%e6%98%afVue%ef%bc%9f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e8%bf%98%e6%98%afVue%ef%bc%9f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f&title=React%e8%bf%98%e6%98%afVue%ef%bc%9f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f&title=React%e8%bf%98%e6%98%afVue%ef%bc%9f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f&title=React%e8%bf%98%e6%98%afVue%ef%bc%9f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7zabl64gty2%2f&title=React%e8%bf%98%e6%98%afVue%ef%bc%9f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React还是Vue？</h1><div class="meta"><div class="postdate"><time datetime="2019-01-15" itemprop="datePublished">2019-01-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e原文链接：React or Vue: Which Javascript UI Library Should You Be Using? | Codementor\x3cbr\x3e作者：Anthony Gore\x3cbr\x3e译者：sunny\x3cbr\x3e转载需提前联系译者，未经允许不得转载。\x3cbr\x3e本文首发于\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/fe-guide\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端指南\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e2016年，React巩固了它JavaScript web框架之王的地位。在这一年里，Web和原生APP的库都迅速发展，同时与Angular相比，也具有明显优势。\x3c\/p\x3e\n\x3cp\x3e与此同时，2016年对于Vue而言，也是很重要的一年。Vue2的发布给JavaScript社区带来了巨大的冲击，在Github上获得了25000个star。\x3c\/p\x3e\n\x3cp\x3e不可否认，React和Vue的范围十分类似：它们都是轻量级的组件库，都用于构建用户界面，专注于视图层。两者都可以在简单项目中，也可以使用工具将它们扩展为复杂的应用程序。\x3c\/p\x3e\n\x3cp\x3e因此，很多web开发人员都想知道，到底应该选择哪一个？一个明显优于另一个？有什么需要注意的利弊吗？还是说，两者基本相同？\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e两个框架，两个倡导者\x3c\/h2\x3e\n\x3cp\x3e在本文中，我想彻底地公正地比较两者之前的区别。唯一的问题就是：我是Vue的爱好者，必然会有一些偏见。我经常在我的项目中使用Vue，还发布了一些在线教程，即\x3ca href=\x22https:\/\/www.udemy.com\/vuejs-2-essentials\/?couponCode=JSDOJO-CM\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eUltimate Vue.js Developers course\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e为了摆脱我偏见的影响，我找到了我的朋友Alexis Mangin，他是一名优秀的JavaScript开发者，也是React的爱好者。他沉浸在React中，经常在Web和移动APP开发中使用React。\x3c\/p\x3e\n\x3cp\x3eAlexis曾经问我：“为什么你这么喜欢Vue，从来不用React？”。由于我不太了解React，我很难回答这个问题。所以，我决定，一起坐下来，展示我们选择的库，看看它们究竟能提供什么东西。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVM3pO?w=600\x26amp;h=380\x22 src=\x22https:\/\/static.alili.tech\/img\/bVM3pO?w=600\x26amp;h=380\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e经过激烈的讨论和互相学习，我们得出了以下6个结论。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e如果你喜欢使用模板（ 或需要一些其中的选项）构建应用程序，那么请选择Vue\x3c\/h3\x3e\n\x3cp\x3e将标记放在HTML文件中是Vue应用程序的默认选项。与Angular类似，大括号用于数据绑定表达式，指令（特殊的HTML属性）用于向模板添加功能。下面是一个简单的Vue程序例子。它可以输出一条消息，有一个按钮可以动态反转消息：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;app\x26quot;\x3e\n  \x3cp\x3e\x22{{\x22 message \x22}}\x22\x3c\/p\x3e\n  \x3cbutton v-on:click=\x26quot;reverseMessage\x26quot;\x3eReverse Message\x3c\/button\x3e\n\x3c\/div\x3e\n\nnew Vue({\n  el: \x27#app\x27,\n  data: {\n    message: \x27Hello Vue.js!\n  },\n  methods: {\n    reverseMessage: function () {\n      this.message = this.message.split(\x27\x27).reverse().join(\x27\x27);\n    }\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cmake\x22\x3e\x3ccode\x3e\x26lt;div id=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\n  \x26lt;p\x26gt;\x22{{\x22 \x3cspan class=\x22hljs-keyword\x22\x3emessage\x3c\/span\x3e \x22}}\x22\x26lt;\/p\x26gt;\n  \x26lt;button v-\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e:click=\x3cspan class=\x22hljs-string\x22\x3e\x22reverseMessage\x22\x3c\/span\x3e\x26gt;Reverse \x3cspan class=\x22hljs-keyword\x22\x3eMessage\x3c\/span\x3e\x26lt;\/button\x26gt;\n\x26lt;\/div\x26gt;\n\nnew Vue({\n  el: \x27\x3cspan class=\x22hljs-comment\x22\x3e#app\x27,\x3c\/span\x3e\n  data: {\n    \x3cspan class=\x22hljs-keyword\x22\x3emessage\x3c\/span\x3e: \x27Hello Vue.js!\n  },\n  methods: {\n    reverseMessage: \x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e () {\n      this.\x3cspan class=\x22hljs-keyword\x22\x3emessage\x3c\/span\x3e = this.\x3cspan class=\x22hljs-keyword\x22\x3emessage\x3c\/span\x3e.split(\x27\x27).reverse().join(\x27\x27);\n    }\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e相比之下，React应用程序避开模板，要求开放人员在JavaScript中创建DOM，通常用JSX辅助，下面是用React来实现同样的功能：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 class App extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      message: \x27Hello React.js!\x27\n    };\n  }\n  reverseMessage() {\n    this.setState({ \n      message: this.state.message.split(\x27\x27).reverse().join(\x27\x27) \n    });\n  }\n  render() {\n    return (\n      \x3cdiv\x3e\n        \x3cp\x3e{this.state.message}\x3c\/p\x3e\n        \x3cbutton onClick={() =\x3e this.reverseMessage()}\x3e\n          Reverse Message\n        \x3c\/button\x3e\n      \x3c\/div\x3e\n    )\n  }\n}\nReactDOM.render(App, document.getElementById(\x27app\x27));\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eApp\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello React.js!\x27\x3c\/span\x3e\n    };\n  }\n  reverseMessage() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \n      \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.message.split(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e).reverse().join(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e) \n    });\n  }\n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n      \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e{this.state.message}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e this.reverseMessage()}\x26gt;\n          Reverse Message\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    )\n  }\n}\nReactDOM.render(App, \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e));\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于学习标准的web初级开发者而言，模板更容易理解。但是也有很多经验丰富的开发人员乐意使用模板，因为模板可以更好地分离布局和功能，同时也可以选择向Pug这样的预处理器。\x3c\/p\x3e\n\x3cp\x3e但是，使用模板需要学习所有的HTML扩展语法，渲染函数只需要了解标准的HTML和JavaScript\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e如果你喜欢简单的能正常工作的，那么请选择Vue\x3c\/h3\x3e\n\x3cp\x3e一个简单的Vue项目可以不需要解析，直接在浏览器中运行，这允许Vue可以像jQuery一样在项目中引用。\x3c\/p\x3e\n\x3cp\x3e虽然在技术上使用React也是可行的，但是典型的React代码更倾向于像classes和non-mulating 数组方法这样的JSX和ES6的特性。但是Vue在简洁设计方面更为深入。我们来比较两者如何处理应用程序的数据（即“状态”）。\x3c\/p\x3e\n\x3cp\x3e在React中State是不可以直接改变的，需要调用setState接口：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.setState({ \n    message: this.state.message.split(\x27\x27).reverse().join(\x27\x27) \n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ethis\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.setState\x3c\/span\x3e({ \n    \x3cspan class=\x22hljs-attribute\x22\x3emessage\x3c\/span\x3e: this.state.message.\x3cspan class=\x22hljs-built_in\x22\x3esplit\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e).\x3cspan class=\x22hljs-built_in\x22\x3ereverse\x3c\/span\x3e().\x3cspan class=\x22hljs-built_in\x22\x3ejoin\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e) \n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当前和之前的状态差异让React知道什么时候在DOM中重新渲染以及渲染什么，因此不可变的状态是非常必要的。\x3c\/p\x3e\n\x3cp\x3e相比之下，数据可以在Vue中突变。相同的数据属性在Vue中发生变化更为简单。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ Note that data properties are available as properties of \n\/\/ the Vue instance\nthis.message = this.message.split(\x27\x27).reverse().join(\x27\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Note that data properties are available as properties of \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ the Vue instance\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.message = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.message.\x3cspan class=\x22hljs-built_in\x22\x3esplit\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e).\x3cspan class=\x22hljs-built_in\x22\x3ereverse\x3c\/span\x3e().\x3cspan class=\x22hljs-built_in\x22\x3ejoin\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在你得出Vue渲染系统比React渲染低效的结论之前，让我们来看看Vue中的状态管理：当你向状态添加新对象时，Vue会遍历它的所有属性并且转换为getter和setter。Vue系统会持续追踪状态并且在状态发生变化时，自动重新渲染DOM。\x3c\/p\x3e\n\x3cp\x3e令人印象深刻的是，Vue中的状态改变更为简洁的同时，重新渲染系统的效率其实比React更好。\x3c\/p\x3e\n\x3cp\x3eVue的反应系统确实有值得注意的事项。例如：它不能检测到属性的添加、删除以及特定数组的变化。在这种情况下，可以使用Vue API中类似React的set方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e如果你希望你的程序更小更快，那么请选择Vue\x3c\/h3\x3e\n\x3cp\x3eReact和Vue都将构建一个虚拟DOM，并且在应用程序状态更改时同步更新实际的DOM。两者都有自己的优化方法。Vue核心开发人员提供了一个基准测试，展示了Vue的渲染系统比React的更快。在这个测试中，10000个项目的列表被渲染了100次。下面的表格展示了比较的结果。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVLS68?w=600\x26amp;h=226\x22 src=\x22https:\/\/static.alili.tech\/img\/bVLS68?w=600\x26amp;h=226\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从实际角度而言，这种基准只与边缘情况有关。大多数应用程序不需要经常进行这种操作，因此不能将其视为比较的一个重要因素。\x3c\/p\x3e\n\x3cp\x3e虽然页面的大小与项目相关，Vue又占据了优势。目前发布的Vue库只有25.6KB。\x3c\/p\x3e\n\x3cp\x3e要用React实现类似的功能，你需要使用React DOM（37.4KB）和React with Addons库（11.4KB），总共为48.8KB，几乎是Vue的两倍。为了公平起见，你可以使用React获得更多的API，但是不会有双倍的功能。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e如果你想要构建大型应用程序，那么请选择React\x3c\/h3\x3e\n\x3cp\x3e用Vue和React来实现简单的应用程序，就像本文开头所说的一样，大部分开发者会偏向于Vue。这是因为基于模板的应用程序乍看更容易理解，并且能够更快启动。\x3c\/p\x3e\n\x3cp\x3e但是这些初始的好处会导致大型程序进展缓慢。模板很容易出现运行时错误，难以测试，也不容易重构或分解。\x3c\/p\x3e\n\x3cp\x3e相比之下，JavaScript制作的模板可以被组织成可分解的组件，DRY code也更容易重用和测试。\x3c\/p\x3e\n\x3cp\x3eVue也具有组件系统和渲染功能。但是React的渲染系统配置性更高，并且具有浅渲染的特性，与React的测试程序结合时，可以提供更多可测试和可维护的代码。\x3c\/p\x3e\n\x3cp\x3e同时，React不可变的代码并不简单，当透明度和可测试性至关重要时，它会发挥更大的作用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e如果你想要一个同时适用于web和原生APP的库，那么请选择React\x3c\/h3\x3e\n\x3cp\x3eReact Native是用JavaScript创建原生APP的库。它与React相同，只是将web组件换成了原生组件。如果你学习了React.js，那么你很快就可以学会React Native，反之亦然。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27; \nimport { AppRegistry, Text, View } from \x27react-native\x27;  \nclass HelloWorld extends Component {   \n  render() {     \n    return (       \n      \x3cView\x3e         \n        \x3cText\x3eHello, React Native!\x3c\/Text\x3e\n      \x3c\/View\x3e\n    );   \n  }\n}\nAppRegistry.registerComponent(\x27HelloWorld\x27, () =\x3e HelloWorld);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27; \n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { \x3cspan class=\x22hljs-type\x22\x3eAppRegistry\x3c\/span\x3e, \x3cspan class=\x22hljs-type\x22\x3eText\x3c\/span\x3e, \x3cspan class=\x22hljs-type\x22\x3eView\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27react\x3c\/span\x3e-native\x27;  \n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHelloWorld\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{   \n  render() {     \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (       \n      \x26lt;\x3cspan class=\x22hljs-type\x22\x3eView\x3c\/span\x3e\x26gt;         \n        \x26lt;\x3cspan class=\x22hljs-type\x22\x3eText\x3c\/span\x3e\x26gt;\x3cspan class=\x22hljs-type\x22\x3eHello\x3c\/span\x3e, \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eNative\x3c\/span\x3e!\x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eText\x3c\/span\x3e\x26gt;\n      \x26lt;\/\x3cspan class=\x22hljs-type\x22\x3eView\x3c\/span\x3e\x26gt;\n    );   \n  }\n}\n\x3cspan class=\x22hljs-type\x22\x3eAppRegistry\x3c\/span\x3e.registerComponent(\x3cspan class=\x22hljs-symbol\x22\x3e\x27HelloWorl\x3c\/span\x3ed\x27, () =\x26gt; \x3cspan class=\x22hljs-type\x22\x3eHelloWorld\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e重要的是，开发人员可以构建一个web或者原生APP，他们不需要不同的知识体系和工具。如果您打算开发web和移动APP，React会给你带来巨大冲击。\x3c\/p\x3e\n\x3cp\x3e阿里巴巴的Weex是另一个跨平台UI项目。目前，它认为Vue提供了灵感，并且使用了很多相同的语法，并计划完全集成Vue。但是，这个计划的时间表和细节尚未清晰。\x3c\/p\x3e\n\x3cp\x3e由于Vue将HTML模板作为其设计的核心部分，也没有将客户端渲染作为当前的特性，因此很难看到原生的Vue像React.js或React Native一样紧密。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e如果你想要最大的生态系统，那么请选择React\x3c\/h3\x3e\n\x3cp\x3e毫无疑问，React目前是最受欢迎的库，NPM下载量每月约2.5M，Vue每月的下载量为225k。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHAjs?w=800\x26amp;h=326\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHAjs?w=800\x26amp;h=326\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e人气带来的好处不止一点半点。这意味有更多的文章、教程和Stack Overflow回答能够帮助。也意味着在项目中有更多的工具和附加组件可用，同时节省了开发人员自己构建所有模块的时间。\x3c\/p\x3e\n\x3cp\x3e两者都是开源的，但是React诞生自Facebook，受益于它。开发者和热爱React的公司都可以保障React一直被维护。\x3c\/p\x3e\n\x3cp\x3e相比之下，Evan You一个人创建了Vue，同时他也是Vue唯一的全职维护人员。Vue得到了一些企业的赞助，但是还达不到Facebook或是Google的规模。\x3c\/p\x3e\n\x3cp\x3e为了使得Vue团队更为可信，它的小体积和独立性目前并不被当做劣势。Vue有规律的发布周期，令人印象深刻的是，Vue在Github上只有54个公开的问题，3456个关闭的问题，而React有530个开放问题，3447个关闭的问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e如果你已经选择了其中的一个，那么也不需要换了\x3c\/h3\x3e\n\x3cp\x3e总而言之，我们发现，Vue的优势是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e模板或渲染的灵活选项\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e语法以及项目设置的简单\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e渲染速度更快，体积更小\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eReact的优势是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e更大的规模、更多的使用者、更好的可测试性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eWeb和原生APP\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e能提供更多支持和工具的更大的生态系统\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e然而，React和Vue都是优秀的UI库，并且具有更多的相似之处。它们都有的优势是：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e使用虚拟DOM快速渲染\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e轻量级\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e响应式组件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e服务端渲染\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e轻松集成的的路由、捆绑和状态管理\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e强大的支持和社区\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果你认为我们漏掉了一些东西，欢迎在评论中说明。Happy developing！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React还是Vue？</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009268926">https://segmentfault.com/a/1190000009268926</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/7zabl64gty2/" target="_blank">https://alili.tech/archive/7zabl64gty2/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>