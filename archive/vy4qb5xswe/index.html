<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript专题之类型判断(下)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript专题之类型判断(下) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/vy4qb5xswe/",
				"appid": "1613049289050283", 
				"title": "JavaScript专题之类型判断(下) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-10T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/d2zlavi8x98/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/xyfrz84gtu/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f&text=JavaScript%e4%b8%93%e9%a2%98%e4%b9%8b%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%28%e4%b8%8b%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f&text=JavaScript%e4%b8%93%e9%a2%98%e4%b9%8b%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%28%e4%b8%8b%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f&title=JavaScript%e4%b8%93%e9%a2%98%e4%b9%8b%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%28%e4%b8%8b%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f&is_video=false&description=JavaScript%e4%b8%93%e9%a2%98%e4%b9%8b%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%28%e4%b8%8b%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e4%b8%93%e9%a2%98%e4%b9%8b%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%28%e4%b8%8b%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f&title=JavaScript%e4%b8%93%e9%a2%98%e4%b9%8b%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%28%e4%b8%8b%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f&title=JavaScript%e4%b8%93%e9%a2%98%e4%b9%8b%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%28%e4%b8%8b%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f&title=JavaScript%e4%b8%93%e9%a2%98%e4%b9%8b%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%28%e4%b8%8b%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fvy4qb5xswe%2f&title=JavaScript%e4%b8%93%e9%a2%98%e4%b9%8b%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad%28%e4%b8%8b%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript专题之类型判断(下)</h1><div class="meta"><div class="postdate"><time datetime="2019-01-10" itemprop="datePublished">2019-01-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3eJavaScript专题系列第五篇，讲解更加复杂的类型判断，比如 plainObject、空对象、类数组对象、Window对象、DOM 元素等\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e在上篇\x3ca href=\x22https:\/\/github.com\/mqyqingfeng\/Blog\/issues\/28\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《JavaScript专题之类型判断(上)》\x3c\/a\x3e中，我们抄袭 jQuery 写了一个 type 函数，可以检测出常见的数据类型，然而在开发中还有更加复杂的判断，比如 plainObject、空对象、Window 对象等，这一篇就让我们接着抄袭 jQuery 去看一下这些类型的判断。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eplainObject\x3c\/h2\x3e\n\x3cp\x3eplainObject 来自于 jQuery，可以翻译成纯粹的对象，所谓\x22纯粹的对象\x22，就是该对象是通过 \x22{}\x22 或 \x22new Object\x22 创建的，该对象含有零个或者多个键值对。\x3c\/p\x3e\n\x3cp\x3e之所以要判断是不是 plainObject，是为了跟其他的 JavaScript对象如 null，数组，宿主对象（documents）等作区分，因为这些用 typeof 都会返回object。\x3c\/p\x3e\n\x3cp\x3ejQuery提供了 isPlainObject 方法进行判断，先让我们看看使用的效果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name) {\n    this.name = name;\n}\n\nconsole.log($.isPlainObject({})) \/\/ true\n\nconsole.log($.isPlainObject(new Object)) \/\/ true\n\nconsole.log($.isPlainObject(Object.create(null))); \/\/ true\n\nconsole.log($.isPlainObject(Object.assign({a: 1}, {b: 2}))); \/\/ true\n\nconsole.log($.isPlainObject(new Person(\x27yayu\x27))); \/\/ false\n\nconsole.log($.isPlainObject(Object.create({}))); \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log($.isPlainObject({})) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log($.isPlainObject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e)) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log($.isPlainObject(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e))); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log($.isPlainObject(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({\x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e}, {\x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e}))); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log($.isPlainObject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x27yayu\x27\x3c\/span\x3e))); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log($.isPlainObject(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create({}))); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由此我们可以看到，除了 {} 和 new Object 创建的之外，jQuery 认为一个没有原型的对象也是一个纯粹的对象。\x3c\/p\x3e\n\x3cp\x3e实际上随着 jQuery 版本的提升，isPlainObject 的实现也在变化，我们今天讲的是 3.0 版本下的 isPlainObject，我们直接看源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 上节中写 type 函数时，用来存放 toString 映射结果的对象\nvar class2type = {};\n\n\/\/ 相当于 Object.prototype.toString\nvar toString = class2type.toString;\n\n\/\/ 相当于 Object.prototype.hasOwnProperty\nvar hasOwn = class2type.hasOwnProperty;\n\nfunction isPlainObject(obj) {\n    var proto, Ctor;\n\n    \/\/ 排除掉明显不是obj的以及一些宿主对象如Window\n    if (!obj || toString.call(obj) !== \x26quot;[object Object]\x26quot;) {\n        return false;\n    }\n\n    \/**\n     * getPrototypeOf es5 方法，获取 obj 的原型\n     * 以 new Object 创建的对象为例的话\n     * obj.__proto__ === Object.prototype\n     *\/\n    proto = Object.getPrototypeOf(obj);\n\n    \/\/ 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true\n    if (!proto) {\n        return true;\n    }\n\n    \/**\n     * 以下判断通过 new Object 方式创建的对象\n     * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor\n     * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数\n     *\/\n    Ctor = hasOwn.call(proto, \x26quot;constructor\x26quot;) \x26amp;\x26amp; proto.constructor;\n\n    \/\/ 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数\n    return typeof Ctor === \x26quot;function\x26quot; \x26amp;\x26amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 上节中写 type 函数时，用来存放 toString 映射结果的对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e class2type = {};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相当于 Object.prototype.toString\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e toString = class2type.toString;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相当于 Object.prototype.hasOwnProperty\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e hasOwn = class2type.hasOwnProperty;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisPlainObject\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e proto, Ctor;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 排除掉明显不是obj的以及一些宿主对象如Window\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!obj || toString.call(obj) !== \x3cspan class=\x22hljs-string\x22\x3e\x22[object Object]\x22\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * getPrototypeOf es5 方法，获取 obj 的原型\n     * 以 new Object 创建的对象为例的话\n     * obj.__proto__ === Object.prototype\n     *\/\x3c\/span\x3e\n    proto = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(obj);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!proto) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * 以下判断通过 new Object 方式创建的对象\n     * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor\n     * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数\n     *\/\x3c\/span\x3e\n    Ctor = hasOwn.call(proto, \x3cspan class=\x22hljs-string\x22\x3e\x22constructor\x22\x3c\/span\x3e) \x26amp;\x26amp; proto.constructor;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e Ctor === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e \x26amp;\x26amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意：我们判断 Ctor 构造函数是不是 Object 构造函数，用的是 hasOwn.toString.call(Ctor)，这个方法可不是 Object.prototype.toString，不信我们在函数里加上下面这两句话：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(hasOwn.toString.call(Ctor)); \/\/ function Object() { [native code] }\nconsole.log(Object.prototype.toString.call(Ctor)); \/\/ [object Function]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(hasOwn.toString.call(Ctor)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ function Object() { [native code] }\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.prototype.toString.call(Ctor)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [object Function]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e发现返回的值并不一样，这是因为 hasOwn.toString 调用的其实是 Function.prototype.toString，毕竟 hasOwnProperty 可是一个函数！\x3c\/p\x3e\n\x3cp\x3e而且 Function 对象覆盖了从 Object 继承来的 Object.prototype.toString 方法。函数的 toString 方法会返回一个表示函数源代码的字符串。具体来说，包括 function关键字，形参列表，大括号，以及函数体中的内容。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eEmptyObject\x3c\/h2\x3e\n\x3cp\x3ejQuery提供了 isEmptyObject 方法来判断是否是空对象，代码简单，我们直接看源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isEmptyObject( obj ) {\n\n        var name;\n\n        for ( name in obj ) {\n            return false;\n        }\n\n        return true;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisEmptyObject\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e obj \x3c\/span\x3e) \x3c\/span\x3e{\n\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name;\n\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ( name \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e obj ) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实所谓的 isEmptyObject 就是判断是否有属性，for 循环一旦执行，就说明有属性，有属性就会返回 false。\x3c\/p\x3e\n\x3cp\x3e但是根据这个源码我们可以看出isEmptyObject实际上判断的并不仅仅是空对象。\x3c\/p\x3e\n\x3cp\x3e举个栗子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(isEmptyObject({})); \/\/ true\nconsole.log(isEmptyObject([])); \/\/ true\nconsole.log(isEmptyObject(null)); \/\/ true\nconsole.log(isEmptyObject(undefined)); \/\/ true\nconsole.log(isEmptyObject(1)); \/\/ true\nconsole.log(isEmptyObject(\x27\x27)); \/\/ true\nconsole.log(isEmptyObject(true)); \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isEmptyObject({})); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isEmptyObject([])); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isEmptyObject(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isEmptyObject(\x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isEmptyObject(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isEmptyObject(\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isEmptyObject(\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上都会返回 true。\x3c\/p\x3e\n\x3cp\x3e但是既然 jQuery 是这样写，可能是因为考虑到实际开发中 isEmptyObject 用来判断 {} 和 {a: 1} 是足够的吧。如果真的是只判断 {}，完全可以结合上篇写的 type 函数筛选掉不适合的情况。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eWindow对象\x3c\/h2\x3e\n\x3cp\x3eWindow 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身，这点在\x3ca href=\x22https:\/\/github.com\/mqyqingfeng\/Blog\/issues\/5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《JavaScript深入之变量对象》\x3c\/a\x3e中讲到过。我们可以利用这个特性判断是否是 Window 对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isWindow( obj ) {\n    return obj != null \x26amp;\x26amp; obj === obj.window;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisWindow\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e obj \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e obj != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; obj === obj.window;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eisArrayLike\x3c\/h2\x3e\n\x3cp\x3eisArrayLike，看名字可能会让我们觉得这是判断类数组对象的，其实不仅仅是这样，jQuery 实现的 isArrayLike，数组和类数组都会返回 true。\x3c\/p\x3e\n\x3cp\x3e因为源码比较简单，我们直接看源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function isArrayLike(obj) {\n\n    \/\/ obj 必须有 length属性\n    var length = !!obj \x26amp;\x26amp; \x26quot;length\x26quot; in obj \x26amp;\x26amp; obj.length;\n    var typeRes = type(obj);\n\n    \/\/ 排除掉函数和 Window 对象\n    if (typeRes === \x26quot;function\x26quot; || isWindow(obj)) {\n        return false;\n    }\n\n    return typeRes === \x26quot;array\x26quot; || length === 0 ||\n        typeof length === \x26quot;number\x26quot; \x26amp;\x26amp; length \x3e 0 \x26amp;\x26amp; (length - 1) in obj;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisArrayLike\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj\x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ obj 必须有 length属性\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e length = !!obj \x26amp;\x26amp; \x3cspan class=\x22hljs-string\x22\x3e\x22length\x22\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e obj \x26amp;\x26amp; obj.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e typeRes = type(obj);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 排除掉函数和 Window 对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (typeRes === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e || isWindow(obj)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e typeRes === \x3cspan class=\x22hljs-string\x22\x3e\x22array\x22\x3c\/span\x3e || length === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e ||\n        \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e length === \x3cspan class=\x22hljs-string\x22\x3e\x22number\x22\x3c\/span\x3e \x26amp;\x26amp; length \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; (length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e obj;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e重点分析 return 这一行，使用了或语句，只要一个为 true，结果就返回 true。\x3c\/p\x3e\n\x3cp\x3e所以如果 isArrayLike 返回true，至少要满足三个条件之一：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e是数组\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e长度为 0\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3elengths 属性是大于 0 的数组，并且obj[length - 1]必须存在\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e第一个就不说了，看第二个，为什么长度为 0 就可以直接判断为 true 呢？\x3c\/p\x3e\n\x3cp\x3e那我们写个对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var obj = {a: 1, b: 2, length: 0}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3elength\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eisArrayLike 函数就会返回 true，那这个合理吗？\x3c\/p\x3e\n\x3cp\x3e回答合不合理之前，我们先看一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function a(){\n    console.log(isArrayLike(arguments))\n}\na();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ea\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(isArrayLike(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e))\n}\na();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果我们去掉length === 0 这个判断，就会打印 false，然而我们都知道 arguments 是一个类数组对象，这里是应该返回 true 的。\x3c\/p\x3e\n\x3cp\x3e所以是不是为了放过空的 arguments 时也放过了一些存在争议的对象呢？\x3c\/p\x3e\n\x3cp\x3e第三个条件：length 是数字，并且 length \x26gt; 0 且最后一个元素存在。\x3c\/p\x3e\n\x3cp\x3e为什么仅仅要求最后一个元素存在呢？\x3c\/p\x3e\n\x3cp\x3e让我们先想下数组是不是可以这样写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [,,3]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [,,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们写一个对应的类数组对象就是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arrLike = {\n    2: 3,\n    length: 3\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arrLike = {\n    \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3elength\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e也就是说当我们在数组中用逗号直接跳过的时候，我们认为该元素是不存在的，类数组对象中也就不用写这个元素，但是最后一个元素是一定要写的，要不然 length 的长度就不会是最后一个元素的 key 值加 1。比如数组可以这样写\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arr = [1,,];\nconsole.log(arr.length) \/\/ 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,,];\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(arr.length) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是类数组对象就只能写成：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var arrLike = {\n    0: 1,\n    length: 1\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arrLike = {\n    \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3elength\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以符合条件的类数组对象是一定存在最后一个元素的！\x3c\/p\x3e\n\x3cp\x3e这就是满足 isArrayLike 的三个条件，其实除了 jQuery 之外，很多库都有对 isArrayLike 的实现，比如 underscore:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n\nvar isArrayLike = function(collection) {\n    var length = getLength(collection);\n    return typeof length == \x27number\x27 \x26amp;\x26amp; length \x3e= 0 \x26amp;\x26amp; length \x3c= MAX_ARRAY_INDEX;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e MAX_ARRAY_INDEX = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.pow(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e53\x3c\/span\x3e) - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e isArrayLike = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecollection\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e length = getLength(collection);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e length == \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e \x26amp;\x26amp; length \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; length \x26lt;= MAX_ARRAY_INDEX;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eisElement\x3c\/h2\x3e\n\x3cp\x3eisElement 判断是不是 DOM 元素。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22isElement = function(obj) {\n    return !!(obj \x26amp;\x26amp; obj.nodeType === 1);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3eisElement = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e !!(obj \x26amp;\x26amp; obj.nodeType === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e结语\x3c\/h2\x3e\n\x3cp\x3e这一篇我们介绍了 jQuery 的 isPlainObject、isEmptyObject、isWindow、isArrayLike、以及 underscore 的 isElement 实现。我们可以看到，即使是 jQuery 这样优秀的库，一些方法的实现也并不是非常完美和严密的，但是最后为什么这么做，其实也是一种权衡，权衡所失与所得，正如玉伯在《从 JavaScript 数组去重谈性能优化》中讲到：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e所有这些点，都必须脚踏实地在具体应用场景下去分析、去选择，要让场景说话。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e专题系列\x3c\/h2\x3e\n\x3cp\x3eJavaScript专题系列目录地址：\x3ca href=\x22https:\/\/github.com\/mqyqingfeng\/Blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/mqyqingfeng\/Blog\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3eJavaScript专题系列预计写二十篇左右，主要研究日常开发中一些功能点的实现，比如防抖、节流、去重、类型判断、拷贝、最值、扁平、柯里、递归、乱序、排序等，特点是研(chao)究(xi) underscore 和 jQuery 的实现方式。\x3c\/p\x3e\n\x3cp\x3e如果有错误或者不严谨的地方，请务必给予指正，十分感谢。如果喜欢或者有所启发，欢迎 star，对作者也是一种鼓励。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript专题之类型判断(下)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010054116">https://segmentfault.com/a/1190000010054116</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/vy4qb5xswe/" target="_blank">https://alili.tech/archive/vy4qb5xswe/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/sj57jxyoook/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（上）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/qsw902j95k/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（下）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/nnpmjlot58j/">IndexedDB使用与出坑指南<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/alvlbas9oai/">JS事件模型<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/u0pzym8k36o/">JS练习实例--编写经典小游戏俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/khwpyk5yz8q/">JavaScript 事件代理和委托<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/kuocl6lc3n/">JavaScript 版俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/n8bk54lyrf/">Promise学习:基础入门<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/7bk7u30qncb/">Redux 入坑进阶 - 源码解析<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/853kqfmqmf7/">Snap.svg 基本知识入门<aside class="dates">2019-02-03</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>