<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Hammer.js源码简析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Hammer.js源码简析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9xxcznrq047/",
				"appid": "1613049289050283", 
				"title": "Hammer.js源码简析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-16T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ptqkugdqox9/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/wr9bm1wv9e9/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f&text=Hammer.js%e6%ba%90%e7%a0%81%e7%ae%80%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f&text=Hammer.js%e6%ba%90%e7%a0%81%e7%ae%80%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f&title=Hammer.js%e6%ba%90%e7%a0%81%e7%ae%80%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f&is_video=false&description=Hammer.js%e6%ba%90%e7%a0%81%e7%ae%80%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Hammer.js%e6%ba%90%e7%a0%81%e7%ae%80%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f&title=Hammer.js%e6%ba%90%e7%a0%81%e7%ae%80%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f&title=Hammer.js%e6%ba%90%e7%a0%81%e7%ae%80%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f&title=Hammer.js%e6%ba%90%e7%a0%81%e7%ae%80%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9xxcznrq047%2f&title=Hammer.js%e6%ba%90%e7%a0%81%e7%ae%80%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Hammer.js源码简析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-16" itemprop="datePublished">2019-01-16</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3e开始\x3c\/h1\x3e\n\x3cp\x3e话说上周周末闲的蛋疼，突然想了解一下前端手势如何处理，好解开自己一个知识盲点，于是开始啃源码。。。并纪录一下。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e一个手势\x3c\/h1\x3e\n\x3cp\x3e在我们的前端页面里面复杂的手势应该是不多见的，一般常用就是拖拉，双击，放大缩小这几个，但是合理运用手势很明显也能为我们页面的交互体验有一点增色，那么问题来了，如何识别一个手势尼？\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3eHammer.js\x3c\/h1\x3e\n\x3cp\x3eHammer.js 应该算是前端使用的比较广泛的一个手势框架了（我所了解的还有一个AlloyTouch，更小，当然它提供的抽象程度是不如Hammer.js的），今天就拿这个框架来开刀吧。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e配置参数\x3c\/h2\x3e\n\x3cp\x3e我们先来看Hammer.js的配置参数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n      \/\/手势事件触发时，是否同时触发对应的一个自定义的dom事件，当然这个没有直接绑定事件回调高效\n      domEvents: false, \n      \/\/这个会影响对应的css属性touch-action的值，下面会接着说\n      touchAction: TOUCH_ACTION_COMPUTE, \n      enable: true, \/\/是否开启手势识别\n      \/\/可以指定在其他的元素上来检测与touch相关的事件并作为输入源，如果没设置就是当前检测的元素了\n      inputTarget: null, \n      inputClass: null, \/\/输入源类型，鼠标还是触摸或者是混合\n      recognizers: [], \/\/我们配置的手势识别器\n      \/\/预设的一些手势识别器，格式：[RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]]\n      preset: [ \n          [RotateRecognizer, { enable: false }],\n          [PinchRecognizer, { enable: false }, [\x27rotate\x27]],\n          [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],\n          [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, [\x27swipe\x27]],\n          [TapRecognizer],\n          [TapRecognizer, { event: \x27doubletap\x27, taps: 2 }, [\x27tap\x27]],\n          [PressRecognizer]\n      ],\n      cssProps: { \/\/额外的一些css属性\n        userSelect: \x27none\x27,\n        touchSelect: \x27none\x27,\n        touchCallout: \x27none\x27,\n        contentZooming: \x27none\x27,\n        userDrag: \x27none\x27,\n        tapHighlightColor: \x27rgba(0,0,0,0)\x27\n     }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/手势事件触发时，是否同时触发对应的一个自定义的dom事件，当然这个没有直接绑定事件回调高效\x3c\/span\x3e\n      domEvents: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/这个会影响对应的css属性touch-action的值，下面会接着说\x3c\/span\x3e\n      touchAction: TOUCH_ACTION_COMPUTE, \n      \x3cspan class=\x22hljs-attr\x22\x3eenable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/是否开启手势识别\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/可以指定在其他的元素上来检测与touch相关的事件并作为输入源，如果没设置就是当前检测的元素了\x3c\/span\x3e\n      inputTarget: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \n      \x3cspan class=\x22hljs-attr\x22\x3einputClass\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/输入源类型，鼠标还是触摸或者是混合\x3c\/span\x3e\n      recognizers: [], \x3cspan class=\x22hljs-comment\x22\x3e\/\/我们配置的手势识别器\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/预设的一些手势识别器，格式：[RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]]\x3c\/span\x3e\n      preset: [ \n          [RotateRecognizer, { \x3cspan class=\x22hljs-attr\x22\x3eenable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e }],\n          [PinchRecognizer, { \x3cspan class=\x22hljs-attr\x22\x3eenable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e }, [\x3cspan class=\x22hljs-string\x22\x3e\x27rotate\x27\x3c\/span\x3e]],\n          [SwipeRecognizer, { \x3cspan class=\x22hljs-attr\x22\x3edirection\x3c\/span\x3e: DIRECTION_HORIZONTAL }],\n          [PanRecognizer, { \x3cspan class=\x22hljs-attr\x22\x3edirection\x3c\/span\x3e: DIRECTION_HORIZONTAL }, [\x3cspan class=\x22hljs-string\x22\x3e\x27swipe\x27\x3c\/span\x3e]],\n          [TapRecognizer],\n          [TapRecognizer, { \x3cspan class=\x22hljs-attr\x22\x3eevent\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27doubletap\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3etaps\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e }, [\x3cspan class=\x22hljs-string\x22\x3e\x27tap\x27\x3c\/span\x3e]],\n          [PressRecognizer]\n      ],\n      \x3cspan class=\x22hljs-attr\x22\x3ecssProps\x3c\/span\x3e: { \x3cspan class=\x22hljs-comment\x22\x3e\/\/额外的一些css属性\x3c\/span\x3e\n        userSelect: \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3etouchSelect\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3etouchCallout\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3econtentZooming\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3euserDrag\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27none\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3etapHighlightColor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27rgba(0,0,0,0)\x27\x3c\/span\x3e\n     }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总的来说配置参数不多，也不算复杂，这个框架基本也算是开箱即用了，好，我们接着再深入一点。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e初始化\x3c\/h2\x3e\n\x3cp\x3e接着来到源码里面manager.js，可以看到以下一段的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Manager {\n    constructor() {\n        ...\n        this.element = element;\n        this.input = createInputInstance(this);\/\/ 1\n        this.touchAction = new TouchAction(this,this.options.touchAction);\/\/ 2\n\n        toggleCssProps(this, true);\n        \n        each(this.options.recognizers, (item) =\x3e { \/\/3\n           let recognizer = this.add(new (item[0])(item[1]));\n               item[2] \x26amp;\x26amp; recognizer.recognizeWith(item[2]);\n               item[3] \x26amp;\x26amp; recognizer.requireFailure(item[3]);\n           }, this);\n        }\n    ...\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eManager\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n        ...\n        this.element = element;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input = createInputInstance(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.touchAction = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e TouchAction(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.touchAction);\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\n        toggleCssProps(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n        \n        each(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.options.recognizers, (item) =\x26gt; { \x3cspan class=\x22hljs-comment\x22\x3e\/\/3\x3c\/span\x3e\n           \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e recognizer = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.add(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e (item[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e])(item[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]));\n               item[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e] \x26amp;\x26amp; recognizer.recognizeWith(item[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]);\n               item[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e] \x26amp;\x26amp; recognizer.requireFailure(item[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]);\n           }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        }\n    ...\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e1.新建一个输入源\x3cbr\x3e根据设备的不同手势可能是来自鼠标也有可能来自手机上的触摸屏，而且mouse event的属性和touch event的属性是有一丝差异的（还有pointer event），所以为了方便后续处理，Hammer.js也分别定义了不同类型输入源：MouseInput，PointerEventInput，SingleTouchInput，TouchInput和TouchMouseInput；并针对不同的事件，对参数做了一个简单处理（handler方法），最终得到统一格式的数据输出，就像这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    {\n       pointers: touches[0],\n       changedPointers: touches[1],\n       pointerType: INPUT_TYPE_TOUCH,\n       srcEvent: ev\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    {\n       \x3cspan class=\x22hljs-attr\x22\x3epointers\x3c\/span\x3e: touches[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e],\n       \x3cspan class=\x22hljs-attr\x22\x3echangedPointers\x3c\/span\x3e: touches[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e],\n       \x3cspan class=\x22hljs-attr\x22\x3epointerType\x3c\/span\x3e: INPUT_TYPE_TOUCH,\n       \x3cspan class=\x22hljs-attr\x22\x3esrcEvent\x3c\/span\x3e: ev\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在获取统一格式的输入数据后，会交由InputHandler进一步处理，会判断这次输入是手势的开始还是结束，如果是开始就会新建一个手势识别的session，并且计算一些与手势相关的数据（角度，偏移距离，移动方向等），具体可以在compute-input-data.js里面看到。\x3cbr\x3e经过以这一轮计算，我们已经有足够的数据来支持之后的手势识别了。\x3cbr\x3e另外一提的是，这五种输入源都继承了Input，在Input里面事件是这样绑定的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n    this.evEl \x26amp;\x26amp; addEventListeners(this.element, this.evEl, this.domHandler);\n    this.evTarget \x26amp;\x26amp; addEventListeners(this.target, this.evTarget, this.domHandler);\n    this.evWin \x26amp;\x26amp; addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.evEl \x26amp;\x26amp; addEventListeners(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.element, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.evEl, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.domHandler);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.evTarget \x26amp;\x26amp; addEventListeners(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.target, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.evTarget, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.domHandler);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.evWin \x26amp;\x26amp; addEventListeners(getWindowForElement(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.element), \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.evWin, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.domHandler);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有三种绑定目标，当前的element，inputTarget，element所属的window，在window上绑定事件处理器还是很必要的（例如拖拉一个元素的时候）；另外翻了一下代码，inputTarget绑定都是touch相关的事件，不是很明白它的意图和场景，为什么要分离一个目标单独处理触摸事件。\x3c\/p\x3e\n\x3cp\x3e2.设置元素样式里touch-action的值\x3cbr\x3e在手机浏览器里面，一般也会自带一些手势处理，例如向右滑动或者向左滑动就是前进和后退，所以除了我们自己定义手势，还需要对浏览器的手势做一些限制或者禁止。\x3cbr\x3e这里也举个栗子吧，在Hammer.js里面默认提供拖拉手势的识别器（就是pan.js），当在检测水平方向的拖拉的时候，这个识别器会把touch-action的值设为pay-y（允许浏览器处理垂直方向的拖拉，可以是一个垂直的滚动或者其他），那如果我又接着定义一个垂直方向拖拉的识别器时，touch-action的值是多少尼？（答案就是none，浏览器不会帮我们再处理了，垂直方向滚动也只能靠自己），那是怎样计算出来的尼？\x3c\/p\x3e\n\x3cp\x3e在创建TouchAction对象时，如果配置参数中touchAction的值为TOUCH_ACTION_COMPUTE，便调用compute方法开始遍历recognizers，收集它们所希望设置的touch-action的值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    compute() {\n        let actions = [];\n        each(this.manager.recognizers, (recognizer) =\x3e {\n          if (boolOrFn(recognizer.options.enable, [recognizer])) {\n            actions = actions.concat(recognizer.getTouchAction());\n          }\n        });\n        return cleanTouchActions(actions.join(\x27 \x27));\n      }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    compute() {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e actions = [];\n        each(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.manager.recognizers, (recognizer) =\x26gt; {\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (boolOrFn(recognizer.options.enable, [recognizer])) {\n            actions = actions.concat(recognizer.getTouchAction());\n          }\n        });\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e cleanTouchActions(actions.join(\x3cspan class=\x22hljs-string\x22\x3e\x27 \x27\x3c\/span\x3e));\n      }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最终在cleanTouchActions方法集中计算最终的值：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     ...\n     let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n     let hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n     if (hasPanX \x26amp;\x26amp; hasPanY) {\n       return TOUCH_ACTION_NONE;\n     }\n     ...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e     ...\n     let hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n     \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);\n     \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hasPanX \x26amp;\x26amp; hasPanY) {\n       \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e TOUCH_ACTION_NONE;\n     }\n     ...\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3.配置手势识别器\x3cbr\x3e主要是配置各个手势识别器之间的关系，是否可以协同还是互斥，用官网一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n    var hammer = new Hammer(el, {});\n    \n    var singleTap = new Hammer.Tap({ event: \x27singletap\x27 });\n    var doubleTap = new Hammer.Tap({event: \x27doubletap\x27, taps: 2 });\n    var tripleTap = new Hammer.Tap({event: \x27tripletap\x27, taps: 3 });\n    \n    hammer.add([doubleTap, doubleTap, singleTap]);\n    \n    tripleTap.recognizeWith([doubleTap, singleTap]);\n    doubleTap.recognizeWith(singleTap);\n    \n    doubleTap.requireFailure(tripleTap);\n    singleTap.requireFailure([tripleTap, doubleTap]);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e hammer = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Hammer(el, {});\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e singleTap = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Hammer.Tap({ \x3cspan class=\x22hljs-attr\x22\x3eevent\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27singletap\x27\x3c\/span\x3e });\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e doubleTap = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Hammer.Tap({\x3cspan class=\x22hljs-attr\x22\x3eevent\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27doubletap\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3etaps\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e });\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tripleTap = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Hammer.Tap({\x3cspan class=\x22hljs-attr\x22\x3eevent\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27tripletap\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3etaps\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e });\n    \n    hammer.add([doubleTap, doubleTap, singleTap]);\n    \n    tripleTap.recognizeWith([doubleTap, singleTap]);\n    doubleTap.recognizeWith(singleTap);\n    \n    doubleTap.requireFailure(tripleTap);\n    singleTap.requireFailure([tripleTap, doubleTap]);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上定义了三个手势识别器：singleTap，doubleTap和tripleTap，很明显这个三个识别器是互斥的，如果用户点三下屏幕时都触发就比较尴尬了；\x3cbr\x3e这里得注意添加的顺序，因为Hammer.js是会按顺序遍历识别器调用他们的recognize方法，因为我们已经设置了手势的互斥，Hammer.js为了知道手势是单击还是双击，singleTap，doubleTap，tripleTap识别器都设置了300ms等待时间来判断之后还会不会有点击事件，根据识别顺序，singleTap总能获取tripleTap和doubleTap的识别结果来判断是否要触发事件，假如我们不设置他们之间的互斥关系，Hammer.js默认一满足条件就会触发，就会出现刚才说的那种尴尬的场景。\x3cbr\x3e那recognizeWith有啥作用尼，看以下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n    if (!curRecognizer || (curRecognizer \x26amp;\x26amp; curRecognizer.state \x26amp; STATE_RECOGNIZED)) {\n          curRecognizer = session.curRecognizer = null;\n        }\n    \n        let i = 0;\n        while (i \x3c recognizers.length) {\n          recognizer = recognizers[i];\n          if (session.stopped !== FORCED_STOP \x26amp;\x26amp; (\n                  !curRecognizer || recognizer === curRecognizer || \n                  recognizer.canRecognizeWith(curRecognizer))) {\n            recognizer.recognize(inputData);\n          } else {\n            recognizer.reset();\n          }\n          if (!curRecognizer \x26amp;\x26amp; recognizer.state \x26amp; (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n            curRecognizer = session.curRecognizer = recognizer;\n          }\n          i\x2b\x2b;\n        }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!curRecognizer || (curRecognizer \x26amp;\x26amp; curRecognizer.state \x26amp; STATE_RECOGNIZED)) {\n          curRecognizer = session.curRecognizer = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        }\n    \n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i \x26lt; recognizers.length) {\n          recognizer = recognizers[i];\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (session.stopped !== FORCED_STOP \x26amp;\x26amp; (\n                  !curRecognizer || recognizer === curRecognizer || \n                  recognizer.canRecognizeWith(curRecognizer))) {\n            recognizer.recognize(inputData);\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            recognizer.reset();\n          }\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!curRecognizer \x26amp;\x26amp; recognizer.state \x26amp; (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n            curRecognizer = session.curRecognizer = recognizer;\n          }\n          i\x2b\x2b;\n        }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然singleTap，doubleTap和tripleTap从最终结果上应该是互斥的，但是同样的数据输入时可能会同时让几个手势识别器识别，例如当用户点击一下屏幕，singleTap识别器的状态可能是STATE_RECOGNIZED或者STATE_BEGAN（等待doubleTap和tripleTap识别器的结果），session会把singTap识别器记录为当前的手势识别器，但是doubleTap和tripleTap也是需要记录一些状态（例如当前点击次数），因为很有可能接下来又是一个单击，变成双击手势；当用户接着再单击一下，doubleTap识别器因为设置了recognizeWith(singleTap)和以协同singleTap识别数据输入，然后doubleTap识别器开始进入STATE_RECOGNIZED或者STATE_BEGAN（等待tripleTap识别器的结果），此时session当前的手势识别器就是doubleTap了，而singleTap识别器因为没有设置recognizeWith(doubleTap)，会被重置。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e一点小的细节\x3c\/h2\x3e\n\x3cp\x3e我们在旋转一张图片时，如何实现旋转，怎么知道旋转的角度尼？\x3cbr\x3e再回到computeInputData方法，有这样一行代码获取偏转角度：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    ...\n    let center = input.center = getCenter(pointers);\n    ...\n    input.angle = getAngle(offsetCenter, center);\n    ...\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    ...\n    let center = input.center = getCenter(pointers);\n    ...\n    input.angle = getAngle(offsetCenter, center);\n    ...\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再跟踪一下getCenter方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\n     while (i \x3c pointersLength) {\n        x \x2b= pointers[i].clientX;\n        y \x2b= pointers[i].clientY;\n        i\x2b\x2b;\n      }\n    \n     return {\n        x: round(x \/ pointersLength),\n        y: round(y \/ pointersLength)\n      };\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n     \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i \x26lt; pointersLength) {\n        x \x2b= pointers[i].clientX;\n        y \x2b= pointers[i].clientY;\n        i\x2b\x2b;\n      }\n    \n     \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: round(x \/ pointersLength),\n        \x3cspan class=\x22hljs-attr\x22\x3ey\x3c\/span\x3e: round(y \/ pointersLength)\n      };\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很简单的算出手势的中心位置，当我们双指旋转时，中心位置也会跟着移动，很容易计算出前后偏转角度。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e最后一点思考\x3c\/h1\x3e\n\x3cp\x3eHammer.js都是在冒泡阶段绑定事件处理器，为什么不在捕获阶段拦截事件尼，如果一个向右活动的手势被识别，后续的事件（如touchMove）已经没必要再传给子节点，完全可以在拦截的元素上处理，这样性能上也应该会有一点提升，挖个坑给自己以后实现一下。\x3cbr\x3e最后的最后。。。\x3cbr\x3e因为没有使用经验，单靠啃源码，难免有所错漏，望指正。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Hammer.js源码简析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009122378">https://segmentfault.com/a/1190000009122378</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9xxcznrq047/" target="_blank">https://alili.tech/archive/9xxcznrq047/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>