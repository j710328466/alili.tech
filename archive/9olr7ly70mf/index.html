<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React从入门到精通系列之(19)彻底理解React如何重新处理DOM(Diffing算法)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React从入门到精通系列之(19)彻底理解React如何重新处理DOM(Diffing算法) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9olr7ly70mf/",
				"appid": "1613049289050283", 
				"title": "React从入门到精通系列之(19)彻底理解React如何重新处理DOM(Diffing算法) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/evtauqulqa/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/tjeml12s3/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f&text=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2819%29%e5%bd%bb%e5%ba%95%e7%90%86%e8%a7%a3React%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%a4%84%e7%90%86DOM%28Diffing%e7%ae%97%e6%b3%95%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f&text=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2819%29%e5%bd%bb%e5%ba%95%e7%90%86%e8%a7%a3React%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%a4%84%e7%90%86DOM%28Diffing%e7%ae%97%e6%b3%95%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2819%29%e5%bd%bb%e5%ba%95%e7%90%86%e8%a7%a3React%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%a4%84%e7%90%86DOM%28Diffing%e7%ae%97%e6%b3%95%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f&is_video=false&description=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2819%29%e5%bd%bb%e5%ba%95%e7%90%86%e8%a7%a3React%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%a4%84%e7%90%86DOM%28Diffing%e7%ae%97%e6%b3%95%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2819%29%e5%bd%bb%e5%ba%95%e7%90%86%e8%a7%a3React%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%a4%84%e7%90%86DOM%28Diffing%e7%ae%97%e6%b3%95%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2819%29%e5%bd%bb%e5%ba%95%e7%90%86%e8%a7%a3React%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%a4%84%e7%90%86DOM%28Diffing%e7%ae%97%e6%b3%95%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2819%29%e5%bd%bb%e5%ba%95%e7%90%86%e8%a7%a3React%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%a4%84%e7%90%86DOM%28Diffing%e7%ae%97%e6%b3%95%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2819%29%e5%bd%bb%e5%ba%95%e7%90%86%e8%a7%a3React%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%a4%84%e7%90%86DOM%28Diffing%e7%ae%97%e6%b3%95%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9olr7ly70mf%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2819%29%e5%bd%bb%e5%ba%95%e7%90%86%e8%a7%a3React%e5%a6%82%e4%bd%95%e9%87%8d%e6%96%b0%e5%a4%84%e7%90%86DOM%28Diffing%e7%ae%97%e6%b3%95%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React从入门到精通系列之(19)彻底理解React如何重新处理DOM(Diffing算法)</h1><div class="meta"><div class="postdate"><time datetime="2019-01-29" itemprop="datePublished">2019-01-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e十九、彻底理解React如何重新处理DOM(Diffing算法)\x3c\/h2\x3e\n\x3cp\x3eReact提供了一个声明式的API，所以你不必担心每次DOM更新时内部会修改哪些东西。虽然在React中并不是那么明显地告诉你具体如何实现的，不过这也让编写应用变得更加容易。\x3c\/p\x3e\n\x3cp\x3e本文会详细解释在React中的\x3ccode\x3e“diffing”\x3c\/code\x3e算法是怎么做的，以便组件更新是可预测的，从而让高性能应用变得足够快。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e动机\x3c\/h3\x3e\n\x3cp\x3e当使用React时，在单个时间点，您可以将\x3ccode\x3erender()\x3c\/code\x3e函数看做是在创建React元素树。 在下一个\x3ccode\x3estate\x3c\/code\x3e或\x3ccode\x3eprops\x3c\/code\x3e更新时\x3ccode\x3erender()\x3c\/code\x3e函数将返回一个不同的React元素树。 React需要弄清楚如何高效地更新UI去匹配上最新的元素树。\x3c\/p\x3e\n\x3cp\x3e对于将一个树变换成另一个树的最小操作数的算法问题，现在已经存在一些比较通用的解决方案。 然而，那些现有的最先进的技术算法都有\x3ccode\x3eO(n^3)\x3c\/code\x3e的复杂度（n是树中的元素的数量）。\x3c\/p\x3e\n\x3cp\x3e如果在React中使用这些算法，显示1000个元素将需要大约十亿次比较。 这个真的代价太昂贵了。 相反，React实现了一个\x3ccode\x3e基于两个假设\x3c\/code\x3e直观推断出的\x3ccode\x3eO(n)\x3c\/code\x3e算法：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e不同类型的两个元素将产生不同的树。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e开发人员可以在不同渲染之间使用\x3ccode\x3ekey\x3c\/code\x3e属性来表示哪些子元素是稳定的。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e实际上，这两条假设对几乎所有的实际使用都是有效的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eDiffing算法\x3c\/h3\x3e\n\x3cp\x3e当比较两棵DOM树的差异时，React首先比较两个根元素。 如果根元素的类型不同，那么行为也是不同的。\x3c\/p\x3e\n\x3ch4\x3e不同类型的DOM元素\x3c\/h4\x3e\n\x3cp\x3e每当根元素是不同的类型时，React将删除旧的DOM树并从头开始重新构建新的DOM树。 从\x3ccode\x3e\x26lt;a\x26gt;\x3c\/code\x3e到\x3ccode\x3e\x26lt;img\x26gt;\x3c\/code\x3e、从\x3ccode\x3e\x26lt;Article\x26gt;\x3c\/code\x3e到\x3ccode\x3e\x26lt;Comment\x26gt;\x3c\/code\x3e、从\x3ccode\x3e\x26lt;Button\x26gt;\x3c\/code\x3e到\x3ccode\x3e\x26lt;div\x26gt;\x3c\/code\x3e ，只要不一样就会完全重新构建。\x3c\/p\x3e\n\x3cp\x3e当删除就的DOM树时，旧的DOM节点也被删掉。 这个时候组件实例触发\x3ccode\x3ecomponentWillUnmount()\x3c\/code\x3e函数 。当构建一个新的DOM树时，新的DOM节点会被插入到DOM中。 组件实例触发\x3ccode\x3ecomponentWillMoun()\x3c\/code\x3e和\x3ccode\x3ecomponentDidMount()\x3c\/code\x3e。 与之前旧的DOM树相关联的任何\x3ccode\x3estate\x3c\/code\x3e也都将丢失。\x3c\/p\x3e\n\x3cp\x3e在根元素之下的任何组件将被卸载并且它们的\x3ccode\x3estate\x3c\/code\x3e也会全部丢失。 例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 从\n\x3cdiv\x3e\n    \x3cCounter \/\x3e\n\x3c\/div\x3e\n\/\/ 变为\n\x3cspan\x3e\n    \x3cCounter \/\x3e\n\x3c\/span\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从\x3c\/span\x3e\n\x26lt;div\x26gt;\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCounter\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 变为\x3c\/span\x3e\n\x26lt;span\x26gt;\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCounter\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为根元素从\x3ccode\x3ediv\x3c\/code\x3e变为了\x3ccode\x3espan\x3c\/code\x3e，所以旧的\x3ccode\x3eCounter\x3c\/code\x3e组件将被销毁，然后再重新构建一个新的。\x3c\/p\x3e\n\x3ch4\x3e相同类型的DOM元素\x3c\/h4\x3e\n\x3cp\x3e当比较相同类型的两个React DOM元素时，React会先查看两者的属性差异，然后保留相同的底层DOM节点，仅仅去更新那些被更改的属性。 例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv className=\x26quot;before\x26quot; title=\x26quot;hello\x26quot; \/\x3e\n\n\x3cdiv className=\x26quot;after\x26quot; title=\x26quot;hello\x26quot; \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x26lt;div className=\x3cspan class=\x22hljs-string\x22\x3e\x22before\x22\x3c\/span\x3e title=\x3cspan class=\x22hljs-string\x22\x3e\x22hello\x22\x3c\/span\x3e \/\x26gt;\n\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22after\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etitle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22hello\x22\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过比较这两个元素属性，React就会知道只需要修改底层DOM节点上的\x3ccode\x3eclassName\x3c\/code\x3e即可。\x3c\/p\x3e\n\x3cp\x3e当更新\x3ccode\x3estyle\x3c\/code\x3e属性时，React也会知道只需要更新\x3ccode\x3estyle\x3c\/code\x3e中的那些已更改的属性。 例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv style=\x22{{\x22color: \x27red\x27, width: \x27300px\x27\x22}}\x22 \/\x3e\n\n\x3cdiv style=\x22{{\x22color: \x27red\x27, width: \x27400px\x27\x22}}\x22 \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x26lt;div style=\x22{{\x22\x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ewidth\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27300px\x27\x3c\/span\x3e\x22}}\x22 \/\x26gt;\n\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estyle\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22{{\x22color:\x3c\/span\x3e \x27\x3cspan class=\x22hljs-attr\x22\x3ered\x3c\/span\x3e\x27, \x3cspan class=\x22hljs-attr\x22\x3ewidth:\x3c\/span\x3e \x27\x3cspan class=\x22hljs-attr\x22\x3e400px\x3c\/span\x3e\x27\x22}}\x22 \/\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当在这两个元素之间转换时，React知道只需修改\x3ccode\x3ewidth\x3c\/code\x3e，而不是\x3ccode\x3ecolor\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e处理根DOM节点后，React会根据上面的判断逻辑对子节点进行递归扫描。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch4\x3e相同类型的组件元素\x3c\/h4\x3e\n\x3cp\x3e当组件更新时，实例保持不变，因此在不同的渲染之间组件内的\x3ccode\x3estate\x3c\/code\x3e是保持不变的。 React会更新底层组件实例的\x3ccode\x3eprops\x3c\/code\x3e来匹配新元素，并在底层实例上调用\x3ccode\x3ecomponentWillReceiveProps()\x3c\/code\x3e和\x3ccode\x3ecomponentWillUpdate()\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e接下来，调用\x3ccode\x3erender()\x3c\/code\x3e方法，\x3ccode\x3ediff\x3c\/code\x3e算法就会对上一个结果和新结果进行递归比较。\x3c\/p\x3e\n\x3ch4\x3e递归子元素\x3c\/h4\x3e\n\x3cp\x3e默认情况下，当对DOM节点的子元素进行递归时，React只是同时迭代两个子元素lists，并在有差异时产生变化。\x3c\/p\x3e\n\x3cp\x3e例如，当在子元素的末尾再添加一个元素时，这两个树之间就会有一个的很好转换效果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cul\x3e\n    \x3cl1\x3eone\x3c\/li\x3e\n    \x3cli\x3etwo\x3c\/li\x3e\n\x3c\/ul\x3e\n\n\x3cul\x3e\n    \x3cli\x3eone\x3c\/li\x3e\n    \x3cli\x3etwo\x3c\/li\x3e\n    \x3cli\x3ethree\x3c\/li\x3e\n\x3c\/ul\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x26lt;ul\x26gt;\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3el1\x3c\/span\x3e\x26gt;\x3c\/span\x3eone\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    \x26lt;li\x26gt;two\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/li\x26gt;\n\x26lt;\/u\x3c\/span\x3el\x26gt;\n\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3eone\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3etwo\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3ethree\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact将匹配两个\x3ccode\x3e\x26lt;li\x26gt;one\x26lt;\/li\x26gt;\x3c\/code\x3e树，匹配两个\x3ccode\x3e\x26lt;li\x26gt;two\x26lt;\/li\x26gt;\x3c\/code\x3e树，然后插入一个\x3ccode\x3e\x26lt;li\x26gt;three\x26lt;\/li\x26gt;\x3c\/code\x3e树。\x3c\/p\x3e\n\x3cp\x3e但是，不要太天真了。如果在子元素的开头部分插入一个元素的话，性能会便的很差。 例如，这两棵树之间的转换效果就很差：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cul\x3e\n    \x3cli\x3eone\x3c\/li\x3e\n    \x3cli\x3etwo\x3c\/li\x3e\n\x3cul\x3e\n\n\x3cul\x3e\n    \x3cli\x3ezero\x3c\/li\x3e\n    \x3cli\x3eone\x3c\/li\x3e\n    \x3cli\x3etwo\x3c\/li\x3e\n\x3cul\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x26lt;ul\x26gt;\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3eone\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    \x26lt;li\x26gt;two\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/li\x26gt;\n\x26lt;ul\x26gt;\n\n\x26lt;ul\x26gt;\n    \x26lt;li\x26gt;zero\x26lt;\/\x3c\/span\x3eli\x26gt;\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3eone\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    \x26lt;li\x26gt;two\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/li\x26gt;\n\x26lt;ul\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种情况React将更改每个子元素 ，而不会意识到它可以保持\x3ccode\x3e\x26lt;li\x26gt;one\x26lt;\/li\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;li\x26gt;two\x26lt;\/li\x26gt;\x3c\/code\x3e子元素树完好无损。 这种低效率的情况是一个必须注意的问题。\x3c\/p\x3e\n\x3ch4\x3ekeys\x3c\/h4\x3e\n\x3cp\x3e为了解决上面的问题，React提供了一个\x3ccode\x3ekey\x3c\/code\x3e属性。 当子元素有\x3ccode\x3ekey\x3c\/code\x3e属性时，React使用\x3ccode\x3ekey\x3c\/code\x3e将原始树中的子元素与后续树中的子元素进行匹配。 例如，上面的那个低效例子添加一个\x3ccode\x3ekey\x3c\/code\x3e就可以让子元素树转换变的很有效：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cul\x3e\n    \x3cli key=\x26quot;1\x26quot;\x3eone\x3c\/li\x3e\n    \x3cli key=\x26quot;2\x26quot;\x3etwo\x3c\/li\x3e\n\x3cul\x3e\n\n\x3cul\x3e\n    \x3cli key=\x26quot;0\x26quot;\x3ezero\x3c\/li\x3e\n    \x3cli key=\x26quot;1\x26quot;\x3eone\x3c\/li\x3e\n    \x3cli key=\x26quot;2\x26quot;\x3etwo\x3c\/li\x3e\n\x3cul\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x26lt;ul\x26gt;\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x221\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eone\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    \x26lt;li key=\x3cspan class=\x22hljs-string\x22\x3e\x222\x22\x3c\/span\x3e\x26gt;two\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/li\x26gt;\n\x26lt;ul\x26gt;\n\n\x26lt;ul\x26gt;\n    \x26lt;li key=\x220\x22\x26gt;zero\x26lt;\/\x3c\/span\x3eli\x26gt;\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x221\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eone\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    \x26lt;li key=\x3cspan class=\x22hljs-string\x22\x3e\x222\x22\x3c\/span\x3e\x26gt;two\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/li\x26gt;\n\x26lt;ul\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在React就可以知道\x3ccode\x3ekey=\x220\x22\x3c\/code\x3e的元素是新的，并且\x3ccode\x3ekey=\x221\x22\x3c\/code\x3e和\x3ccode\x3ekey=\x222\x22\x3c\/code\x3e的元素只需移动即可。\x3c\/p\x3e\n\x3cp\x3e在实践中，使用一个唯一的\x3ccode\x3ekey\x3c\/code\x3e并不难。 您要显示的元素可能已具有唯一的\x3ccode\x3eID\x3c\/code\x3e，因此\x3ccode\x3ekey\x3c\/code\x3e可以来自你自己的数据中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cli key={item.id\x3e{item.name}\x3c\/li\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x26lt;li key={item.id\x26gt;{item.name}\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/li\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果不是这样，你可以向数据模型中给每一项数据添加一个新的\x3ccode\x3eID\x3c\/code\x3e属性，或者对内容的某些部分进行哈希生成\x3ccode\x3ekey\x3c\/code\x3e。 \x3ccode\x3ekey\x3c\/code\x3e属性只有在其兄弟元素之间是唯一的，并不是全局唯一的。\x3c\/p\x3e\n\x3cp\x3e最后一种方式是可以将数组中的索引作为\x3ccode\x3ekey\x3c\/code\x3e。 如果数组中的每一项不需要重新排序，同样也可以很好地工作，但是万一需要重新排序的话，这会变的很慢。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e权衡利弊\x3c\/h3\x3e\n\x3cp\x3e要记住重要的是，\x3ccode\x3ediffing\x3c\/code\x3e算法是一个具体的实现细节。 React可以在每个操作上去重新渲染应用; 最终结果都是一样的。\x3c\/p\x3e\n\x3cp\x3e在当前的实现中，你可以看到一个事实是一个子树已经成功移动到它的兄弟元素当中，但你不能告诉它已经移动到别的地方。 该算法将重新渲染这个完整的子元素树。\x3c\/p\x3e\n\x3cp\x3e因为React很依赖这个直观推断的算法来判断DOM是否需要重新处理，如果不能满足这个算法的那两个假设条件前提，应用的性能将会受到很大影响。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e该算法不会去尝试匹配那些不同组件类型的子元素树。 如果你看到自己在返回相似输出结果的两个组件类型之间来来回回，你可能需要把它们改为相同的类型组件。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ekey\x3c\/code\x3e属性应该是稳定，可预测和唯一的。 不稳定的键(如使用\x3ccode\x3eMath.random()\x3c\/code\x3e生的\x3ccode\x3ekey\x3c\/code\x3e)将导致许多组件实例和DOM节点进行不必要地重复创建，这可能导致子组件中的性能降低和\x3ccode\x3estate\x3c\/code\x3e丢失。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React从入门到精通系列之(19)彻底理解React如何重新处理DOM(Diffing算法)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007826792">https://segmentfault.com/a/1190000007826792</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9olr7ly70mf/" target="_blank">https://alili.tech/archive/9olr7ly70mf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/sj57jxyoook/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（上）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/qsw902j95k/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（下）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/nnpmjlot58j/">IndexedDB使用与出坑指南<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/alvlbas9oai/">JS事件模型<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/u0pzym8k36o/">JS练习实例--编写经典小游戏俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/khwpyk5yz8q/">JavaScript 事件代理和委托<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/kuocl6lc3n/">JavaScript 版俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/n8bk54lyrf/">Promise学习:基础入门<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/7bk7u30qncb/">Redux 入坑进阶 - 源码解析<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/853kqfmqmf7/">Snap.svg 基本知识入门<aside class="dates">2019-02-03</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>