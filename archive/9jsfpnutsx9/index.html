<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="十大经典排序算法总结(Javascript描述)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>十大经典排序算法总结(Javascript描述) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9jsfpnutsx9/",
				"appid": "1613049289050283", 
				"title": "十大经典排序算法总结(Javascript描述) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-03T02:30:40"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fg9m4gkkc7f/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/354cnfbyrq8/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f&text=%e5%8d%81%e5%a4%a7%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93%28Javascript%e6%8f%8f%e8%bf%b0%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f&text=%e5%8d%81%e5%a4%a7%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93%28Javascript%e6%8f%8f%e8%bf%b0%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f&title=%e5%8d%81%e5%a4%a7%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93%28Javascript%e6%8f%8f%e8%bf%b0%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f&is_video=false&description=%e5%8d%81%e5%a4%a7%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93%28Javascript%e6%8f%8f%e8%bf%b0%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%8d%81%e5%a4%a7%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93%28Javascript%e6%8f%8f%e8%bf%b0%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f&title=%e5%8d%81%e5%a4%a7%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93%28Javascript%e6%8f%8f%e8%bf%b0%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f&title=%e5%8d%81%e5%a4%a7%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93%28Javascript%e6%8f%8f%e8%bf%b0%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f&title=%e5%8d%81%e5%a4%a7%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93%28Javascript%e6%8f%8f%e8%bf%b0%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9jsfpnutsx9%2f&title=%e5%8d%81%e5%a4%a7%e7%bb%8f%e5%85%b8%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e6%80%bb%e7%bb%93%28Javascript%e6%8f%8f%e8%bf%b0%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">十大经典排序算法总结(Javascript描述)</h1><div class="meta"><div class="postdate"><time datetime="2019-02-03" itemprop="datePublished">2019-02-03</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e读者自行尝试可以\x3ca href=\x22https:\/\/github.com\/damonare\/Sorts\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e想看源码戳这\x3c\/a\x3e，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e个人博客：\x3ca href=\x22http:\/\/damonare.cn\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDamonare的个人博客\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e原文地址：\x3ca href=\x22http:\/\/damonare.github.io\/2016\/09\/16\/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93%EF%BC%88javascript%E6%8F%8F%E8%BF%B0%EF%BC%89\/#more\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e十大经典算法总结\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cul\x3e\n\x3cli\x3e\x3cp\x3e这世界上总存在着那么一些看似相似但有完全不同的东西，比如雷锋和雷峰塔，小平和小平头，玛丽和马里奥，Java和javascript....当年javascript为了抱Java大腿恬不知耻的让自己变成了Java的干儿子，哦，不是应该是跪舔，毕竟都跟了Java的姓了。可如今，javascript来了个咸鱼翻身，几乎要统治web领域，Nodejs，React Native的出现使得javascript在后端和移动端都开始占有了一席之地。可以这么说,在Web的江湖，\x26lt;mark\x26gt;JavaScript可谓风头无两，已经坐上了头把交椅。\x26lt;\/mark\x26gt;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在传统的计算机算法和数据结构领域，大多数专业教材和书籍的默认语言都是Java或者C\/C\x2b \x2b，O’REILLY家倒是出了一本叫做《数据结构与算法javascript描述》的书，但不得不说，不知道是作者吃了shit还是译者根本就没校对，满书的小错误，这就像那种无穷无尽的小bug一样,简直就是让人有种嘴里塞满了shit的感觉，吐也不是咽下去也不是。对于一个前端来说，尤其是笔试面试的时候，算法方面考的其实不难（\x26lt;mark\x26gt;十大排序算法或是和十大排序算法同等难度的\x26lt;\/mark\x26gt;），但就是之前没用javascript实现过或是没仔细看过相关算法的原理，导致写起来浪费很多时间。所以撸一撸袖子决定自己查资料自己总结一篇博客等用到了直接看自己的博客就OK了，正所谓靠天靠地靠大牛不如靠自己(ˉ(∞)ˉ)。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e算法的由来：9世纪波斯数学家提出的：“al-Khowarizmi”就是下图这货（感觉重要数学元素提出者貌似都戴了顶白帽子），开个玩笑，阿拉伯人对于数学史的贡献还是值得人敬佩的。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921372?w=277\x26amp;h=344\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921372?w=277\x26amp;h=344\x22 alt=\x22大大\x22 title=\x22大大\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e正文\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e排序算法说明\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e（1）排序的定义：对一序列对象根据某个关键字进行排序；\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e输入：n个数：a1,a2,a3,...,an\x3cbr\x3e输出：n个数的排列:a1\x27,a2\x27,a3\x27,...,an\x27，使得a1\x27\x26lt;=a2\x27\x26lt;=a3\x27\x26lt;=...\x26lt;=an\x27。\x3c\/p\x3e\n\x3cp\x3e再讲的形象点就是排排坐，调座位，高的站在后面，矮的站在前面咯。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e（3）对于评述算法优劣术语的说明\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e稳定\x3c\/strong\x3e：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；\x3cbr\x3e\x3cstrong\x3e不稳定\x3c\/strong\x3e：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e内排序\x3c\/strong\x3e：所有排序操作都在内存中完成；\x3cbr\x3e\x3cstrong\x3e外排序\x3c\/strong\x3e：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e时间复杂度\x3c\/strong\x3e: 一个算法执行所耗费的时间。\x3cbr\x3e\x3cstrong\x3e空间复杂度\x3c\/strong\x3e: 运行完一个程序所需内存的大小。\x3c\/p\x3e\n\x3cp\x3e关于时间空间复杂度的更多了解请戳\x3ca href=\x22http:\/\/blog.csdn.net\/booirror\/article\/details\/7707551\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e，或是看书程杰大大编写的《大话数据结构》还是很赞的，通俗易懂。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e（4）排序算法图片总结(图片来源于网络):\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e排序对比：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921373?w=966\x26amp;h=588\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921373?w=966\x26amp;h=588\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e图片名词解释：\x3c\/strong\x3e\x3cbr\x3en: 数据规模\x3cbr\x3ek:“桶”的个数\x3cbr\x3eIn-place: 占用常数内存，不占用额外内存\x3cbr\x3eOut-place: 占用额外内存\x3c\/p\x3e\n\x3cp\x3e排序分类：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921374?w=528\x26amp;h=363\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921374?w=528\x26amp;h=363\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1.冒泡排序（Bubble Sort）\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e好的，开始总结第一个排序算法，冒泡排序。我想对于它每个学过C语言的都会了解的吧，这可能是很多人接触的第一个排序算法。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(1)算法描述\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3e具体算法描述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;.比较相邻的元素。如果第一个比第二个大，就交换它们两个；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;.针对所有的元素重复以上的步骤，除了最后一个；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;4\x26gt;.重复步骤1~3，直到排序完成。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavaScript代码实现：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i \x3c len; i\x2b\x2b) {\n        for (var j = 0; j \x3c len - 1 - i; j\x2b\x2b) {\n            if (arr[j] \x3e arr[j\x2b1]) {        \/\/相邻元素两两对比\n                var temp = arr[j\x2b1];        \/\/元素交换\n                arr[j\x2b1] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bubbleSort(arr));\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3efunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; len; i\x2b\x2b) {\n        for (var j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; len - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e - i; j\x2b\x2b) {\n            if (arr[j] \x26gt; arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) {        \x3cspan class=\x22hljs-comment\x22\x3e\/\/相邻元素两两对比\x3c\/span\x3e\n                var temp = arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];        \x3cspan class=\x22hljs-comment\x22\x3e\/\/元素交换\x3c\/span\x3e\n                arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\nvar arr=[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\nconsole.log(bubbleSort(arr));\x3cspan class=\x22hljs-comment\x22\x3e\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e改进冒泡排序： \x3c\/strong\x3e设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e改进后算法如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nfunction bubbleSort2(arr) {\n    console.time(\x27改进后冒泡排序耗时\x27);\n    var i = arr.length-1;  \/\/初始时,最后位置保持不变\n    while ( i\x3e 0) {\n        var pos= 0; \/\/每趟开始时,无记录交换\n        for (var j= 0; j\x3c i; j\x2b\x2b)\n            if (arr[j]\x3e arr[j\x2b1]) {\n                pos= j; \/\/记录交换的位置\n                var tmp = arr[j]; arr[j]=arr[j\x2b1];arr[j\x2b1]=tmp;\n            }\n        i= pos; \/\/为下一趟排序作准备\n     }\n     console.timeEnd(\x27改进后冒泡排序耗时\x27);\n     return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bubbleSort2(arr));\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\nfunction bubbleSort2(arr) {\n    console.time(\x27改进后冒泡排序耗时\x27);\n    var i = arr.length\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始时,最后位置保持不变\x3c\/span\x3e\n    while ( i\x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        var pos= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/每趟开始时,无记录交换\x3c\/span\x3e\n        for (var j= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j\x26lt; i; j\x2b\x2b)\n            if (arr[j]\x26gt; arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) {\n                pos= j; \x3cspan class=\x22hljs-comment\x22\x3e\/\/记录交换的位置\x3c\/span\x3e\n                var tmp = arr[j]; arr[j]=arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]=tmp;\n            }\n        i= pos; \x3cspan class=\x22hljs-comment\x22\x3e\/\/为下一趟排序作准备\x3c\/span\x3e\n     }\n     console.timeEnd(\x27改进后冒泡排序耗时\x27);\n     return arr;\n}\nvar arr=[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\nconsole.log(bubbleSort2(arr));\x3cspan class=\x22hljs-comment\x22\x3e\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值,我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次可以得到两个最终值(最大者和最小者) , 从而使排序趟数几乎减少了一半。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e改进后的算法实现为:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function bubbleSort3(arr3) {\n    var low = 0;\n    var high= arr.length-1; \/\/设置变量的初始值\n    var tmp,j;\n    console.time(\x272.改进后冒泡排序耗时\x27);\n    while (low \x3c high) {\n        for (j= low; j\x3c high; \x2b\x2bj) \/\/正向冒泡,找到最大者\n            if (arr[j]\x3e arr[j\x2b1]) {\n                tmp = arr[j]; arr[j]=arr[j\x2b1];arr[j\x2b1]=tmp;\n            }\n        --high;                 \/\/修改high值, 前移一位\n        for (j=high; j\x3elow; --j) \/\/反向冒泡,找到最小者\n            if (arr[j]\x3carr[j-1]) {\n                tmp = arr[j]; arr[j]=arr[j-1];arr[j-1]=tmp;\n            }\n        \x2b\x2blow;                  \/\/修改low值,后移一位\n    }\n    console.timeEnd(\x272.改进后冒泡排序耗时\x27);\n    return arr3;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bubbleSort3(arr));\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3efunction bubbleSort3(arr3) {\n    var low = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    var high= arr.length\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/设置变量的初始值\x3c\/span\x3e\n    var tmp,j;\n    console.time(\x27\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e改进后冒泡排序耗时\x27);\n    while (low \x26lt; high) {\n        for (j= low; j\x26lt; high; \x2b\x2bj) \x3cspan class=\x22hljs-comment\x22\x3e\/\/正向冒泡,找到最大者\x3c\/span\x3e\n            if (arr[j]\x26gt; arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) {\n                tmp = arr[j]; arr[j]=arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]=tmp;\n            }\n        --high;                 \x3cspan class=\x22hljs-comment\x22\x3e\/\/修改high值, 前移一位\x3c\/span\x3e\n        for (j=high; j\x26gt;low; --j) \x3cspan class=\x22hljs-comment\x22\x3e\/\/反向冒泡,找到最小者\x3c\/span\x3e\n            if (arr[j]\x26lt;arr[j\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e]) {\n                tmp = arr[j]; arr[j]=arr[j\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e];arr[j\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e]=tmp;\n            }\n        \x2b\x2blow;                  \x3cspan class=\x22hljs-comment\x22\x3e\/\/修改low值,后移一位\x3c\/span\x3e\n    }\n    console.timeEnd(\x27\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e改进后冒泡排序耗时\x27);\n    return arr3;\n}\nvar arr=[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\nconsole.log(bubbleSort3(arr));\x3cspan class=\x22hljs-comment\x22\x3e\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e三种方法耗时对比：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921375?w=537\x26amp;h=350\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921375?w=537\x26amp;h=350\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e由图可以看出改进后的冒泡排序明显的时间复杂度更低，耗时更短了。读者自行尝试可以戳这，博主在github建了个库，读者可以Clone下来本地尝试。此博文配合源码体验更棒哦~~~\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e冒泡排序动图演示:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921376?w=826\x26amp;h=257\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921376?w=826\x26amp;h=257\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e(3)算法分析\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e最佳情况：T(n) = O(n)\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e当输入的数据已经是正序时（都已经是正序了，为毛何必还排序呢....）\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e最差情况：T(n) = O(n2)\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e当输入的数据是反序时(卧槽，我直接反序不就完了....)\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e平均情况：T(n) = O(n2)\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e2.选择排序（Selection Sort）\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e表现最稳定的排序算法之一(这个稳定不是指算法层面上的稳定哈，相信聪明的你能明白我说的意思2333)，因为无论什么数据进去都是O(n²)的时间复杂度.....所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(1)算法简介\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3en个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;.初始状态：无序区为R[1..n]，有序区为空；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;.第i趟排序(i=1,2,3...n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i\x2b1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;.n-1趟结束，数组有序化了。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavascript代码实现:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    console.time(\x27选择排序耗时\x27);\n    for (var i = 0; i \x3c len - 1; i\x2b\x2b) {\n        minIndex = i;\n        for (var j = i \x2b 1; j \x3c len; j\x2b\x2b) {\n            if (arr[j] \x3c arr[minIndex]) {     \/\/寻找最小的数\n                minIndex = j;                 \/\/将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    console.timeEnd(\x27选择排序耗时\x27);\n    return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(selectionSort(arr));\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3efunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    console.time(\x27选择排序耗时\x27);\n    for (var i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; len - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i\x2b\x2b) {\n        minIndex = i;\n        for (var j = i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; j \x26lt; len; j\x2b\x2b) {\n            if (arr[j] \x26lt; arr[minIndex]) {     \x3cspan class=\x22hljs-comment\x22\x3e\/\/寻找最小的数\x3c\/span\x3e\n                minIndex = j;                 \x3cspan class=\x22hljs-comment\x22\x3e\/\/将最小数的索引保存\x3c\/span\x3e\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    console.timeEnd(\x27选择排序耗时\x27);\n    return arr;\n}\nvar arr=[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\nconsole.log(selectionSort(arr));\x3cspan class=\x22hljs-comment\x22\x3e\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x3c\/span\x3e\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e选择排序动图演示：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921377?w=811\x26amp;h=248\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921377?w=811\x26amp;h=248\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e(3)算法分析\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e最佳情况：T(n) = O(n2)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最差情况：T(n) = O(n2)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e平均情况：T(n) = O(n2)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e3.插入排序（Insertion Sort）\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。当然，如果你说你打扑克牌摸牌的时候从来不按牌的大小整理牌，那估计这辈子你对插入排序的算法都不会产生任何兴趣了.....\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(1)算法简介\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3e一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;.从第一个元素开始，该元素可以认为已经被排序；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;.取出下一个元素，在已经排序的元素序列中从后向前扫描；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;.如果该元素（已排序）大于新元素，将该元素移到下一位置；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;4\x26gt;.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;5\x26gt;.将新元素插入到该位置后；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;6\x26gt;.重复步骤2~5。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavascript代码实现:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function insertionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === \x27Array\x27) {\n        console.time(\x27插入排序耗时：\x27);\n        for (var i = 1; i \x3c array.length; i\x2b\x2b) {\n            var key = array[i];\n            var j = i - 1;\n            while (j \x3e= 0 \x26amp;\x26amp; array[j] \x3e key) {\n                array[j \x2b 1] = array[j];\n                j--;\n            }\n            array[j \x2b 1] = key;\n        }\n        console.timeEnd(\x27插入排序耗时：\x27);\n        return array;\n    } else {\n        return \x27array is not an Array!\x27;\n    }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3efunction insertionSort(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Object.prototype.toString.call(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e).slice(\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, -\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) === \x27Array\x27) {\n        console.\x3cspan class=\x22hljs-built_in\x22\x3etime\x3c\/span\x3e(\x27插入排序耗时：\x27);\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; i\x2b\x2b) {\n            \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i];\n            \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e j = i - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (j \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j] \x26gt; \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n                \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j];\n                j--;\n            }\n            \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e;\n        }\n        console.timeEnd(\x27插入排序耗时：\x27);\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x27\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enot\x3c\/span\x3e an Array!\x27;\n    }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e改进插入排序：\x3c\/strong\x3e 查找插入位置时使用二分查找的方式\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function binaryInsertionSort(array) {\n    if (Object.prototype.toString.call(array).slice(8, -1) === \x27Array\x27) {\n        console.time(\x27二分插入排序耗时：\x27);\n\n        for (var i = 1; i \x3c array.length; i\x2b\x2b) {\n            var key = array[i], left = 0, right = i - 1;\n            while (left \x3c= right) {\n                var middle = parseInt((left \x2b right) \/ 2);\n                if (key \x3c array[middle]) {\n                    right = middle - 1;\n                } else {\n                    left = middle \x2b 1;\n                }\n            }\n            for (var j = i - 1; j \x3e= left; j--) {\n                array[j \x2b 1] = array[j];\n            }\n            array[left] = key;\n        }\n        console.timeEnd(\x27二分插入排序耗时：\x27);\n\n        return array;\n    } else {\n        return \x27array is not an Array!\x27;\n    }\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(binaryInsertionSort(arr));\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3efunction binaryInsertionSort(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Object.prototype.toString.call(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e).slice(\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, -\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) === \x27Array\x27) {\n        console.\x3cspan class=\x22hljs-built_in\x22\x3etime\x3c\/span\x3e(\x27二分插入排序耗时：\x27);\n\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; i\x2b\x2b) {\n            \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i], left = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, right = i - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (left \x26lt;= right) {\n                \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e middle = parseInt((left \x2b right) \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[middle]) {\n                    right = middle - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n                } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                    left = middle \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n                }\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e j = i - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; j \x26gt;= left; j--) {\n                \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j];\n            }\n            \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[left] = \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e;\n        }\n        console.timeEnd(\x27二分插入排序耗时：\x27);\n\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x27\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enot\x3c\/span\x3e an Array!\x27;\n    }\n}\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e arr=[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(binaryInsertionSort(arr));\/\/[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e]\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e改进前后对比：\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921378?w=535\x26amp;h=320\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921378?w=535\x26amp;h=320\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e插入排序动图演示:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921379?w=811\x26amp;h=505\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921379?w=811\x26amp;h=505\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e(3)算法分析\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e最佳情况：输入数组按升序排列。T(n) = O(n)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最坏情况：输入数组按降序排列。T(n) = O(n2)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e平均情况：T(n) = O(n2)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e4.希尔排序（Shell Sort）\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e1959年Shell发明；\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e第一个突破O(n^2)的排序算法；是简单插入排序的改进版；它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序\x3c\/p\x3e\n\x3ch4\x3e(1)算法简介\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第4版》的合著者Robert Sedgewick提出的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3e先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;. 选择一个增量序列t1，t2，…，tk，其中ti\x26gt;tj，tk=1；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;.按增量序列个数k，对序列进行k 趟排序；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;.每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavascript代码实现：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    console.time(\x27希尔排序耗时:\x27);\n    while(gap \x3c len\/5) {          \/\/动态定义间隔序列\n        gap =gap*5\x2b1;\n    }\n    for (gap; gap \x3e 0; gap = Math.floor(gap\/5)) {\n        for (var i = gap; i \x3c len; i\x2b\x2b) {\n            temp = arr[i];\n            for (var j = i-gap; j \x3e= 0 \x26amp;\x26amp; arr[j] \x3e temp; j-=gap) {\n                arr[j\x2bgap] = arr[j];\n            }\n            arr[j\x2bgap] = temp;\n        }\n    }\n    console.timeEnd(\x27希尔排序耗时:\x27);\n    return arr;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(shellSort(arr));\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshellSort\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = arr.length,\n        temp,\n        gap = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.time(\x3cspan class=\x22hljs-string\x22\x3e\x27希尔排序耗时:\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(gap \x26lt; len\/\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e) {          \x3cspan class=\x22hljs-comment\x22\x3e\/\/动态定义间隔序列\x3c\/span\x3e\n        gap =gap*\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (gap; gap \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; gap = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.floor(gap\/\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = gap; i \x26lt; len; i\x2b\x2b) {\n            temp = arr[i];\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j = i-gap; j \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; arr[j] \x26gt; temp; j-=gap) {\n                arr[j\x2bgap] = arr[j];\n            }\n            arr[j\x2bgap] = temp;\n        }\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x27希尔排序耗时:\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr=[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(shellSort(arr));\x3cspan class=\x22hljs-comment\x22\x3e\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e希尔排序图示（图片来源网络）：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921380?w=480\x26amp;h=469\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921380?w=480\x26amp;h=469\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e（3）算法分析\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e最佳情况：T(n) = O(nlog2 n)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最坏情况：T(n) = O(nlog2 n)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e平均情况：T(n) =O(nlog n)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e5.归并排序（Merge Sort）\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(1)算法简介\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e　归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3e具体算法描述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;.把长度为n的输入序列分成两个长度为n\/2的子序列；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;.对这两个子序列分别采用归并排序；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;.将两个排序好的子序列合并成一个最终的排序序列。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavscript代码实现:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function mergeSort(arr) {  \/\/采用自上而下的递归方法\n    var len = arr.length;\n    if(len \x3c 2) {\n        return arr;\n    }\n    var middle = Math.floor(len \/ 2),\n        left = arr.slice(0, middle),\n        right = arr.slice(middle);\n    return merge(mergeSort(left), mergeSort(right));\n}\n\nfunction merge(left, right)\n{\n    var result = [];\n    console.time(\x27归并排序耗时\x27);\n    while (left.length \x26amp;\x26amp; right.length) {\n        if (left[0] \x3c= right[0]) {\n            result.push(left.shift());\n        } else {\n            result.push(right.shift());\n        }\n    }\n\n    while (left.length)\n        result.push(left.shift());\n\n    while (right.length)\n        result.push(right.shift());\n    console.timeEnd(\x27归并排序耗时\x27);\n    return result;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(mergeSort(arr));\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs swift\x22\x3e\x3ccode\x3efunction mergeSort(arr) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/采用自上而下的递归方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = arr.length;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(len \x26lt; \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e middle = \x3cspan class=\x22hljs-type\x22\x3eMath\x3c\/span\x3e.floor(len \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e),\n        \x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e = arr.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, middle),\n        \x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e = arr.slice(middle);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e merge(mergeSort(\x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e), mergeSort(\x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e));\n}\n\nfunction merge(\x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e)\n{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [];\n    console.time(\x27归并排序耗时\x27);\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e.length \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e.length) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] \x26lt;= \x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]) {\n            result.push(\x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e.shift());\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            result.push(\x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e.shift());\n        }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e.length)\n        result.push(\x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e.shift());\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e.length)\n        result.push(\x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e.shift());\n    console.timeEnd(\x27归并排序耗时\x27);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr=[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\nconsole.log(mergeSort(arr));\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e归并排序动图演示:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921381?w=811\x26amp;h=505\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921381?w=811\x26amp;h=505\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e(3)算法分析\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e最佳情况：T(n) = O(n)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最差情况：T(n) = O(nlogn)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e平均情况：T(n) = O(nlogn)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e6.快速排序（Quick Sort）\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(1)算法简介\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3e快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;.从数列中挑出一个元素，称为 \x22基准\x22（pivot）；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;.重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;.递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavascript代码实现：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*方法说明：快速排序\n@param  array 待排序数组*\/\n\/\/方法一\nfunction quickSort(array, left, right) {\n    console.time(\x271.快速排序耗时\x27);\n    if (Object.prototype.toString.call(array).slice(8, -1) === \x27Array\x27 \x26amp;\x26amp; typeof left === \x27number\x27 \x26amp;\x26amp; typeof right === \x27number\x27) {\n        if (left \x3c right) {\n            var x = array[right], i = left - 1, temp;\n            for (var j = left; j \x3c= right; j\x2b\x2b) {\n                if (array[j] \x3c= x) {\n                    i\x2b\x2b;\n                    temp = array[i];\n                    array[i] = array[j];\n                    array[j] = temp;\n                }\n            }\n            quickSort(array, left, i - 1);\n            quickSort(array, i \x2b 1, right);\n        }\n        console.timeEnd(\x271.快速排序耗时\x27);\n        return array;\n    } else {\n        return \x27array is not an Array or left or right is not a number!\x27;\n    }\n}\n\n\/\/方法二\nvar quickSort2 = function(arr) {\n    console.time(\x272.快速排序耗时\x27);\n　　if (arr.length \x3c= 1) { return arr; }\n　　var pivotIndex = Math.floor(arr.length \/ 2);\n　　var pivot = arr.splice(pivotIndex, 1)[0];\n　　var left = [];\n　　var right = [];\n　　for (var i = 0; i \x3c arr.length; i\x2b\x2b){\n　　　　if (arr[i] \x3c pivot) {\n　　　　　　left.push(arr[i]);\n　　　　} else {\n　　　　　　right.push(arr[i]);\n　　　　}\n　　}\nconsole.timeEnd(\x272.快速排序耗时\x27);\n　　return quickSort2(left).concat([pivot], quickSort2(right));\n};\n\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(quickSort(arr,0,arr.length-1));\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\nconsole.log(quickSort2(arr));\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*方法说明：快速排序\n@param  array 待排序数组*\/\x3c\/span\x3e\n\/\/方法一\nfunction quickSort(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, left, right) {\n    console.\x3cspan class=\x22hljs-built_in\x22\x3etime\x3c\/span\x3e(\x27\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e.快速排序耗时\x27);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Object.prototype.toString.call(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e).slice(\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, -\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) === \x27Array\x27 \x26amp;\x26amp; typeof left === \x27number\x27 \x26amp;\x26amp; typeof right === \x27number\x27) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (left \x26lt; right) {\n            \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e x = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[right], i = left - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, temp;\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e j = left; j \x26lt;= right; j\x2b\x2b) {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j] \x26lt;= x) {\n                    i\x2b\x2b;\n                    temp = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i];\n                    \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i] = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j];\n                    \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j] = temp;\n                }\n            }\n            quickSort(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, left, i - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n            quickSort(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, right);\n        }\n        console.timeEnd(\x27\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e.快速排序耗时\x27);\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x27\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enot\x3c\/span\x3e an Array \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e left \x3cspan class=\x22hljs-keyword\x22\x3eor\x3c\/span\x3e right \x3cspan class=\x22hljs-built_in\x22\x3eis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enot\x3c\/span\x3e a number!\x27;\n    }\n}\n\n\/\/方法二\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e quickSort2 = function(arr) {\n    console.\x3cspan class=\x22hljs-built_in\x22\x3etime\x3c\/span\x3e(\x27\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e.快速排序耗时\x27);\n　　\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (arr.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) { \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e arr; }\n　　\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e pivotIndex = Math.\x3cspan class=\x22hljs-built_in\x22\x3efloor\x3c\/span\x3e(arr.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n　　\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e pivot = arr.\x3cspan class=\x22hljs-built_in\x22\x3esplice\x3c\/span\x3e(pivotIndex, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n　　\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e left = [];\n　　\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e right = [];\n　　\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; arr.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; i\x2b\x2b){\n　　　　\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (arr[i] \x26lt; pivot) {\n　　　　　　left.\x3cspan class=\x22hljs-built_in\x22\x3epush\x3c\/span\x3e(arr[i]);\n　　　　} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n　　　　　　right.\x3cspan class=\x22hljs-built_in\x22\x3epush\x3c\/span\x3e(arr[i]);\n　　　　}\n　　}\nconsole.timeEnd(\x27\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e.快速排序耗时\x27);\n　　\x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e quickSort2(left).\x3cspan class=\x22hljs-built_in\x22\x3econcat\x3c\/span\x3e([pivot], quickSort2(right));\n};\n\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e arr=[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(quickSort(arr,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,arr.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e-\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e));\/\/[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e]\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(quickSort2(arr));\/\/[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e]\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e快速排序动图演示：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921382?w=811\x26amp;h=252\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921382?w=811\x26amp;h=252\x22 alt=\x22快速排序\x22 title=\x22快速排序\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e(3)算法分析\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e最佳情况：T(n) = O(nlogn)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最差情况：T(n) = O(n2)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e平均情况：T(n) = O(nlogn)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e7.堆排序（Heap Sort）\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e堆排序可以说是一种利用堆的概念来排序的选择排序。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(1)算法简介\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3e具体算法描述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;.将初始待排序关键字序列(R1,R2....Rn)构建成大顶堆，此堆为初始的无序区；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;.将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,......Rn-1)和新的有序区(Rn),且满足R[1,2...n-1]\x26lt;=R[n]；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;.由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,......Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2....Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavascript代码实现：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*方法说明：堆排序\n@param  array 待排序数组*\/\nfunction heapSort(array) {\n    console.time(\x27堆排序耗时\x27);\n    if (Object.prototype.toString.call(array).slice(8, -1) === \x27Array\x27) {\n        \/\/建堆\n        var heapSize = array.length, temp;\n        for (var i = Math.floor(heapSize \/ 2) - 1; i \x3e= 0; i--) {\n            heapify(array, i, heapSize);\n        }\n\n        \/\/堆排序\n        for (var j = heapSize - 1; j \x3e= 1; j--) {\n            temp = array[0];\n            array[0] = array[j];\n            array[j] = temp;\n            heapify(array, 0, --heapSize);\n        }\n        console.timeEnd(\x27堆排序耗时\x27);\n        return array;\n    } else {\n        return \x27array is not an Array!\x27;\n    }\n}\n\/*方法说明：维护堆的性质\n@param  arr 数组\n@param  x   数组下标\n@param  len 堆大小*\/\nfunction heapify(arr, x, len) {\n    if (Object.prototype.toString.call(arr).slice(8, -1) === \x27Array\x27 \x26amp;\x26amp; typeof x === \x27number\x27) {\n        var l = 2 * x \x2b 1, r = 2 * x \x2b 2, largest = x, temp;\n        if (l \x3c len \x26amp;\x26amp; arr[l] \x3e arr[largest]) {\n            largest = l;\n        }\n        if (r \x3c len \x26amp;\x26amp; arr[r] \x3e arr[largest]) {\n            largest = r;\n        }\n        if (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } else {\n        return \x27arr is not an Array or x is not a number!\x27;\n    }\n}\nvar arr=[91,60,96,13,35,65,46,65,10,30,20,31,77,81,22];\nconsole.log(heapSort(arr));\/\/[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*方法说明：堆排序\n\x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e  array 待排序数组*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eheapSort\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(array)\x3c\/span\x3e \x3c\/span\x3e{\n    console.time(\x3cspan class=\x22hljs-string\x22\x3e\x27堆排序耗时\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Object.prototype.toString.call(\x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e).slice(\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) === \x3cspan class=\x22hljs-string\x22\x3e\x27Array\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/建堆\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e heapSize = \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e.length, temp;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = Math.floor(heapSize \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i--) {\n            heapify(\x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e, i, heapSize);\n        }\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/堆排序\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j = heapSize - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; j \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; j--) {\n            temp = \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n            \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e[j];\n            \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e[j] = temp;\n            heapify(\x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, --heapSize);\n        }\n        console.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x27堆排序耗时\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3earray\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27array is not an Array!\x27\x3c\/span\x3e;\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/*方法说明：维护堆的性质\n\x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e  arr 数组\n\x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e  x   数组下标\n\x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e  len 堆大小*\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eheapify\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(arr, x, len)\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Object.prototype.toString.call(arr).slice(\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e) === \x3cspan class=\x22hljs-string\x22\x3e\x27Array\x27\x3c\/span\x3e \x26amp;\x26amp; typeof x === \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e l = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * x \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, r = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * x \x2b \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, largest = x, temp;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (l \x26lt; len \x26amp;\x26amp; arr[l] \x26gt; arr[largest]) {\n            largest = l;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (r \x26lt; len \x26amp;\x26amp; arr[r] \x26gt; arr[largest]) {\n            largest = r;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (largest != x) {\n            temp = arr[x];\n            arr[x] = arr[largest];\n            arr[largest] = temp;\n            heapify(arr, largest, len);\n        }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27arr is not an Array or x is not a number!\x27\x3c\/span\x3e;\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr=[\x3cspan class=\x22hljs-number\x22\x3e91\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e60\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e96\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e35\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e65\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e65\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e31\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e77\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e81\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e];\nconsole.log(heapSort(arr));\x3cspan class=\x22hljs-comment\x22\x3e\/\/[10, 13, 20, 22, 30, 31, 35, 46, 60, 65, 65, 77, 81, 91, 96]\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e堆排序动图演示：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921383?w=547\x26amp;h=364\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921383?w=547\x26amp;h=364\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e(3)算法分析\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e最佳情况：T(n) = O(nlogn)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最差情况：T(n) = O(nlogn)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e平均情况：T(n) = O(nlogn)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e8.计数排序（Counting Sort）\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。\x3c\/p\x3e\n\x3ch4\x3e(1)算法简介\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3e具体算法描述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;. 找出待排序的数组中最大和最小的元素；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;4\x26gt;. 反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavascript代码实现：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function countingSort(array) {\n    var len = array.length,\n        B = [],\n        C = [],\n        min = max = array[0];\n    console.time(\x27计数排序耗时\x27);\n    for (var i = 0; i \x3c len; i\x2b\x2b) {\n        min = min \x3c= array[i] ? min : array[i];\n        max = max \x3e= array[i] ? max : array[i];\n        C[array[i]] = C[array[i]] ? C[array[i]] \x2b 1 : 1;\n    }\n    for (var j = min; j \x3c max; j\x2b\x2b) {\n        C[j \x2b 1] = (C[j \x2b 1] || 0) \x2b (C[j] || 0);\n    }\n    for (var k = len - 1; k \x3e= 0; k--) {\n        B[C[array[k]] - 1] = array[k];\n        C[array[k]]--;\n    }\n    console.timeEnd(\x27计数排序耗时\x27);\n    return B;\n}\nvar arr = [2, 2, 3, 8, 7, 1, 2, 2, 2, 7, 3, 9, 8, 2, 1, 4, 2, 4, 6, 9, 2];\nconsole.log(countingSort(arr)); \/\/[1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4, 6, 7, 7, 8, 8, 9, 9]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3efunction countingSort(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e len = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e,\n        B = [],\n        C = [],\n        \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n    console.\x3cspan class=\x22hljs-built_in\x22\x3etime\x3c\/span\x3e(\x27计数排序耗时\x27);\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; len; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e \x26lt;= \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i] ? \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e : \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i];\n        \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e \x26gt;= \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i] ? \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e : \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i];\n        C[\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i]] = C[\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i]] ? C[\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i]] \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e j = \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e; j \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e; j\x2b\x2b) {\n        C[j \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = (C[j \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] || \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x2b (C[j] || \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e k = len - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; k \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; k--) {\n        B[C[\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[k]] - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[k];\n        C[\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[k]]--;\n    }\n    console.timeEnd(\x27计数排序耗时\x27);\n    \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e B;\n}\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e];\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(countingSort(arr)); \/\/[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eJavaScript动图演示：\x3c\/strong\x3e、\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921384?w=1012\x26amp;h=557\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921384?w=1012\x26amp;h=557\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e(3)算法分析\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n \x2b k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e最佳情况：T(n) = O(n\x2bk)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最差情况：T(n) = O(n\x2bk)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e平均情况：T(n) = O(n\x2bk)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e9.桶排序（Bucket Sort）\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(1)算法简介\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3e具体算法描述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;.设置一个定量的数组当作空桶；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;.遍历输入数据，并且把数据一个一个放到对应的桶里去；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;.对每个不是空的桶进行排序；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;4\x26gt;.从不是空的桶里把排好序的数据拼接起来。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavascript代码实现:\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*方法说明：桶排序\n@param  array 数组\n@param  num   桶的数量*\/\nfunction bucketSort(array, num) {\n    if (array.length \x3c= 1) {\n        return array;\n    }\n    var len = array.length, buckets = [], result = [], min = max = array[0], regex = \x27\/^[1-9]\x2b[0-9]*$\/\x27, space, n = 0;\n    num = num || ((num \x3e 1 \x26amp;\x26amp; regex.test(num)) ? num : 10);\n    console.time(\x27桶排序耗时\x27);\n    for (var i = 1; i \x3c len; i\x2b\x2b) {\n        min = min \x3c= array[i] ? min : array[i];\n        max = max \x3e= array[i] ? max : array[i];\n    }\n    space = (max - min \x2b 1) \/ num;\n    for (var j = 0; j \x3c len; j\x2b\x2b) {\n        var index = Math.floor((array[j] - min) \/ space);\n        if (buckets[index]) {   \/\/  非空桶，插入排序\n            var k = buckets[index].length - 1;\n            while (k \x3e= 0 \x26amp;\x26amp; buckets[index][k] \x3e array[j]) {\n                buckets[index][k \x2b 1] = buckets[index][k];\n                k--;\n            }\n            buckets[index][k \x2b 1] = array[j];\n        } else {    \/\/空桶，初始化\n            buckets[index] = [];\n            buckets[index].push(array[j]);\n        }\n    }\n    while (n \x3c num) {\n        result = result.concat(buckets[n]);\n        n\x2b\x2b;\n    }\n    console.timeEnd(\x27桶排序耗时\x27);\n    return result;\n}\nvar arr=[3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];\nconsole.log(bucketSort(arr,4));\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*方法说明：桶排序\n@param  array 数组\n@param  num   桶的数量*\/\x3c\/span\x3e\nfunction bucketSort(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e len = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e, buckets = [], result = [], \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e], regex = \x27\/^[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e-\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e]\x2b[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e-\x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e]*$\/\x27, \x3cspan class=\x22hljs-built_in\x22\x3espace\x3c\/span\x3e, n = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e || ((\x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e \x26gt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x26amp;\x26amp; regex.test(\x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e)) ? \x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e);\n    console.\x3cspan class=\x22hljs-built_in\x22\x3etime\x3c\/span\x3e(\x27桶排序耗时\x27);\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; len; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e \x26lt;= \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i] ? \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e : \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i];\n        \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e \x26gt;= \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i] ? \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e : \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[i];\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3espace\x3c\/span\x3e = (\x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e - \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) \/ \x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; len; j\x2b\x2b) {\n        \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e index = Math.\x3cspan class=\x22hljs-built_in\x22\x3efloor\x3c\/span\x3e((\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j] - \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e) \/ \x3cspan class=\x22hljs-built_in\x22\x3espace\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (buckets[index]) {   \/\/  非空桶，插入排序\n            \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e k = buckets[index].\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (k \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x26amp;\x26amp; buckets[index][k] \x26gt; \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j]) {\n                buckets[index][k \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = buckets[index][k];\n                k--;\n            }\n            buckets[index][k \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = \x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j];\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {    \/\/空桶，初始化\n            buckets[index] = [];\n            buckets[index].\x3cspan class=\x22hljs-built_in\x22\x3epush\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3earray\x3c\/span\x3e[j]);\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (n \x26lt; \x3cspan class=\x22hljs-built_in\x22\x3enum\x3c\/span\x3e) {\n        result = result.\x3cspan class=\x22hljs-built_in\x22\x3econcat\x3c\/span\x3e(buckets[n]);\n        n\x2b\x2b;\n    }\n    console.timeEnd(\x27桶排序耗时\x27);\n    \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e result;\n}\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e arr=[\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(bucketSort(arr,\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e));\/\/[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e]\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e桶排序图示（图片来源网络）：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921385?w=435\x26amp;h=298\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921385?w=435\x26amp;h=298\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e关于桶排序\x3ca href=\x22http:\/\/www.cnblogs.com\/lonelyxmas\/p\/3561938.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e更多\x3c\/a\x3e\x3c\/p\x3e\n\x3ch4\x3e(3)算法分析\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e　桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e最佳情况：T(n) = O(n\x2bk)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最差情况：T(n) = O(n\x2bk)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e平均情况：T(n) = O(n2)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e10.基数排序（Radix Sort）\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(1)算法简介\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e(2)算法描述和实现\x3c\/h4\x3e\n\x3cp\x3e具体算法描述如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;1\x26gt;.取得数组中的最大数，并取得位数；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;2\x26gt;.arr为原始数组，从最低位开始取每个位组成radix数组；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x26lt;3\x26gt;.对radix进行计数排序（利用计数排序适用于小范围数的特点）；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3eJavascript代码实现：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 基数排序适用于：\n *  (1)数据范围较小，建议在小于1000\n *  (2)每个数值都要大于等于0\n * @author xiazdong\n * @param  arr 待排序数组\n * @param  maxDigit 最大位数\n *\/\n\/\/LSD Radix Sort\n\nfunction radixSort(arr, maxDigit) {\n    var mod = 10;\n    var dev = 1;\n    var counter = [];\n    console.time(\x27基数排序耗时\x27);\n    for (var i = 0; i \x3c maxDigit; i\x2b\x2b, dev *= 10, mod *= 10) {\n        for(var j = 0; j \x3c arr.length; j\x2b\x2b) {\n            var bucket = parseInt((arr[j] % mod) \/ dev);\n            if(counter[bucket]== null) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        var pos = 0;\n        for(var j = 0; j \x3c counter.length; j\x2b\x2b) {\n            var value = null;\n            if(counter[j]!=null) {\n                while ((value = counter[j].shift()) != null) {\n                      arr[pos\x2b\x2b] = value;\n                }\n          }\n        }\n    }\n    console.timeEnd(\x27基数排序耗时\x27);\n    return arr;\n}\nvar arr = [3, 44, 38, 5, 47, 15, 36, 26, 27, 2, 46, 4, 19, 50, 48];\nconsole.log(radixSort(arr,2)); \/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 基数排序适用于：\n *  (1)数据范围较小，建议在小于1000\n *  (2)每个数值都要大于等于0\n * @author xiazdong\n * @param  arr 待排序数组\n * @param  maxDigit 最大位数\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/LSD Radix Sort\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eradixSort\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3earr, maxDigit\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mod = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dev = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = [];\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.time(\x3cspan class=\x22hljs-string\x22\x3e\x27基数排序耗时\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; maxDigit; i\x2b\x2b, dev *= \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e, mod *= \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; arr.length; j\x2b\x2b) {\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bucket = \x3cspan class=\x22hljs-built_in\x22\x3eparseInt\x3c\/span\x3e((arr[j] % mod) \/ dev);\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(counter[bucket]== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n                counter[bucket] = [];\n            }\n            counter[bucket].push(arr[j]);\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e pos = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j \x26lt; counter.length; j\x2b\x2b) {\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(counter[j]!=\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e ((value = counter[j].shift()) != \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n                      arr[pos\x2b\x2b] = value;\n                }\n          }\n        }\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x27基数排序耗时\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e44\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e38\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e47\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e36\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e46\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e19\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e48\x3c\/span\x3e];\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(radixSort(arr,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/[2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50]\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e基数排序LSD动图演示：\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000006921386?w=1012\x26amp;h=574\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000006921386?w=1012\x26amp;h=574\x22 alt=\x22这里写图片描述\x22 title=\x22这里写图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e(3)算法分析\x3c\/h4\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e最佳情况：T(n) = O(n * k)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e最差情况：T(n) = O(n * k)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e平均情况：T(n) = O(n * k)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e基数排序有两种方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eMSD 从高位开始进行排序\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eLSD 从低位开始进行排序\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e基数排序 vs 计数排序 vs 桶排序\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e基数排序：根据键值的每位数字来分配桶\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e计数排序：每个桶只存储单一键值\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e桶排序：每个桶存储一定范围的数值\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e后记\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e十大排序算法的总结到这里就算告一段落了。博主总结完之后只有一个感觉，排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法更值得我们推敲。站在十大算法的门前心里还是诚惶诚恐的，身为一个小学生，博主的总结难免会有所疏漏，欢迎各位批评指定。\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>十大经典排序算法总结(Javascript描述)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006921369">https://segmentfault.com/a/1190000006921369</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9jsfpnutsx9/" target="_blank">https://alili.tech/archive/9jsfpnutsx9/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/sj57jxyoook/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（上）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/qsw902j95k/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（下）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/nnpmjlot58j/">IndexedDB使用与出坑指南<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/alvlbas9oai/">JS事件模型<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/u0pzym8k36o/">JS练习实例--编写经典小游戏俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/khwpyk5yz8q/">JavaScript 事件代理和委托<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/kuocl6lc3n/">JavaScript 版俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/n8bk54lyrf/">Promise学习:基础入门<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/7bk7u30qncb/">Redux 入坑进阶 - 源码解析<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/853kqfmqmf7/">Snap.svg 基本知识入门<aside class="dates">2019-02-03</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>