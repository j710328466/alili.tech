<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React系列——antd组件开发思路——alert分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React系列——antd组件开发思路——alert分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/u1071t0ddqf/",
				"appid": "1613049289050283", 
				"title": "React系列——antd组件开发思路——alert分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qd89oacc06/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/efgdmbjqz7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f&text=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94antd%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af%e2%80%94%e2%80%94alert%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f&text=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94antd%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af%e2%80%94%e2%80%94alert%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94antd%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af%e2%80%94%e2%80%94alert%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f&is_video=false&description=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94antd%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af%e2%80%94%e2%80%94alert%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94antd%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af%e2%80%94%e2%80%94alert%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94antd%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af%e2%80%94%e2%80%94alert%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94antd%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af%e2%80%94%e2%80%94alert%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94antd%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af%e2%80%94%e2%80%94alert%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fu1071t0ddqf%2f&title=React%e7%b3%bb%e5%88%97%e2%80%94%e2%80%94antd%e7%bb%84%e4%bb%b6%e5%bc%80%e5%8f%91%e6%80%9d%e8%b7%af%e2%80%94%e2%80%94alert%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React系列——antd组件开发思路——alert分析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-29" itemprop="datePublished">2019-01-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e先附上antd源码地址：\x3ca href=\x22https:\/\/github.com\/ant-design\/ant-design\/tree\/master\/components\/alert\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3c\/a\x3e\x3ca href=\x22https:\/\/github.com\/ant-design\/ant-design\/tree\/master\/components\/alert\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/ant-design...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e昨天写了一篇分析antd之button组件的分析，今晚继续讲antd组件篇，这篇文章主要介绍的是alert实现原理，以及我们可以从antd的组件思想中学习到的react组件开发知识。\x3cbr\x3eps：antd用的是typescript，如果是纯ES写法稍微有些不同。\x3c\/p\x3e\n\x3cp\x3e下面这张图是alert组件的主要结构图。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHksO?w=1408\x26amp;h=664\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHksO?w=1408\x26amp;h=664\x22 alt=\x22alert\x22 title=\x22alert\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e有这么几个部分：\x3cbr\x3e1、demo：alert组件的使用方法\x3cbr\x3e2、style：组件内部可能用到的初始化样式\x3cbr\x3e3、2个.md说明文档，一个是英文版，一个是中文版\x3cbr\x3e4、index.tsx：alert组件（关于这个组件，我是有话要说的，这个命名应该用alert，然后index通常是用来导出alert组件，antd每个组件都不是同一个人写的，估计写alert组件的人也没考虑那么多。）\x3c\/p\x3e\n\x3cp\x3e大概知道了alert项目文件的构成之后，如何去分析组件怎样实现的呢？\x3cbr\x3e先别看代码，看一下?提供的中文文档。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHks8?w=1964\x26amp;h=1434\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHks8?w=1964\x26amp;h=1434\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e主要看API部分，这些api就是组件内部需要定义的接口，一共有8个参数，包括类型、事件等可能需要用到的功能。假设你们公司也打算用react来封装自己的组件，首先要考虑的是制定这样一份API方案，确定需要实现的功能以及保留的功能。\x3c\/p\x3e\n\x3cp\x3e看完文档之后，对alert组件的数据模型有了一个大概的了解，那么接下来就要看看代码是如何实现的。\x3cbr\x3ereact组件其实就是一个JSX语法组成的模板，给dom绑定事件，从外部传入需要的参数等。\x3c\/p\x3e\n\x3cp\x3e下面这个是index.tsx的源码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27; \/\/react都认识了\nimport ReactDOM from \x27react-dom\x27; \/\/用来获取当前的dom节点，这里只有这一个用途\nimport Animate from \x27rc-animate\x27; \/\/动画组件，好吧，原来antd的组件内部是这么不纯净，导入这么多额外的插件，难怪有人觉得antd太庞大了。\nimport Icon from \x27..\/icon\x27; \/\/icon又出现了，这小子几乎在好几个antd组件都会用到\nimport classNames from \x27classnames\x27; \/\/定义样式对象\n\n\/\/构造函数，干啥的呢，现在还不知道，往下看吧。\nfunction noop() {}\n\n\/\/这些就是可以调用的API\nexport interface AlertProps {\n  \/**\n   * Type of Alert styles, options:`success`, `info`, `warning`, `error`\n   *\/\n  type?: \x27success\x27 | \x27info\x27 | \x27warning\x27 | \x27error\x27;\n  \/** Whether Alert can be closed *\/\n  closable?: boolean;\n  \/** Close text to show *\/\n  closeText?: React.ReactNode;\n  \/** Content of Alert *\/\n  message: React.ReactNode;\n  \/** Additional content of Alert *\/\n  description?: React.ReactNode;\n  \/** Callback when close Alert *\/\n  onClose?: React.MouseEventHandler\x3cany\x3e;\n  \/** Whether to show icon *\/\n  showIcon?: boolean;\n  style?: React.CSSProperties;\n  prefixCls?: string;\n  className?: string;\n  banner?: boolean;\n}\n\n\/\/组件的入口在这里，一个继承于React.Component的Alert子类。\nexport default class Alert extends React.Component\x3cAlertProps, any\x3e {\n\/\/defaultProps是react组件的一个参数\n  static defaultProps = {\n    type: \x27info\x27,\n  };\n\/\/从类的思想来看，constructor是子类Alert的构造函数，这个组件和button组件的写法有所不同，可能是出自2个工程师之手，我们可以看到在构造函数里面初始化了state的2个参数closing、closed。\n  constructor(props) {\n    super(props);\n    this.state = {\n      closing: true,\n      closed: false,\n    };\n  }\n\/\/组件内部的点击关闭事件\n  handleClose = (e) =\x3e {\n    e.preventDefault();\n    let dom = ReactDOM.findDOMNode(this) as HTMLElement;\n    dom.style.height = `${dom.offsetHeight}px`;\n    \/\/ Magic code\n    \/\/ 重复一次后才能正确设置 height\n    dom.style.height = `${dom.offsetHeight}px`;\n    \n    \/\/设置完高度之后通过setState来更新状态，关闭alert。\n    this.setState({\n      closing: false,\n    });\n    \/\/关闭时触发的回调函数，onClose可以在外部定义，至于noop，在这个组件并没有实现任何功能。\n    (this.props.onClose || noop)(e);\n  }\n\/\/动画结束时触发的回调函数，是动画插件提供的功能，不能算作本组件自己定义的函数。该回调只做了一件事，更新state。\n  animationEnd = () =\x3e {\n    this.setState({\n      closed: true,\n      closing: true,\n    });\n  }\n\/\/终于到了render方法了，每个react组件都有一个render方法，然后必然又一个return dom。\n  render() {\n\/\/从外部传入的参数，通过this.props传入，一般用const来定义，这里用let不太合适，但不是个错误。\n    let {\n      closable, description, type, prefixCls = \x27ant-alert\x27, message, closeText, showIcon, banner,\n      className = \x27\x27, style,\n    } = this.props;\n\n    \/\/ banner模式默认有 Icon，如果传入了showIcon，就显示showIcon，否则显示banner，那要是banner也没有传入呢，那就啥都不显示了。\n    showIcon = showIcon || banner;\n    \/\/ banner模式默认为警告，想要使用其他类型success、info、error，就不要传入banner，然后传入type即可。\n    type = banner ? \x27warning\x27 : type;\n    \n    \/\/根据传入的type类型来判断icon要显示那种类型样式。注意，icon也是一个小组件。\n    let iconType = \x27\x27;\n    switch (type) {\n      case \x27success\x27:\n        iconType = \x27check-circle\x27;\n        break;\n      case \x27info\x27:\n        iconType = \x27info-circle\x27;\n        break;\n      case \x27error\x27:\n        iconType = \x27cross-circle\x27;\n        break;\n      case \x27warning\x27:\n        iconType = \x27exclamation-circle\x27;\n        break;\n      default:\n        iconType = \x27default\x27;\n    }\n\n    \/\/ use outline icon in alert with description\n    if (!!description) {\n      iconType \x2b= \x27-o\x27;\n    }\n    \/\/classNames用法很简单，冒号左边是类名，右边是bool，true就显示当前样式，false就不显示当前样式，而close、description、icon、banner的样式通过外部是否传入参数或者state的状态来判断，type的样式就默认显示。\n    let alertCls = classNames(prefixCls, {\n      [`${prefixCls}-${type}`]: true,\n      [`${prefixCls}-close`]: !this.state.closing,\n      [`${prefixCls}-with-description`]: !!description,\n      [`${prefixCls}-no-icon`]: !showIcon,\n      [`${prefixCls}-banner`]: !!banner,\n    }, className);\n\n    \/\/ 当closeText传入为true时，将closable设置为true，我很好奇closable不也是一个可以外部传入的值吗，为什么还需要通过closeText来判断呢，感觉这3行代码有点不合理。\n    if (closeText) {\n      closable = true;\n    }\n    \/\/如果closable为true，则closeIcon等于a标签，否则等于空。\n    const closeIcon = closable ? (\n      \x3ca onClick={this.handleClose} className={`${prefixCls}-close-icon`}\x3e\n        {closeText || \x3cIcon type=\x26quot;cross\x26quot; \/\x3e}\n      \x3c\/a\x3e\n    ) : null;\n    \/\/如果closed是true，就return null，false则return下面的组件。\n    return this.state.closed ? null : (\n      \x3cAnimate\n        component=\x26quot;\x26quot;\n        showProp=\x26quot;data-show\x26quot;\n        transitionName={`${prefixCls}-slide-up`}\n        onEnd={this.animationEnd}\n      \x3e\n        \x3cdiv data-show={this.state.closing} className={alertCls} style={style}\x3e\n          {showIcon ? \x3cIcon className={`${prefixCls}-icon`} type={iconType} \/\x3e : null}\n          \x3cspan className={`${prefixCls}-message`}\x3e{message}\x3c\/span\x3e\n          \x3cspan className={`${prefixCls}-description`}\x3e{description}\x3c\/span\x3e\n          {closeIcon}\n        \x3c\/div\x3e\n      \x3c\/Animate\x3e\n    );\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/react都认识了\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/用来获取当前的dom节点，这里只有这一个用途\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Animate \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27rc-animate\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/动画组件，好吧，原来antd的组件内部是这么不纯净，导入这么多额外的插件，难怪有人觉得antd太庞大了。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Icon \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/icon\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/icon又出现了，这小子几乎在好几个antd组件都会用到\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e classNames \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27classnames\x27\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/定义样式对象\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/构造函数，干啥的呢，现在还不知道，往下看吧。\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enoop\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/这些就是可以调用的API\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e interface AlertProps {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/**\n   * Type of Alert styles, options:`success`, `info`, `warning`, `error`\n   *\/\x3c\/span\x3e\n  type?: \x3cspan class=\x22hljs-string\x22\x3e\x27success\x27\x3c\/span\x3e | \x3cspan class=\x22hljs-string\x22\x3e\x27info\x27\x3c\/span\x3e | \x3cspan class=\x22hljs-string\x22\x3e\x27warning\x27\x3c\/span\x3e | \x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/** Whether Alert can be closed *\/\x3c\/span\x3e\n  closable?: boolean;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/** Close text to show *\/\x3c\/span\x3e\n  closeText?: React.ReactNode;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/** Content of Alert *\/\x3c\/span\x3e\n  message: React.ReactNode;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/** Additional content of Alert *\/\x3c\/span\x3e\n  description?: React.ReactNode;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/** Callback when close Alert *\/\x3c\/span\x3e\n  onClose?: React.MouseEventHandler\x26lt;any\x26gt;;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/** Whether to show icon *\/\x3c\/span\x3e\n  showIcon?: boolean;\n  style?: React.CSSProperties;\n  prefixCls?: string;\n  className?: string;\n  banner?: boolean;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/组件的入口在这里，一个继承于React.Component的Alert子类。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAlert\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x26lt;\x3cspan class=\x22hljs-title\x22\x3eAlertProps\x3c\/span\x3e, \x3cspan class=\x22hljs-title\x22\x3eany\x3c\/span\x3e\x26gt; \x3c\/span\x3e{\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/defaultProps是react组件的一个参数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e defaultProps = {\n    \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27info\x27\x3c\/span\x3e,\n  };\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/从类的思想来看，constructor是子类Alert的构造函数，这个组件和button组件的写法有所不同，可能是出自2个工程师之手，我们可以看到在构造函数里面初始化了state的2个参数closing、closed。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\n      \x3cspan class=\x22hljs-attr\x22\x3eclosing\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eclosed\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    };\n  }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/组件内部的点击关闭事件\x3c\/span\x3e\n  handleClose = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    e.preventDefault();\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e dom = ReactDOM.findDOMNode(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e HTMLElement;\n    dom.style.height = \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${dom.offsetHeight}\x3c\/span\x3epx`\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Magic code\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重复一次后才能正确设置 height\x3c\/span\x3e\n    dom.style.height = \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${dom.offsetHeight}\x3c\/span\x3epx`\x3c\/span\x3e;\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/设置完高度之后通过setState来更新状态，关闭alert。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      \x3cspan class=\x22hljs-attr\x22\x3eclosing\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/关闭时触发的回调函数，onClose可以在外部定义，至于noop，在这个组件并没有实现任何功能。\x3c\/span\x3e\n    (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.onClose || noop)(e);\n  }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/动画结束时触发的回调函数，是动画插件提供的功能，不能算作本组件自己定义的函数。该回调只做了一件事，更新state。\x3c\/span\x3e\n  animationEnd = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      \x3cspan class=\x22hljs-attr\x22\x3eclosed\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      \x3cspan class=\x22hljs-attr\x22\x3eclosing\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    });\n  }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/终于到了render方法了，每个react组件都有一个render方法，然后必然又一个return dom。\x3c\/span\x3e\n  render() {\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/从外部传入的参数，通过this.props传入，一般用const来定义，这里用let不太合适，但不是个错误。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e {\n      closable, description, type, prefixCls = \x3cspan class=\x22hljs-string\x22\x3e\x27ant-alert\x27\x3c\/span\x3e, message, closeText, showIcon, banner,\n      className = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e, style,\n    } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ banner模式默认有 Icon，如果传入了showIcon，就显示showIcon，否则显示banner，那要是banner也没有传入呢，那就啥都不显示了。\x3c\/span\x3e\n    showIcon = showIcon || banner;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ banner模式默认为警告，想要使用其他类型success、info、error，就不要传入banner，然后传入type即可。\x3c\/span\x3e\n    type = banner ? \x3cspan class=\x22hljs-string\x22\x3e\x27warning\x27\x3c\/span\x3e : type;\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/根据传入的type类型来判断icon要显示那种类型样式。注意，icon也是一个小组件。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e iconType = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (type) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27success\x27\x3c\/span\x3e:\n        iconType = \x3cspan class=\x22hljs-string\x22\x3e\x27check-circle\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27info\x27\x3c\/span\x3e:\n        iconType = \x3cspan class=\x22hljs-string\x22\x3e\x27info-circle\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27error\x27\x3c\/span\x3e:\n        iconType = \x3cspan class=\x22hljs-string\x22\x3e\x27cross-circle\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27warning\x27\x3c\/span\x3e:\n        iconType = \x3cspan class=\x22hljs-string\x22\x3e\x27exclamation-circle\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n        iconType = \x3cspan class=\x22hljs-string\x22\x3e\x27default\x27\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ use outline icon in alert with description\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!!description) {\n      iconType \x2b= \x3cspan class=\x22hljs-string\x22\x3e\x27-o\x27\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/classNames用法很简单，冒号左边是类名，右边是bool，true就显示当前样式，false就不显示当前样式，而close、description、icon、banner的样式通过外部是否传入参数或者state的状态来判断，type的样式就默认显示。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e alertCls = classNames(prefixCls, {\n      [\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${prefixCls}\x3c\/span\x3e-\x3cspan class=\x22hljs-subst\x22\x3e${type}\x3c\/span\x3e`\x3c\/span\x3e]: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n      [\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${prefixCls}\x3c\/span\x3e-close`\x3c\/span\x3e]: !\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.closing,\n      [\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${prefixCls}\x3c\/span\x3e-with-description`\x3c\/span\x3e]: !!description,\n      [\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${prefixCls}\x3c\/span\x3e-no-icon`\x3c\/span\x3e]: !showIcon,\n      [\x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${prefixCls}\x3c\/span\x3e-banner`\x3c\/span\x3e]: !!banner,\n    }, className);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当closeText传入为true时，将closable设置为true，我很好奇closable不也是一个可以外部传入的值吗，为什么还需要通过closeText来判断呢，感觉这3行代码有点不合理。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (closeText) {\n      closable = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果closable为true，则closeIcon等于a标签，否则等于空。\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e closeIcon = closable ? (\n      \x26lt;a onClick={this.handleClose} className={`${prefixCls}-close-icon`}\x26gt;\n        {closeText || \x26lt;Icon type=\x22cross\x22 \/\x26gt;}\n      \x26lt;\/a\x26gt;\n    ) : null;\n    \/\/如果closed是true，就return null，false则return下面的组件。\n    return this.state.closed ? null : (\n      \x26lt;Animate\n        component=\x22\x22\n        showProp=\x22data-show\x22\n        transitionName={`${prefixCls}-slide-up`}\n        onEnd={this.animationEnd}\n      \x26gt;\n        \x26lt;div data-show={this.state.closing} className={alertCls} style={style}\x26gt;\n          {showIcon ? \x26lt;Icon className={`${prefixCls}-icon`} type={iconType} \/\x26gt; : null}\n          \x26lt;span className={`${prefixCls}-message`}\x26gt;{message}\x26lt;\/span\x26gt;\n          \x26lt;span className={`${prefixCls}-description`}\x26gt;{description}\x26lt;\/span\x26gt;\n          {closeIcon}\n        \x26lt;\/div\x26gt;\n      \x26lt;\/Animate\x26gt;\n    );\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根据alert组件的模型，我们可以总结出其他react组件的开发模式。\x3cbr\x3e1、写好API文档，这些API将作为组件的参数。\x3cbr\x3e2、写一个基本的react组件架构，比如import、export class、render()、constructor()、interface。\x3cbr\x3e3、接着就在render()方法里面写需要外部传入的参数，通过this.props来控制。\x3cbr\x3e4、在return里面写好你的dom结构，你还可能在render方法定义可变的样式，类似上面的alert组件。\x3cbr\x3e5、给dom绑定事件，然后在alert组件内部写这些事件的逻辑。\x3cbr\x3e6、写逻辑这部分是最难的，要花多点心思去组织你的代码。\x3c\/p\x3e\n\x3cp\x3e赶紧去自己尝试些一个类似的组件吧。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React系列——antd组件开发思路——alert分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007904615">https://segmentfault.com/a/1190000007904615</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/u1071t0ddqf/" target="_blank">https://alili.tech/archive/u1071t0ddqf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/dc9tmbt89lc/">CSS3 巧妙实现聊天气泡<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/awfhylei7vr/">Element 一套优雅的 Vue 2 组件库是如何开发的<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/5n6e7oj31zb/">Ionic2入坑基础教程和安装指南<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/k9uktrr2ck/">JavaScript arguments 对象全面介绍<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/d31ygsiurr7/">JavaScript 版俄罗斯方块——重构<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/f1goxj498pc/">JavaScript中this绑定详解<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/fpk9tyls8sb/">Markcook2.0，使用Vue2.0和Vuex2.0进行完全重构升级<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/rnj4z8l02t/">N3-components - 强劲的 Vue UI组件库<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/7njdijhy2um/">Node.js &#43; React Native 毕设：农业物联网监测系统的开发手记<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/f8zzbybr4tl/">Redux、Flux、Vuex<aside class="dates">2019-02-02</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>