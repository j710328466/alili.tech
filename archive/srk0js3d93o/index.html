<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 函数式编程到底是个啥"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 函数式编程到底是个啥 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/srk0js3d93o/",
				"appid": "1613049289050283", 
				"title": "JavaScript 函数式编程到底是个啥 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-11T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hpvs2alnsol/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dk6bw496hkf/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f&text=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%88%b0%e5%ba%95%e6%98%af%e4%b8%aa%e5%95%a5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f&text=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%88%b0%e5%ba%95%e6%98%af%e4%b8%aa%e5%95%a5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%88%b0%e5%ba%95%e6%98%af%e4%b8%aa%e5%95%a5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f&is_video=false&description=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%88%b0%e5%ba%95%e6%98%af%e4%b8%aa%e5%95%a5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%88%b0%e5%ba%95%e6%98%af%e4%b8%aa%e5%95%a5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%88%b0%e5%ba%95%e6%98%af%e4%b8%aa%e5%95%a5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%88%b0%e5%ba%95%e6%98%af%e4%b8%aa%e5%95%a5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%88%b0%e5%ba%95%e6%98%af%e4%b8%aa%e5%95%a5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fsrk0js3d93o%2f&title=JavaScript%20%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b%e5%88%b0%e5%ba%95%e6%98%af%e4%b8%aa%e5%95%a5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 函数式编程到底是个啥</h1><div class="meta"><div class="postdate"><time datetime="2019-01-11" itemprop="datePublished">2019-01-11</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e随着大前端时代的到来，在产品开发过程中，前端所占业务比重越来越大、交互越来越重。传统的老夫拿起JQuery就是一把梭应付当下重交互页面已经十分乏力。于是乎有了Angular，React，Vue这些现代框架。\x3c\/p\x3e\n\x3cp\x3e但随之而来的还有大量的新知识新名词，如MVC，MVVM，Flux这些设计模式就弄得很多同学傻傻分不清。这时候又见到别人讨论什么函数式编程，更是一脸懵逼了。\x3c\/p\x3e\n\x3cp\x3e我们大多听过面向对象编程，面向过程编程，那啥又是函数式编程呢？在我们前端开发中又有哪些应用场景？我抱着这个疑惑，初步的学习了下。\x3cem\x3e（此文仅是学习，无甚干货）。\x3c\/em\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e函数式编程\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e定义\x3c\/h3\x3e\n\x3cp\x3e函数式编程（Functional Programming，后面简称FP），维基百科的定义是：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e是一种编程范型，它将电脑运算视为数学上的函数计算，并且避免使用程序状态以及易变对象。函数编程语言最重要的基础是λ演算（lambda calculus）。而且λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。比起命令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e我来尝试理解下这个定义，好像就是说，在敲代码的时候，我要把过程逻辑写成函数，定义好输入参数，只关心它的输出结果。而且可以把函数作为输入输出。感觉好像平常写js时，就是这样的嘛！\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e特性\x3c\/h3\x3e\n\x3cp\x3e网上FP的定义与特性琳琅满目。各种百科、博客、一些老师的网站上都有大同小异的介绍。为了方便阅读，我列下几个好像比较重要的特性，并附上我的第一眼理解。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e函数是一等公民\x3c\/strong\x3e。就是说函数可以跟其他变量一样，可以作为其他函数的输入输出。喔，回调函数就是典型应用。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e不可变量\x3c\/strong\x3e。就是说，不能用var跟let咯。按这要求，我似乎有点难写代码。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e纯函数\x3c\/strong\x3e。就是没有副作用的函数。这个好理解，就是不修改函数外部的变量。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e引用透明\x3c\/strong\x3e。这个也好理解，就是说同样的输入，必定是同样的输出。函数内部不依赖外部状态，如一些全局变量。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e惰性计算\x3c\/strong\x3e。大意就是：一个表达式绑定的变量，不是声明的时候就计算出来，而是真正用到它的时候才去计算。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e还有一些衍生的特性，如柯里化与组合，三言两语说不清，就不阐述了，有兴趣的同学可以自己再了解了解。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eFP在JavaScript中的应用\x3c\/h2\x3e\n\x3cp\x3eReact就是典型的FP。它不同于Vue这样的MVVM框架，它仅仅是个View层。\x3cbr\x3e\x3ccode\x3eReactView = render(data)\x3c\/code\x3e 它只关心你的输入，最终给你返回相应视图。所以你休想在react组件中去修改父组件的状态，更没有与dom的双向绑定。\x3c\/p\x3e\n\x3cp\x3e这个是框架上的应用，那么在我们平常书写JavaScript时有哪些应用呢？换句话说，平常书写js时候，遇到什么情况，我们采用FP会更好。\x3c\/p\x3e\n\x3cp\x3e从最常见的入手吧，如典型的操作数组：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 从users中筛选出年龄大于15岁的人的名字\nconst users = [\n  {\n    age: 10,\n    name: \x27张三\x27,\n  }, {\n    age: 20,\n    name: \x27李四\x27\n  }, {\n    age: 30,\n    name: \x27王五\x27\n  }\n];\n\n\/\/ 过程式\nconst names = [];\nfor (let i = 0; i \x3c users.length; i\x2b\x2b)　{\n  if (users[i].age \x3e 15) {\n    names.push(users[i].name);\n  }\n}\n\/\/ 函数式\nconst names = users.filter(u =\x3e u.age \x3e 15).map(u =\x3e u.name);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从users中筛选出年龄大于15岁的人的名字\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e users = [\n  {\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27张三\x27\x3c\/span\x3e,\n  }, {\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27李四\x27\x3c\/span\x3e\n  }, {\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e30\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27王五\x27\x3c\/span\x3e\n  }\n];\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 过程式\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e names = [];\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; users.length; i\x2b\x2b)　{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (users[i].age \x26gt; \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e) {\n    names.push(users[i].name);\n  }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 函数式\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e names = users.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eu\x3c\/span\x3e =\x26gt;\x3c\/span\x3e u.age \x26gt; \x3cspan class=\x22hljs-number\x22\x3e15\x3c\/span\x3e).map(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eu\x3c\/span\x3e =\x26gt;\x3c\/span\x3e u.name);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e嗯，代码精简了很多，但是貌似带来了更大的开销。如果是非常大的数据，非常多的筛选工作，那就会循环多次。\x3c\/p\x3e\n\x3cp\x3e这里得想到刚刚的惰性计算。按照惰性求值的要求，应该是要最后返回结果时，才真正去筛选年纪并得到姓名数组。\x3c\/p\x3e\n\x3cp\x3e然而JavaScript的数组并不支持惰性求值。这时候我们得上一些工具库，如\x3ca href=\x22https:\/\/lodash.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eLodash\x3c\/a\x3e。可以看下它文档中的例子：\x3ca href=\x22https:\/\/lodash.com\/docs\/4.17.4#chain\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e_.chain\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e好像也没好到哪里去啊，不就是把多行代码变一行嘛？说的那么玄乎，还多了性能开销，然后又跟我说得上个工具库。。。\x3c\/p\x3e\n\x3cp\x3e说的好像很有道理，但是for循环是有个弊端的，它产生了变量i，而这个变量又是不可控的，如果业务逻辑一复杂，谁知道它循环到什么时候i有没有发生变化，然后导致循环出问题呢？\x3c\/p\x3e\n\x3cp\x3e我们再看一个与DOM交互的场景：\x3cbr\x3e假如页面有一个按钮\x3ccode\x3ebutton\x3c\/code\x3e，我们需要求出用户点击了几次，但是一秒钟内重复点击的不算。传统方法会这么写。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var count = 0;\nvar rate = 1000;\nvar lastClick = Date.now() - rate;\nvar button = document.querySelector(\x27button\x27);\nbutton.addEventListener(\x27click\x27, () =\x3e {\n  if (Date.now() - lastClick \x3e= rate) {\n    console.log(`Clicked ${\x2b\x2bcount} times`);\n    lastClick = Date.now();\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e count = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rate = \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e lastClick = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - rate;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e button = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27button\x27\x3c\/span\x3e);\nbutton.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, () =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now() - lastClick \x26gt;= rate) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`Clicked \x3cspan class=\x22hljs-subst\x22\x3e${\x2b\x2bcount}\x3c\/span\x3e times`\x3c\/span\x3e);\n    lastClick = \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e.now();\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e妥，完全没问题。但是发现多了很多状态，count，rate，lastClick，还得对比来对比去。那如果用FP会是怎么样的呢？\x3c\/p\x3e\n\x3cp\x3e抱歉。。。没法写。。。除非很强大的编程能力，自己封装好方法去处理。所以在这里，我们可以上个工具---\x3ca href=\x22http:\/\/reactivex.io\/rxjs\/manual\/overview.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRx.js\x3c\/a\x3e，上述的例子就是rxjs中引用的，我们看它是如何优雅地处理的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var button = document.querySelector(\x27button\x27);\nRx.Observable.fromEvent(button, \x27click\x27)\n  .throttleTime(1000) \/\/ 每隔1000毫秒才能触发事件\n  .scan(count =\x3e count \x2b 1, 0) \/\/ 求值，默认值是0\n  .subscribe(count =\x3e console.log(`Clicked ${count} times`)); \/\/ 订阅结果、输出值\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e button = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.querySelector(\x3cspan class=\x22hljs-string\x22\x3e\x27button\x27\x3c\/span\x3e);\nRx.Observable.fromEvent(button, \x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e)\n  .throttleTime(\x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 每隔1000毫秒才能触发事件\x3c\/span\x3e\n  .scan(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ecount\x3c\/span\x3e =\x26gt;\x3c\/span\x3e count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 求值，默认值是0\x3c\/span\x3e\n  .subscribe(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ecount\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`Clicked \x3cspan class=\x22hljs-subst\x22\x3e${count}\x3c\/span\x3e times`\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅结果、输出值\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e巧夺天工！再也不用去管理状态了，不需要声明一堆变量，修改来修改去，判断来判断去，简直完美。\x3c\/p\x3e\n\x3cp\x3e平常我们有很多需要更新dom的异步操作，如搜索行为：用户连续输入查询值，如果停顿半秒就执行搜索，如果搜索了多次，发起了多次请求，那只返回最终输入的那次搜索结果。\x3c\/p\x3e\n\x3cp\x3e闭上眼想想，你之前是怎么实现的。反正我都是设置开始时间，结束时间，上次时间，等等变量。繁琐，而且不可控。\x3c\/p\x3e\n\x3cp\x3e当我们以FP的思想去实现时，就会想方设法的减少变量，来优雅程序。最常见的方法就是用下别人的工具库来实现它。当然有些简单的场景也可以自己实现，最主要的还是要有这个意识。\x3c\/p\x3e\n\x3cp\x3e其实我们平常已经写了一些FP了，只是我们没意识到，或者没怎么写好。就好比闭包，很多人都不了解闭包的概念，但实际上已经写了很多闭包代码。其实闭包本身也是函数式编程的一个应用。\x3c\/p\x3e\n\x3cp\x3e鉴于我自己理解也不深，没法多阐述FP的应用，大家如果有兴趣，可以多了解了解。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eFP在JavaScript中的优劣势\x3c\/h2\x3e\n\x3cp\x3e总结一下FP的优劣，以便于我们在实际开发中，能更好的抉择是否采用FP。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e优势\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e更好的管理状态\x3c\/strong\x3e。因为它的宗旨是无状态，或者说更少的状态。而平常DOM的开发中，因为DOM的视觉呈现依托于状态变化，所以不可避免的产生了非常多的状态，而且不同组件可能还相互依赖。以FP来编程，能最大化的减少这些未知、优化代码、减少出错情况。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e更简单的复用\x3c\/strong\x3e。极端的FP代码应该是每一行代码都是一个函数，当然我们不需要这么极端。我们尽量的把过程逻辑以更纯的函数来实现，固定输入-\x26gt;固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e更优雅的组合\x3c\/strong\x3e。往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。参考上面第二点，更强的复用性，带来更强大的组合性。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e隐性好处。减少代码量，提高维护性。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e劣势\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eJavaScript不能算是严格意义上的函数式语言，很多函数式编程的特性并没有。比如上文说的数组的惰性链求值。为了实现它就得上工具库，或者自己封装实现，提高了代码编写成本。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e跟过程式相比，它并没有提高性能。有些地方，如果强制用FP去写，由于没有中间变量，还可能会降低性能。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e代码不易读。这个因人而异，因码而已。特别熟悉FP的人可能会觉得这段代码一目了然。而不熟悉的人，遇到写的晦涩的代码，看着一堆堆lambda演算跟匿名函数 \x3ccode\x3e() =\x26gt; () =\x26gt; ()\x3c\/code\x3e 瞬间就懵逼了。看懂代码，得脑子里先演算半小时。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e学习成本高。一方面继承于上一点。另一方面，很多前端coder，就是因为相对不喜欢一些底层的抽象的编程语言，才来踏入前端坑，你现在又让他们一头扎入FP，显得手足无措。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e个人觉得，FP还是好的。对于开发而言，确确实实能优化我们的代码，熟悉之后，也能提高编程效率。对于编程本身而言，也能拓展我们的思维，不局限在过程式的编程代码。\x3c\/p\x3e\n\x3cp\x3e在编写JS中，可以尽量的运用FP的思维，如不可变量、纯函数、惰性求值。但也不必教条式的遵循函数式编程，一定要怎样怎样。比如我们看下知乎大V某温的一个回答：\x3ca href=\x22https:\/\/www.zhihu.com\/question\/59871249\/answer\/171201717\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e传送门\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e唉，做个页面仔不容易啊。但是不想当大牛的页面仔不是好页面仔！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e参考\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2017\/02\/fp-tutorial.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e函数式编程入门教程-阮一峰\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/zh.wikipedia.org\/wiki\/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e函数编程语言-维基百科\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/www.zhihu.com\/question\/59871249\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e前端开发js函数式编程真实用途体现在哪里？-知乎答者\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 函数式编程到底是个啥</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009864459">https://segmentfault.com/a/1190000009864459</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/srk0js3d93o/" target="_blank">https://alili.tech/archive/srk0js3d93o/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>