<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React从入门到精通系列之(16)性能优化"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React从入门到精通系列之(16)性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/tjeml12s3/",
				"appid": "1613049289050283", 
				"title": "React从入门到精通系列之(16)性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/9olr7ly70mf/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/f1uq3yxj6l8/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f&text=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2816%29%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f&text=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2816%29%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2816%29%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f&is_video=false&description=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2816%29%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2816%29%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2816%29%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2816%29%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2816%29%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ftjeml12s3%2f&title=React%e4%bb%8e%e5%85%a5%e9%97%a8%e5%88%b0%e7%b2%be%e9%80%9a%e7%b3%bb%e5%88%97%e4%b9%8b%2816%29%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React从入门到精通系列之(16)性能优化</h1><div class="meta"><div class="postdate"><time datetime="2019-01-29" itemprop="datePublished">2019-01-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e十六、性能优化\x3c\/h2\x3e\n\x3cp\x3e在React内部，React使用了几种比较聪明的技术来实现\x3ccode\x3e最小化更新UI所需的昂贵的DOM操作\x3c\/code\x3e的数量。\x3c\/p\x3e\n\x3cp\x3e对于许多应用来说，使用React将很快速的渲染出用户界面，从而无需进行大量工作来专门做优化性能的工作。\x3c\/p\x3e\n\x3cp\x3e大概有以下有几种方法来加快你的React应用程序。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e使用生产环境的配置进行构建\x3c\/h3\x3e\n\x3cp\x3e如果你在React应用中进行基准测试或这遇到了性能问题，请首先确保你是使用的压缩后线上版本js文件来进行的测试：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e对于\x3ccode\x3eCreate React App\x3c\/code\x3e来说，你需要在构建时运行\x3ccode\x3enpm run build\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对于单文件来说，我们提供了生产环境版本\x3ccode\x3e.min.js\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e使用的是Browserify，你先设置\x3ccode\x3eNODE_ENV=production\x3c\/code\x3e然后运行。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e使用的是webpack，你需要在生产环境配置中加入以下插件：\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new webpack.DefinePlugin({\n    \x27process.env\x27: {\n        NODE_ENV: JSON.stringify(\x27production\x27)\n    }\n}),\nnew webpack.optimize.UglifyJSPlugin();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.DefinePlugin({\n    \x3cspan class=\x22hljs-string\x22\x3e\x27process.env\x27\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3eNODE_ENV\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(\x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e)\n    }\n}),\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e webpack.optimize.UglifyJSPlugin();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在构建应用程序时开发构建工具可以打印一些有帮助的额外警告。\x3cbr\x3e但是由于需要额外地记录这些警告信息，所以它也会变得更慢。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e避免重复处理DOM\x3c\/h3\x3e\n\x3cp\x3eReact会创建并维护所渲染的UI内部表示信息。其中包括从组件返回的React元素。 此表示信息使React避免创建DOM节点和访问那些没有必要的节点，因为这样做可能会比JavaScript对象上的一些操作更慢。 有时它被称为\x3ccode\x3e“虚拟DOM”\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e当组件的\x3ccode\x3eprops\x3c\/code\x3e或\x3ccode\x3estate\x3c\/code\x3e更改时，React通过将最新返回的元素与先前渲染的元素进行比较来决定是否需要实际的DOM更新。 当它们不相等时，React将更新DOM。\x3c\/p\x3e\n\x3cp\x3e在某些情况下，您的组件可以通过重写生命周期函数\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e来加快所有这些操作。这个函数会在重新渲染之前触发。 此函数的默认实现返回\x3ccode\x3etrue\x3c\/code\x3e，让React执行更新：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22shouldComponentUpdate(nextProps, nextState) {\n    return true;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eshouldComponentUpdate(nextProps, nextState) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你知道在某些情况下你的组件不需要更新，你可以从\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e中返回\x3ccode\x3efalse\x3c\/code\x3e，而不是跳过整个渲染过程，其中包括调用当前组件和下面的\x3ccode\x3erender()\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eshouldComponentUpdate的应用\x3c\/h3\x3e\n\x3cp\x3e这里是一个组件的子树。 对于其中每一个子树来说，\x3ccode\x3eSCU\x3c\/code\x3e指示\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e返回什么，\x3ccode\x3evDOMEq\x3c\/code\x3e指示渲染的React元素是否相等。 最后，圆圈的颜色表示组件是否必须重新处理。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGXZA?w=977\x26amp;h=692\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGXZA?w=977\x26amp;h=692\x22 alt=\x22虚拟DOM比较\x22 title=\x22虚拟DOM比较\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e因为\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e对于以\x3ccode\x3eC2\x3c\/code\x3e为根的子树返回了\x3ccode\x3efalse\x3c\/code\x3e，所以React没有尝试渲染\x3ccode\x3eC2\x3c\/code\x3e，因此甚至不必在\x3ccode\x3eC4\x3c\/code\x3e和\x3ccode\x3eC5\x3c\/code\x3e上调用\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e对于\x3ccode\x3eC1\x3c\/code\x3e和\x3ccode\x3eC3\x3c\/code\x3e，\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e返回true，因此React必须下到子树中并检查它们。 对于\x3ccode\x3eC6 \x3c\/code\x3e 子树\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e返回\x3ccode\x3etrue\x3c\/code\x3e，并且因为渲染的元素不是相同的，React不得不更新DOM。\x3c\/p\x3e\n\x3cp\x3e最后一个有趣的例子是\x3ccode\x3eC8\x3c\/code\x3e。 React不得不渲染这个组件，不过由于React元素返回的元素等于之前渲染的元素，所以它不必更新DOM。\x3c\/p\x3e\n\x3cp\x3e注意，React只需要做\x3ccode\x3eC6\x3c\/code\x3e的DOM重新处理，这是不可避免的。\x3cbr\x3e对于\x3ccode\x3eC8\x3c\/code\x3e，它通过比较渲染的React元素来决定是否重新处理DOM。至于\x3ccode\x3eC2\x3c\/code\x3e的子树和\x3ccode\x3eC7\x3c\/code\x3e，我们在\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e返回\x3ccode\x3efalse\x3c\/code\x3e时它甚至都不需要比较元素，并且也没有调用\x3ccode\x3erender()\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e例子\x3c\/h3\x3e\n\x3cp\x3e如果你的组件的唯一的改变方式就是改变\x3ccode\x3eprops.color\x3c\/code\x3e或\x3ccode\x3estate.count\x3c\/code\x3e，你可以用\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e检查：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27;\nimport ReactDOM from \x27react-dom\x27;\n\nclass CounterButton extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {count: 1};\n        this.click = this.click.bind(this);\n    }\n\n    click() {\n        this.setState(prevState =\x3e ({\n            count: prevState.count \x2b 1\n        }));\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        if (this.props.color !== nextProps.color) {\n            return true;\n        }\n        return this.state.count !== nextState.count;\n    }\n\n    render() {\n        return (\n            \x3cbutton color={this.props.color} onClick={this.click}\x3e\n                Count：{this.state.count}\n            \x3c\/button\x3e\n        );\n    }\n}\nReactDOM.render(\n    \x3cCounterButton color=\x26quot;blue\x26quot;\/\x3e,\n    document.getElementById(\x27root\x27)\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounterButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e};\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.click = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.click.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    }\n\n    click() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eprevState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n            \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: prevState.count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n        }));\n    }\n\n    shouldComponentUpdate(nextProps, nextState) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.color !== nextProps.color) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.count !== nextState.count;\n    }\n\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.color}\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.click}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                Count：{this.state.count}\n            \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n        );\n    }\n}\nReactDOM.render(\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCounterButton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e,\n    document.getElementById(\x27root\x27)\n);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这段代码中，\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e只是检查\x3ccode\x3eprops.color\x3c\/code\x3e或\x3ccode\x3estate.count\x3c\/code\x3e是否有任何变化。 如果它们的值没有更改，则组件不更新。 如果你的组件比这个例子中的组件更复杂，你可以使用类似的模式在props和state的所有字段之间做一个\x3ccode\x3e“浅比较”\x3c\/code\x3e，以确定组件是否应该更新。\x3c\/p\x3e\n\x3cp\x3e比较常见的模式是使用React提供的一个帮助对象来使用这个逻辑，可以直接继承\x3ccode\x3eReact.PureComponent\x3c\/code\x3e。 \x3cbr\x3e 所以上面这段代码有一个更简单的方法来实现同样的事情：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React from \x27react\x27;\nimport ReactDOM from \x27react-dom\x27;\n\nclass CounterButton extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.state = {count: 1};\n        this.click = this.click.bind(this);\n    }\n\n    click() {\n        this.setState(prevState =\x3e ({\n            count: prevState.count \x2b 1\n        }));\n    }\n\n    render() {\n        return (\n            \x3cbutton color={this.props.color} onClick={this.click}\x3e\n                Count: {this.state.count}\n            \x3c\/button\x3e\n        );\n    }\n}\nReactDOM.render(\n    \x3cCounterButton color=\x26quot;blue\x26quot;\/\x3e,\n    document.getElementById(\x27root\x27)\n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react-dom\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounterButton\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ePureComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e};\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.click = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.click.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    }\n\n    click() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eprevState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n            \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: prevState.count \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n        }));\n    }\n\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.props.color}\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.click}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                Count: {this.state.count}\n            \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n        );\n    }\n}\nReactDOM.render(\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eCounterButton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e,\n    document.getElementById(\x27root\x27)\n);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e大多数时候，你可以使用\x3ccode\x3eReact.PureComponent\x3c\/code\x3e而不是编写自己的\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e。 它只做一个浅层的比较，所以你不需要直接使用它，如果你的组件内部\x3ccode\x3eprops\x3c\/code\x3e或\x3ccode\x3estate\x3c\/code\x3e的数据有可能会\x3ccode\x3e突然变化\x3c\/code\x3e，那么\x3ccode\x3e浅比较\x3c\/code\x3e将失效。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e浅比较\x3c\/code\x3e的失效可能是一个更加复杂的数据结构问题(\x3ccode\x3e突然变化\x3c\/code\x3e)。 例如，假设您想要一个以逗号分隔单词列表的\x3ccode\x3eListOfWords\x3c\/code\x3e组件，使用一个父\x3ccode\x3eWordAdder\x3c\/code\x3e组件，当你单击一个按钮用来添加一个单词到列表中时。 下面的代码将无法正常工作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ PureComponent在内部会帮我们对props和state进行简单对比(浅比较)\n\/\/ 值类型比较值，引用类型比较引用，但是不会比较引用类型的内部数据是否改变。\n\/\/ 所以就会出现一个bug，不管你怎么点button，div是不会增加的。\nclass ListOfWords extends React.PureComponent {\n    render() {\n        return \x3cdiv\x3e{this.props.words.join(\x27,\x27)}\x3c\/div\x3e;\n    }\n}\n\nclass WordAdder extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {words: [\x27zhangyatao\x27]};\n        this.click = this.click.bind(this);\n    }\n    click() {\n        \/\/ 这么写是不对的，因为state的更新是异步的，所以可能会导致一些不必要的bug\n        const words = this.state.word;\n        words.push(\x27zhangyatao\x27);\n        this.setState({words: words});\n    }\n    render() {\n        return (\n            \x3cdiv\x3e\n                \x3cbutton onClick={this.click} \/\x3e\n                \x3cListOfWords words={this.state.words} \/\x3e\n            \x3c\/div\x3e\n        );\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ PureComponent在内部会帮我们对props和state进行简单对比(浅比较)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 值类型比较值，引用类型比较引用，但是不会比较引用类型的内部数据是否改变。\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所以就会出现一个bug，不管你怎么点button，div是不会增加的。\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eListOfWords\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ePureComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e{this.props.words.join(\x27,\x27)}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n    }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWordAdder\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = {\x3cspan class=\x22hljs-attr\x22\x3ewords\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27zhangyatao\x27\x3c\/span\x3e]};\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.click = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.click.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    }\n    click() {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这么写是不对的，因为state的更新是异步的，所以可能会导致一些不必要的bug\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e words = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.word;\n        words.push(\x3cspan class=\x22hljs-string\x22\x3e\x27zhangyatao\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\x3cspan class=\x22hljs-attr\x22\x3ewords\x3c\/span\x3e: words});\n    }\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x26lt;div\x26gt;\n                \x26lt;button onClick={this.click} \/\x26gt;\n                \x26lt;ListOfWords words={this.state.words} \/\x26gt;\n            \x26lt;\/div\x26gt;\n        );\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e问题是\x3ccode\x3ePureComponent\x3c\/code\x3e将对\x3ccode\x3ethis.props.words\x3c\/code\x3e的旧值和新值进行简单比较。 由于这个代码在\x3ccode\x3eWordAdder\x3c\/code\x3e的\x3ccode\x3eclick\x3c\/code\x3e方法中改变了单词数组，所以即使数组中的实际单词已经改变，\x3ccode\x3eListOfWords\x3c\/code\x3e组件中的\x3ccode\x3ethis.props.words\x3c\/code\x3e的旧值和新值还是相等的。 因此即便\x3ccode\x3eListOfWords\x3c\/code\x3e具有要被渲染出来的新单词它也还是不更新任何内容。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e超能力之『不会突然变化的数据』\x3c\/h3\x3e\n\x3cp\x3e避免此问题的最简单的方法就是避免将那些\x3ccode\x3e可能突然变化的数据\x3c\/code\x3e作为你的props或state。 例如，上面的\x3ccode\x3eclick\x3c\/code\x3e方法里面使用\x3ccode\x3econcat\x3c\/code\x3e代替\x3ccode\x3epush\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22click() {\n    this.setState(prevState =\x3e ({\n        count: prevState.words.concat([\x27zhangyatao\x27])\n    }));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eclick() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eprevState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n        \x3cspan class=\x22hljs-attr\x22\x3ecount\x3c\/span\x3e: prevState.words.concat([\x3cspan class=\x22hljs-string\x22\x3e\x27zhangyatao\x27\x3c\/span\x3e])\n    }));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eES6支持数组的\x3ccode\x3espread\x3c\/code\x3e语法可以让这变得更容易。 如果您使用的是\x3ccode\x3eCreate React App\x3c\/code\x3e，那么此语法默认可以使用的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22click() {\n    this.setState(prevState =\x3e ({\n        words: [...prevState.words, \x27zhangyatao\x27]\n    }));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eclick() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eprevState\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n        \x3cspan class=\x22hljs-attr\x22\x3ewords\x3c\/span\x3e: [...prevState.words, \x3cspan class=\x22hljs-string\x22\x3e\x27zhangyatao\x27\x3c\/span\x3e]\n    }));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e您还可以把那部分\x3ccode\x3e有可能突然变化的数据\x3c\/code\x3e的代码按照上面的方式给重写下，从而以避免这种问题。 \x3cbr\x3e例如，假设我们有一个名为\x3ccode\x3ecolormap\x3c\/code\x3e的对象，我们要写一个函数，将\x3ccode\x3ecolormap.right\x3c\/code\x3e改为\x3ccode\x3e\x27blue\x27\x3c\/code\x3e。 我们可以写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function updateColorMap(colormap) {\n    colormap.right = \x27blue\x27;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateColorMap\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecolormap\x3c\/span\x3e) \x3c\/span\x3e{\n    colormap.right = \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e要将上面的代码写成不会濡染改变的对象，我们可以使用\x3ccode\x3eObject.assign\x3c\/code\x3e方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function updateColorMap(colormap) {\n    return Object.assign(colormap, {right: \x27blue\x27});\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateColorMap\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecolormap\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(colormap, {\x3cspan class=\x22hljs-attr\x22\x3eright\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e});\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eupdateColorMap\x3c\/code\x3e现在会返回一个新对象，而不是改变之前的旧对象。 \x3ccode\x3eObject.assign\x3c\/code\x3e在ES6中，需要\x3ccode\x3epolyfill\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e有一个JavaScript提议来添加对象\x3ccode\x3espread\x3c\/code\x3e属性，以便不会\x3ccode\x3e突然变化\x3c\/code\x3e的更新对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function updateColorMap(colormap) {\n    return {...colormap, right: \x27blue\x27};\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateColorMap\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecolormap\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {...colormap, \x3cspan class=\x22hljs-attr\x22\x3eright\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e};\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果使用\x3ccode\x3eCreate React App\x3c\/code\x3e，默认情况下\x3ccode\x3eObject.assign\x3c\/code\x3e和对象\x3ccode\x3espread\x3c\/code\x3e语法都可用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e使用不突变的数据结构\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eImmutable.js\x3c\/code\x3e是另一种解决这个问题的方法。 它提供不可变的，持久的集合，通过结构共享工作：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e不可变：一旦创建，集合不能在另一个时间点更改。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e持久性：可以从先前的集合和类集合的突变中创建处一个新集合。 创建新集合后，原始集合仍然有效。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e结构共享：使用尽可能多的与原始集合相同的结构创建新集合，从而将最低程度的减少复制来提高性能。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React从入门到精通系列之(16)性能优化</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007818047">https://segmentfault.com/a/1190000007818047</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/tjeml12s3/" target="_blank">https://alili.tech/archive/tjeml12s3/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>