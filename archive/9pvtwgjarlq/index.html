<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="中文输入法与React文本输入框的问题与解决方案"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>中文输入法与React文本输入框的问题与解决方案 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/9pvtwgjarlq/",
				"appid": "1613049289050283", 
				"title": "中文输入法与React文本输入框的问题与解决方案 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-28T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/vda4333rfwn/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dklfgwyc9f/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f&text=%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95%e4%b8%8eReact%e6%96%87%e6%9c%ac%e8%be%93%e5%85%a5%e6%a1%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f&text=%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95%e4%b8%8eReact%e6%96%87%e6%9c%ac%e8%be%93%e5%85%a5%e6%a1%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f&title=%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95%e4%b8%8eReact%e6%96%87%e6%9c%ac%e8%be%93%e5%85%a5%e6%a1%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f&is_video=false&description=%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95%e4%b8%8eReact%e6%96%87%e6%9c%ac%e8%be%93%e5%85%a5%e6%a1%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95%e4%b8%8eReact%e6%96%87%e6%9c%ac%e8%be%93%e5%85%a5%e6%a1%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f&title=%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95%e4%b8%8eReact%e6%96%87%e6%9c%ac%e8%be%93%e5%85%a5%e6%a1%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f&title=%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95%e4%b8%8eReact%e6%96%87%e6%9c%ac%e8%be%93%e5%85%a5%e6%a1%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f&title=%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95%e4%b8%8eReact%e6%96%87%e6%9c%ac%e8%be%93%e5%85%a5%e6%a1%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f9pvtwgjarlq%2f&title=%e4%b8%ad%e6%96%87%e8%be%93%e5%85%a5%e6%b3%95%e4%b8%8eReact%e6%96%87%e6%9c%ac%e8%be%93%e5%85%a5%e6%a1%86%e7%9a%84%e9%97%ae%e9%a2%98%e4%b8%8e%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">中文输入法与React文本输入框的问题与解决方案</h1><div class="meta"><div class="postdate"><time datetime="2019-01-28" itemprop="datePublished">2019-01-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e问题来源是来自这个React官方存储库的issue \x3ca href=\x22https:\/\/github.com\/facebook\/react\/issues\/3926\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e#3926\x3c\/a\x3e，与这个议题关联的有很多其他的issue，来自许多项目，有些是与React相关，有些则是vue或其它JS套件。也已经有其他的项目是专注于解决这个问题，例如\x3ca href=\x22https:\/\/github.com\/fast-flow\/react-composition\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-composition\x3c\/a\x3e，不过它是一个使用ES5语法的React组件。在其他的讨论区上也有类似的\x3ca href=\x22http:\/\/react-china.org\/t\/onchange-input\/3385\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e问题与解答\x3c\/a\x3e。本文的目的是希望能针对这个问题提供一些说明、现在暂时性的解决方案。\x3c\/p\x3e\n\x3cp\x3e下图为目前解决React中\x22Controlled\x22(受控制的)input元件的演示，可以到\x3ca href=\x22https:\/\/eyesofkids.github.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e去测试:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHPqj?w=601\x26amp;h=535\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHPqj?w=601\x26amp;h=535\x22 alt=\x22input元件的演示\x22 title=\x22input元件的演示\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注意事项: 目前的解决方案我认为是暂时性的，结果都放在这个\x3ca href=\x22https:\/\/github.com\/eyesofkids\/react-compositionevent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub库\x3c\/a\x3e上。这要分为\x22Controlled\x22(受控制的)与\x22Uncontrolled\x22(不受控制的)两个种类的组件，影响的主要是input与textarea两个组件，输入法(IME, input method editor)的问题，不只会发生在中文，同样的在日文、韩文或其它使用输入法的语言应该都有同样问题。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e问题何来\x3c\/h2\x3e\n\x3cp\x3eReact组件主要使用\x3ccode\x3eonChange\x3c\/code\x3e人造事件，作为文本输入框(input)或文字输入区(textarea)触发文字输入时的事件，这个事件用起来很直觉，理应当是如此。但\x3ccode\x3eonChange\x3c\/code\x3e在浏览器上，只要在这个文本输入框上，有任何的键盘动作它都会触发，也就是如果你是使用了中文、日文、韩文输入法(IME)，不论是哪一种，拼音的、笔划的还是其他的，只要有按下一个键盘的动作，就会触发一次浏览器上这个元素的\x3ccode\x3echange\x3c\/code\x3e事件，对于原本就使用键盘上的英文字符作为输入的语言来说，这没什么太大的问题，但对于要使用输入法的语言用户来说，不停的触发\x3ccode\x3echange\x3c\/code\x3e事件，可能会造成程序功能上的运行逻辑问题。\x3c\/p\x3e\n\x3cp\x3e举出一个实际的应用情况，一个使用React撰写的搜索计算机书籍的功能，用户可以在文本输入框里输入要搜索的书名，程序中是利用\x3ccode\x3eonChange\x3c\/code\x3e事件触发，进行比对数据库中的书籍标题，当你想搜索一本名为\x22林哥的Java教程\x22，第一个字为\x22林\x22，拼音输入法需要输入\x22lin\x22三个键盘上的字符，在\x22林\x22这个字从输入法编辑器中加到真正的input元素前，\x3ccode\x3eonChange\x3c\/code\x3e已经捕捉到\x22lin\x22三个字符，在列表中已搜索出一大堆有关\x22linux\x22的书籍。细节就不说了，还有可能对字符数量的的检查之类的问题。不过，这是正确的程序运作逻辑吗?很明显的这是一个大问题。\x3c\/p\x3e\n\x3cp\x3e当然，你也可以用对中文字词检查的修正方式，或是干脆不要用\x3ccode\x3echange\x3c\/code\x3e事件，改用其他按钮触发之类的事件来作这事情，或是不要用React中的\x22Controlled\x22(受控制的)input或textare组件，但这会局限住在程序开发应用上的自由，要如何选择就看你自己了，是不要使用它还是想办法正视问题来解决它。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e网页上的DOM元素与\x22Uncontrolled\x22(不受控制的)的组件\x3c\/h2\x3e\n\x3cp\x3e这个问题在浏览器中，早就已经有了可应对的解决方法，DOM事件中有一组额外的\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/CompositionEvent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCompositionEvent\x3c\/a\x3e(组成事件)可以辅助开发者，它可以在可编辑的DOM元素上触发，主要是input与textarea上，所以可以用来辅助解决\x3ccode\x3echange\x3c\/code\x3e事件的输入法问题。CompositionEvent(组成事件)共有三个事件，分别为\x3ccode\x3ecompositionstart\x3c\/code\x3e、\x3ccode\x3ecompositionupdate\x3c\/code\x3e与\x3ccode\x3ecompositionend\x3c\/code\x3e，它们代表的是开始进行字的组成、刷新与结束，也就是代表开始以输入法编辑器来组合键盘上的英文字符，选字或刷新字的组合，到最后输出字到真实DOM中的文本输入框中，实务上每个中文字在输入时，\x3ccode\x3ecompositionstart\x3c\/code\x3e与\x3ccode\x3ecompositionend\x3c\/code\x3e都只会会被触发一次，而\x3ccode\x3ecompositionupdate\x3c\/code\x3e则是有可能多次触发。\x3c\/p\x3e\n\x3cp\x3e藉由CompositionEvent的辅助来解决的方式，也就是说在网页上的input元素，可以利用CompositionEvent作为一个信号，如果正在使用IME输入中文时，\x3ccode\x3echange\x3c\/code\x3e事件中的代码就先不要运行，等\x3ccode\x3ecompositionend\x3c\/code\x3e触发时，接着的\x3ccode\x3echange\x3c\/code\x3e事件才可以运行其中的代码，运作的原理就是这样简单而已。\x3c\/p\x3e\n\x3cp\x3e在React应用中，如果是一个\x22Uncontrolled\x22(不受控制的)的input组件，它与网页上真实DOM中的input元素的事件行为无差异，也就是说，直接使用CompositionEvent的解决方式，就可以解决这个输入法的问题，以下面的代码为例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ @flow\nimport React from \x27react\x27\n\nconst Cinput = (props: Object) =\x3e {\n  \/\/ record if is on Composition\n  let isOnComposition: boolean = false\n\n  const handleComposition = (e: KeyboardEvent) =\x3e {\n    if (e.type === \x27compositionend\x27) {\n      \/\/ composition is end\n      isOnComposition = false\n    } else {\n      \/\/ in composition\n      isOnComposition = true\n    }\n  }\n\n  const handleChange = (e: KeyboardEvent) =\x3e {\n    \/\/ only when onComposition===false to fire onChange\n    if (e.target instanceof HTMLInputElement \x26amp;\x26amp; !isOnComposition) {\n      props.onChange(e)\n    }\n  }\n\n  return (\n    \x3cinput\n      {...props}\n      onCompositionStart={handleComposition}\n      onCompositionUpdate={handleComposition}\n      onCompositionEnd={handleComposition}\n      onChange={handleChange}\n    \/\x3e\n  )\n}\n\nexport default Cinput\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ @flow\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Cinput = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops: \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ record if is on Composition\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isOnComposition: boolean = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e handleComposition = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee: KeyboardEvent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.type === \x3cspan class=\x22hljs-string\x22\x3e\x27compositionend\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ composition is end\x3c\/span\x3e\n      isOnComposition = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ in composition\x3c\/span\x3e\n      isOnComposition = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e handleChange = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee: KeyboardEvent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ only when onComposition===false to fire onChange\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.target \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e HTMLInputElement \x26amp;\x26amp; !isOnComposition) {\n      props.onChange(e)\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e\n      {\x3cspan class=\x22hljs-attr\x22\x3e...props\x3c\/span\x3e}\n      \x3cspan class=\x22hljs-attr\x22\x3eonCompositionStart\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{handleComposition}\x3c\/span\x3e\n      \x3cspan class=\x22hljs-attr\x22\x3eonCompositionUpdate\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{handleComposition}\x3c\/span\x3e\n      \x3cspan class=\x22hljs-attr\x22\x3eonCompositionEnd\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{handleComposition}\x3c\/span\x3e\n      \x3cspan class=\x22hljs-attr\x22\x3eonChange\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{handleChange}\x3c\/span\x3e\n    \/\x26gt;\x3c\/span\x3e\n  )\n}\n\nexport default Cinput\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这是一个典型的\x22Uncontrolled\x22(不受控制的)input组件，主要是它不用\x3ccode\x3evalue\x3c\/code\x3e这个属性。但如果它有来自上层组件的\x3ccode\x3evalue\x3c\/code\x3e属性与值，也就是上层组件用props传递给它\x3ccode\x3evalue\x3c\/code\x3e属性的值，就成了\x22Controlled\x22(受控制的)组件，它的事件整个模式就会与网页上的真实DOM中的input元素不一样，这后面再说明。\x3c\/p\x3e\n\x3cp\x3e这个解决方案在几乎所有能支持CompositionEvent的浏览器(IE9以上)都可以运行得很好，不过在Google Chrome浏览器在2016年的版本53之后，更动了\x3ccode\x3echange\x3c\/code\x3e与\x3ccode\x3ecompositionend\x3c\/code\x3e的\x3ca href=\x22https:\/\/chromium.googlesource.com\/chromium\/src\/\x2b\/afce9d93e76f2ff81baaa088a4ea25f67d1a76b3%5E%21\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e触发顺序\x3c\/a\x3e，所以需要针对Chrome浏览器调整一下，如果是在Chrome浏览器中触发\x3ccode\x3ecompositionend\x3c\/code\x3e时，也要运行一次在原本在\x3ccode\x3echange\x3c\/code\x3e要运行的代码，就改成这样而已。下面在上个代码中的\x3ccode\x3ehandleComposition\x3c\/code\x3e函数中，多加了侦测是否为Chrome浏览器，与触发原本的onChange方法代码，修改过的代码如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ detect it is Chrome browser?\nconst isChrome = !!window.chrome \x26amp;\x26amp; !!window.chrome.webstore\n\nconst handleComposition = (e: KeyboardEvent) =\x3e {\n  if (e.type === \x27compositionend\x27) {\n    \/\/ composition is end\n    isOnComposition = false\n\n    \/\/ fixed for Chrome v53\x2b and detect all Chrome\n    \/\/ https:\/\/chromium.googlesource.com\/chromium\/src\/\n    \/\/ \x2b\/afce9d93e76f2ff81baaa088a4ea25f67d1a76b3%5E%21\/\n    if (e.target instanceof HTMLInputElement \x26amp;\x26amp; !isOnComposition \x26amp;\x26amp; isChrome) {\n      \/\/ fire onChange\n      props.onChange(e)\n    }\n  } else {\n    \/\/ in composition\n    isOnComposition = true\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ detect it is Chrome browser?\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isChrome = !!\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.chrome \x26amp;\x26amp; !!\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.chrome.webstore\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e handleComposition = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee: KeyboardEvent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.type === \x3cspan class=\x22hljs-string\x22\x3e\x27compositionend\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ composition is end\x3c\/span\x3e\n    isOnComposition = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ fixed for Chrome v53\x2b and detect all Chrome\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ https:\/\/chromium.googlesource.com\/chromium\/src\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x2b\/afce9d93e76f2ff81baaa088a4ea25f67d1a76b3%5E%21\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.target \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e HTMLInputElement \x26amp;\x26amp; !isOnComposition \x26amp;\x26amp; isChrome) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ fire onChange\x3c\/span\x3e\n      props.onChange(e)\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ in composition\x3c\/span\x3e\n    isOnComposition = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x22Uncontrolled\x22(不受控制的)input或textarea组件，解决方式就是这么简单而已，利用CompositionEvent过滤掉不必要的\x3ccode\x3echange\x3c\/code\x3e事件。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注: 其它的解决方式还有，像\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/InputEvent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eInputEvent\x3c\/a\x3e中有一个\x3ccode\x3eisComposing\x3c\/code\x3e属性，它也可以作为侦测目前是否正在进行输入法的组字工作，但InputEvent事件目前只有Firefox中可以用，看起来没什么前景。另外，W3C新提出的\x3ca href=\x22https:\/\/www.w3.org\/TR\/ime-api\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIME API\x3c\/a\x3e或许是一个未来较佳的解决方案，但目前只有\x3ca href=\x22https:\/\/blogs.msdn.microsoft.com\/ie\/2014\/03\/31\/building-better-input-experience-for-east-asian-users-with-the-ime-api-in-ie11\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIE11 有实作\x3c\/a\x3e，其他浏览器品牌都没有。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e\x22Controlled\x22(受控制的)的组件\x3c\/h2\x3e\n\x3cp\x3e在React应用中，使用\x22Controlled\x22(受控制的)的input或textarea组件是另一回事，它会开始复杂起来。\x3c\/p\x3e\n\x3cp\x3e\x22Controlled\x22(受控制的)的组件并不是只有加上\x3ccode\x3evalue\x3c\/code\x3e这个属性这么简单，input或textarea组件所呈现的值，主要会来自state，state有可能是上层组件的，利用props一层层传递过来的，或是这个组件中本身就有的state，直接赋给在这个组件中的render中的input或textarea组件。也就是说，input最后呈现的文字如果要进行改变，就需要改变到组件(不论在何处)的state，要改变state只有透过setState方法，而setState方法有可能是个异步(延时)运行的情况。\x3c\/p\x3e\n\x3cp\x3e把这整个流程串接在一起后，我相信事件触发的不连续情况会变得很严重，需要对不同情况下作测试与评估。目前我所作的测试还只是最基本的组件运用而已，复杂的组件情况还没有开始进行。因为state有很多种用途，有时候内部使用，有时候要对外部用户输入介面的事件，或是有时候要对服务器端的数据接收或传送，不论是不是要使用Redux、MobX或Flux之类的state容器函数库或框架，最终要进行重新渲染的工作，还是得调用React中的setState方法才行。\x3c\/p\x3e\n\x3cp\x3e在基本的测试时，我发现\x22Controlled\x22(受控制的)的input组件，它不仅事件触发不连续的情况严重，而且有可能在不同浏览器上会有不同的结果。完全不会有问题的只有一个浏览器，就是上面注释中所说的已经实作出\x3ca href=\x22https:\/\/www.w3.org\/TR\/ime-api\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIME API\x3c\/a\x3e的IE11，IE11上可能根本不需要任何解决方案，它的输入法编辑器是独立于浏览器上的文本输入框之外的。\x3c\/p\x3e\n\x3cp\x3e目前已测试的结果是有三种情况，\x22Chrome, Opera, IE, Edge\x22为一种，\x22Firefox\x22为一种，\x22Safari\x22为一种。我为这三种情况分别写了不同的解决方式的代码，但这个事件触发的不连续情况，现在无法有一致性的解决方案，我只能推测这大概可能是React内部设计的问题。\x3c\/p\x3e\n\x3cp\x3e不论是三种的那一种解决方案，有一个重点是你不能像上面的一般性解决方案，阻挡\x3ccode\x3echange\x3c\/code\x3e事件时要运行的代码，也就是阻挡\x3ccode\x3esetState\x3c\/code\x3e变动\x3ccode\x3estate\x3c\/code\x3e值，因为只要一经阻挡，\x3ccode\x3einput\x3c\/code\x3e组件的\x3ccode\x3evalue\x3c\/code\x3e值就赋不到值，而且也不会触发重新渲染。所以你只能让\x3ccode\x3echange\x3c\/code\x3e事件不断触发，就像往常一样。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e那么要如何解决程序逻辑运作的问题？\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e我使用了另一个内部的state对象中的值，称为\x3ccode\x3einnerValue\x3c\/code\x3e，它是对比在input组件上不断因触发\x3ccode\x3echange\x3c\/code\x3e事件而输入的值，称为\x3ccode\x3einputValue\x3c\/code\x3e。\x3ccode\x3einnerValue\x3c\/code\x3e是个会经过CompositionEvent修正过的值，所以它永远不会带有在输入法组字过程的字符串值。\x3c\/p\x3e\n\x3cp\x3e这个解决方案，是一个\x22挂羊头卖狗肉\x22的用法，不论用户在input组件如何输入，输入的过程都会改变\x3ccode\x3einputValue\x3c\/code\x3e而已，\x3ccode\x3einputValue\x3c\/code\x3e是一个暂存与呈现用的值，最终用来进行程序逻辑运算的是\x3ccode\x3einnerValue\x3c\/code\x3e。以最一开始的例子来说，用户输入\x22林哥的Java教程\x22，在一开始的\x22林\x22字输入时，\x3ccode\x3einputValue\x3c\/code\x3e是从\x22lin\x22到输入完成变为\x22林\x22，而\x3ccode\x3einnerValue\x3c\/code\x3e是在输入期间是空字符串值，输入完成才会变为\x22林\x22。所以，搜索功能可以用\x3ccode\x3einnerValue\x3c\/code\x3e来作为运算的依据，用这个值来搜索对应的数据，这才是正确的运算逻辑，因为\x3ccode\x3einnerValue\x3c\/code\x3e才是真正的不带输入法组字过程的值。\x3c\/p\x3e\n\x3cp\x3e大致上说明一下解决方式的代码，首先它有两个在这个模块作用域中的全局变量，一个用来记录是否在输入法的组字过程中，另一个是给专给Safari浏览器用的:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ if now is in composition session\nlet isOnComposition = false\n\n\/\/ for safari use only, innervalue can\x27t setState when compositionend occurred\nlet isInnerChangeFromOnChange = false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ if now is in composition session\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isOnComposition = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ for safari use only, innervalue can\x27t setState when compositionend occurred\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e isInnerChangeFromOnChange = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在专门处理\x3ccode\x3echange\x3c\/code\x3e事件的\x3ccode\x3ehandleChange\x3c\/code\x3e方法中，判断\x3ccode\x3eisInnerChangeFromOnChange\x3c\/code\x3e这一段是专门为了解决Safari浏览器的问题所写，Safari浏览器的行为是CompositionEvent在触发时，其中的\x3ccode\x3eevent.target.value\x3c\/code\x3e居然是组字过程中的英文字符，而不是触发这个事件的input元素的所有字符串，这也是特别怪异的地方，所以才会利用在\x3ccode\x3ecompositionend\x3c\/code\x3e后会再触发一次\x3ccode\x3echange\x3c\/code\x3e的特性，在这里刷新\x3ccode\x3einnerValue\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e后面的代码，是代表在输入法的组字过程中，setState方法使用的差异，在组字过程中(\x3ccode\x3eisOnComposition === true\x3c\/code\x3e)的话，只会更动\x3ccode\x3einputValue\x3c\/code\x3e值，而不会更动到\x3ccode\x3einnerValue\x3c\/code\x3e的值，这对应了上述所说的一个运作过程，一般的输入键盘上的字符时不会有输入法的问题，则是两个值一并更动。代码如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22handleChange = (e: Event) =\x3e {\n   \/\/ console.log(\x27change type \x27, e.type, \x27, target \x27, e.target, \x27, target.value \x27, e.target.value)\n\n  \/\/ Flow check\n  if (!(e.target instanceof HTMLInputElement)) return\n\n  if (isInnerChangeFromOnChange) {\n    this.setState({ inputValue: e.target.value, innerValue: e.target.value })\n    isInnerChangeFromOnChange = false\n    return\n  }\n\n  \/\/ when is on composition, change inputValue only\n  \/\/ when not in composition change inputValue and innerValue both\n  if (!isOnComposition) {\n    this.setState({\n      inputValue: e.target.value,\n      innerValue: e.target.value,\n    })\n  } else {\n    this.setState({ inputValue: e.target.value })\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3ehandleChange = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee: Event\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ console.log(\x27change type \x27, e.type, \x27, target \x27, e.target, \x27, target.value \x27, e.target.value)\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Flow check\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(e.target \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e HTMLInputElement)) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isInnerChangeFromOnChange) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3einputValue\x3c\/span\x3e: e.target.value, \x3cspan class=\x22hljs-attr\x22\x3einnerValue\x3c\/span\x3e: e.target.value })\n    isInnerChangeFromOnChange = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ when is on composition, change inputValue only\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ when not in composition change inputValue and innerValue both\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isOnComposition) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({\n      \x3cspan class=\x22hljs-attr\x22\x3einputValue\x3c\/span\x3e: e.target.value,\n      \x3cspan class=\x22hljs-attr\x22\x3einnerValue\x3c\/span\x3e: e.target.value,\n    })\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3einputValue\x3c\/span\x3e: e.target.value })\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在专门处理\x3ccode\x3ecomposition\x3c\/code\x3e事件的\x3ccode\x3ehandleComposition\x3c\/code\x3e方法中，主要是为了在\x3ccode\x3ecompositionend\x3c\/code\x3e触发时，进行刷新\x3ccode\x3einnerValue\x3c\/code\x3e所撰写的一些代码。在第一种情况时，也就是在Chrome, IE, Edge, Opera浏览器时，只需要直接用\x3ccode\x3ee.target.value\x3c\/code\x3e刷新\x3ccode\x3einnerValue\x3c\/code\x3e即可。在第二种情况是Firefox，它不知道为什么会掉值，所以还需要帮它再一并刷新\x3ccode\x3einnerValue\x3c\/code\x3e一次。第三种情况，上面有说过了，特别的怪异情况，所以对\x3ccode\x3einnerValue\x3c\/code\x3e的刷新改到\x3ccode\x3ecompositionend\x3c\/code\x3e之后的那个\x3ccode\x3echange\x3c\/code\x3e事件去作了。代码如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22handleComposition = (e: Event) =\x3e {\n   \/\/ console.log(\x27type \x27, e.type, \x27, target \x27, e.target, \x27,target.value \x27, e.target.value, \x27, data\x27, e.data)\n\n   \/\/ Flow check\n  if (!(e.target instanceof HTMLInputElement)) return\n\n  if (e.type === \x27compositionend\x27) {\n    \/\/ Chrome is ok for only setState innerValue\n    \/\/ Opera, IE and Edge is like Chrome\n    if (isChrome || isIE || isEdge || isOpera) {\n      this.setState({ innerValue: e.target.value })\n    }\n\n    \/\/ Firefox need to setState inputValue again...\n    if (isFirefox) {\n      this.setState({ innerValue: e.target.value, inputValue: e.target.value })\n    }\n\n    \/\/ Safari think e.target.value in composition event is keyboard char,\n    \/\/  but it will fire another change after compositionend\n    if (isSafari) {\n       \/\/ do change in the next change event\n      isInnerChangeFromOnChange = true\n    }\n\n    isOnComposition = false\n  } else {\n    isOnComposition = true\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3ehandleComposition = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee: Event\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ console.log(\x27type \x27, e.type, \x27, target \x27, e.target, \x27,target.value \x27, e.target.value, \x27, data\x27, e.data)\x3c\/span\x3e\n\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Flow check\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(e.target \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e HTMLInputElement)) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (e.type === \x3cspan class=\x22hljs-string\x22\x3e\x27compositionend\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Chrome is ok for only setState innerValue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Opera, IE and Edge is like Chrome\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isChrome || isIE || isEdge || isOpera) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3einnerValue\x3c\/span\x3e: e.target.value })\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Firefox need to setState inputValue again...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isFirefox) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({ \x3cspan class=\x22hljs-attr\x22\x3einnerValue\x3c\/span\x3e: e.target.value, \x3cspan class=\x22hljs-attr\x22\x3einputValue\x3c\/span\x3e: e.target.value })\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Safari think e.target.value in composition event is keyboard char,\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/  but it will fire another change after compositionend\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isSafari) {\n       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ do change in the next change event\x3c\/span\x3e\n      isInnerChangeFromOnChange = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    }\n\n    isOnComposition = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    isOnComposition = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e注: 目前这个暂时的解决方式，其方式并不是参考自\x3ca href=\x22https:\/\/github.com\/fast-flow\/react-composition\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-composition\x3c\/a\x3e项目，解决方式虽然有些类似，但react-composition用的是ES5的React工厂样式组件语法，我对这种语法并不熟悉。在写这篇文档时，才仔细看了一下react-composition的代码，只能说它的作者实际上也有测试过这个问题，也知道只有用另一个state中的值才能解决这问题。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e如果你是使用\x22Uncontrolled\x22(不受控制的)的组件，那么解决方法很简单，就如同上面所说的，像一般的网页上的DOM元素的解决方式即可。\x3c\/p\x3e\n\x3cp\x3e但对于\x22Controlled\x22(受控制的)的组件来说，目前的解决方案是一种try-and-error(试误法)的暂时性解决方案，我目前只能按照已测试的平台与浏览器去修正，没测过的浏览器与平台，就不得而知了。\x3c\/p\x3e\n\x3cp\x3e关于这个\x22Controlled\x22(受控制的)的组件的事件触发，目前看到有在不同浏览器上的事件触发不连续情况，我也有发一个\x3ca href=\x22https:\/\/github.com\/facebook\/react\/issues\/8683\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e议题(Issue)\x3c\/a\x3e给React官方。或许比较好的治本方案，是需要从state更动方式的内部代码，或是人造事件触发的顺序，进行一些调整，这超出我的能力范围，就有待开发团队的回应了。\x3c\/p\x3e\n\x3cp\x3e最后，如果你正好有需要到这个功能，或是你认为这个功能有需要，你可以帮忙测试看看或是提供一些建议。我已经把所有的代码、演示、线上测试、解决方案都集中到这个Github库的\x3ca href=\x22https:\/\/github.com\/eyesofkids\/react-compositionevent\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-compositionevent\x3c\/a\x3e中。或许你现在需要一个解决方案，你可以用里面目前的暂时性解决方式试试也可以。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>中文输入法与React文本输入框的问题与解决方案</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008023476">https://segmentfault.com/a/1190000008023476</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/9pvtwgjarlq/" target="_blank">https://alili.tech/archive/9pvtwgjarlq/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5328xogjarn/">IndexedDB--HTML5本地存储<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/xpccu0hsqbr/">JS学习系列 01 - 编译原理和作用域<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/shv09bbtbfd/">Vue2 SSR 的优化之旅<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5vj1ojfo6h6/">[2016年末巨献] — HTML5可交互地铁线路图（第二季：帝都进阶版）<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/m02hlm4bzh/">vue2.0开发聊天程序（三）组件的通信<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/mz5o7n90plg/">《很高兴我没有猝死》- 前端新人的 2016 年总结和感悟<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/3vhoe2mo09k/">一道颇有难度的JavaScript题<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/uj12mb7thp/">使用CANVAS实现交互性圆形马赛克效果<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/ja636h8hcxa/">写于 2016 年末<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5uomnoq1kmi/">前端学习资源整理<aside class="dates">2019-01-28</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>