<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="深入理解React 高阶组件"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>深入理解React 高阶组件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/cvayxl3wvpi/",
				"appid": "1613049289050283", 
				"title": "深入理解React 高阶组件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-07T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fiiariwzu3/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/vz75b960cu/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f&text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f&text=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f&is_video=false&description=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcvayxl3wvpi%2f&title=%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">深入理解React 高阶组件</h1><div class="meta"><div class="postdate"><time datetime="2019-01-07" itemprop="datePublished">2019-01-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3e1. 基本概念\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e高阶组件\x3c\/strong\x3e是React 中一个很重要且较复杂的概念，高阶组件在很多第三方库（如Redux）中都被经常使用，即使你开发的是普通的业务项目，用好高阶组件也能显著提高你的代码质量。\x3c\/p\x3e\n\x3cp\x3e高阶组件的定义是类比于高阶函数的定义。高阶函数接收函数作为参数，并且返回值也是一个函数。类似的，高阶组件接收React组件作为参数，并且返回一个新的React组件。\x3cstrong\x3e高阶组件本质上也是一个函数，并不是一个组件，这一点一定要注意。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e2. 应用场景\x3c\/h3\x3e\n\x3cp\x3e为什么React引入高阶组件的概念？它到底有何威力？让我们先通过一个简单的例子说明一下。\x3c\/p\x3e\n\x3cp\x3e假设我有一个组件，需要从LocalStorage中获取数据，然后渲染出来。于是我们可以这样写组件代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27\n\nclass MyComponent extends Component {\n\n  componentWillMount() {\n      let data = localStorage.getItem(\x27data\x27);\n      this.setState({data});\n  }\n  \n  render() {\n    return \x3cdiv\x3e{this.state.data}\x3c\/div\x3e\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n\n  componentWillMount() {\n      let data = localStorage.getItem(\x3cspan class=\x22hljs-symbol\x22\x3e\x27dat\x3c\/span\x3ea\x27);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({data});\n  }\n  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.data}\x26lt;\/div\x26gt;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码很简单，但当我有其他组件也需要从LocalStorage中获取同样的数据展示出来时，我需要在每个组件都重复\x3ccode\x3ecomponentWillMount\x3c\/code\x3e中的代码，这显然是很冗余的。下面让我们来看看使用高阶组件可以怎么改写这部分代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27\n\nfunction withPersistentData(WrappedComponent) {\n  return class extends Component {\n    componentWillMount() {\n      let data = localStorage.getItem(\x27data\x27);\n        this.setState({data});\n    }\n    \n    render() {\n      \/\/ 通过{...this.props} 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent\n      return \x3cWrappedComponent data={this.state.data} {...this.props} \/\x3e\n    }\n  }\n}\n\nclass MyComponent2 extends Component {  \n  render() {\n    return \x3cdiv\x3e{this.props.data}\x3c\/div\x3e\n  }\n}\n\nconst MyComponentWithPersistentData = withPersistentData(MyComponent2)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27\n\nfunction withPersistentData(\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    componentWillMount() {\n      let data = localStorage.getItem(\x3cspan class=\x22hljs-symbol\x22\x3e\x27dat\x3c\/span\x3ea\x27);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({data});\n    }\n    \n    render() {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过{...this.props} 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e data={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.data} {...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props} \/\x26gt;\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent2\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.data}\x26lt;\/div\x26gt;\n  }\n}\n\nconst \x3cspan class=\x22hljs-type\x22\x3eMyComponentWithPersistentData\x3c\/span\x3e = withPersistentData(\x3cspan class=\x22hljs-type\x22\x3eMyComponent2\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ewithPersistentData\x3c\/code\x3e就是一个高阶组件，它返回一个新的组件，在新组件的\x3ccode\x3ecomponentWillMount\x3c\/code\x3e中统一处理从LocalStorage中获取数据的逻辑，然后将获取到的数据以属性的方式传递给被包装的组件\x3ccode\x3eWrappedComponent\x3c\/code\x3e，这样在\x3ccode\x3eWrappedComponent\x3c\/code\x3e中就可以直接使用\x3ccode\x3ethis.props.data\x3c\/code\x3e获取需要展示的数据了，如\x3ccode\x3eMyComponent2\x3c\/code\x3e所示。当有其他的组件也需要这段逻辑时，继续使用\x3ccode\x3ewithPersistentData\x3c\/code\x3e这个高阶组件包装这些组件就可以了。\x3c\/p\x3e\n\x3cp\x3e通过这个例子，可以看出\x3cstrong\x3e高阶组件的主要功能是封装并分离组件的通用逻辑，让通用逻辑在组件间更好地被复用\x3c\/strong\x3e。高阶组件的这种实现方式，本质上是一个装饰者设计模式。\x3c\/p\x3e\n\x3cp\x3e高阶组件的参数并非只能是一个组件，它还可以接收其他参数。例如，组件MyComponent3需要从LocalStorage中获取key为name的数据，而不是上面例子中写死的key为data的数据，\x3ccode\x3ewithPersistentData\x3c\/code\x3e这个高阶组件就不满足我们的需求了。我们可以让它接收额外的一个参数，来决定从LocalStorage中获取哪个数据：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27\n\nfunction withPersistentData(WrappedComponent, key) {\n  return class extends Component {\n    componentWillMount() {\n      let data = localStorage.getItem(key);\n        this.setState({data});\n    }\n    \n    render() {\n      \/\/ 通过{...this.props} 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent\n      return \x3cWrappedComponent data={this.state.data} {...this.props} \/\x3e\n    }\n  }\n}\n\nclass MyComponent2 extends Component {  \n  render() {\n    return \x3cdiv\x3e{this.props.data}\x3c\/div\x3e\n  }\n  \n  \/\/省略其他逻辑...\n}\n\nclass MyComponent3 extends Component {  \n  render() {\n    return \x3cdiv\x3e{this.props.data}\x3c\/div\x3e\n  }\n  \n  \/\/省略其他逻辑...\n}\n\nconst MyComponent2WithPersistentData = withPersistentData(MyComponent2, \x27data\x27);\nconst MyComponent3WithPersistentData = withPersistentData(MyComponent3, \x27name\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27\n\nfunction withPersistentData(\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e, key) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    componentWillMount() {\n      let data = localStorage.getItem(key);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({data});\n    }\n    \n    render() {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过{...this.props} 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e data={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.data} {...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props} \/\x26gt;\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent2\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.data}\x26lt;\/div\x26gt;\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/省略其他逻辑...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent3\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.data}\x26lt;\/div\x26gt;\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/省略其他逻辑...\x3c\/span\x3e\n}\n\nconst \x3cspan class=\x22hljs-type\x22\x3eMyComponent2WithPersistentData\x3c\/span\x3e = withPersistentData(\x3cspan class=\x22hljs-type\x22\x3eMyComponent2\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e\x27dat\x3c\/span\x3ea\x27);\nconst \x3cspan class=\x22hljs-type\x22\x3eMyComponent3WithPersistentData\x3c\/span\x3e = withPersistentData(\x3cspan class=\x22hljs-type\x22\x3eMyComponent3\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3e\x27nam\x3c\/span\x3ee\x27);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e新版本的\x3ccode\x3ewithPersistentData\x3c\/code\x3e就满足我们获取不同key值的需求了。高阶组件中的参数当然也可以有函数，我们将在下一节进一步说明。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e3. 进阶用法\x3c\/h3\x3e\n\x3cp\x3e高阶组件最常见的函数签名形式是这样的：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eHOC([param])([WrappedComponent])\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e用这种形式改写\x3ccode\x3ewithPersistentData\x3c\/code\x3e，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27\n\nfunction withPersistentData = (key) =\x3e (WrappedComponent) =\x3e {\n  return class extends Component {\n    componentWillMount() {\n      let data = localStorage.getItem(key);\n        this.setState({data});\n    }\n    \n    render() {\n      \/\/ 通过{...this.props} 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent\n      return \x3cWrappedComponent data={this.state.data} {...this.props} \/\x3e\n    }\n  }\n}\n\nclass MyComponent2 extends Component {  \n  render() {\n    return \x3cdiv\x3e{this.props.data}\x3c\/div\x3e\n  }\n  \n  \/\/省略其他逻辑...\n}\n\nclass MyComponent3 extends Component {  \n  render() {\n    return \x3cdiv\x3e{this.props.data}\x3c\/div\x3e\n  }\n  \n  \/\/省略其他逻辑...\n}\n\nconst MyComponent2WithPersistentData = withPersistentData(\x27data\x27)(MyComponent2);\nconst MyComponent3WithPersistentData = withPersistentData(\x27name\x27)(MyComponent3);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e, { \x3cspan class=\x22hljs-type\x22\x3eComponent\x3c\/span\x3e } from \x3cspan class=\x22hljs-symbol\x22\x3e\x27reac\x3c\/span\x3et\x27\n\nfunction withPersistentData = (key) =\x26gt; (\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    componentWillMount() {\n      let data = localStorage.getItem(key);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState({data});\n    }\n    \n    render() {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过{...this.props} 把传递给当前组件的属性继续传递给被包装的组件WrappedComponent\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e data={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state.data} {...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props} \/\x26gt;\n    }\n  }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent2\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.data}\x26lt;\/div\x26gt;\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/省略其他逻辑...\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent3\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{  \n  render() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.data}\x26lt;\/div\x26gt;\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/省略其他逻辑...\x3c\/span\x3e\n}\n\nconst \x3cspan class=\x22hljs-type\x22\x3eMyComponent2WithPersistentData\x3c\/span\x3e = withPersistentData(\x3cspan class=\x22hljs-symbol\x22\x3e\x27dat\x3c\/span\x3ea\x27)(\x3cspan class=\x22hljs-type\x22\x3eMyComponent2\x3c\/span\x3e);\nconst \x3cspan class=\x22hljs-type\x22\x3eMyComponent3WithPersistentData\x3c\/span\x3e = withPersistentData(\x3cspan class=\x22hljs-symbol\x22\x3e\x27nam\x3c\/span\x3ee\x27)(\x3cspan class=\x22hljs-type\x22\x3eMyComponent3\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实际上，此时的\x3ccode\x3ewithPersistentData\x3c\/code\x3e和我们最初对高阶组件的定义已经不同。它已经变成了一个高阶函数，但这个高阶函数的返回值是一个高阶组件。我们可以把它看成高阶组件的变种形式。这种形式的高阶组件大量出现在第三方库中。如\x3ca href=\x22https:\/\/github.com\/reactjs\/react-redux\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ereact-redux\x3c\/a\x3e中的connect就是一个典型。connect的定义如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs accesslog\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econnect(\x3cspan class=\x22hljs-string\x22\x3e[mapStateToProps]\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e[mapDispatchToProps]\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e[mergeProps]\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e[options]\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个函数会将一个React组件连接到Redux 的 store。在连接的过程中，connect通过函数参数\x3ccode\x3emapStateToProps\x3c\/code\x3e，从全局store中取出当前组件需要的state，并把state转化成当前组件的props；同时通过函数参数\x3ccode\x3emapDispatchToProps\x3c\/code\x3e，把当前组件用到的Redux的action creator，以props的方式传递给当前组件。\x3ccode\x3econnect\x3c\/code\x3e并不会修改传递进去的组件的定义，而是它会返回一个新的组件。\x3c\/p\x3e\n\x3cp\x3e例如，我们把组件ComponentA连接到Redux上的写法类似于：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ConnectedComponentA = connect(componentASelector, componentAActions)(ComponentA);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lisp\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econst ConnectedComponentA = connect(\x3cspan class=\x22hljs-name\x22\x3ecomponentASelector\x3c\/span\x3e, componentAActions)(\x3cspan class=\x22hljs-name\x22\x3eComponentA\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以把它拆分来看：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ connect 是一个函数，返回值enhance也是一个函数\nconst enhance = connect(componentASelector, componentAActions);\n\/\/ enhance是一个高阶组件\nconst ConnectedComponentA = enhance(ComponentA);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ connect 是一个函数，返回值enhance也是一个函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e enhance = \x3cspan class=\x22hljs-built_in\x22\x3econnect\x3c\/span\x3e(componentASelector, componentAActions);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ enhance是一个高阶组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ConnectedComponentA = enhance(ComponentA);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当多个函数的输出和它的输入类型相同时，这些函数是很容易组合到一起使用的。例如，有f，g，h三个高阶组件，都只接受一个组件作为参数，于是我们可以很方便的嵌套使用它们：\x3ccode\x3ef( g( h(WrappedComponent) ) )\x3c\/code\x3e。这里可以有一个例外，即最内层的高阶组件h可以有多个参数，但其他高阶组件必须只能接收一个参数，只有这样才能保证内层的函数返回值和外层的函数参数数量一致(都只有1个)。\x3c\/p\x3e\n\x3cp\x3e例如我们将connect和另一个打印日志的高阶组件\x3ccode\x3ewithLog\x3c\/code\x3e联合使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ConnectedComponentA = connect(componentASelector)(withLog(ComponentA));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lisp\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econst ConnectedComponentA = connect(\x3cspan class=\x22hljs-name\x22\x3ecomponentASelector\x3c\/span\x3e)(\x3cspan class=\x22hljs-name\x22\x3ewithLog\x3c\/span\x3e(\x3cspan class=\x22hljs-name\x22\x3eComponentA\x3c\/span\x3e))\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们定义一个工具函数：\x3ccode\x3ecompose(...functions)\x3c\/code\x3e，调用\x3ccode\x3ecompose(f, g, h) \x3c\/code\x3e等价于 \x3ccode\x3e(...args) =\x26gt; f(g(h(...args)))\x3c\/code\x3e。用\x3ccode\x3ecompose\x3c\/code\x3e函数我们可以把高阶组件嵌套的写法打平：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const enhance = compose(\n  connect(componentASelector),\n  withLog\n);\nconst ConnectedComponentA = enhance(ComponentA);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lisp\x22\x3e\x3ccode\x3econst enhance = compose(\n  \x3cspan class=\x22hljs-name\x22\x3econnect\x3c\/span\x3e(\x3cspan class=\x22hljs-name\x22\x3ecomponentASelector\x3c\/span\x3e),\n  withLog\n)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\nconst ConnectedComponentA = enhance(\x3cspan class=\x22hljs-name\x22\x3eComponentA\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e像Redux等很多第三方库都提供了\x3ccode\x3ecompose\x3c\/code\x3e的实现，\x3ccode\x3ecompose\x3c\/code\x3e结合高阶组件使用，可以显著提高代码的可读性和逻辑的清晰度。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e4.与父组件区别\x3c\/h3\x3e\n\x3cp\x3e有些同学可能会觉得高阶组件有些类似父组件的使用。例如，我们完全可以把高阶组件中的逻辑放到一个父组件中去执行，执行完成的结果再传递给子组件。从逻辑的执行流程上来看，高阶组件确实和父组件比较相像，但是高阶组件强调的是逻辑的抽象。高阶组件是一个函数，函数关注的是逻辑；父组件是一个组件，组件主要关注的是UI\/DOM。如果逻辑是与DOM直接相关的，那么这部分逻辑适合放到父组件中实现；如果逻辑是与DOM不直接相关的，那么这部分逻辑适合使用高阶组件抽象，如数据校验、请求发送等。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e5. 注意事项\x3c\/h3\x3e\n\x3cp\x3e1）\x3cstrong\x3e不要在组件的render方法中使用高阶组件，尽量也不要在组件的其他生命周期方法中使用高阶组件。\x3c\/strong\x3e因为高阶组件每次都会返回一个新的组件，在render中使用会导致每次渲染出来的组件都不相等（\x3ccode\x3e===\x3c\/code\x3e），于是每次render，组件都会卸载（unmount），然后重新挂载（mount），既影响了效率，又丢失了组件及其子组件的状态。高阶组件最适合使用的地方是在组件定义的外部，这样就不会受到组件生命周期的影响了。\x3c\/p\x3e\n\x3cp\x3e2）\x3cstrong\x3e如果需要使用被包装组件的静态方法，那么必须手动拷贝这些静态方法。\x3c\/strong\x3e因为高阶组件返回的新组件，是不包含被包装组件的静态方法。\x3ca href=\x22https:\/\/github.com\/mridgway\/hoist-non-react-statics\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehoist-non-react-statics\x3c\/a\x3e可以帮助我们方便的拷贝组件所有的自定义静态方法。有兴趣的同学可以自行了解。\x3c\/p\x3e\n\x3cp\x3e3）\x3cstrong\x3eRefs不会被传递给被包装组件。\x3c\/strong\x3e尽管在定义高阶组件时，我们会把所有的属性都传递给被包装组件，但是\x3ccode\x3eref\x3c\/code\x3e并不会传递给被包装组件，因为\x3ccode\x3eref\x3c\/code\x3e根本不属于React组件的属性。如果你在高阶组件的返回组件中定义了\x3ccode\x3eref\x3c\/code\x3e，那么它指向的是这个返回的新组件，而不是内部被包装的组件。如果你希望获取被包装组件的引用，你可以把\x3ccode\x3eref\x3c\/code\x3e的回调函数定义成一个普通属性（给它一个ref以外的名字）。下面的例子就用inputRef这个属性名代替了常规的ref命名：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function FocusInput({ inputRef, ...rest }) {\n  return \x3cinput ref={inputRef} {...rest} \/\x3e;\n}\n\n\/\/enhance 是一个高阶组件\nconst EnhanceInput = enhance(FocusInput);\n\n\/\/ 在一个组件的render方法中...\nreturn (\x3cEnhanceInput \n  inputRef={(input) =\x3e {\n    this.input = input\n  }\n}\x3e)\n\n\/\/ 让FocusInput自动获取焦点\nthis.input.focus();\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFocusInput\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e({ inputRef, \x3cspan class=\x22hljs-rest_arg\x22\x3e...rest\x3c\/span\x3e })\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;input ref={inputRef} {...rest} \/\x26gt;;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/enhance 是一个高阶组件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e EnhanceInput = enhance(FocusInput);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在一个组件的render方法中...\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x26lt;EnhanceInput \n  inputRef={(input) =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input = input\n  }\n}\x26gt;)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 让FocusInput自动获取焦点\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.input.focus();\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3e欢迎关注我的公众号：老干部的大前端，领取21本大前端精选书籍！\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bV4lGT?w=540\x26amp;h=193\x22 src=\x22https:\/\/static.alili.tech\/img\/bV4lGT?w=540\x26amp;h=193\x22 alt=\x223808299627-5a93ba468b59a\x22 title=\x223808299627-5a93ba468b59a\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>深入理解React 高阶组件</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010307650">https://segmentfault.com/a/1190000010307650</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/cvayxl3wvpi/" target="_blank">https://alili.tech/archive/cvayxl3wvpi/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/t42iv2yle7e/">2016-我的前端之路:工具化与工程化<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/xlhryjzdso/">2016年总结--成长<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/4wvjfeus9ur/">2016年末总结，我的前端之路<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/w7062tmcw3/">3D 视差效果<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/5jt1iw1t77b/">AlloyTouch实战--60行代码搞定QQ看点资料卡<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/kquf0fxkw2j/">ES6，你不得不学！<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/r5b6g4133jh/">Emmet-前端开发神器<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/5dbaikv4emi/">FreeCodeCamp中级算法题答案<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/iuyeljg6lm/">JSONP是什么<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/23ftsgrtzzc/">JS中的观察者模式(发布订阅)<aside class="dates">2019-01-29</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>