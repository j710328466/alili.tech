<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JS 中的 This 别再被问倒了，面试常见问题分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JS 中的 This 别再被问倒了，面试常见问题分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/z1mb1bkel1/",
				"appid": "1613049289050283", 
				"title": "JS 中的 This 别再被问倒了，面试常见问题分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-15T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ai4fjy26e6/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/65fk89jl90u/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f&text=JS%20%e4%b8%ad%e7%9a%84%20This%20%e5%88%ab%e5%86%8d%e8%a2%ab%e9%97%ae%e5%80%92%e4%ba%86%ef%bc%8c%e9%9d%a2%e8%af%95%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f&text=JS%20%e4%b8%ad%e7%9a%84%20This%20%e5%88%ab%e5%86%8d%e8%a2%ab%e9%97%ae%e5%80%92%e4%ba%86%ef%bc%8c%e9%9d%a2%e8%af%95%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f&title=JS%20%e4%b8%ad%e7%9a%84%20This%20%e5%88%ab%e5%86%8d%e8%a2%ab%e9%97%ae%e5%80%92%e4%ba%86%ef%bc%8c%e9%9d%a2%e8%af%95%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f&is_video=false&description=JS%20%e4%b8%ad%e7%9a%84%20This%20%e5%88%ab%e5%86%8d%e8%a2%ab%e9%97%ae%e5%80%92%e4%ba%86%ef%bc%8c%e9%9d%a2%e8%af%95%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JS%20%e4%b8%ad%e7%9a%84%20This%20%e5%88%ab%e5%86%8d%e8%a2%ab%e9%97%ae%e5%80%92%e4%ba%86%ef%bc%8c%e9%9d%a2%e8%af%95%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f&title=JS%20%e4%b8%ad%e7%9a%84%20This%20%e5%88%ab%e5%86%8d%e8%a2%ab%e9%97%ae%e5%80%92%e4%ba%86%ef%bc%8c%e9%9d%a2%e8%af%95%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f&title=JS%20%e4%b8%ad%e7%9a%84%20This%20%e5%88%ab%e5%86%8d%e8%a2%ab%e9%97%ae%e5%80%92%e4%ba%86%ef%bc%8c%e9%9d%a2%e8%af%95%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f&title=JS%20%e4%b8%ad%e7%9a%84%20This%20%e5%88%ab%e5%86%8d%e8%a2%ab%e9%97%ae%e5%80%92%e4%ba%86%ef%bc%8c%e9%9d%a2%e8%af%95%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fz1mb1bkel1%2f&title=JS%20%e4%b8%ad%e7%9a%84%20This%20%e5%88%ab%e5%86%8d%e8%a2%ab%e9%97%ae%e5%80%92%e4%ba%86%ef%bc%8c%e9%9d%a2%e8%af%95%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JS 中的 This 别再被问倒了，面试常见问题分析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-15" itemprop="datePublished">2019-01-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eGitHub地址：\x3ca href=\x22https:\/\/github.com\/SimonZhangITer\/MyBlog\/issues\/12\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/SimonZhang...\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3ethis的指向问题应该是让每一个前端er都头疼的问题，我也一样，曾经遇到甚至都是一顿乱猜。最近在研读一些书籍如《你不知道的JavaScript》和《JavaScript语言精粹与编程实践》，让我对this的问题豁然开朗。故写下此篇文章，分享一下我的心得。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e隐式绑定\x3c\/h1\x3e\n\x3cp\x3e关于this，一般来说，谁调用了方法，该方法的this就指向谁，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n    console.log(this.a)\n}\n\nvar a = 3;\n\nvar obj = {\n    a: 2,\n    foo: foo\n};\n\nobj.foo(); \/\/ 输出2,因为是obj调用的foo，所以foo的this指向了obj，而obj.a = 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo\n};\n\nobj.foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出2,因为是obj调用的foo，所以foo的this指向了obj，而obj.a = 2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果存在多次调用，\x3ccode\x3e对象属性引用链只有上一层或者说最后一层在调用位置中起作用\x3c\/code\x3e，如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n    console.log( this.a )\n}\n\nvar obj2 = { \n    a: 42,\n    foo: foo\n}\n\nvar obj1 = {\n    a: 2,\n    obj2: obj2\n}\n\nobj1.obj2.foo(); \/\/ 42\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a )\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = { \n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e42\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eobj2\x3c\/span\x3e: obj2\n}\n\nobj1.obj2.foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 42\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e隐式丢失\x3c\/h2\x3e\n\x3cp\x3e一个最常见的this绑定问题就是被\x3ccode\x3e隐式绑定\x3c\/code\x3e的函数会丢失绑定对象，也就是说他回应用默认绑定，从而把this绑定到全局对象或者undefined上，取决于是否是严格模式。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n    console.log( this.a )\n}\n\nvar obj1 = {\n    a: 2,\n    foo: foo\n}\n\nvar bar = obj1.foo; \/\/ 函数别名！\n\nvar a = \x26quot;oops, global\x26quot;; \/\/ a是全局对象的属性\n\nbar(); \/\/ \x26quot;oops, global\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a )\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = obj1.foo; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 函数别名！\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-string\x22\x3e\x22oops, global\x22\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a是全局对象的属性\x3c\/span\x3e\n\nbar(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22oops, global\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e虽然bar是obj.foo的一个引用，但是实际上，它引用的是foo函数本身，因此此时的bar()其实是一个不带任何修饰的函数调用，因此应用了默认绑定\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e一个更微妙、更常见并且更出乎意料的情况发生在\x3ccode\x3e传入回调函数时\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n    console.log( this.a )\n}\n\nfunction doFoo( fn ){\n    \/\/ fn 其实引用的是 foo\n    fn(); \/\/ \x3c-- 调用位置！\n}\n\nvar obj = {\n    a: 2,\n    foo: foo\n}\n\nvar a = \x26quot;oops, global\x26quot;; \/\/ a是全局对象的属性\n\ndoFoo( obj.foo ); \/\/ \x26quot;oops, global\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a )\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoFoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e fn \x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ fn 其实引用的是 foo\x3c\/span\x3e\n    fn(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;-- 调用位置！\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-string\x22\x3e\x22oops, global\x22\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ a是全局对象的属性\x3c\/span\x3e\n\ndoFoo( obj.foo ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22oops, global\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e参数传递其实就是一种隐式赋值\x3c\/code\x3e，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样，如果把函数传入语言内置的函数而不是传入自己声明的函数（如setTimeout等），\x3ccode\x3e结果也是一样的\x3c\/code\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e显式绑定\x3c\/h1\x3e\n\x3cp\x3e简单的说，就是指定this，如：call、apply、bind、new绑定等\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e硬绑定\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo( something ) {\n    console.log( this.a, something)\n    return this.a \x2b something\n}\n\nvar obj = {\n    a: 2\n}\n\nvar bar = function() {\n    return foo.apply( obj, arguments)\n}\n\nvar b = bar(3); \/\/ 2 3\nconsole.log(b); \/\/ 5\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e something \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a, something)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a \x2b something\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e foo.apply( obj, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = bar(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2 3\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里简单做一下解释：\x3cbr\x3e在bar函数中，foo使用apply函数绑定了obj，也就是说foo中的this将指向obj，与此同时，使用arguments（不限制传入参数的数量）作为参数传入foo函数中；所以在运行bar(3)的时候，首先输出obj.a也就是2和传入的3，然后foo返回了两者的相加值，所以b的值为5\x3c\/p\x3e\n\x3cp\x3e同样，本例也可以使用\x3ccode\x3ebind\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo( something ) {\n    console.log( this.a, something)\n    return this.a \x2b something\n}\n\nvar obj = {\n    a: 2\n}\n\nvar bar = foo.bind(obj)\n\nvar b = bar(3); \/\/ 2 3\nconsole.log(b); \/\/ 5\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e something \x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a, something)\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a \x2b something\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = foo.bind(obj)\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = bar(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2 3\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3enew绑定\x3c\/h2\x3e\n\x3cp\x3e在传统面向类的语言中，使用new初始化类的时候会调用类中的构造函数，但是JS中new的机制实际上和面向类和语言完全不同。\x3c\/p\x3e\n\x3cp\x3e使用\x3ccode\x3enew\x3c\/code\x3e来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e创建（或者说构造）一个全新的对象\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e这个新对象会被执行[[Prototype]]连接\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e这个新对象会绑定到函数调用的this\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果函数没有返回其他对象，那么new表达式中的函数会自动返回这个新对象\x3cbr\x3e如：\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(a){\n    this.a = a\n}\n\nvar bar = new foo(2);\nconsole.log(bar.a); \/\/ 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = a\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e foo(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(bar.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用new来调用foo(...)时，我们会构造一个新对象并把它绑定到foo(...)调用中的this上。new是最后一种可以影响函数调用时this绑定行为的方法，我们称之为new绑定。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader5\x22\x3ethis的优先级\x3c\/h1\x3e\n\x3cp\x3e毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。\x3c\/p\x3e\n\x3cp\x3e隐式绑定和显式绑定哪个优先级更高？我们来测试一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(a){\n    console.log(this.a)\n}\n\nvar obj1 = {\n    a: 2,\n    foo: foo\n}\n\nvar obj2 = {\n    a: 3,\n    foo: foo\n}\n\nobj1.foo(); \/\/ 2\nobj2.foo(); \/\/ 3\n\nobj1.foo.call(obj2); \/\/ 3\nobj2.foo.call(obj1); \/\/ 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo\n}\n\nobj1.foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\nobj2.foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\nobj1.foo.call(obj2); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\nobj2.foo.call(obj1); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，\x3ccode\x3e显式绑定\x3c\/code\x3e优先级更高，也就是说在判断时应当先考虑是否可以存在显式绑定。\x3c\/p\x3e\n\x3cp\x3e现在我们要搞清楚\x3ccode\x3enew绑定\x3c\/code\x3e和\x3ccode\x3e隐式绑定\x3c\/code\x3e的优先级谁高谁低 ：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(a){\n    this.a = something\n}\n\nvar obj1 = {\n    foo: foo\n}\n\nvar obj2 = {}\n\nobj1.foo(2); \nconsole.log(obj1.a); \/\/ 2\n\nobj1.foo.call(obj2,3);\nconsole.log(obj2.a); \/\/ 3\n\nvar bar = new obj1.foo(4)\nconsole.log(obj1.a); \/\/ 2\nconsole.log(bar.a); \/\/ 4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = something\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3efoo\x3c\/span\x3e: foo\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {}\n\nobj1.foo(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj1.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\nobj1.foo.call(obj2,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj2.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e obj1.foo(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj1.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(bar.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到\x3ccode\x3enew绑定\x3c\/code\x3e比\x3ccode\x3e隐式绑定\x3c\/code\x3e优先级高。但是\x3ccode\x3enew绑定\x3c\/code\x3e和\x3ccode\x3e显式绑定\x3c\/code\x3e谁的优先级更高呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(something){\n    this.a = something\n}\n\nvar obj1 = {}\n\nvar bar = foo.bind(obj1);\nbar(2);\nconsole.log(obj1.a); \/\/ 2\n\nvar baz = new bar(3);\nconsole.log(obj1.a); \/\/ 2\nconsole.log(baz.a); \/\/ 3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esomething\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = something\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = foo.bind(obj1);\nbar(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj1.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e baz = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e bar(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj1.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(baz.a); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，\x3ccode\x3enew绑定\x3c\/code\x3e修改了\x3ccode\x3e硬绑定\x3c\/code\x3e中的this，所以\x3ccode\x3enew绑定\x3c\/code\x3e的优先级比\x3ccode\x3e显式绑定\x3c\/code\x3e更高。\x3c\/p\x3e\n\x3cp\x3e之所以要在new中使用硬绑定函数，主要目的是预先设置函数的一些参数，这样在使用new进行初始化时就可以只传入其余的参数。bind(...)的功能之一就是可以把除了第一个参数（第一个参数用于绑定this）之外的其他参数都传给下层的函数（这种技术称为“部分应用”，是“\x3ccode\x3e柯里化\x3c\/code\x3e”的一种）。举例来说：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(p1,p2){\n    this.val = p1 \x2b p2;\n}\n\n\/\/ 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么\n\/\/ 反正使用new时this会被修改\nvar bar = foo.bind(null,\x27p1\x27);\n\nvar baz = new bar(\x27p2\x27);\n\nbaz.val; \/\/ p1p2\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ep1,p2\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.val = p1 \x2b p2;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 之所以使用null是因为在本例中我们并不关心硬绑定的this是什么\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 反正使用new时this会被修改\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = foo.bind(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27p1\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e baz = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e bar(\x3cspan class=\x22hljs-string\x22\x3e\x27p2\x27\x3c\/span\x3e);\n\nbaz.val; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ p1p2\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e柯里化:在直觉上，柯里化声称“如果你固定某些参数，你将得到接受余下参数的一个函数”。所以对于有两个变量的函数yx，如果固定了 y = 2，则得到有一个变量的函数 2x\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3eThis在箭头函数中的应用\x3c\/h1\x3e\n\x3cp\x3e箭头函数不使用this的四种标准规则，而是根据外层（函数或者全局）作用域来决定this。\x3c\/p\x3e\n\x3cp\x3e我们来看一下箭头函数的词法作用域：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n    \/\/ 返回一个箭头函数\n    return (a) =\x3e {\n        \/\/ this继承自foo()\n        console.log(this.a)\n    };\n}\n\nvar obj1 = {\n    a: 2\n};\n\nvar obj2 = {\n    a: 3\n};\n\nvar bar = foo.call(obj1);\nbar.call(obj2); \/\/ 2, 不是3！\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回一个箭头函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this继承自foo()\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a)\n    };\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = foo.call(obj1);\nbar.call(obj2); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2, 不是3！\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3efoo()内部创建的箭头函数会捕获调用时foo()的this。由于foo()的this绑定到obj1，bar（引用箭头函数）的this也会绑定到obj1，箭头函数的绑定无法被修改。（new也不行!）\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader7\x22\x3e总结\x3c\/h1\x3e\n\x3cp\x3e如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面这四条规则来判断this的绑定对象。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e由new调用？绑定到新创建的对象。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e由call或者apply（或者bind）调用？绑定到指定的对象。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e由上下文对象调用？绑定到那个上下文对象。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e默认：在严格模式下绑定到undefined，否则绑定到全局对象。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JS 中的 This 别再被问倒了，面试常见问题分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009215974">https://segmentfault.com/a/1190000009215974</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/z1mb1bkel1/" target="_blank">https://alili.tech/archive/z1mb1bkel1/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>