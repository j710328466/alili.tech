<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="[译]关于Node.js streams你需要知道的一切"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>[译]关于Node.js streams你需要知道的一切 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/k10d0an1g0d/",
				"appid": "1613049289050283", 
				"title": "[译]关于Node.js streams你需要知道的一切 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-12T02:30:24"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/cj2admd85n5/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/o8xqfd9kkt/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f&text=%5b%e8%af%91%5d%e5%85%b3%e4%ba%8eNode.js%20streams%e4%bd%a0%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e5%88%87"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f&text=%5b%e8%af%91%5d%e5%85%b3%e4%ba%8eNode.js%20streams%e4%bd%a0%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e5%88%87"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f&title=%5b%e8%af%91%5d%e5%85%b3%e4%ba%8eNode.js%20streams%e4%bd%a0%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e5%88%87"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f&is_video=false&description=%5b%e8%af%91%5d%e5%85%b3%e4%ba%8eNode.js%20streams%e4%bd%a0%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e5%88%87"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%5b%e8%af%91%5d%e5%85%b3%e4%ba%8eNode.js%20streams%e4%bd%a0%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e5%88%87&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f&title=%5b%e8%af%91%5d%e5%85%b3%e4%ba%8eNode.js%20streams%e4%bd%a0%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e5%88%87"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f&title=%5b%e8%af%91%5d%e5%85%b3%e4%ba%8eNode.js%20streams%e4%bd%a0%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e5%88%87"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f&title=%5b%e8%af%91%5d%e5%85%b3%e4%ba%8eNode.js%20streams%e4%bd%a0%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e5%88%87"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fk10d0an1g0d%2f&title=%5b%e8%af%91%5d%e5%85%b3%e4%ba%8eNode.js%20streams%e4%bd%a0%e9%9c%80%e8%a6%81%e7%9f%a5%e9%81%93%e7%9a%84%e4%b8%80%e5%88%87"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">[译]关于Node.js streams你需要知道的一切</h1><div class="meta"><div class="postdate"><time datetime="2019-01-12" itemprop="datePublished">2019-01-12</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3eNode.js的stream模块是有名的应用困难，更别说理解了。那现在可以告诉你，这些都不是问题了。\x3c\/p\x3e\n\x3cp\x3e多年来，开发人员在那里创建了大量的软件包，其唯一目的就是使用stream使用起来更简单，但是在这篇文章里，我们专注于介绍原生的Node.js Steam Api。\x3c\/p\x3e\n\x3cp\x3e\x22Stream 是Node.js中最好的却最容易被误解的部分\x22 ----- Dominic Tarr\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3eStreams到底是什么\x3c\/h1\x3e\n\x3cp\x3eStreams是数据的集合，就跟数组和字符串一样。不同点就在于Streams可能不是立刻就全部可用，并且不会全部载入内存。这使得他非常适合处理大量数据，或者处理每隔一段时间有一个数据片段传入的情况。\x3c\/p\x3e\n\x3cp\x3e但是，Stream并不仅仅适用于处理大数据(大块的数据。。。)。使用它，同样也有利于组织我们大代码。就像我们使用管道去和合并强大的Linux命令。在Node.js中，我们也可以做同样的事情。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVO90e?w=800\x26amp;h=102\x22 src=\x22https:\/\/static.alili.tech\/img\/bVO90e?w=800\x26amp;h=102\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const grep = ... \/\/ A stream for the grep output\nconst wc = ... \/\/ A stream for the wc input\ngrep.pipe(wc)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e grep = ... \x3cspan class=\x22hljs-comment\x22\x3e\/\/ A stream for the grep output\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e wc = ... \x3cspan class=\x22hljs-comment\x22\x3e\/\/ A stream for the wc input\x3c\/span\x3e\ngrep.pipe(wc)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eNode.js的很多内置模块都实现了Stream接口\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVO90l?w=800\x26amp;h=473\x22 src=\x22https:\/\/static.alili.tech\/img\/bVO90l?w=800\x26amp;h=473\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面例子里面的Node.js对象列表包括了可读流和可写流，有一些对象既是可读流也是可写流，像TCP sockets, zlib 和 crypto streams。\x3c\/p\x3e\n\x3cp\x3e注意这些对象是有很密切的关联的。当一个客户端的HTTP 响应对象是一个可读流，那么在服务器端这就是一个可写流。因为在HTTP例子中，我们通常是从一个对象(\x3ccode\x3ehttp.IncomingMessage\x3c\/code\x3e)读取再写入到另外一个对象(\x3ccode\x3ehttp.ServerResponse\x3c\/code\x3e)中去。\x3c\/p\x3e\n\x3cp\x3e还要注意，当涉及到子进程时，\x3ccode\x3estdio\x3c\/code\x3e流（\x3ccode\x3estdin\x3c\/code\x3e，\x3ccode\x3estdout\x3c\/code\x3e，\x3ccode\x3estderr\x3c\/code\x3e）具有逆流类型。这就允许我们非常方便的使用管道从主进程连接子进程的\x3ccode\x3eStreams\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e一些实例的Streams例子\x3c\/h1\x3e\n\x3cp\x3e理论都是很好的，但事实到底是怎么样子的呢？让我们看一些例子示范代码\x3ccode\x3eStreams\x3c\/code\x3e在内存使用方面的比较。\x3c\/p\x3e\n\x3cp\x3e我们先创建一个大文件\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\nconst file = fs.createWriteStream(\x27.\/big.file\x27);\n\nfor(let i=0; i\x3c= 1e6; i\x2b\x2b) {\n  file.write(\x27Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\\n\x27);\n}\n\nfile.end();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = require(\x27fs\x27);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efile\x3c\/span\x3e = fs.createWriteStream(\x27.\/big.\x3cspan class=\x22hljs-keyword\x22\x3efile\x3c\/span\x3e\x27);\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(let i=0; i\x26lt;= 1e6; i\x2b\x2b) {\n  \x3cspan class=\x22hljs-keyword\x22\x3efile\x3c\/span\x3e.write(\x27Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed \x3cspan class=\x22hljs-keyword\x22\x3edo\x3c\/span\x3e eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip \x3cspan class=\x22hljs-keyword\x22\x3eex\x3c\/span\x3e ea commodo consequat. Duis aute irure dolor \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e reprehenderit \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e culpa \x3cspan class=\x22hljs-keyword\x22\x3equi\x3c\/span\x3e officia deserunt mollit anim id \x3cspan class=\x22hljs-keyword\x22\x3eest\x3c\/span\x3e laborum.\\\x3cspan class=\x22hljs-keyword\x22\x3en\x3c\/span\x3e\x27);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3efile\x3c\/span\x3e.end();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看看我使用什么创建文件的？一个可写流嘛\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3efs\x3c\/code\x3e模块可以通过\x3ccode\x3eStream\x3c\/code\x3e接口来读取和写入文件。在上面的例子中，我们在循环中通过可写流向\x3ccode\x3ebig.file\x3c\/code\x3e写入了1百万行数据。\x3c\/p\x3e\n\x3cp\x3e运行上面的代码会生成一个大概400M的文件\x3c\/p\x3e\n\x3cp\x3e这是一个简单的Node web服务器，专门为\x3ccode\x3ebig.file\x3c\/code\x3e提供服务：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\nconst server = require(\x27http\x27).createServer();\n\nserver.on(\x27request\x27, (req, res) =\x3e {\n  fs.readFile(\x27.\/big.file\x27, (err, data) =\x3e {\n    if (err) throw err;\n  \n    res.end(data);\n  });\n});\n\nserver.listen(8000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\nconst server = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27http\x27\x3c\/span\x3e).createServer();\n\nserver.\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27request\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(req, res)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  fs.readFile(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/big.file\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(err, data)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (err) \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e err;\n  \n    res.end(data);\n  });\n});\n\nserver.listen(\x3cspan class=\x22hljs-number\x22\x3e8000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当\x3ccode\x3eserver\x3c\/code\x3e收到请求，它会使用异步方法\x3ccode\x3efs.readFile\x3c\/code\x3e处理这个\x3ccode\x3ebig file\x3c\/code\x3e。但是这并不代表我们会打断事件循环机制。一切都是正确的吗？？\x3c\/p\x3e\n\x3cp\x3e那现在当我们启动\x3ccode\x3eserver\x3c\/code\x3e，看看内存监视器都发生了什么。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVO925?w=800\x26amp;h=422\x22 src=\x22https:\/\/static.alili.tech\/img\/bVO925?w=800\x26amp;h=422\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e现在访问这个服务器，看看内存的使用情况。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVPfUo?w=800\x26amp;h=614\x22 src=\x22https:\/\/static.alili.tech\/img\/bVPfUo?w=800\x26amp;h=614\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e内存占用立刻飙升到434.8 MB。\x3c\/p\x3e\n\x3cp\x3e在我们把文件内容输出到客户端之前，我们就把整个文件读入了内存。这是很低效的。\x3c\/p\x3e\n\x3cp\x3eHTTP response对象(上文中的\x3ccode\x3eres\x3c\/code\x3e对象)也是一个可写流，这就意味着如果我们有一个代表着\x3ccode\x3ebig file\x3c\/code\x3e的可读流，我们可以通过管道把他们俩连接起来实现同样的功能，而不需要使用400M内存。\x3c\/p\x3e\n\x3cp\x3eNode的\x3ccode\x3efs\x3c\/code\x3e模块给我们提供了一个可以操作任何文件的可读流,通过\x3ccode\x3ecreateReadStream\x3c\/code\x3e方法创建。我们可以把它和response对象连接起来。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\nconst server = require(\x27http\x27).createServer();\n\nserver.on(\x27request\x27, (req, res) =\x3e {\n  const src = fs.createReadStream(\x27.\/big.file\x27);\n  src.pipe(res);\n});\n\nserver.listen(8000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e server = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27http\x27\x3c\/span\x3e).createServer();\n\nserver.on(\x3cspan class=\x22hljs-string\x22\x3e\x27request\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereq, res\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e src = fs.createReadStream(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/big.file\x27\x3c\/span\x3e);\n  src.pipe(res);\n});\n\nserver.listen(\x3cspan class=\x22hljs-number\x22\x3e8000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在再去访问server的时候，令人惊讶的事情发生了(看内存监视器)\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVPaMa?w=800\x26amp;h=615\x22 src=\x22https:\/\/static.alili.tech\/img\/bVPaMa?w=800\x26amp;h=615\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e发生了什么？\x3c\/p\x3e\n\x3cp\x3e当我们访问服务器的时候，我们通过流每次使用一段数据，这意味着我们不是把全部的数据都加载到内存中。内存使用量只上升了不到25M。\x3c\/p\x3e\n\x3cp\x3e可以把上面的例子用到极致，生成5百万行数据而不是1百万行。这样子的话，这个文件的大小会超过2GB，这实际上大于Node中的默认缓冲区限制。\x3c\/p\x3e\n\x3cp\x3e如果你想在server上使用\x3ccode\x3efs.readFile\x3c\/code\x3e,这在默认情况下是行不通的，除非你改了Node.js的默认缓冲区限制。但是使用\x3ccode\x3efs.createReadStream\x3c\/code\x3e，把2 GB的数据返回给客户端根本不存在问题，甚至内存使用量都没有任何变化。\x3c\/p\x3e\n\x3cp\x3e准备好学习Steam了吗？\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3eStreams 101\x3c\/h1\x3e\n\x3cp\x3e在Node.js中有4中基本的流类型：Readable, Writable, Duplex, and Transform streams。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eReadable 可读流是可以从中消耗数据的源的抽象，一个例子就是\x3ccode\x3efs.createReadStream\x3c\/code\x3e方法\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eWritable 可写流是可以写入数据的目标的抽象，一个例子就是\x3ccode\x3efs.createWriteStream\x3c\/code\x3e方法\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eduplex Steam是一个同时具有读写功能的流，一个例子就是TCP socket\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTransform 是一个双工流，它可以在交换数据的时候做转换。一个例子就是\x3ccode\x3ezlib.createGzip\x3c\/code\x3e使用gzip压缩数据。你可以把Transform streams当成是一个传入可读流，返回一个可写流的函数。它还有一个别名\x3ccode\x3ethrough streams\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e所有的Stream都是\x3ccode\x3eEventEmitter\x3c\/code\x3e的实例对象。当流读和写的时候都会触发相应的事件。但是还有一个更简单的使用方法，那就是使用\x3ccode\x3epipe\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eThe pipe method\x3c\/h2\x3e\n\x3cp\x3e要记住下面这个魔幻方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22readableSrc.pipe(writableDest)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ereadableSrc\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-tag\x22\x3ewritableDest\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这一行里面，我们通过管道把可读流(源)输出到一个可写流里面去(目标)，源必须是一个可写流，目标必须是可写流。当然，他们也都可以是duplex\/Transform。事实上，当我们使用管道连接流的时候，我们可以像在linux中一样使用链式连接。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22readableSrc\n  .pipe(transformStream1)\n  .pipe(transformStream2)\n  .pipe(finalWrtitableDest)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ereadableSrc\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-tag\x22\x3etransformStream1\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-tag\x22\x3etransformStream2\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-tag\x22\x3efinalWrtitableDest\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3epipe\x3c\/code\x3e方法返回目标流，这保证了我们可以使用链式调用。对于streams a(可读流)，b,c(可读可写流)，d可写流，我们可以使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22a.pipe(b).pipe(c).pipe(d)\n# Which is equivalent to:\na.pipe(b)\nb.pipe(c)\nc.pipe(d)\n# Which, in Linux, is equivalent to:\n$ a | b | c | d\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs swift\x22\x3e\x3ccode\x3ea.pipe(b).pipe(\x3cspan class=\x22hljs-built_in\x22\x3ec\x3c\/span\x3e).pipe(d)\n# \x3cspan class=\x22hljs-type\x22\x3eWhich\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e equivalent to:\na.pipe(b)\nb.pipe(\x3cspan class=\x22hljs-built_in\x22\x3ec\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3ec\x3c\/span\x3e.pipe(d)\n# \x3cspan class=\x22hljs-type\x22\x3eWhich\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eLinux\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3eis\x3c\/span\x3e equivalent to:\n$ a | b | \x3cspan class=\x22hljs-built_in\x22\x3ec\x3c\/span\x3e | d\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3epipe\x3c\/code\x3e方法是使用流最简便的方法。通常通过管道和事件的方法使用流，但是要尽量避免两者混用。通常当你使用\x3ccode\x3epipe\x3c\/code\x3e方法就不需要使用事件了。但是当你需要更多定制的操作的话，使用事件的方式会更好。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eStream events\x3c\/h2\x3e\n\x3cp\x3e除了从可读流读取数据传输到可写流，\x3ccode\x3epipe\x3c\/code\x3e方法还自动处理一些其他事情。比如处理错误，处理文件结束操作，流之间速度快慢问题。\x3c\/p\x3e\n\x3cp\x3e同时，流也可以直接使用事件操作。以下是和管道相等的通过事件操作流的方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22# readable.pipe(writable)\n\nreadable.on(\x27data\x27, (chunk) =\x3e {\n  writable.write(chunk);\n});\n\nreadable.on(\x27end\x27, () =\x3e {\n  writable.end();\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e# readable.pipe(writable)\x3c\/span\x3e\n\nreadable.\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(chunk)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  writable.write(chunk);\n});\n\nreadable.\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27end\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  writable.end();\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面是一些重要流的事件和方法。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVPdu7?w=800\x26amp;h=459\x22 src=\x22https:\/\/static.alili.tech\/img\/bVPdu7?w=800\x26amp;h=459\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这些事件和方法在某种程度上是相关的，因为它们通常被一起使用。\x3c\/p\x3e\n\x3cp\x3e可读流上的最重要的事件是\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3edata\x3c\/code\x3e事件，当可读流传输了一段数据的时候会触发\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eend\x3c\/code\x3e事件，当没有数据被传输时触发\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e可写流上的最重要的事件是\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3edrain\x3c\/code\x3e事件，当可写流可以接收事件的时候被触发\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3efinish\x3c\/code\x3e事件，当所有数据被接收时被触发\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e事件和方法可以结合起来，以便定制和优化流的使用。读取可读流，我们可以使用\x3ccode\x3epipe\/unpipe\x3c\/code\x3e方法，或者\x3ccode\x3eread\/unshift\/resume\x3c\/code\x3e方法。使用可写流，我们可以可写流作为\x3ccode\x3epipe\/unpipe\x3c\/code\x3e方法的参数，或者使用\x3ccode\x3ewrite\x3c\/code\x3e方法写入，使用\x3ccode\x3eend\x3c\/code\x3e方法关闭。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e可读流的暂停和流动\x3c\/h2\x3e\n\x3cp\x3e可读流有两个很重要的模式影响了我们使用的方式。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e暂停模式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e流动模式\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这些模式有时候被称为拉和推模式\x3c\/p\x3e\n\x3cp\x3e所有的可读流开始的时候都是默认暂停模式，但是它们可以轻易的被切换成流动模式，当我们需要的时候又可以切换成暂停模式。有时候这个切换是自动的。\x3c\/p\x3e\n\x3cp\x3e当一个可读流是暂停模式的时候，我们可以使用\x3ccode\x3eread\x3c\/code\x3e方法从流中读取。但是当一个流是流动模式的时候，数据是持续的流动，我们需要使用事件去监听数据的变化。\x3c\/p\x3e\n\x3cp\x3e在流动模式中，如果可读流没有监听者，可读流的数据会丢失。这就是为什么当可读流逝流动模式的时候，我们必须使用\x3ccode\x3edata\x3c\/code\x3e事件去监听数据的变化。事实上，只需添加一个数据事件处理程序即可将暂停的流转换为流模式，删除数据事件处理程序将流切换回暂停模式。 其中一些是为了与旧的Node Stream接口进行向后兼容。\x3c\/p\x3e\n\x3cp\x3e可以使用\x3ccode\x3eresume()\x3c\/code\x3e和\x3ccode\x3epause()\x3c\/code\x3e方法在这两种模式之间切换。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVPea7?w=800\x26amp;h=445\x22 src=\x22https:\/\/static.alili.tech\/img\/bVPea7?w=800\x26amp;h=445\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e当我们使用\x3ccode\x3epipe\x3c\/code\x3e方法操作可读流的时候是不需要担心上面的这些操作的，因为\x3ccode\x3epipe\x3c\/code\x3e方法会自动帮我们处理这些问题。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e流的创建\x3c\/h1\x3e\n\x3cp\x3e当我们讨论Node.js中的流时，有两项重要的任务：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e流的创建\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e流的使用\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们到现在为止讨论的都是如何使用流，那下面来看看如何创建吧！\x3c\/p\x3e\n\x3cp\x3eStreams的创建通常使用\x3ccode\x3estream\x3c\/code\x3e模块。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e创建一个可写流\x3c\/h2\x3e\n\x3cp\x3e为了创建一个可写流，我们需要使用\x3ccode\x3estream\x3c\/code\x3e模块里面的\x3ccode\x3eWritable\x3c\/code\x3e类。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { Writable } = require(\x27stream\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { Writable } = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以有很多种方式实现一个可写流。例如，我们可以继承\x3ccode\x3eWritable\x3c\/code\x3e类。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class myWritableStream extends Writable {\n\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emyWritableStream\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWritable\x3c\/span\x3e \x3c\/span\x3e{\n\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是我更喜欢使用构造函数的方式创建。通过给\x3ccode\x3eWritable\x3c\/code\x3e传递一些参数来创建一个对象。唯一必须要传的选项时\x3ccode\x3ewrite\x3c\/code\x3e方法，它需要暴漏需要写入的数据块。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { Writable } = require(\x27stream\x27);\nconst outStream = new Writable({\n  write(chunk, encoding, callback) {\n    console.log(chunk.toString());\n    callback();\n  }\n});\n\nprocess.stdin.pipe(outStream);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { Writable } = require(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e outStream = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Writable({\n  \x3cspan class=\x22hljs-built_in\x22\x3ewrite\x3c\/span\x3e(chunk, encoding, callback) {\n    console.log(chunk.toString());\n    callback();\n  }\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.stdin.pipe(outStream);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ewrite\x3c\/code\x3e方法接收3个参数\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3echunk\x3c\/code\x3e通常是一个buffer对象，我们可以通过配置修改\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eencoding\x3c\/code\x3e在这种情况下就需要了，不过通常情况是可以忽略的\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecallback\x3c\/code\x3e是当我们处理完这个数据块的时候需要调用的函数。这是一个写入是否成功的信号。如果失败了，给这个回调传递一个\x3ccode\x3eError\x3c\/code\x3e对象\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e在\x3ccode\x3eoutStream\x3c\/code\x3e中，我们简单的把\x3ccode\x3echunk\x3c\/code\x3e打印出来，因为并没有发生错误，我们直接调用了\x3ccode\x3ecallback\x3c\/code\x3e方法。这是这是简单并不实用的\x3ccode\x3e打印\x3c\/code\x3e流。它会打印接收到的所有值。\x3c\/p\x3e\n\x3cp\x3e为了使用这个流，我们可以简单的\x3ccode\x3eprocess.stdin\x3c\/code\x3e这个可读流。通过\x3ccode\x3epipe\x3c\/code\x3e方法连接起来。\x3c\/p\x3e\n\x3cp\x3e当我们运行上面的例子，任何我们在控制台输入的内容都会被\x3ccode\x3econsole.log\x3c\/code\x3e打印出来。\x3c\/p\x3e\n\x3cp\x3e这不是一个非常实用的流的实现，但是它已经被Node.js内置实现了。\x3ccode\x3eoutStream\x3c\/code\x3e功能和\x3ccode\x3eprocess.stdout\x3c\/code\x3e基本类似。我们也可以通过\x3ccode\x3epipe\x3c\/code\x3e方法把\x3ccode\x3estdin\x3c\/code\x3e和\x3ccode\x3estdout\x3c\/code\x3e连接起来并实现同样的功能。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22process.stdin.pipe(process.stdout);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eprocess\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.stdin\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(\x3cspan class=\x22hljs-selector-tag\x22\x3eprocess\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.stdout\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e创建一个可读流\x3c\/h2\x3e\n\x3cp\x3e创建可读流，我们需要\x3ccode\x3eReadable\x3c\/code\x3e类\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { Readable } = require(\x27stream\x27);\nconst inStream = new Readable({});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { Readable } = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e inStream = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Readable({});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e创建一个可读流非常简单。可以使用\x3ccode\x3epush\x3c\/code\x3e方法推入数据给其他流使用\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { Readable } = require(\x27stream\x27); \nconst inStream = new Readable();\ninStream.push(\x27ABCDEFGHIJKLM\x27);\ninStream.push(\x27NOPQRSTUVWXYZ\x27);\ninStream.push(null); \/\/ No more data\ninStream.pipe(process.stdout);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gradle\x22\x3e\x3ccode\x3econst { Readable } = require(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e); \nconst inStream = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Readable();\ninStream.\x3cspan class=\x22hljs-keyword\x22\x3epush\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27ABCDEFGHIJKLM\x27\x3c\/span\x3e);\ninStream.\x3cspan class=\x22hljs-keyword\x22\x3epush\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27NOPQRSTUVWXYZ\x27\x3c\/span\x3e);\ninStream.\x3cspan class=\x22hljs-keyword\x22\x3epush\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ No more data\x3c\/span\x3e\ninStream.pipe(process.stdout);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们\x3ccode\x3epush\x3c\/code\x3e一个\x3ccode\x3enull\x3c\/code\x3e对象进去的时候，这就标志着我们要终止传输了。\x3c\/p\x3e\n\x3cp\x3e我们可以简单的把这个流通过\x3ccode\x3epipe\x3c\/code\x3e方法连接到一个可写流\x3ccode\x3eprocess.stdout\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e运行上面的代码，会获取所有的\x3ccode\x3einStream\x3c\/code\x3e的数据并打印出来。非常简单但有效。\x3c\/p\x3e\n\x3cp\x3e我们在通过\x3ccode\x3epipe\x3c\/code\x3e连接之前，就会把所有的数据推送到流里面。更好的方法是在消费者要求时按需推送数据。可以通过修改可读流配置里面的\x3ccode\x3eread()\x3c\/code\x3e方法实现。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const inStream = new Readable({\n  read(size) {\n    \/\/ there is a demand on the data... Someone wants to read it.\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e inStream = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Readable({\n  \x3cspan class=\x22hljs-built_in\x22\x3eread\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ there is a demand on the data... Someone wants to read it.\x3c\/span\x3e\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当读取方法在可读流上被调用时，该实现可以将部分数据推送到队列。 例如，我们可以一次推一个字母，从字符代码65（表示A）开始，并在每次推送时递增：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const inStream = new Readable({\n  read(size) {\n    this.push(String.fromCharCode(this.currentCharCode\x2b\x2b));\n    if (this.currentCharCode \x3e 90) {\n      this.push(null);\n    }\n  }\n});\ninStream.currentCharCode = 65;\ninStream.pipe(process.stdout);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e inStream = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Readable({\n  \x3cspan class=\x22hljs-built_in\x22\x3eread\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(\x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e.fromCharCode(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentCharCode\x2b\x2b));\n    \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentCharCode \x26gt; \x3cspan class=\x22hljs-number\x22\x3e90\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(null);\n    }\n  }\n});\ninStream.currentCharCode = \x3cspan class=\x22hljs-number\x22\x3e65\x3c\/span\x3e;\ninStream.pipe(\x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.stdout);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当有流在读取可读流的数据的时候，\x3ccode\x3eread\x3c\/code\x3e方法会持续执行，这样就会一直推出更多的字符。我们需要在某个时刻终止它，这就是为什么我们设置了一个终止条件推入了\x3ccode\x3enull\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e我们应该始终按需推送数据。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3eDuplex\/Transform 流的实现\x3c\/h2\x3e\n\x3cp\x3e使用Duplex流，我们通过同一个对象实现可读流和可写流。这类似同时实现了两个接口。\x3c\/p\x3e\n\x3cp\x3e下面这个例子就结合了上面两个可读流和可写流的综合例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { Duplex } = require(\x27stream\x27);\n\nconst inoutStream = new Duplex({\n  write(chunk, encoding, callback) {\n    console.log(chunk.toString());\n    callback();\n  },\n\n  read(size) {\n    this.push(String.fromCharCode(this.currentCharCode\x2b\x2b));\n    if (this.currentCharCode \x3e 90) {\n      this.push(null);\n    }\n  }\n});\n\ninoutStream.currentCharCode = 65;\nprocess.stdin.pipe(inoutStream).pipe(process.stdout);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { Duplex } = require(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e inoutStream = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Duplex({\n  \x3cspan class=\x22hljs-built_in\x22\x3ewrite\x3c\/span\x3e(chunk, encoding, callback) {\n    console.log(chunk.toString());\n    callback();\n  },\n\n  \x3cspan class=\x22hljs-built_in\x22\x3eread\x3c\/span\x3e(\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(\x3cspan class=\x22hljs-keyword\x22\x3eString\x3c\/span\x3e.fromCharCode(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentCharCode\x2b\x2b));\n    \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.currentCharCode \x26gt; \x3cspan class=\x22hljs-number\x22\x3e90\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(null);\n    }\n  }\n});\n\ninoutStream.currentCharCode = \x3cspan class=\x22hljs-number\x22\x3e65\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.stdin.pipe(inoutStream).pipe(\x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.stdout);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过合并这些方法，我们可以使用这个\x3ccode\x3eduplex\x3c\/code\x3e流读取从A-Z的字母也同样可以使用它的打印功能。我们把\x3ccode\x3estdin\x3c\/code\x3e流连接到这个\x3ccode\x3eduplex\x3c\/code\x3e上去使用它的打印功能，再把这个\x3ccode\x3eduplex\x3c\/code\x3e流本身连接到\x3ccode\x3estdout\x3c\/code\x3e上去就在控制台看到了A-Z。\x3c\/p\x3e\n\x3cp\x3e双工流的可读写的两侧完全独立运行。就像一个对象上两种独立的功能。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3etransform\x3c\/code\x3e流是一种更有趣的\x3ccode\x3eduplex\x3c\/code\x3e流。因为它的输出来源于她的输入。\x3c\/p\x3e\n\x3cp\x3e对于一个\x3ccode\x3etransform\x3c\/code\x3e流，我们不需要实现\x3ccode\x3eread\x3c\/code\x3e和\x3ccode\x3ewrite\x3c\/code\x3e方法，我们仅仅需要实现\x3ccode\x3etransform\x3c\/code\x3e方法，这个方法合并了它们两个。它具有写入方法的功能，也可以用它推送数据。\x3c\/p\x3e\n\x3cp\x3e这是一个简单的\x3ccode\x3etransform\x3c\/code\x3e例子，把任何输入转换成大写。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { Transform } = require(\x27stream\x27);\n\nconst upperCaseTr = new Transform({\n  transform(chunk, encoding, callback) {\n    this.push(chunk.toString().toUpperCase());\n    callback();\n  }\n});\n\nprocess.stdin.pipe(upperCaseTr).pipe(process.stdout);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { Transform } = require(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e upperCaseTr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Transform({\n  transform(chunk, encoding, callback) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(chunk.toString().toUpperCase());\n    callback();\n  }\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.stdin.pipe(upperCaseTr).pipe(\x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.stdout);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个\x3ccode\x3etransform\x3c\/code\x3estream里面，像上个例子中双工流一样。但是我们只实现了\x3ccode\x3etransform()\x3c\/code\x3e方法。我们把\x3ccode\x3echunk\x3c\/code\x3e转换成大写，再把大写字母作为可读流的输入。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3eStreams Object Mode\x3c\/h2\x3e\n\x3cp\x3e默认，流会接收 Buffer\/String 类型的数据。还有个字段 \x3ccode\x3eobjectMode\x3c\/code\x3e 设置，可以让stream 接收任意类型的对象。\x3c\/p\x3e\n\x3cp\x3e下面是一个这种类型的例子。以下变换流的组合使得将逗号分隔值的字符串映射为JavaScript对象的功能。 所以“a，b，c，d”成为{a：b，c：d}。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { Transform } = require(\x27stream\x27);\n\nconst commaSplitter = new Transform({\n  readableObjectMode: true,\n  transform(chunk, encoding, callback) {\n    this.push(chunk.toString().trim().split(\x27,\x27));\n    callback();\n  }\n});\n\nconst arrayToObject = new Transform({\n  readableObjectMode: true,\n  writableObjectMode: true,\n  transform(chunk, encoding, callback) {\n    const obj = {};\n    for(let i=0; i \x3c chunk.length; i\x2b=2) {\n      obj[chunk[i]] = chunk[i\x2b1];\n    }\n    this.push(obj);\n    callback();\n  }\n});\n\nconst objectToString = new Transform({\n  writableObjectMode: true,\n  transform(chunk, encoding, callback) {\n    this.push(JSON.stringify(chunk) \x2b \x27\\n\x27);\n    callback();\n  }\n});\n\nprocess.stdin\n  .pipe(commaSplitter)\n  .pipe(arrayToObject)\n  .pipe(objectToString)\n  .pipe(process.stdout)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { Transform } = require(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e commaSplitter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Transform({\n  readableObjectMode: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e,\n  transform(chunk, encoding, callback) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(chunk.toString().trim().split(\x3cspan class=\x22hljs-string\x22\x3e\x27,\x27\x3c\/span\x3e));\n    callback();\n  }\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arrayToObject = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Transform({\n  readableObjectMode: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e,\n  writableObjectMode: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e,\n  transform(chunk, encoding, callback) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = {};\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(let i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; chunk.length; i\x2b=\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n      obj[chunk[i]] = chunk[i\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(obj);\n    callback();\n  }\n});\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e objectToString = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Transform({\n  writableObjectMode: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e,\n  transform(chunk, encoding, callback) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.push(JSON.stringify(chunk) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\\n\x27\x3c\/span\x3e);\n    callback();\n  }\n});\n\nprocess.stdin\n  .pipe(commaSplitter)\n  .pipe(arrayToObject)\n  .pipe(objectToString)\n  .pipe(process.stdout)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们通过commasplitter传递输入字符串（例如，\x3ccode\x3e“a，b，c，d”\x3c\/code\x3e），它将数组作为其可读数据（\x3ccode\x3e[“a”，“b”，“c”，“d”]\x3c\/code\x3e））。 在该流上添加可读的\x3ccode\x3eObjectMode\x3c\/code\x3e标志是必要的，因为我们正在将对象推送到其上，而不是字符串。\x3c\/p\x3e\n\x3cp\x3e然后我们把数组导入到\x3ccode\x3earrayToObject\x3c\/code\x3e数据流中，我们需要把\x3ccode\x3ewritableObjectMode\x3c\/code\x3e设置为 \x3ccode\x3etrue\x3c\/code\x3e，以表示\x3ccode\x3earrayToObject\x3c\/code\x3e会接收一个对象。另外它还会推送一个对象出去，所以还要把他的\x3ccode\x3ereadableObjectMode\x3c\/code\x3e为\x3ccode\x3etrue\x3c\/code\x3e。最后一个\x3ccode\x3eobjectToString\x3c\/code\x3e接收一个对象但是输出字符串，所以就只需要设置一个\x3ccode\x3ewritableObjectMode\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVPfDe?w=482\x26amp;h=210\x22 src=\x22https:\/\/static.alili.tech\/img\/bVPfDe?w=482\x26amp;h=210\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3eNode.js内置transform streams对象\x3c\/h2\x3e\n\x3cp\x3eNode有一些非常有用的内置transform streams对象。这包括\x3ccode\x3ezlib\x3c\/code\x3e和\x3ccode\x3ecrypto\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e下面这个例子使用了\x3ccode\x3ezlib.createGzip()\x3c\/code\x3e结合了额\x3ccode\x3efs\x3c\/code\x3e readable\/writable streams实现了文件压缩。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\nconst zlib = require(\x27zlib\x27);\nconst file = process.argv[2];\n\nfs.createReadStream(file)\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream(file \x2b \x27.gz\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = require(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e zlib = require(\x3cspan class=\x22hljs-string\x22\x3e\x27zlib\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3efile\x3c\/span\x3e = process.argv[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e];\n\nfs.createReadStream(\x3cspan class=\x22hljs-keyword\x22\x3efile\x3c\/span\x3e)\n  .pipe(zlib.createGzip())\n  .pipe(fs.createWriteStream(\x3cspan class=\x22hljs-keyword\x22\x3efile\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27.gz\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你可以使用上面的脚本压缩任何你传入的参数文件。我们把文件的可读流传入了\x3ccode\x3ezlib\x3c\/code\x3e的内置转换流。再写入到新的.gz文件中。\x3c\/p\x3e\n\x3cp\x3e使用管道还有一个很酷的事情，就是可以和事件结合起来。比如我想用户看到进度，并在结束的时候发个消息。因为\x3ccode\x3epipe\x3c\/code\x3e方法会返回目标流，我们也可以通过链式注册事件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\nconst zlib = require(\x27zlib\x27);\nconst file = process.argv[2];\n\nfs.createReadStream(file)\n  .pipe(zlib.createGzip())\n  .on(\x27data\x27, () =\x3e process.stdout.write(\x27.\x27))\n  .pipe(fs.createWriteStream(file \x2b \x27.zz\x27))\n  .on(\x27finish\x27, () =\x3e console.log(\x27Done\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\nconst zlib = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27zlib\x27\x3c\/span\x3e);\nconst file = process.argv[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e];\n\nfs.createReadStream(file)\n  .pipe(zlib.createGzip())\n  .\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e process.stdout.write(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e))\n  .pipe(fs.createWriteStream(file \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27.zz\x27\x3c\/span\x3e))\n  .\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27finish\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Done\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以使用管道方法，我们可以轻松地操作流，但是我们还可以使用需要的事件进一步定制与这些流的交互。\x3c\/p\x3e\n\x3cp\x3e管道方法的好处是，我们可以用它来以一种可读的方式逐一构成我们的程序。 例如，我们可以简单地创建一个变换流来报告进度，而不用监听上面的数据事件，并用另一个\x3ccode\x3e.pipe()\x3c\/code\x3e调用替换 \x3ccode\x3e.on()\x3c\/code\x3e 调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const fs = require(\x27fs\x27);\nconst zlib = require(\x27zlib\x27);\nconst file = process.argv[2];\n\nconst { Transform } = require(\x27stream\x27);\n\nconst reportProgress = new Transform({\n  transform(chunk, encoding, callback) {\n    process.stdout.write(\x27.\x27);\n    callback(null, chunk);\n  }\n});\n\nfs.createReadStream(file)\n  .pipe(zlib.createGzip())\n  .pipe(reportProgress)\n  .pipe(fs.createWriteStream(file \x2b \x27.zz\x27))\n  .on(\x27finish\x27, () =\x3e console.log(\x27Done\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e fs = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27fs\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e zlib = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27zlib\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e file = process.argv[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e];\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { Transform } = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27stream\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e reportProgress = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Transform({\n  transform(chunk, encoding, callback) {\n    process.stdout.write(\x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e);\n    callback(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, chunk);\n  }\n});\n\nfs.createReadStream(file)\n  .pipe(zlib.createGzip())\n  .pipe(reportProgress)\n  .pipe(fs.createWriteStream(file \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27.zz\x27\x3c\/span\x3e))\n  .on(\x3cspan class=\x22hljs-string\x22\x3e\x27finish\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Done\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ereportProgress\x3c\/code\x3e流是一个简单的\x3ccode\x3epass-through\x3c\/code\x3e流，但是也跟标准事件一样报告进度。注意\x3ccode\x3ecallback()\x3c\/code\x3e函数的第二个参数，这相当于把数据推送出去。\x3c\/p\x3e\n\x3cp\x3e结合流的应用是无止境的。例如，如果我们需要在我们gzip之前或之后加密文件，我们需要做的就是按照我们需要的确切顺序来管理另一个转换流。使用Node的\x3ccode\x3ecrypto\x3c\/code\x3e模块处理这个事情。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const crypto = require(\x27crypto\x27);\n\/\/ ...\n\nfs.createReadStream(file)\n  .pipe(zlib.createGzip())\n  .pipe(crypto.createCipher(\x27aes192\x27, \x27a_secret\x27))\n  .pipe(reportProgress)\n  .pipe(fs.createWriteStream(file \x2b \x27.zz\x27))\n  .on(\x27finish\x27, () =\x3e console.log(\x27Done\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst crypto = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27crypto\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-regexp\x22\x3e\/\/\x3c\/span\x3e ...\n\nfs.createReadStream(file)\n  .pipe(zlib.createGzip())\n  .pipe(crypto.createCipher(\x3cspan class=\x22hljs-string\x22\x3e\x27aes192\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27a_secret\x27\x3c\/span\x3e))\n  .pipe(reportProgress)\n  .pipe(fs.createWriteStream(file \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27.zz\x27\x3c\/span\x3e))\n  .\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27finish\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Done\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的脚本压缩然后加密传递的文件，只有具有密码的人才可以使用文件。 我们无法使用正常的解压缩实用程序解压缩此文件，因为它已被加密。\x3c\/p\x3e\n\x3cp\x3e为了能够解压缩文件，我们需要使用完全相反的操作，这也很简单。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fs.createReadStream(file)\n  .pipe(crypto.createDecipher(\x27aes192\x27, \x27a_secret\x27))\n  .pipe(zlib.createGunzip())\n  .pipe(reportProgress)\n  .pipe(fs.createWriteStream(file.slice(0, -3)))\n  .on(\x27finish\x27, () =\x3e console.log(\x27Done\x27));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3efs\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.createReadStream\x3c\/span\x3e(file)\n  \x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(crypto.createDecipher(\x3cspan class=\x22hljs-string\x22\x3e\x27aes192\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27a_secret\x27\x3c\/span\x3e))\n  \x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(zlib.createGunzip())\n  \x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(reportProgress)\n  \x3cspan class=\x22hljs-selector-class\x22\x3e.pipe\x3c\/span\x3e(fs.createWriteStream(file.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, -\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)))\n  \x3cspan class=\x22hljs-selector-class\x22\x3e.on\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27finish\x27\x3c\/span\x3e, () =\x26gt; console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Done\x27\x3c\/span\x3e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e假设传递的文件是压缩版本，上面的代码将创建一个读取流，将其传输到crypto createDecipher（）流中（使用相同的秘密），将其输出管道输入到zlib createGunzip（）流中， 然后将文件写回到没有扩展名的文件中。\x3c\/p\x3e\n\x3cp\x3e以上就是全部了，谢谢阅读！！\x3c\/p\x3e\n\x3cp\x3e翻译自\x3ca href=\x22https:\/\/medium.freecodecamp.com\/node-js-streams-everything-you-need-to-know-c9141306be93\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNode.js Streams: Everything you need to know\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>[译]关于Node.js streams你需要知道的一切</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009793488">https://segmentfault.com/a/1190000009793488</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/k10d0an1g0d/" target="_blank">https://alili.tech/archive/k10d0an1g0d/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>