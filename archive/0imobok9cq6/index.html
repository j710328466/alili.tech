<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="详解js中的继承（二）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>详解js中的继承（二） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/0imobok9cq6/",
				"appid": "1613049289050283", 
				"title": "详解js中的继承（二） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-18T02:30:34"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ers7zehlnzu/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/l107wfmw3kp/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f&text=%e8%af%a6%e8%a7%a3js%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f&text=%e8%af%a6%e8%a7%a3js%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f&title=%e8%af%a6%e8%a7%a3js%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f&is_video=false&description=%e8%af%a6%e8%a7%a3js%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%af%a6%e8%a7%a3js%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%ef%bc%88%e4%ba%8c%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f&title=%e8%af%a6%e8%a7%a3js%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f&title=%e8%af%a6%e8%a7%a3js%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f&title=%e8%af%a6%e8%a7%a3js%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0imobok9cq6%2f&title=%e8%af%a6%e8%a7%a3js%e4%b8%ad%e7%9a%84%e7%bb%a7%e6%89%bf%ef%bc%88%e4%ba%8c%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">详解js中的继承（二）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-18" itemprop="datePublished">2019-01-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3e趁周末结束之前赶紧先把坑填上。上回我们说到了原型链，并且留下了几个思考题，先把答案公布一下。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e在最后一个例子里，console.log(b1.constructor)，结果是什么？\x3cbr\x3e\x3cstrong\x3e答案：function A，因为b1本身没有\x3ccode\x3econstructor\x3c\/code\x3e属性，会沿着原型链向上找到B prototype对象，然后再往上找到A prototype对象，此时找到了\x3ccode\x3econstructor\x3c\/code\x3e属性，也就是指向函数对象A，可参见上文最后一张图片\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eB.prototype = new A();\x3c\/code\x3e和 \x3ccode\x3eB.prototype.sayB = function(){ console.log(\x22from B\x22) }\x3c\/code\x3e这两句的执行顺序能不能交换?\x3cbr\x3e\x3cstrong\x3e答案：不能，因为我们说过了，第一句是把改写B函数对象的prototype指向的原型对象，如果我们交换了顺序，是在原先的B的原型对象上绑定了方法，然后再把指针指向新的原型对象，那新的原型对象上自然就没有绑定\x3ccode\x3esayB\x3c\/code\x3e方法，接下来的\x3ccode\x3eb1.sayB()\x3c\/code\x3e就会报函数未定义错误，\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在最后一个例子里，\x3ccode\x3eA\x3c\/code\x3e看似已经是原型链的最顶层，那\x3ccode\x3eA\x3c\/code\x3e还能再往上吗？\x3cbr\x3e\x3cstrong\x3e答案，可以，因为其实所有的引用类型都默认继承了了\x3ccode\x3eObject\x3c\/code\x3e\x3c\/strong\x3e,也就是说，完整的原型链应该是\x3ccode\x3eA prototype\x3c\/code\x3e的\x3ccode\x3e[Prototype]\x3c\/code\x3e属性指向\x3ccode\x3eObject prototype\x3c\/code\x3e。如图：\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVKTdR?w=1515\x26amp;h=1199\x22 src=\x22https:\/\/static.alili.tech\/img\/bVKTdR?w=1515\x26amp;h=1199\x22 alt=\x22完整的原型链\x22 title=\x22完整的原型链\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e顺便补充一下，\x3ccode\x3eObject prototype\x3c\/code\x3e上的原生方法，包括我们常用的\x3ccode\x3ehasOwnProperty()\x3c\/code\x3e、\x3ccode\x3eisPropertyOf()\x3c\/code\x3e等。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e接着谈继承\x3c\/h2\x3e\n\x3cp\x3e在上一篇我们讲解了原型链的原理，建议没有理解清楚的读者朋友先理解之前的知识点，避免难点叠加\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e原型链的缺陷\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\n\x3cp\x3e引用类型的值在原型链传递中存在的问题\x3cbr\x3e我们知道js中有值类型和引用类型，其中引用类型包括\x3ccode\x3eObject\x3c\/code\x3e.\x3ccode\x3eArray\x3c\/code\x3e等，引用类型的值有一个特点：\x3cstrong\x3e在赋值的时候，赋给变量的是它在内存中的地址。\x3c\/strong\x3e换句话说，被赋值完的变量相当于一个指针，这会有什么问题呢？看例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   function A() {\n        this.name = \x26quot;a\x26quot; \n        this.color = [\x27red\x27,\x27green\x27];         \n    }\n    function B(){\n\n    }\n     \/\/让B的原型对象指向A的一个实例\n     B.prototype = new A();\n     \n     \/\/生成两个个B的实例\n     var b1 = new B();\n     var b2 = new B();\n     \/\/观察color属性\n     console.log(b1.name)\/\/a\n     console.log(b2.name)\/\/a\n     console.log(b1.color)\/\/[red,green]\n     console.log(b2.color)\/\/[red,green]\n     \/\/改变b1的name和color属性\n     b1.name = \x27b\x27\n     b1.color.push(\x27black\x27)\n     \n     \/\/重新观察color属性\n     console.log(b1)\/\/b\n     console.log(b2)\/\/a\n     console.log(b2.name)\n     console.log(b1.color)\/\/[\x26quot;red\x26quot;, \x26quot;green\x26quot;, \x26quot;black\x26quot;]\n     console.log(b2.color)\/\/[\x26quot;red\x26quot;, \x26quot;green\x26quot;, \x26quot;black\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e   \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eA\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x22a\x22\x3c\/span\x3e \n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color = [\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e];         \n    }\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eB\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n\n    }\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/让B的原型对象指向A的一个实例\x3c\/span\x3e\n     B.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e A();\n     \n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/生成两个个B的实例\x3c\/span\x3e\n     \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B();\n     \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B();\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/观察color属性\x3c\/span\x3e\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/a\x3c\/span\x3e\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/a\x3c\/span\x3e\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[red,green]\x3c\/span\x3e\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[red,green]\x3c\/span\x3e\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/改变b1的name和color属性\x3c\/span\x3e\n     b1.name = \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e\n     b1.color.push(\x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e)\n     \n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/重新观察color属性\x3c\/span\x3e\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1)\x3cspan class=\x22hljs-comment\x22\x3e\/\/b\x3c\/span\x3e\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2)\x3cspan class=\x22hljs-comment\x22\x3e\/\/a\x3c\/span\x3e\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.name)\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22red\x22, \x22green\x22, \x22black\x22]\x3c\/span\x3e\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22red\x22, \x22green\x22, \x22black\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e发现问题了吗？我们修改了\x3ccode\x3eb1\x3c\/code\x3e的color和\x3ccode\x3ename\x3c\/code\x3e属性，但是\x3ccode\x3eb2\x3c\/code\x3e的\x3ccode\x3ename\x3c\/code\x3e属性不变，\x3ccode\x3ecolor\x3c\/code\x3e属性发生了改变。为了搞清楚这里问题，请尝试回答我的问题(想不出来的话，可以自己通过在控制台打印出来验证)：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eb1\x3c\/code\x3e和\x3ccode\x3eb2\x3c\/code\x3e有自己的\x3ccode\x3ecolor\x3c\/code\x3e属性吗？\x3cbr\x3e答案：没有，只是\x3ccode\x3eB prototype\x3c\/code\x3e上有color属性，因为它是\x3ccode\x3eA\x3c\/code\x3e的一个实例，\x3ccode\x3eb1\x3c\/code\x3e和\x3ccode\x3eb2\x3c\/code\x3e其实是通过[Proto]属性访问\x3ccode\x3eB prototype\x3c\/code\x3e上的\x3ccode\x3ecolor\x3c\/code\x3e属性(指针)，从而访问和操作color数组的；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eb1\x3c\/code\x3e和\x3ccode\x3eb2\x3c\/code\x3e有自己的\x3ccode\x3ename\x3c\/code\x3e属性吗？\x3cbr\x3e答案：一开始都没有，当执行了\x3ccode\x3eb1.name = \x27b\x27\x3c\/code\x3e时，相当于b1有了自己的\x3ccode\x3ename\x3c\/code\x3e属性，而\x3ccode\x3eb2\x3c\/code\x3e依然没有\x3ccode\x3ename\x3c\/code\x3e属性。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e所以以上问题的原因来源就是我们前面说的：\x3cstrong\x3e引用类型的值在赋值的时候，赋给变量的是它在内存中的地址。\x3c\/strong\x3e(如果关于值类型和引用类型有没掌握的同学可以先去看看或者私下问我，这里默认这个是已经了解的。)\x3cbr\x3e所以在原型链中如果\x3ccode\x3eA\x3c\/code\x3e（其实就是继承中的父类型）含有引用类型的值，那么子类型的实例\x3cstrong\x3e共享这个引用类型得值\x3c\/strong\x3e，也就是上面的color数组，这就是原型链的第一个缺陷。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第二个缺陷是：在创建子类型的实例(如\x3ccode\x3eb1\x3c\/code\x3e,\x3ccode\x3eb2\x3c\/code\x3e)时，无法向父类型的构造函数中传递参数。比如在上面的例子中，如果\x3ccode\x3eA\x3c\/code\x3e的\x3ccode\x3ename\x3c\/code\x3e属性是要传递参数的而不是写死的，那么我们在实例化\x3ccode\x3eb1\x3c\/code\x3e和\x3ccode\x3eb2\x3c\/code\x3e的时候根本没法传参\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e借用构造函数继承\x3c\/h3\x3e\n\x3cp\x3e为了解决引用类型值带来的问题，我们会采用\x3cstrong\x3e借用构造函数继承\x3c\/strong\x3e的方式，又名\x3cstrong\x3e*伪造对象或者经典继承\x3c\/strong\x3e，核心思路是：\x3cstrong\x3e我们在子类型的构造函数中调用父类型的构造函数\x3c\/strong\x3e，这里要用到一个方法\x3ccode\x3ecall()\x3c\/code\x3e或者\x3ccode\x3eapply()\x3c\/code\x3e函数，关于这个函数，我这里简单介绍一下，可以简单的理解功能就是，\x3cstrong\x3e允许一个对象调用另一个对象的方法\x3c\/strong\x3e。具体的作用如果大家觉得需要可以在评论区回复，我会后面单独写一下这两个函数。在这里就不展开了。具体实现如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22        function A() {\n            this.name = \x26quot;a\x26quot; \n            this.color = [\x27red\x27,\x27green\x27];         \n        }\n        function B(){\n          \/\/“借用”|就体现在这里，子类型B借用了父类型A的构造函数，从而在这里实现了继承\n          A.call(this);\n        }\n       \n         \n         \/\/生成两个个B的实例\n         var b1 = new B();\n         var b2 = new B();\n         \/\/观察color属性\n         console.log(b1.name)\/\/a\n         console.log(b2.name)\/\/a\n         console.log(b1.color)\/\/[\x27red\x27,\x27green\x27]\n         console.log(b2.color)\/\/[\x27red\x27,\x27green\x27]\n         \/\/改变b1的name和color属性\n         b1.name = \x27b\x27\n         b1.color.push(\x27black\x27)\n         \n         \/\/重新观察属性\n         console.log(b1.name)\/\/b\n         console.log(b2.name)\/\/a\n         console.log(b1.color)\/\/[\x27red\x27,\x27green\x27,\x27black\x27]\n         console.log(b2.color)\/\/[\x26quot;red\x26quot;, \x26quot;green\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eA\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x22a\x22\x3c\/span\x3e \n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color = [\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e];         \n        }\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eB\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/“借用”|就体现在这里，子类型B借用了父类型A的构造函数，从而在这里实现了继承\x3c\/span\x3e\n          A.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n        }\n       \n         \n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/生成两个个B的实例\x3c\/span\x3e\n         \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B();\n         \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B();\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/观察color属性\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/a\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/a\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x27red\x27,\x27green\x27]\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x27red\x27,\x27green\x27]\x3c\/span\x3e\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/改变b1的name和color属性\x3c\/span\x3e\n         b1.name = \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e\n         b1.color.push(\x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e)\n         \n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/重新观察属性\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/b\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/a\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x27red\x27,\x27green\x27,\x27black\x27]\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22red\x22, \x22green\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这里我们没有采用原型链，而是利用\x3ccode\x3ecall()\x3c\/code\x3e方法来实现\x3cstrong\x3e在子类型的构造函数中借用父类型的构造函数\x3c\/strong\x3e，完成了继承，这样继承的结果就是：\x3ccode\x3eb1\x3c\/code\x3e,\x3ccode\x3eb2\x3c\/code\x3e\x3cstrong\x3e都分别拥有\x3c\/strong\x3e自己的\x3ccode\x3ename\x3c\/code\x3e和\x3ccode\x3ecolor\x3c\/code\x3e属性(可以直接\x3ccode\x3econsole.log(b1)\x3c\/code\x3e查看对象的属性)，也就是\x3ccode\x3eb1\x3c\/code\x3e和\x3ccode\x3eb2\x3c\/code\x3e完全独立的。这就解决了之前的第一个问题，而且传递参数的问题其实也可以解决，再稍微改一下\x3ccode\x3eA\x3c\/code\x3e函数:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/这里name改成传递参数的\n        function A(name) {\n            this.name = name \n            this.color = [\x27red\x27,\x27green\x27];         \n        }\n        function B(name){\n          \/\/在这里我们接受一个参数，并且通过call方法传递到A的构造函数中\n          A.call(this,name);\n        }\n       \n         \n         \/\/生成两个个B的实例\n         var b1 = new B(\x27Mike\x27);\n         var b2 = new B(\x27Bob\x27);\n         \/\/观察属性\n         console.log(b1.name)\/\/Mike\n         console.log(b2.name)\/\/Bob\n         console.log(b1.color)\/\/[\x27red\x27,\x27green\x27]\n         console.log(b2.color)\/\/[\x27red\x27,\x27green\x27]\n      \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里name改成传递参数的\x3c\/span\x3e\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eA\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name \n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color = [\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e];         \n        }\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eB\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/在这里我们接受一个参数，并且通过call方法传递到A的构造函数中\x3c\/span\x3e\n          A.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,name);\n        }\n       \n         \n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/生成两个个B的实例\x3c\/span\x3e\n         \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B(\x3cspan class=\x22hljs-string\x22\x3e\x27Mike\x27\x3c\/span\x3e);\n         \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B(\x3cspan class=\x22hljs-string\x22\x3e\x27Bob\x27\x3c\/span\x3e);\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/观察属性\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/Mike\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.name)\x3cspan class=\x22hljs-comment\x22\x3e\/\/Bob\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x27red\x27,\x27green\x27]\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2.color)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x27red\x27,\x27green\x27]\x3c\/span\x3e\n      \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实上面就可以直接写成这样，但是为了让大家更容易理解，故意分开，隔离变量(大家看我这么用心真的不考虑点个赞吗？)，顺便再解释一下\x3ccode\x3eA.call(this,name);\x3c\/code\x3e就是让\x3ccode\x3ethis\x3c\/code\x3e对象(这里是指B)调用构造函数\x3ccode\x3eA\x3c\/code\x3e，同时传入一个参数\x3ccode\x3ename\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e可以看到，借用构造函数继承不会有原型链继承的问题，那为什么不都借用采用构造函数继承的方法呢？原因在于：这种继承方式，所有的属性和方法都要在构造函数中定义，比如我们这里也要绑定之前的\x3ccode\x3esayA()\x3c\/code\x3e方法并继承，就只能写在\x3ccode\x3eA\x3c\/code\x3e的构造函数里面，而写在\x3ccode\x3eA prototype\x3c\/code\x3e的的方法，没法通过这种方式继承，而把所有的属性和方法都要在构造函数中定义的话，就\x3cstrong\x3e不能对函数方法进行复用\x3c\/strong\x3e.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e组合继承\x3c\/h3\x3e\n\x3cp\x3e学习了原型链的继承和借用构造函数的继承后，我们可以发现，这两种方法的优缺点刚好互补：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e原型链继承可以把方法定义在原型上，从而复用方法\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e借用构造函数继承法可以解决引用类型值的继承问题和传递参数问题\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e因此，就自然而然的想到，结合这两种方法，于是就有了下面的\x3cstrong\x3e组合继承\x3c\/strong\x3e，也叫\x3cstrong\x3e伪经典继承\x3c\/strong\x3e，（前面的借用构造函数是经典继承，可以联系起来），具体实现如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    function A(name) {\n            this.name = name \n            this.color = [\x27red\x27,\x27green\x27];     \n        }\n        A.prototype.sayA = function(){\n          console.log(\x26quot;form A\x26quot;)\n        }\n        function B(name,age){\n          \/\/借用构造函数继承\n          A.call(this,name);\n          this.age = age;\n        }\n\n        \/\/原型链\n        B.prototype = new A();\n        B.prototype.sayB = function(){\n          console.log(\x26quot;form B\x26quot;)\n        }\n         \n         \/\/生成两个个B的实例\n         var b1 = new B(\x27Mike\x27,12);\n         var b2 = new B(\x27Bob\x27,13);\n         \/\/观察color属性\n         console.log(b1)\/\/{name:\x27Mike\x27...}\n         console.log(b2)\/\/{name:\x27Bob\x27...}\n         b1.sayA()\/\/from A\n         b2.sayB()\/\/from B\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eA\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name \n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color = [\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e];     \n        }\n        A.prototype.sayA = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22form A\x22\x3c\/span\x3e)\n        }\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eB\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,age\x3c\/span\x3e)\x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/借用构造函数继承\x3c\/span\x3e\n          A.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,name);\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n        }\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/原型链\x3c\/span\x3e\n        B.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e A();\n        B.prototype.sayB = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22form B\x22\x3c\/span\x3e)\n        }\n         \n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/生成两个个B的实例\x3c\/span\x3e\n         \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B(\x3cspan class=\x22hljs-string\x22\x3e\x27Mike\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e);\n         \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B(\x3cspan class=\x22hljs-string\x22\x3e\x27Bob\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e);\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/观察color属性\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b1)\x3cspan class=\x22hljs-comment\x22\x3e\/\/{name:\x27Mike\x27...}\x3c\/span\x3e\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(b2)\x3cspan class=\x22hljs-comment\x22\x3e\/\/{name:\x27Bob\x27...}\x3c\/span\x3e\n         b1.sayA()\x3cspan class=\x22hljs-comment\x22\x3e\/\/from A\x3c\/span\x3e\n         b2.sayB()\x3cspan class=\x22hljs-comment\x22\x3e\/\/from B\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子只是对上面的例子稍作修改：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e我们在\x3ccode\x3eA prototype\x3c\/code\x3e上定义了\x3ccode\x3esayA()\x3c\/code\x3e ，在\x3ccode\x3eB prototype\x3c\/code\x3e 定义了\x3ccode\x3esayB()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e我们增加了\x3ccode\x3eB.prototype = new A();\x3c\/code\x3e原型链\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e最终实现的效果就是，b1和b2都有各自的属性，同时方法都定义在两个原型对象上，这就达到了我们的目的：\x3cstrong\x3e属性独立，方法复用\x3c\/strong\x3e，这种继承的理解相对简单，因为就是把前两种继承方式简单的结合一下，\x3cstrong\x3e原型链负责原型对象上的方法，call借用构造函数负责让子类型拥有各自的属性。\x3c\/strong\x3e\x3cbr\x3e组合继承是js中最常用的继承方式\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e原型式继承\x3c\/h3\x3e\n\x3cp\x3e原型式继承与之前的继承方式不太相同，原理上相当于\x3cstrong\x3e对对象进行一次浅复制\x3c\/strong\x3e，浅复制简单的说就是：把\x3cstrong\x3e父对像的属性，全部拷贝给子对象\x3c\/strong\x3e。但是我们前面说到，由于\x3cstrong\x3e引用类型值的赋值特点，所以属性如果是引用类型的值，拷贝过去的也仅仅是个指针，拷贝完后父子对象的指针是指向同一个引用类型的\x3c\/strong\x3e（关于深复制和浅复制如果需要细讲的同样可以在评论区留言。）原型式继承目前可以通过\x3ccode\x3eObject.create()\x3c\/code\x3e方式来实现，(这个函数的原理我不想在这里提，因为我希望读者在看完这里内容以后自己去查阅一下这个内容)本文只讲实现方式：\x3cbr\x3e\x3ccode\x3eObject.create()\x3c\/code\x3e接收两个参数：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e第一个参数是作为新对象的原型的对象\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第二个参数是定义为新对象增加额外属性的对象（这个是可选属性）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果没有传递第二个参数的话，就相当于直接运行\x3ccode\x3eobject()\x3c\/code\x3e方法（这个方法如果不懂直接百度就好）\x3cbr\x3e上面的说法可能有点拗口，换句话说：\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e比如说我们现在要创建一个新对象\x3ccode\x3eB\x3c\/code\x3e，那么要先传入第一个参数对象\x3ccode\x3eA\x3c\/code\x3e，这个A将被作为\x3ccode\x3eB prototype\x3c\/code\x3e;然后可以再传入一个参数对象\x3ccode\x3eC\x3c\/code\x3e，\x3ccode\x3eC\x3c\/code\x3e对象中可以定义我们需要的一些额外的属性。来看例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    var A  = {\n        name:\x27A\x27,\n        color:[\x27red\x27,\x27green\x27]\n    }\n\n    \/\/使用Object.create方法先复制一个对象\n    var B = Object.create(A);\n    B.name = \x27B\x27;\n    B.color.push(\x27black\x27);\n\n    \/\/使用Object.create方法再复制一个对象\n    var C = Object.create(A);\n    C.name = \x27C\x27;\n    B.color.push(\x27blue\x27);\n    console.log(A.name)\/\/A\n    console.log(B.name)\/\/B\n    console.log(C.name)\/\/C\n    console.log(A.color)\/\/[\x26quot;red\x26quot;, \x26quot;green\x26quot;, \x26quot;black\x26quot;, \x26quot;blue\x26quot;]\n         \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xl\x22\x3e\x3ccode\x3e    var A  = {\n        \x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e:[\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e]\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/使用Object.create方法先复制一个对象\x3c\/span\x3e\n    var B = Object.create(A);\n    B.\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e;\n    B.\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e.push(\x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/使用Object.create方法再复制一个对象\x3c\/span\x3e\n    var C = Object.create(A);\n    C.\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27C\x27\x3c\/span\x3e;\n    B.\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e.push(\x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e);\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(A.\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e\/\/A\x3c\/span\x3e\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(B.\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e\/\/B\x3c\/span\x3e\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(C.\x3cspan class=\x22hljs-keyword\x22\x3ename\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e\/\/C\x3c\/span\x3e\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(A.\x3cspan class=\x22hljs-built_in\x22\x3ecolor\x3c\/span\x3e)\x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22red\x22, \x22green\x22, \x22black\x22, \x22blue\x22]\x3c\/span\x3e\n         \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个例子中，我们只传入第一个参数，所以\x3ccode\x3eB\x3c\/code\x3e和\x3ccode\x3eC\x3c\/code\x3e都是对\x3ccode\x3eA\x3c\/code\x3e\x3cstrong\x3e浅复制\x3c\/strong\x3e的结果，由于\x3ccode\x3ename\x3c\/code\x3e是值类型的，\x3ccode\x3ecolor\x3c\/code\x3e是引用类型的，所以ABC的name值独立，color属性指向同一个对象。接下来举个传递两个参数的例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    var A  = {\n        name:\x27A\x27,\n        color:[\x27red\x27,\x27green\x27],\n        sayA:function(){\n            console.log(\x27from A\x27);\n        }\n    };\n\n    \/\/使用Object.create方法先复制一个对象\n    var B = Object.create(A,{\n        name:{\n          value:\x27B\x27\n        }\n    });\n    console.log(B)\/\/Object{name:\x27B\x27}\n    B.sayA()\/\/\x27from A\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e A  = {\n        \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e:[\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e],\n        \x3cspan class=\x22hljs-attr\x22\x3esayA\x3c\/span\x3e:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27from A\x27\x3c\/span\x3e);\n        }\n    };\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/使用Object.create方法先复制一个对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e B = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(A,{\n        \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:{\n          \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27B\x27\x3c\/span\x3e\n        }\n    });\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(B)\x3cspan class=\x22hljs-comment\x22\x3e\/\/Object{name:\x27B\x27}\x3c\/span\x3e\n    B.sayA()\x3cspan class=\x22hljs-comment\x22\x3e\/\/\x27from A\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子就很清楚的表明了这个函数的作用了，传入的\x3ccode\x3eA\x3c\/code\x3e对象被当做\x3ccode\x3eB\x3c\/code\x3e的原型，所以生成\x3ccode\x3eB\x3c\/code\x3e对象没有sayA()方法，却可以调用该方法(类似于通过原型链)，同时我们在第二个参数中修改了\x3ccode\x3eB\x3c\/code\x3e自己的\x3ccode\x3ename\x3c\/code\x3e，所以就实现了这种\x3cstrong\x3e原型式继承\x3c\/strong\x3e。原型式继承的好处是：如果我们只是简单的想保持一个对象和另一个对象类似，不必大费周章写一堆代码，直接调用就能实现\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e寄生式继承\x3c\/h3\x3e\n\x3cp\x3e寄生式继承和原型继承联系紧密，思路类似于\x3cstrong\x3e工厂模式,即创建一个只负责封装继承过程的函数，在函数中根据需要增强对象，最后返回对象\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 function createA(name){\n    \/\/创建新对象\n    var obj = Object(name);\n    \/\/增强功能\n     obj.sayO = function(){\n         console.log(\x26quot;from O\x26quot;)\n     };\n    \/\/返回对象\n    return obj;\n     \n}\nvar A = {\n    name:\x27A\x27,\n    color:[\x27red\x27,\x27green\x27,\x27blue\x27]\n};\n\/\/实现继承\nvar  B = createA(A);\nconsole.log(B)\/\/Object {name: \x26quot;A\x26quot;, color: Array[3]}\nB.sayO();\/\/from O\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateA\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/创建新对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e(name);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/增强功能\x3c\/span\x3e\n     obj.sayO = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22from O\x22\x3c\/span\x3e)\n     };\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/返回对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e obj;\n     \n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e A = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e:[\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27blue\x27\x3c\/span\x3e]\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/实现继承\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e  B = createA(A);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(B)\x3cspan class=\x22hljs-comment\x22\x3e\/\/Object {name: \x22A\x22, color: Array[3]}\x3c\/span\x3e\nB.sayO();\x3cspan class=\x22hljs-comment\x22\x3e\/\/from O\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e继承的结果是\x3ccode\x3eB\x3c\/code\x3e拥有\x3ccode\x3eA\x3c\/code\x3e的所有属性和方法，而且具有自己的sayO()方法，效果和原型式继承很相似，读者可以比较一下寄生式继承和原型式继承的相似和区别。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e寄生组合式继承\x3c\/h3\x3e\n\x3cp\x3e终于写到最后一个继承了，我们在之前讲了5种继承方式，分别是\x3cstrong\x3e原型链\x3c\/strong\x3e，\x3cstrong\x3e借用构造函数继承\x3c\/strong\x3e，\x3cstrong\x3e组合继承\x3c\/strong\x3e，\x3cstrong\x3e原型式继承\x3c\/strong\x3e，\x3cstrong\x3e寄生式继承\x3c\/strong\x3e，其中，前三种联系比较紧密，后面两种也比较紧密，而我们要讲的最后一种，是和\x3cstrong\x3e组合继承\x3c\/strong\x3e还有\x3cstrong\x3e寄生式继承\x3c\/strong\x3e有关系的。（看名字就知道了嘛）\x3c\/p\x3e\n\x3cp\x3e\x3cem\x3e友情提示：如果看到这里有点累的读者可以先休息一下，因为虽然已经分了一二两篇，本文的篇幅还是稍长（我都打了两个多小时了），而且如果先把之前的理解清楚，比较容易理解最后一种继承。\x3c\/em\x3e\x3c\/p\x3e\n\x3ch4\x3e组合继承仍有缺陷\x3c\/h4\x3e\n\x3cp\x3e我们在之前说过，最常用的继承方式就是\x3cstrong\x3e组合继承\x3c\/strong\x3e，但是看似完美的组合继承依然有缺点：\x3cstrong\x3e子类型会两次调用父类型的构造函数\x3c\/strong\x3e，一次是在\x3cstrong\x3e子类型的构造函数里\x3c\/strong\x3e，另一次是在\x3cstrong\x3e实现原型链的步骤\x3c\/strong\x3e,来看之前的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    function A(name) {\n            this.name = name \n            this.color = [\x27red\x27,\x27green\x27];     \n        }\n        A.prototype.sayA = function(){\n          console.log(\x26quot;form A\x26quot;)\n        }\n        function B(name,age){\n         \/\/第二次调用了A\n          A.call(this,name);\n          this.age = age;\n        }\n\n        \/\/第一次调用了A\n        B.prototype = new A();\n        B.prototype.sayB = function(){\n          console.log(\x26quot;form B\x26quot;)\n        }\n         \n\n         var b1 = new B(\x27Mike\x27,12);\n         var b2 = new B(\x27Bob\x27,13);\n          console.log(B.prototype)\/\/A {name: undefined, color: Array[2]}\n       \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eA\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name \n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.color = [\x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e];     \n        }\n        A.prototype.sayA = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22form A\x22\x3c\/span\x3e)\n        }\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eB\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,age\x3c\/span\x3e)\x3c\/span\x3e{\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/第二次调用了A\x3c\/span\x3e\n          A.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,name);\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age;\n        }\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/第一次调用了A\x3c\/span\x3e\n        B.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e A();\n        B.prototype.sayB = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22form B\x22\x3c\/span\x3e)\n        }\n         \n\n         \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b1 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B(\x3cspan class=\x22hljs-string\x22\x3e\x27Mike\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e);\n         \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e B(\x3cspan class=\x22hljs-string\x22\x3e\x27Bob\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e13\x3c\/span\x3e);\n          \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(B.prototype)\x3cspan class=\x22hljs-comment\x22\x3e\/\/A {name: undefined, color: Array[2]}\x3c\/span\x3e\n       \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在第一次调用的时候，生成了\x3ccode\x3eB.prototype\x3c\/code\x3e对象，它具有\x3ccode\x3ename\x3c\/code\x3e和\x3ccode\x3ecolor\x3c\/code\x3e属性，因为它是\x3ccode\x3eA\x3c\/code\x3e的一个实例；第二次调用的时候，就是实例化\x3ccode\x3eb1\x3c\/code\x3e和\x3ccode\x3eb2\x3c\/code\x3e的时候，这时候\x3ccode\x3eb1\x3c\/code\x3e和\x3ccode\x3eb2\x3c\/code\x3e也具有了\x3ccode\x3ename\x3c\/code\x3e和\x3ccode\x3ecolor\x3c\/code\x3e属性，我们之前说过，原型链的意义是：\x3cstrong\x3e当对象本身不存在某个属性或方法的时候，可以沿着原型链向上查找，如果对象自身已经有某种属性或者方法，就访问自身的\x3c\/strong\x3e，但是我们现在发现，通过组合继承，只要是\x3ccode\x3eA\x3c\/code\x3e里面原有的属性，\x3ccode\x3eB prototype\x3c\/code\x3e对象一定会有，\x3ccode\x3eb1\x3c\/code\x3e和\x3ccode\x3eb2\x3c\/code\x3e肯定也会有，这样就造成了一种浪费：\x3ccode\x3eB prototyope\x3c\/code\x3e上的属性其实我们根本用不上，为了解决这个问题，我们采用寄生组合式继承。\x3cbr\x3e寄生组合式继承的核心思路是其实就是换一种方式实现\x3ccode\x3e B.prototype = new A();\x3c\/code\x3e从而避免两次调用父类型的构造函数，官方定义是：\x3cstrong\x3e使用寄生式继承来继承父类型的原型，然后将结果指定给子类型的原型，\x3c\/strong\x3e。`这句话不容易理解，来看例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/我们一直默认A是父类型，B是子类型\nfunction inheritPrototype(B,A){\n    \/\/复制一个A的原型对象\n    var pro  = Object(A.prototype);\n    \/\/改写这个原型对象的constructor指针指向B\n    pro.constructor = B;\n    \/\/改写B的prototype指针指向这个原型对象\n    B.prototype = pro;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\/\/我们一直默认\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e是父类型，\x3cspan class=\x22hljs-type\x22\x3eB\x3c\/span\x3e是子类型\n\x3cspan class=\x22hljs-title\x22\x3efunction\x3c\/span\x3e inheritProto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e(\x3cspan class=\x22hljs-type\x22\x3eB\x3c\/span\x3e,\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e){\n    \/\/复制一个\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e的原型对象\n    var pro  = \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e(\x3cspan class=\x22hljs-type\x22\x3eA\x3c\/span\x3e.prototype);\n    \/\/改写这个原型对象的constructor指针指向\x3cspan class=\x22hljs-type\x22\x3eB\x3c\/span\x3e\n    pro.constructor = \x3cspan class=\x22hljs-type\x22\x3eB\x3c\/span\x3e;\n    \/\/改写\x3cspan class=\x22hljs-type\x22\x3eB\x3c\/span\x3e的prototype指针指向这个原型对象\n    \x3cspan class=\x22hljs-type\x22\x3eB\x3c\/span\x3e.prototype = pro;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个函数很简短，只有三行，函数内部发生的事情是:\x3cstrong\x3e我们复制一个A的原型对象，然后把这个原型对象替换掉B的原型对象\x3c\/strong\x3e。为什么说这样就代替了\x3ccode\x3e B.prototype = new A();\x3c\/code\x3e,不妨思考一下，\x3cstrong\x3e我们最初为什么要把B的prototype属性指向A的一个实例?\x3c\/strong\x3e无非就是想得到\x3ccode\x3eA的prototype的一个复制品\x3c\/code\x3e，然后实现原型链。而现在我们这样的做法，同样达到了我们的母的目的，而且，\x3cstrong\x3e此时B的原型对象上不会再有A的属性了，因为它不是A的实例。\x3c\/strong\x3e因此，只要把将上面的\x3ccode\x3e B.prototype = new A();\x3c\/code\x3e，替换成\x3ccode\x3einheritPrototype(B,A)\x3c\/code\x3e，就完成了寄生组合式继承。\x3c\/p\x3e\n\x3cp\x3e寄生组合式继承保持了组合继承的优点，又避开了组合继承会有无用属性的缺陷，被认为是最理想的继承方式。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3e终于写完了！！ 明天还得起早去上班，下一次更新可能会放在这一周的周末。关于这一篇内容，建议的阅读方式是\x3cstrong\x3e先读前三种继承方式，再看后两种继承，都理解的差不多了，就可以看最后一种继承方式了。\x3c\/strong\x3e中间注意消化和休息。最后再提一下吧：\x3cstrong\x3e如果喜欢本文，请大方的点一下右上角的推荐和收藏（反正你们还是喜欢只收藏不推荐），虽然说写这个一方面是为了自己巩固知识，但是为了让读者更容易理解，我尽量都是采用拆解的方式来讲，而且穿插了新知识的时候都会给出解释，并不是直接搬运书本知识过来，那样毫无意义。这么做还是希望写的文章能够更有价值，让更多人能够得到帮助！\x3c\/strong\x3e以上内容属于个人见解，如果有不同意见，欢迎指出和探讨。请尊重作者的版权，转载请注明出处，如作商用，请与作者联系，感谢！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>详解js中的继承（二）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008754962">https://segmentfault.com/a/1190000008754962</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/0imobok9cq6/" target="_blank">https://alili.tech/archive/0imobok9cq6/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>