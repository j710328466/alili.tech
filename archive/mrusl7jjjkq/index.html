<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 高阶组件(HOC)入门指南"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 高阶组件(HOC)入门指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/mrusl7jjjkq/",
				"appid": "1613049289050283", 
				"title": "React 高阶组件(HOC)入门指南 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-14T02:30:07"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/rgn4y4d2oxn/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/lh3etl87o7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f&text=React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f&text=React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f&title=React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f&is_video=false&description=React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f&title=React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f&title=React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f&title=React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fmrusl7jjjkq%2f&title=React%20%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e5%85%a5%e9%97%a8%e6%8c%87%e5%8d%97"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 高阶组件(HOC)入门指南</h1><div class="meta"><div class="postdate"><time datetime="2019-01-14" itemprop="datePublished">2019-01-14</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e　　之前的文章\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000008814336\x22\x3eReact Mixins入门指南\x3c\/a\x3e介绍了React Mixin的使用。在实际使用中React Mixin的作用还是非常强大的，能够使得我们在多个组件中共用相同的方法。但是工程中大量使用Mixin也会带来非常多的问题。\x3ca href=\x22https:\/\/twitter.com\/dan_abramov\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDan Abramov\x3c\/a\x3e在文章[Mixins Considered Harmful\x3cbr\x3e](\x3ca href=\x22https:\/\/facebook.github.io\/react\/blog\/2016\/07\/13\/mixins-considered-harmful.html)\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/facebook.github.io\/re...\x3c\/a\x3e介绍了Mixin带来的一些问题,总结下来主要是以下几点:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e破坏组件封装性: Mixin可能会引入不可见的属性。例如在渲染组件中使用Mixin方法，给组件带来了不可见的属性(props)和状态(state)。并且Mixin可能会相互依赖，相互耦合，不利于代码维护。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不同的Mixin中的方法可能会相互冲突\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e　　为了处理上述的问题，React官方推荐使用高阶组件(High Order Component)\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e高阶组件(HOC)\x3c\/h2\x3e\n\x3cp\x3e　　刚开始学习高阶组件时，这个概念就透漏着高级的气味，看上去就像是一种先进的编程技术的一个深奥术语，毕竟名字里就有\x22高阶\x22这种字眼，实质上并不是如此。高阶组件的概念应该是来源于JavaScript的高阶函数:\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e高阶函数就是接受函数作为输入或者输出的函数\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e　　这么看来\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000008193605\x22\x3e柯里化\x3c\/a\x3e也是高阶函数了。React官方定义高阶组件的概念是:\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eA higher-order component is a function that takes a component and returns a new component.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e　　(本人也翻译了React官方文档的\x3ca href=\x22https:\/\/github.com\/MrErHu\/React-Advanced-Guides-CN\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAdvanced Guides部分\x3c\/a\x3e，官方的高阶组件中文文档戳\x3ca href=\x22https:\/\/github.com\/MrErHu\/React-Advanced-Guides-CN\/blob\/master\/doc\/Higher%20Order%20Components.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e)\x3c\/p\x3e\n\x3cp\x3e　　这么看来，高阶组件仅仅只是是一个接受组件组作输入并返回组件的函数。看上去并没有什么，那么高阶组件能为我们带来什么呢？首先看一下高阶组件是如何实现的，通常情况下，实现高阶组件的方式有以下两种:\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e属性代理(Props Proxy)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e反向继承(Inheritance Inversion)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e属性代理\x3c\/h3\x3e\n\x3cp\x3e　　又是一个听起来很高大上的名词，实质上是通过包裹原来的组件来操作props，举个简单的例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nimport React, { Component } from \x27React\x27;\n\/\/高阶组件定义\nconst HOC = (WrappedComponent) =\x3e\n  class WrapperComponent extends Component {\n    render() {\n      return \x3cWrappedComponent {...this.props} \/\x3e;\n    }\n}\n\/\/普通的组件\nclass WrappedComponent extends Component{\n    render(){\n        \/\/....\n    }\n}\n\n\/\/高阶组件使用\nexport default HOC(WrappedComponent)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27React\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/高阶组件定义\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HOC = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWrapperComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWrappedComponent\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...this.props\x3c\/span\x3e} \/\x26gt;\x3c\/span\x3e;\n    }\n}\n\/\/普通的组件\nclass WrappedComponent extends Component{\n    render(){\n        \/\/....\n    }\n}\n\n\/\/高阶组件使用\nexport default HOC(WrappedComponent)\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　上面的例子非常简单，但足以说明问题。我们可以看见函数HOC返回了新的组件(WrapperComponent)，这个组件原封不动的返回作为参数的组件(也就是被包裹的组件:WrappedComponent)，并将传给它的参数(props)全部传递给被包裹的组件(WrappedComponent)。这么看起来好像并没有什么作用，其实属性代理的作用还是非常强大的。\x3c\/p\x3e\n\x3ch4\x3e操作props\x3c\/h4\x3e\n\x3cp\x3e　　我们看到之前要传递给被包裹组件WrappedComponent的属性首先传递给了高阶组件返回的组件(WrapperComponent)，这样我们就获得了props的控制权(这也就是为什么这种方法叫做属性代理)。我们可以按照需要对传入的props进行增加、删除、修改(当然修改带来的风险需要你自己来控制)，举个例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const HOC = (WrappedComponent) =\x3e\n    class WrapperComponent extends Component {\n        render() {\n            const newProps = {\n                name: \x27HOC\x27\n            }\n            return \x3cWrappedComponent\n                {...this.props}\n                {...newProps}\n            \/\x3e;\n        }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HOC = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWrapperComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n        render() {\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newProps = {\n                \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27HOC\x27\x3c\/span\x3e\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWrappedComponent\x3c\/span\x3e\n                {\x3cspan class=\x22hljs-attr\x22\x3e...this.props\x3c\/span\x3e}\n                {\x3cspan class=\x22hljs-attr\x22\x3e...newProps\x3c\/span\x3e}\n            \/\x26gt;\x3c\/span\x3e;\n        }\n    }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　在上面的例子中，我们为被包裹组件(WrappedComponent)新增加了固定的name属性，因此WrappedComponent组件中就会多一个name的属性。\x3c\/p\x3e\n\x3ch4\x3e获得\x3ccode\x3erefs\x3c\/code\x3e的引用\x3c\/h4\x3e\n\x3cp\x3e　　我们在属性代理中，可以轻松的拿到被包裹的组件的实例引用(\x3ccode\x3eref\x3c\/code\x3e)，例如:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27React\x27;\n　\nconst HOC = (WrappedComponent) =\x3e\n    class wrapperComponent extends Component {\n        storeRef(ref) {\n            this.ref = ref;\n        }\n        render() {\n            return \x3cWrappedComponent\n                {...this.props}\n                ref = {::this.storeRef}\n            \/\x3e;\n        }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27React\x27\x3c\/span\x3e;\n　\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HOC = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewrapperComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n        storeRef(ref) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ref = ref;\n        }\n        render() {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWrappedComponent\x3c\/span\x3e\n                {\x3cspan class=\x22hljs-attr\x22\x3e...this.props\x3c\/span\x3e}\n                \x3cspan class=\x22hljs-attr\x22\x3eref\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e{::this.storeRef}\x3c\/span\x3e\n            \/\x26gt;\x3c\/span\x3e;\n        }\n    }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　上面的例子中，wrapperComponent渲染接受后，我们就可以拿到WrappedComponent组件的实例，进而实现调用实例方法的操作(当然这样会在一定程度上是反模式的，不是非常的推荐)。\x3c\/p\x3e\n\x3ch4\x3e抽象state\x3c\/h4\x3e\n\x3cp\x3e　　属性代理的情况下，我们可以将被包裹组件(WrappedComponent)中的状态提到包裹组件中，一个常见的例子就是实现\x3cstrong\x3e不受控组件\x3c\/strong\x3e到\x3cstrong\x3e受控的组件\x3c\/strong\x3e的转变(关于不受控组件和受控组件戳\x3ca href=\x22https:\/\/github.com\/MrErHu\/React-Advanced-Guides-CN\/blob\/master\/doc\/Uncontrolled%20Components.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class WrappedComponent extends Component {\n    render() {\n        return \x3cinput name=\x26quot;name\x26quot; {...this.props.name} \/\x3e;\n    }\n}\n\nconst HOC = (WrappedComponent) =\x3e\n    class extends Component {\n        constructor(props) {\n            super(props);\n            this.state = {\n                name: \x27\x27,\n            };\n\n            this.onNameChange = this.onNameChange.bind(this);\n        }\n\n        onNameChange(event) {\n            this.setState({\n                name: event.target.value,\n            })\n        }\n\n        render() {\n            const newProps = {\n                name: {\n                    value: this.state.name,\n                    onChange: this.onNameChange,\n                },\n            }\n            return \x3cWrappedComponent {...this.props} {...newProps} \/\x3e;\n        }\n    }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWrappedComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;input name=\x22name\x22 {...this.props.name} \/\x26gt;;\n    }\n}\n\nconst HOC = (WrappedComponent) =\x26gt;\n    class extends Component {\n        constructor(props) {\n            super(props);\n            this.state = {\n                name: \x27\x27,\n            };\n\n            this.onNameChange = this.onNameChange.bind(this);\n        }\n\n        onNameChange(event) {\n            this.setState({\n                name: event.target.value,\n            })\n        }\n\n        render() {\n            const newProps = {\n                name: {\n                    value: this.state.name,\n                    onChange: this.onNameChange,\n                },\n            }\n            return \x26lt;WrappedComponent {...this.props} {...newProps} \/\x26gt;;\n        }\n    }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　上面的例子中通过高阶组件，我们将不受控组件(WrappedComponent)成功的转变为受控组件.\x3c\/p\x3e\n\x3ch4\x3e用其他元素包裹组件\x3c\/h4\x3e\n\x3cp\x3e　　我们可以通过类似:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    render(){\n        \x3cdiv\x3e\n            \x3cWrappedComponent {...this.props} \/\x3e\n        \x3c\/div\x3e\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    render(){\n        \x26lt;div\x26gt;\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWrappedComponent\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...this.props\x3c\/span\x3e} \/\x26gt;\x3c\/span\x3e\n        \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　这种方式将被包裹组件包裹起来，来实现布局或者是样式的目的。\x3c\/p\x3e\n\x3cp\x3e　　在属性代理这种方式实现的高阶组件，以上述为例，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序是先WrapperComponent再WrappedComponent(执行ComponentWillUnmount的时间)。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e反向继承\x3c\/h3\x3e\n\x3cp\x3e　　反向继承是指返回的组件去继承之前的组件(这里都用WrappedComponent代指)\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const HOC = (WrappedComponent) =\x3e\n  class extends WrappedComponent {\n    render() {\n      return super.render();\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HOC = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWrappedComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.render();\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　 我们可以看见返回的组件确实都继承自WrappedComponent,那么所有的调用将是反向调用的(例如:\x3ccode\x3esuper.render()\x3c\/code\x3e)，这也就是为什么叫做反向继承。\x3c\/p\x3e\n\x3ch4\x3e渲染劫持\x3c\/h4\x3e\n\x3cp\x3e　　渲染劫持是指我们可以有意识地控制WrappedComponent的渲染过程，从而控制渲染控制的结果。例如我们可以根据部分参数去决定是否渲染组件:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const HOC = (WrappedComponent) =\x3e\n  class extends WrappedComponent {\n    render() {\n      if (this.props.isRender) {\n        return super.render();\n      } else {\n        return null;\n      }\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode class=\x22javascrit\x22\x3econst \x3cspan class=\x22hljs-type\x22\x3eHOC\x3c\/span\x3e = (\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWrappedComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.isRender) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.render();\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n      }\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　甚至我们可以修改修改render的结果:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/例子来源于《深入React技术栈》\n\nconst HOC = (WrappedComponent) =\x3e\n    class extends WrappedComponent {\n        render() {\n            const elementsTree = super.render();\n            let newProps = {};\n            if (elementsTree \x26amp;\x26amp; elementsTree.type === \x27input\x27) {\n                newProps = {value: \x27may the force be with you\x27};\n            }\n            const props = Object.assign({}, elementsTree.props, newProps);\n            const newElementsTree = React.cloneElement(elementsTree, props, elementsTree.props.children);\n            return newElementsTree;\n    }\n}\nclass WrappedComponent extends Component{\n    render(){\n        return(\n            \x3cinput value={\x27Hello World\x27} \/\x3e\n        )\n    }\n}\nexport default HOC(WrappedComponent)\n\/\/实际显示的效果是input的值为\x26quot;may the force be with you\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/例子来源于《深入React技术栈》\x3c\/span\x3e\n\nconst \x3cspan class=\x22hljs-type\x22\x3eHOC\x3c\/span\x3e = (\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWrappedComponent\x3c\/span\x3e \x3c\/span\x3e{\n        render() {\n            const elementsTree = \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.render();\n            let newProps = {};\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (elementsTree \x26amp;\x26amp; elementsTree.\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e === \x3cspan class=\x22hljs-symbol\x22\x3e\x27inpu\x3c\/span\x3et\x27) {\n                newProps = {value: \x3cspan class=\x22hljs-symbol\x22\x3e\x27may\x3c\/span\x3e the force be \x3cspan class=\x22hljs-keyword\x22\x3ewith\x3c\/span\x3e you\x27};\n            }\n            const props = \x3cspan class=\x22hljs-type\x22\x3eObject\x3c\/span\x3e.assign({}, elementsTree.props, newProps);\n            const newElementsTree = \x3cspan class=\x22hljs-type\x22\x3eReact\x3c\/span\x3e.cloneElement(elementsTree, props, elementsTree.props.children);\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e newElementsTree;\n    }\n}\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWrappedComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n    render(){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e(\n            \x26lt;input value={\x3cspan class=\x22hljs-symbol\x22\x3e\x27Hello\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eWorld\x3c\/span\x3e\x27} \/\x26gt;\n        )\n    }\n}\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eHOC\x3c\/span\x3e(\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/实际显示的效果是input的值为\x22may the force be with you\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　上面的例子中我们将WrappedComponent中的input元素value值修改为:\x3ccode\x3emay the force be with you\x3c\/code\x3e。我们可以看到前后elementTree的区别:\x3cbr\x3eelementsTree:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009386665?w=660\x26amp;h=536\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009386665?w=660\x26amp;h=536\x22 alt=\x22elementsTree\x22 title=\x22elementsTree\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3enewElementsTree:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009386666?w=664\x26amp;h=530\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009386666?w=664\x26amp;h=530\x22 alt=\x22newElementsTree\x22 title=\x22newElementsTree\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e　　在反向继承中，我们可以做非常多的操作，修改state、props甚至是翻转Element Tree。反向继承有一个重要的点: \x3cstrong\x3e反向继承不能保证完整的子组件树被解析\x3c\/strong\x3e，开始我对这个概念也不理解，后来在看了\x3ca href=\x22https:\/\/facebook.github.io\/react\/blog\/2015\/12\/18\/react-components-elements-and-instances.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact Components, Elements, and Instances\x3c\/a\x3e这篇文章之后对这个概念有了自己的一点体会。\x3cbr\x3eReact Components, Elements, and Instances这篇文章主要明确了一下几个点:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e元素(element)是一个是用DOM节点或者组件来描述屏幕显示的纯对象，元素可以在属性(props.children)中包含其他的元素，一旦创建就不会改变。我们通过\x3ccode\x3eJSX\x3c\/code\x3e和\x3ccode\x3eReact.createClass\x3c\/code\x3e创建的都是元素。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e组件(component)可以接受属性(props)作为输入，然后返回一个元素树(element tree)作为输出。有多种实现方式:Class或者函数(Function)。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e　　所以， \x3cstrong\x3e反向继承不能保证完整的子组件树被解析\x3c\/strong\x3e的意思的解析的元素树中包含了组件(函数类型或者Class类型)，就不能再操作组件的子组件了，这就是所谓的\x3cstrong\x3e不能完全解析\x3c\/strong\x3e。举个例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27react\x27;\n\nconst MyFuncComponent = (props)=\x3e{\n    return (\n        \x3cdiv\x3eHello World\x3c\/div\x3e\n    );\n}\n\nclass MyClassComponent extends Component{\n\n    render(){\n        return (\n            \x3cdiv\x3eHello World\x3c\/div\x3e\n        )\n    }\n\n}\n\nclass WrappedComponent extends Component{\n    render(){\n        return(\n            \x3cdiv\x3e\n                \x3cdiv\x3e\n                    \x3cspan\x3eHello World\x3c\/span\x3e\n                \x3c\/div\x3e\n                \x3cMyFuncComponent \/\x3e\n                \x3cMyClassComponent \/\x3e\n            \x3c\/div\x3e\n\n        )\n    }\n}\n\nconst HOC = (WrappedComponent) =\x3e\n    class extends WrappedComponent {\n        render() {\n            const elementsTree = super.render();\n            return elementsTree;\n        }\n    }\n\nexport default HOC(WrappedComponent);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e MyFuncComponent = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello World\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n    );\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyClassComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n\n    render(){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello World\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n        )\n    }\n\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWrappedComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n    render(){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e(\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello World\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMyFuncComponent\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n                \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMyClassComponent\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n            \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\n        )\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HOC = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWrappedComponent\x3c\/span\x3e \x3c\/span\x3e{\n        render() {\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e elementsTree = \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e.render();\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e elementsTree;\n        }\n    }\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e HOC(WrappedComponent);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009386667?w=1382\x26amp;h=1028\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009386667?w=1382\x26amp;h=1028\x22 alt=\x22element tree1\x22 title=\x22element tree1\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009386668?w=930\x26amp;h=956\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009386668?w=930\x26amp;h=956\x22 alt=\x22element tree2\x22 title=\x22element tree2\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e　　我们可以查看解析的元素树(element tree)，\x3ccode\x3ediv\x3c\/code\x3e下的\x3ccode\x3espan\x3c\/code\x3e是可以被完全被解析的，但是\x3ccode\x3eMyFuncComponent\x3c\/code\x3e和\x3ccode\x3eMyClassComponent\x3c\/code\x3e都是组件类型的，其子组件就不能被完全解析了。\x3c\/p\x3e\n\x3ch4\x3e操作props和state\x3c\/h4\x3e\n\x3cp\x3e　　在上面的图中我们可以看到，解析的元素树(element tree)中含有\x3ccode\x3eprops\x3c\/code\x3e和\x3ccode\x3estate\x3c\/code\x3e(例子的组件中没有state),以及\x3ccode\x3eref\x3c\/code\x3e和\x3ccode\x3ekey\x3c\/code\x3e等值。因此，如果需要的话，我们不仅可以读取\x3ccode\x3eprops\x3c\/code\x3e和\x3ccode\x3estate\x3c\/code\x3e,甚至可以修改增加、修改和删除。\x3c\/p\x3e\n\x3cp\x3e　　在某些情况下，我们可能需要为高阶属性传入一些参数，那我们就可以通过柯里化的形式传入参数，例如:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import React, { Component } from \x27React\x27;\n\nconst HOCFactoryFactory = (...params) =\x3e {\n    \/\/ 可以做一些改变 params 的事\n    return (WrappedComponent) =\x3e {\n        return class HOC extends Component {\n            render() {\n                return \x3cWrappedComponent {...this.props} \/\x3e;\n            }\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React, { Component } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27React\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e HOCFactoryFactory = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e...params\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以做一些改变 params 的事\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHOC\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n            render() {\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWrappedComponent\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...this.props\x3c\/span\x3e} \/\x26gt;\x3c\/span\x3e;\n            }\n        }\n    }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以通过下面方式使用:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22HOCFactoryFactory(params)(WrappedComponent)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eHOCFactoryFactory(params)(WrappedComponent)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　这种方式是不是非常类似于\x3ccode\x3eReact-Redux\x3c\/code\x3e库中的\x3ccode\x3econnect\x3c\/code\x3e函数，因为\x3ccode\x3econnect\x3c\/code\x3e也是类似的一种高阶函数。反向继承不同于属性代理的调用顺序，组件的渲染顺序是: 先WrappedComponent再WrapperComponent(执行ComponentDidMount的时间)。而卸载的顺序也是先WrappedComponent再WrapperComponent(执行ComponentWillUnmount的时间)。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eHOC和Mixin的比较\x3c\/h3\x3e\n\x3cp\x3e　　借用《深入React技术栈》一书中的图:\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009386669?w=1690\x26amp;h=932\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009386669?w=1690\x26amp;h=932\x22 alt=\x22HOCandMixin\x22 title=\x22HOCandMixin\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e　　高阶组件属于函数式编程(functional programming)思想，对于被包裹的组件时不会感知到高阶组件的存在，而高阶组件返回的组件会在原来的组件之上具有功能增强的效果。而Mixin这种混入的模式，会给组件不断增加新的方法和属性，组件本身不仅可以感知，甚至需要做相关的处理(例如命名冲突、状态维护)，一旦混入的模块变多时，整个组件就变的难以维护，也就是为什么如此多的React库都采用高阶组件的方式进行开发。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 高阶组件(HOC)入门指南</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009386662">https://segmentfault.com/a/1190000009386662</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/mrusl7jjjkq/" target="_blank">https://alili.tech/archive/mrusl7jjjkq/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5328xogjarn/">IndexedDB--HTML5本地存储<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/xpccu0hsqbr/">JS学习系列 01 - 编译原理和作用域<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/shv09bbtbfd/">Vue2 SSR 的优化之旅<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5vj1ojfo6h6/">[2016年末巨献] — HTML5可交互地铁线路图（第二季：帝都进阶版）<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/m02hlm4bzh/">vue2.0开发聊天程序（三）组件的通信<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/mz5o7n90plg/">《很高兴我没有猝死》- 前端新人的 2016 年总结和感悟<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/3vhoe2mo09k/">一道颇有难度的JavaScript题<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/uj12mb7thp/">使用CANVAS实现交互性圆形马赛克效果<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/ja636h8hcxa/">写于 2016 年末<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5uomnoq1kmi/">前端学习资源整理<aside class="dates">2019-01-28</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>