<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 的 this 指向问题深度解析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 的 this 指向问题深度解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/y82i9j2q4n/",
				"appid": "1613049289050283", 
				"title": "JavaScript 的 this 指向问题深度解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-26T02:30:18"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/wzrwwwg8zni/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/r0kewiatdoa/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f&text=JavaScript%20%e7%9a%84%20this%20%e6%8c%87%e5%90%91%e9%97%ae%e9%a2%98%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f&text=JavaScript%20%e7%9a%84%20this%20%e6%8c%87%e5%90%91%e9%97%ae%e9%a2%98%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f&title=JavaScript%20%e7%9a%84%20this%20%e6%8c%87%e5%90%91%e9%97%ae%e9%a2%98%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f&is_video=false&description=JavaScript%20%e7%9a%84%20this%20%e6%8c%87%e5%90%91%e9%97%ae%e9%a2%98%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e7%9a%84%20this%20%e6%8c%87%e5%90%91%e9%97%ae%e9%a2%98%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f&title=JavaScript%20%e7%9a%84%20this%20%e6%8c%87%e5%90%91%e9%97%ae%e9%a2%98%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f&title=JavaScript%20%e7%9a%84%20this%20%e6%8c%87%e5%90%91%e9%97%ae%e9%a2%98%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f&title=JavaScript%20%e7%9a%84%20this%20%e6%8c%87%e5%90%91%e9%97%ae%e9%a2%98%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fy82i9j2q4n%2f&title=JavaScript%20%e7%9a%84%20this%20%e6%8c%87%e5%90%91%e9%97%ae%e9%a2%98%e6%b7%b1%e5%ba%a6%e8%a7%a3%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 的 this 指向问题深度解析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-26" itemprop="datePublished">2019-01-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3eJavaScript 中的 \x3ccode\x3ethis\x3c\/code\x3e 指向问题有很多博客在解释，仍然有很多人问。上周我们的开发团队连续两个人遇到相关问题，所以我不得不将关于前端构建技术的交流会延长了半个时候讨论 \x3ccode\x3ethis\x3c\/code\x3e 的问题。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e与我们常见的很多语言不同，JavaScript 函数中的 \x3ccode\x3ethis\x3c\/code\x3e 指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，\x3cstrong\x3e函数的调用方式决定了 \x3ccode\x3ethis\x3c\/code\x3e 指向\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3eJavaScript 中，普通的函数调用方式有三种：直接调用、方法调用和 \x3ccode\x3enew\x3c\/code\x3e 调用。除此之外，还有一些特殊的调用方式，比如通过 \x3ccode\x3ebind()\x3c\/code\x3e 将函数绑定到对象之后再进行调用、通过 \x3ccode\x3ecall()\x3c\/code\x3e、\x3ccode\x3eapply()\x3c\/code\x3e 进行调用等。而 es6 引入了箭头函数之后，箭头函数调用时，其 \x3ccode\x3ethis\x3c\/code\x3e 指向又有所不同。下面就来分析这些情况下的 \x3ccode\x3ethis\x3c\/code\x3e 指向。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e直接调用\x3c\/h2\x3e\n\x3cp\x3e直接调用，就是通过 \x3ccode\x3e函数名(...)\x3c\/code\x3e 这种方式调用。这时候，函数内部的 \x3ccode\x3ethis\x3c\/code\x3e 指向全局对象，在浏览器中全局对象是 \x3ccode\x3ewindow\x3c\/code\x3e，在 NodeJs 中全局对象是 \x3ccode\x3eglobal\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e来看一个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 简单兼容浏览器和 NodeJs 的全局对象\nconst _global = typeof window === \x26quot;undefined\x26quot; ? global : window;\n\nfunction test() {\n    console.log(this === _global);    \/\/ true\n}\n\ntest();    \/\/ 直接调用\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 简单兼容浏览器和 NodeJs 的全局对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e _global = \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x22undefined\x22\x3c\/span\x3e ? global : \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === _global);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n}\n\ntest();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直接调用\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 \x3ccode\x3e函数名(...)\x3c\/code\x3e 来对函数进行调用的方式，都称为直接调用。比如下面这个例子也是直接调用\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function(_global) {\n    \/\/ 通过 IIFE 限定作用域\n\n    function test() {\n        console.log(this === _global);  \/\/ true\n    }\n\n    test();     \/\/ 非全局作用域下的直接调用\n})(typeof window === \x26quot;undefined\x26quot; ? global : window);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e_global\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过 IIFE 限定作用域\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === _global);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n    }\n\n    test();     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 非全局作用域下的直接调用\x3c\/span\x3e\n})(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x22undefined\x22\x3c\/span\x3e ? global : \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3ebind() 对直接调用的影响\x3c\/h3\x3e\n\x3cp\x3e还有一点需要注意的是 \x3ccode\x3ebind()\x3c\/code\x3e 的影响。\x3ccode\x3eFunction.prototype.bind()\x3c\/code\x3e 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 \x3ccode\x3ethis\x3c\/code\x3e 始终指向绑定的对象。还是来看例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\nconst testObj = test.bind(obj);\ntest();     \/\/ false\ntestObj();  \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = {};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e testObj = test.bind(obj);\ntest();     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\ntestObj();  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么 \x3ccode\x3ebind()\x3c\/code\x3e 干了啥？不妨模拟一个 \x3ccode\x3ebind()\x3c\/code\x3e 来了解它是如何做到对 \x3ccode\x3ethis\x3c\/code\x3e 产生影响的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n\/\/ 自定义的函数，模拟 bind() 对 this 的影响\nfunction myBind(func, target) {\n    return function() {\n        return func.apply(target, arguments);\n    };\n}\n\nconst testObj = myBind(test, obj);\ntest();     \/\/ false\ntestObj();  \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = {};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自定义的函数，模拟 bind() 对 this 的影响\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emyBind\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efunc, target\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e func.apply(target, \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n    };\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e testObj = myBind(test, obj);\ntest();     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\ntestObj();  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面的示例可以看到，首先，通过闭包，保持了 \x3ccode\x3etarget\x3c\/code\x3e，即绑定的对象；然后在调用函数的时候，对原函数使用了 \x3ccode\x3eapply\x3c\/code\x3e 方法来指定函数的 \x3ccode\x3ethis\x3c\/code\x3e。当然原生的 \x3ccode\x3ebind()\x3c\/code\x3e 实现可能会不同，而且更高效。但这个示例说明了 \x3ccode\x3ebind()\x3c\/code\x3e 的可行性。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3ecall 和 apply 对 this 的影响\x3c\/h3\x3e\n\x3cp\x3e上面的示例中用到了 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Function\/apply\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFunction.prototype.apply()\x3c\/a\x3e，与之类似的还有 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Function\/call\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFunction.prototype.call()\x3c\/a\x3e。这两方法的用法请大家自己通过链接去看文档。不过，它们的第一个参数都是指定函数运行时其中的 \x3ccode\x3ethis\x3c\/code\x3e 指向。\x3c\/p\x3e\n\x3cp\x3e不过使用 \x3ccode\x3eapply\x3c\/code\x3e 和 \x3ccode\x3ecall\x3c\/code\x3e 的时候仍然需要注意，如果目录函数本身是一个绑定了 \x3ccode\x3ethis\x3c\/code\x3e 对象的函数，那 \x3ccode\x3eapply\x3c\/code\x3e 和 \x3ccode\x3ecall\x3c\/code\x3e 不会像预期那样执行，比如\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const obj = {};\n\nfunction test() {\n    console.log(this === obj);\n}\n\n\/\/ 绑定到一个新对象，而不是 obj\nconst testObj = test.bind({});\ntest.apply(obj);    \/\/ true\n\n\/\/ 期望 this 是 obj，即输出 true\n\/\/ 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false\ntestObj.apply(obj); \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = {};\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绑定到一个新对象，而不是 obj\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e testObj = test.bind({});\ntest.apply(obj);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 期望 this 是 obj，即输出 true\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false\x3c\/span\x3e\ntestObj.apply(obj); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由此可见，\x3ccode\x3ebind()\x3c\/code\x3e 对函数的影响是深远的，慎用！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e方法调用\x3c\/h2\x3e\n\x3cp\x3e方法调用是指通过对象来调用其方法函数，它是 \x3ccode\x3e对象.方法函数(...)\x3c\/code\x3e 这样的调用形式。这种情况下，函数中的 \x3ccode\x3ethis\x3c\/code\x3e 指向调用该方法的对象。但是，同样需要注意 \x3ccode\x3ebind()\x3c\/code\x3e 的影响。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const obj = {\n    \/\/ 第一种方式，定义对象的时候定义其方法\n    test() {\n        console.log(this === obj);\n    }\n};\n\n\/\/ 第二种方式，对象定义好之后为其附加一个方法(函数表达式)\nobj.test2 = function() {\n    console.log(this === obj);\n};\n\n\/\/ 第三种方式和第二种方式原理相同\n\/\/ 是对象定义好之后为其附加一个方法(函数定义)\nfunction t() {\n    console.log(this === obj);\n}\nobj.test3 = t;\n\n\/\/ 这也是为对象附加一个方法函数\n\/\/ 但是这个函数绑定了一个不是 obj 的其它对象\nobj.test4 = (function() {\n    console.log(this === obj);\n}).bind({});\n\nobj.test();     \/\/ true\nobj.test2();    \/\/ true\nobj.test3();    \/\/ true\n\n\/\/ 受 bind() 影响，test4 中的 this 指向不是 obj\nobj.test4();    \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一种方式，定义对象的时候定义其方法\x3c\/span\x3e\n    test() {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n    }\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第二种方式，对象定义好之后为其附加一个方法(函数表达式)\x3c\/span\x3e\nobj.test2 = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n};\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第三种方式和第二种方式原理相同\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 是对象定义好之后为其附加一个方法(函数定义)\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3et\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n}\nobj.test3 = t;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这也是为对象附加一个方法函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但是这个函数绑定了一个不是 obj 的其它对象\x3c\/span\x3e\nobj.test4 = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n}).bind({});\n\nobj.test();     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\nobj.test2();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\nobj.test3();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 受 bind() 影响，test4 中的 this 指向不是 obj\x3c\/span\x3e\nobj.test4();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 \x3ccode\x3eobj\x3c\/code\x3e 对象作为其方法。再次强调，函数内部的 \x3ccode\x3ethis\x3c\/code\x3e 指向与定义无关，受调用方式的影响。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e方法中 this 指向全局对象的情况\x3c\/h3\x3e\n\x3cp\x3e注意这里说的是\x3cstrong\x3e方法\x3c\/strong\x3e中而不是\x3cstrong\x3e方法调用\x3c\/strong\x3e中。方法中的 \x3ccode\x3ethis\x3c\/code\x3e 指向全局对象，如果不是因为 \x3ccode\x3ebind()\x3c\/code\x3e，那就一定是因为不是用的方法调用方式，比如\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const obj = {\n    test() {\n        console.log(this === obj);\n    }\n};\n\nconst t = obj.test;\nt();    \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = {\n    test() {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n    }\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e t = obj.test;\nt();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3et\x3c\/code\x3e 就是 \x3ccode\x3eobj\x3c\/code\x3e 的 \x3ccode\x3etest\x3c\/code\x3e 方法，但是 \x3ccode\x3et()\x3c\/code\x3e 调用时，其中的 \x3ccode\x3ethis\x3c\/code\x3e 指向了全局。\x3c\/p\x3e\n\x3cp\x3e之所以要特别提出这种情况，主要是因为常常将一个对象方法作为回调传递给某个函数之后，却发现运行结果与预期不符——因为忽略了调用方式对 \x3ccode\x3ethis\x3c\/code\x3e 的影响。比如下面的例子是在页面中对某些事情进行封装之后特别容易遇到的问题：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Handlers {\n    \/\/ 这里 $button 假设是一个指向某个按钮的 jQuery 对象\n    constructor(data, $button) {\n        this.data = data;\n        $button.on(\x26quot;click\x26quot;, this.onButtonClick);\n    }\n\n    onButtonClick(e) {\n        console.log(this.data);\n    }\n}\n\nconst handlers = new Handlers(\x26quot;string data\x26quot;, $(\x26quot;#someButton\x26quot;));\n\/\/ 对 #someButton 进行点击操作之后\n\/\/ 输出 undefined\n\/\/ 但预期是输出 string data\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHandlers\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里 $button 假设是一个指向某个按钮的 jQuery 对象\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(data, $button) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data;\n        $button.on(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onButtonClick);\n    }\n\n    onButtonClick(e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data);\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e handlers = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Handlers(\x3cspan class=\x22hljs-string\x22\x3e\x22string data\x22\x3c\/span\x3e, $(\x3cspan class=\x22hljs-string\x22\x3e\x22#someButton\x22\x3c\/span\x3e));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对 #someButton 进行点击操作之后\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 undefined\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但预期是输出 string data\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ethis.onButtonClick\x3c\/code\x3e 作为一个参数传入 \x3ccode\x3eon()\x3c\/code\x3e 之后，事件触发时，理论上是对这个函数进行的直接调用，而不是方法调用，所以其中的 \x3ccode\x3ethis\x3c\/code\x3e 会指向全局对象 —— 但实际上由于调用事件处理函数的时候，\x3ccode\x3ethis\x3c\/code\x3e 指向会绑定到触发事件的 DOM 元素上，所以这里的 \x3ccode\x3ethis\x3c\/code\x3e 是指向触发事件的的 DOM 元素(注意：\x3ccode\x3ethis\x3c\/code\x3e 并非 jQuery 对象)，即 \x3ccode\x3e$button.get(0)\x3c\/code\x3e(注意代码前注释中的假设)。\x3c\/p\x3e\n\x3cp\x3e要解决这个问题有很多种方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这是在 es5 中的解决办法之一\nvar _this = this;\n$button.on(\x26quot;click\x26quot;, function() {\n    _this.onButtonClick();\n});\n\n\/\/ 也可以通过 bind() 来解决\n$button.on(\x26quot;click\x26quot;, this.onButtonClick.bind(this));\n\n\/\/ es6 中可以通过箭头函数来处理，在 jQuery 中慎用\n$button.on(\x26quot;click\x26quot;, e =\x3e this.onButtonClick(e));\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这是在 es5 中的解决办法之一\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n$button.on(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    _this.onButtonClick();\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 也可以通过 bind() 来解决\x3c\/span\x3e\n$button.on(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onButtonClick.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ es6 中可以通过箭头函数来处理，在 jQuery 中慎用\x3c\/span\x3e\n$button.on(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e, e =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onButtonClick(e));\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不过请注意，将箭头函数用作 jQuery 的回调时造成要小心函数内对 \x3ccode\x3ethis\x3c\/code\x3e 的使用。jQuery 大多数回调函数(非箭头函数)中的 \x3ccode\x3ethis\x3c\/code\x3e 都是表示调用目标，所以可以写 \x3ccode\x3e$(this).text()\x3c\/code\x3e 这样的语句，但 jQuery 无法改变箭头函数的 \x3ccode\x3ethis\x3c\/code\x3e 指向，同样的语句语义完全不同。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3enew 调用\x3c\/h2\x3e\n\x3cp\x3e在 es6 之前，每一个函数都可以当作是构造函数，通过 \x3ccode\x3enew\x3c\/code\x3e 调用来产生新的对象(函数内无特定返回值的情况下)。而 es6 改变了这种状态，虽然 \x3ccode\x3eclass\x3c\/code\x3e 定义的类用 \x3ccode\x3etypeof\x3c\/code\x3e 运算符得到的仍然是 \x3ccode\x3e\x22function\x22\x3c\/code\x3e，但它不能像普通函数一样直接调用；同时，\x3ccode\x3eclass\x3c\/code\x3e 中定义的方法函数，也不能当作构造函数用 \x3ccode\x3enew\x3c\/code\x3e 来调用。\x3c\/p\x3e\n\x3cp\x3e而在 es5 中，用 \x3ccode\x3enew\x3c\/code\x3e 调用一个构造函数，会创建一个新对象，而其中的 \x3ccode\x3ethis\x3c\/code\x3e 就指向这个新对象。这没有什么悬念，因为 \x3ccode\x3enew\x3c\/code\x3e 本身就是设计来创建新对象的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var data = \x26quot;Hi\x26quot;;    \/\/ 全局变量\n\nfunction AClass(data) {\n    this.data = data;\n}\n\nvar a = new AClass(\x26quot;Hello World\x26quot;);\nconsole.log(a.data);    \/\/ Hello World\nconsole.log(data);      \/\/ Hi\n\nvar b = new AClass(\x26quot;Hello World\x26quot;);\nconsole.log(a === b);   \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e data = \x3cspan class=\x22hljs-string\x22\x3e\x22Hi\x22\x3c\/span\x3e;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 全局变量\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eAClass\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e AClass(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello World\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a.data);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Hello World\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Hi\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e b = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e AClass(\x3cspan class=\x22hljs-string\x22\x3e\x22Hello World\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a === b);   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e箭头函数中的 this\x3c\/h2\x3e\n\x3cp\x3e先来看看 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Functions\/Arrow_functions\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN 上对箭头函数的说明\x3c\/a\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eAn arrow function expression has a shorter syntax than a function expression and does \x3cstrong\x3enot\x3c\/strong\x3e bind its own \x3ccode\x3ethis\x3c\/code\x3e, \x3ccode\x3earguments\x3c\/code\x3e, \x3ccode\x3esuper\x3c\/code\x3e, or \x3ccode\x3enew.target\x3c\/code\x3e. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这里已经清楚了说明了，箭头函数没有自己的 \x3ccode\x3ethis\x3c\/code\x3e 绑定。箭头函数中使用的 \x3ccode\x3ethis\x3c\/code\x3e，其实是直接包含它的那个函数或函数表达式中的 \x3ccode\x3ethis\x3c\/code\x3e。比如\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const obj = {\n    test() {\n        const arrow = () =\x3e {\n            \/\/ 这里的 this 是 test() 中的 this，\n            \/\/ 由 test() 的调用方式决定\n            console.log(this === obj);\n        };\n        arrow();\n    },\n\n    getArrow() {\n        return () =\x3e {\n            \/\/ 这里的 this 是 getArrow() 中的 this，\n            \/\/ 由 getArrow() 的调用方式决定\n            console.log(this === obj);\n        };\n    }\n};\n\nobj.test();     \/\/ true\n\nconst arrow = obj.getArrow();\narrow();        \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = {\n    test() {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arrow = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的 this 是 test() 中的 this，\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由 test() 的调用方式决定\x3c\/span\x3e\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n        };\n        arrow();\n    },\n\n    getArrow() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里的 this 是 getArrow() 中的 this，\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由 getArrow() 的调用方式决定\x3c\/span\x3e\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n        };\n    }\n};\n\nobj.test();     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arrow = obj.getArrow();\narrow();        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e示例中的两个 \x3ccode\x3ethis\x3c\/code\x3e 都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 \x3ccode\x3ethis\x3c\/code\x3e 是由其调用方式决定的。上例的调用方式都是方法调用，所以 \x3ccode\x3ethis\x3c\/code\x3e 都指向方法调用的对象，即 \x3ccode\x3eobj\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e箭头函数让大家在使用闭包的时候不需要太纠结 \x3ccode\x3ethis\x3c\/code\x3e，不需要通过像 \x3ccode\x3e_this\x3c\/code\x3e 这样的局部变量来临时引用 \x3ccode\x3ethis\x3c\/code\x3e 给闭包函数使用。来看一段 Babel 对箭头函数的转译可能能加深理解：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ES6\nconst obj = {\n    getArrow() {\n        return () =\x3e {\n            console.log(this === obj);\n        };\n    }\n}    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ES6\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e obj = {\n    getArrow() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === obj);\n        };\n    }\n}    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ES5，由 Babel 转译\nvar obj = {\n    getArrow: function getArrow() {\n        var _this = this;\n        return function () {\n            console.log(_this === obj);\n        };\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ES5，由 Babel 转译\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3egetArrow\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetArrow\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(_this === obj);\n        };\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e另外需要注意的是，箭头函数不能用 \x3ccode\x3enew\x3c\/code\x3e 调用，不能 \x3ccode\x3ebind()\x3c\/code\x3e 到某个对象(虽然 \x3ccode\x3ebind()\x3c\/code\x3e 方法调用没问题，但是不会产生预期效果)。不管在什么情况下使用箭头函数，它本身是没有绑定 \x3ccode\x3ethis\x3c\/code\x3e 的，它用的是直接外层函数(即包含它的最近的一层函数或函数表达式)绑定的 \x3ccode\x3ethis\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e勘误\x3c\/h2\x3e\n\x3cul\x3e\x3cli\x3ethis.onButtonClick 用于 jQuery 事件的时候，\x3ccode\x3ethis\x3c\/code\x3e 已经被 jQuery 改为指向触发事件的元素，感谢 \x3ca href=\x22\/u\/yuelianggege\x22\x3e@月亮哥哥\x3c\/a\x3e 和 \x3ca href=\x22\/u\/qovoq\x22\x3e@QoVoQ\x3c\/a\x3e 指出。此错误已经在文中修改了。\x3c\/li\x3e\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 的 this 指向问题深度解析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008400124">https://segmentfault.com/a/1190000008400124</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/y82i9j2q4n/" target="_blank">https://alili.tech/archive/y82i9j2q4n/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>