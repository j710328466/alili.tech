<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="【译】JavaScript数据结构（2）：栈与队列"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>【译】JavaScript数据结构（2）：栈与队列 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/fw2oi43q3ka/",
				"appid": "1613049289050283", 
				"title": "【译】JavaScript数据结构（2）：栈与队列 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-07T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/nhqq7i3ibq/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/mp663bk23f/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f&text=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%882%ef%bc%89%ef%bc%9a%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f&text=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%882%ef%bc%89%ef%bc%9a%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%882%ef%bc%89%ef%bc%9a%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f&is_video=false&description=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%882%ef%bc%89%ef%bc%9a%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%882%ef%bc%89%ef%bc%9a%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%882%ef%bc%89%ef%bc%9a%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%882%ef%bc%89%ef%bc%9a%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%882%ef%bc%89%ef%bc%9a%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ffw2oi43q3ka%2f&title=%e3%80%90%e8%af%91%e3%80%91JavaScript%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%ef%bc%882%ef%bc%89%ef%bc%9a%e6%a0%88%e4%b8%8e%e9%98%9f%e5%88%97"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">【译】JavaScript数据结构（2）：栈与队列</h1><div class="meta"><div class="postdate"><time datetime="2019-01-07" itemprop="datePublished">2019-01-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e翻译\x3c\/strong\x3e：疯狂的技术宅\x3cbr\x3e\x3cstrong\x3e英文\x3c\/strong\x3e：\x3ca href=\x22https:\/\/code.tutsplus.com\/articles\/data-structures-with-javascript-stack-and-queue--cms-23348\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/code.tutsplus.com\/art...\x3c\/a\x3e\x3cbr\x3e\x3cstrong\x3e说明\x3c\/strong\x3e：本文翻译自系列文章《Data Structures With JavaScript》，总共为四篇，原作者是在美国硅谷工作的工程师 Cho S. Kim 。这是上本系列的第二篇。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e说明：本专栏文章首发于公众号：jingchengyideng 。\x3c\/p\x3e\n\x3cp\x3e栈和队列是web开发中最常用的两种数据结构。绝大多数用户，甚至包括web开发人员，都不知道这个惊人的事实。如果你是一个程序员，那么请听我讲两个启发性的例子:使用堆栈来组织数据，来实现文本编辑器的“撤消”操作;使用队列处理数据，实现web浏览器的事件循环处理事件(单击click、悬停hoover等)。\x3c\/p\x3e\n\x3cp\x3e等等，先想象一下我们作为用户和程序员，每天使用栈和队列的次数，这太惊人了吧！由于它们在设计上有普遍性和相似性，我决定从这里开始为大家介绍数据结构。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e\x3cstrong\x3e栈\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3e在计算机科学中，栈是一种线性数据结构。如果你理解起来有困难，就像最初非常困惑的我一样，不妨这样认为：一个栈可以对数据按照顺序进行组织和管理。\x3c\/p\x3e\n\x3cp\x3e要理解这种顺序，我们可以把栈这种结构想象为自助餐厅的一堆盘子，当一个盘子被叠加到一堆盘子上时，原有的盘子保留了它们原来的顺序；同时，当一个新盘子被添加时，它会朝栈的底部方向堆积。每当我们添加一个新盘子时，被称作入栈，这个新盘子处于栈的顶部，也被称作栈顶。\x3c\/p\x3e\n\x3cp\x3e这个添加盘子的过程会保留每个盘子被添加到栈中的顺序，每次从栈中取出一个盘子时也是一样的。我可能用了太多的篇幅来描述自助餐厅中的盘子是怎样被添加和删除的过程。\x3c\/p\x3e\n\x3cp\x3e为了是大家理解栈更多的技术细节，让我们回顾一下前面关于文本编辑器的“撤消”操作。每次将文本添加到文本编辑器事，该文本被压入栈中。其中第一次添加的文本代表栈的底部（栈底）；最后一次的修改表示栈的顶部（栈顶）。如果用户希望撤销最后一次修改，则删除处于栈的顶部的那段文本，这个过程可以不断重复，一直到栈中没有更多内容，这时我们会得到一个空白文件。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e\x3cstrong\x3e栈的操作\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e现在我们对栈的模型有了基本概念，下一步就要定义栈的两个操作：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3epush(data) 添加数据\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3epop() 删除最后添加的数据\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\x3cstrong\x3e栈的实现\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e现在让我们开始为栈编写代码吧！\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e栈的属性\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e为了实现栈结构，我们将会创建一个名为 Stack 的构造函数。栈的每个实例都有两个属性：_size 和 _storage。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Stack() {\n    this._size = 0;\n    this._storage = {};\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStack\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._size = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage = {};\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ethis._storage 属性使栈的每一个实例都具有自己的用来存储数据的容器； this._size 属性反映了当前栈中数据的个数。如果创建了一个新的栈的实例，并且有一个数据被存入栈中，那么 this._size 的值将被增加到1。如果又有数据入栈，this._size 的值将增加到2。如果一个数据从栈中被取出，this._size 的值将会减少为1。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e栈的方法(操作)\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e我们需要定义可以向栈中添加（入栈）和从栈中取出（出栈）数据的方法。让我们从添加数据开始。\x3c\/p\x3e\n\x3ch4\x3e\n\x3cstrong\x3e方法1\/2:\x3c\/strong\x3e push(data)\x3c\/h4\x3e\n\x3cp\x3e（每一个栈的实例都具有这个方法，所以我们把它添加到栈结构的原型中）\x3c\/p\x3e\n\x3cp\x3e我们对这个方法有两个要求：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e每当添加数据时, 我们希望能够增加栈的大小。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e每当添加数据时,我们希望能够保留它的添加顺序。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Stack.prototype.push = function(data) {\n    \/\/ increases the size of our storage\n    var size = this._size\x2b\x2b;\n \n    \/\/ assigns size as a key of storage\n    \/\/ assigns data as the value of this key\n    this._storage[size] = data;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3eStack.prototype.push = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ increases the size of our storage\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._size\x2b\x2b;\n \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ assigns size as a key of storage\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ assigns data as the value of this key\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e] = data;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们实现push(data)方法时要包含以下逻辑：声明一个变量 size 并赋值为 this._size\x2b\x2b。指定 size 为 this._storage 的键;并将数据赋给相应键的值。\x3c\/p\x3e\n\x3cp\x3e如果我们调用push(data)方法5次，那么栈的大小将是5。第一次入栈时，将会把数据存入this._storage 中键名为1对应的空间，当第5次入栈时，将会把数据存入this._storage 中键名为5对应的空间。现在我们的数据有了顺序！\x3c\/p\x3e\n\x3ch4\x3e\n\x3cstrong\x3e方法2\/2:\x3c\/strong\x3e pop()\x3c\/h4\x3e\n\x3cp\x3e我们已经实现了把数据送入栈中，下一步我们要从栈中弹出（删除）数据。从栈中弹出数据并不是简单的删除数据，它只删除最后一次添加的数据。\x3c\/p\x3e\n\x3cp\x3e以下是这个方法的要点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e使用栈当前的大小获得最后一次添加的数据。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e删除最后一次添加的数据。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e使 _this._size 计数减一。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e返回刚刚删除的数据。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Stack.prototype.pop = function() {\n    var size = this._size,\n        deletedData;\n \n    deletedData = this._storage[size];\n \n    delete this._storage[size];\n    this.size--;\n \n    return deletedData;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3eStack.prototype.pop = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._size,\n        deletedData;\n \n    deletedData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e];\n \n    \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.size--;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e deletedData;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3epop()方法满足以上四个要点。首先，我们声明了两个变量：size 用来初始化栈的大小；deletedData 用来保存栈中最后一次添加的数据。第二，我们删除了最后一次添加的数据的键值对。第三，我们把栈的大小减少了1.第四，返回从栈中删除的数据。\x3c\/p\x3e\n\x3cp\x3e如果我们测试当前实现的pop()方法，会发现它适用下面的案例：如果向栈内push数据，栈的大小会增加1，如果从栈中pop()数据，栈的大小会减少1！\x3c\/p\x3e\n\x3cp\x3e为了处理这个用例，我们将向pop()中添加if语句。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Stack.prototype.pop = function() {\n    var size = this._size,\n        deletedData;\n \n    if (size) {\n        deletedData = this._storage[size];\n \n        delete this._storage[size];\n        this._size--;\n \n        return deletedData;\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3eStack.prototype.pop = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._size,\n        deletedData;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e) {\n        deletedData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e];\n \n        \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e];\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._size--;\n \n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e deletedData;\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过添加if语句，可以使代码在存储中有数据时才被执行。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e栈的完整实现\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e我们已经实现了完整的栈结构。不管以怎样的顺序调用任何一个方法，代码都可以工作！下面使代码的最终版本：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Stack() {\n    this._size = 0;\n    this._storage = {};\n}\n \nStack.prototype.push = function(data) {\n    var size = \x2b\x2bthis._size;\n    this._storage[size] = data;\n};\n \nStack.prototype.pop = function() {\n    var size = this._size,\n        deletedData;\n \n    if (size) {\n        deletedData = this._storage[size];\n \n        delete this._storage[size];\n        this._size--;\n \n        return deletedData;\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eStack\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._size = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage = {};\n}\n \nStack.prototype.push = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e = \x2b\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._size;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e] = data;\n};\n \nStack.prototype.pop = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._size,\n        deletedData;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e) {\n        deletedData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e];\n \n        \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-built_in\x22\x3esize\x3c\/span\x3e];\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._size--;\n \n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e deletedData;\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e\x3cstrong\x3e从栈到队列\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3e当我们想要按顺序添加数据或删除数据时，可以使用栈结构。根据它的定义，栈可以只删除最近添加的数据。如果想要删除最早的数据该怎么办呢?这时我们希望使用名为queue的数据结构。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e\x3cstrong\x3e队列\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3e与栈类似，队列也是一个线性数据结构。与栈不同的是，队列只删除最先添加的数据。\x3c\/p\x3e\n\x3cp\x3e为了帮助你明白队列是如何工作的，让我们花点时间举个例子。我们可以把队列想象成为熟食店的售票系统。每个顾客拿一张票，当他们的号码被呼叫时接受服务。持第一张票的顾客首先接受服务。\x3c\/p\x3e\n\x3cp\x3e再进一步想象一下，这张票上有一个数字“1”。下一张票上有数字“2”。得到二张票的顾客将会第二个接受服务。（如果我们的售票系统像栈一样运行，最先进入堆栈的客户将会最后一个接受服务！）\x3c\/p\x3e\n\x3cp\x3e队列的一个更实际的例子是Web浏览器的事件循环。当触发不同事件时，例如单击某个按钮，点击事件将被添加到事件循环队列中，并按照它们进入队列的顺序进行处理。\x3c\/p\x3e\n\x3cp\x3e现在我们具有了队列的概念，接下来就要定义它的操作。你会注意到，队列的操作和栈非常相似。区别就在被删除的数据在什么地方。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eenqueue(data) 将数据添加到队列中。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3edequeue 删除最早加入队列的数据。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e\x3cstrong\x3e队列的实现\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3e现在让我们开始写队列的代码吧！\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\x3cstrong\x3e队列的属性\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e在实现队列的代码中，我们将会创建一个名为 Queue 的构造方法。接下来添加三个属性：_oldestIndex, _newestIndex, 和 _storage。在下一小节中，_oldestIndex 和 _newestIndex 的作用将变得更加清晰。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Queue() {\n    this._oldestIndex = 1;\n    this._newestIndex = 1;\n    this._storage = {};\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eQueue\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._oldestIndex = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._newestIndex = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage = {};\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e\x3cstrong\x3e队列的方法\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e现在我们将创建队列会用到的三个方法：size(), enqueue(data), 和 dequeue(data)。我将描述每个方法的作用，写出每个方法的代码，然后解释这些代码。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e方法1\/3：size( )\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e这个方法有两个作用：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e返回当前队列的长度。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e保持队列中键的正确范围。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Queue.prototype.size = function() {\n    return this._newestIndex - this._oldestIndex;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3eQueue.prototype.size = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._newestIndex - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._oldestIndex;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实现 size() 可能显得微不足道，但你会很快发现并不是这样的。为了理解其原因，我们必须快速重新审视 size() 在栈结构中的实现。\x3c\/p\x3e\n\x3cp\x3e回想一下栈的概念模型，假设我们把5个盘子添加到一个栈上。栈的大小是5，每个盘子都有一个数字，从1(第一个添加的盘子)到5(最后一个添加的盘子)。如果我们取走三个盘子，就只剩下两个盘子。我们可以简单地用5减去3，得到正确的大小，也就是2。这是关于栈大小最重要的一点：当前大小相当于从栈顶部的盘子（2）到栈中其他盘子（1）的计数。换句话说，键的范围总是从当前大小到1之间。\x3c\/p\x3e\n\x3cp\x3e现在，让我们将栈大小的实现应用到队列中。假设有五个顾客从我们的售票系统中取到了票。第一个顾客有一张显示数字1的票，第五个客户有一张显示数字5的票。现在有了一个队列，拿着第一张票的第一位顾客。\x3c\/p\x3e\n\x3cp\x3e假设第一个客户接受了服务，这张票会从队列中被移除。与栈类似，我们可以通过从5减去1来获得队列的正确大小。那么服务队列中还有4张票。现在出现了一个问题：队列的大小不能对应正确的票号。如果我们从五减去一个，得到大小是4，但是不能使用4来确定当前队列中剩余票的编号范围。我们并不能确定队列中票号的顺序到底是1到4还是2到5。\x3c\/p\x3e\n\x3cp\x3e这就是 oldestIndex 和 newestIndex 这两个属性 在队列中的用途。所有这一切似乎令人困惑——到现在我仍然会偶尔觉得困惑。下面的例子可以帮助我门理顺所有的逻辑。\x3c\/p\x3e\n\x3cp\x3e假设我们的熟食店有两个售票系统：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e_newestindex 代表顾客售票系统的票。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e_oldestindex 代表员工售票系统的票。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e对于两个售票系统来说，这是最难掌握的概念：当两个系统中的数字相同时，队列中的每个客户都被处理了，队列是空的。我们将使用下面的场景来加强这种逻辑：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e当顾客买票时，顾客的票号从_newestIndex 得到，票的编号是1。顾客售票系统的下一张票号码是2。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e员工不买票，员工售票系统中当前票的编号是1。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e我们在顾客系统中得到当前的票号2，减去员工系统中的号码1，得到的结果是1。这个数字1表示仍然在队列中没有被删除的票的数量\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e员工从它们的售票系统中取票，这张票代表正在被服务的顾客的票号，从_oldestIndex中得到，数字为1。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e重复第4步，现在差为0，队列中没有其他的票了。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e现在属性 _newestindex可以告诉我们被分配在队列中票号的最大值（键），属性 _oldestindex 可以告诉我们最先进入队列中票号（键）。\x3c\/p\x3e\n\x3cp\x3e探讨完了size()，接下来看enqueue(data)方法。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e方法2\/3：enqueue(data)\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e对于 enqueue 方法，有两个功能：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e使用_newestIndex 的值作为 this._storage 的键，并使用要添加的数据作为该键的值。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将_newestIndex 的值增加1。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e基于这两个功能，我们将编写 enqueue(data) 方法的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Queue.prototype.enqueue = function(data) {\n    this._storage[this._newestIndex] = data;\n    this._newestIndex\x2b\x2b;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eQueue.prototype.enqueue = function(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._newestIndex] = \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._newestIndex\x2b\x2b;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该方法的主体只有两行代码。 在第一行，用 this._newestIndex 为this._storage 创建一个新的键，并为其分配数据。 this._newestIndex 始终从1开始。在第二行代码中，我们将 this._newestIndex 的值增加1，将其更新为2。\x3c\/p\x3e\n\x3cp\x3e以上是方法 enqueue(data) 的所有代码。下面我们来实现方法 dequeue( )。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e方法2\/3：dequeue( )\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e以下是此方法的两个功能点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e删除队列中最旧的数据。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e属性 _oldestIndex 加1。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Queue.prototype.dequeue = function() {\n    var oldestIndex = this._oldestIndex,\n        deletedData = this._storage[oldestIndex];\n \n    delete this._storage[oldestIndex];\n    this._oldestIndex\x2b\x2b;\n \n    return deletedData;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eQueue.prototype.dequeue = function() {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldestIndex = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._oldestIndex,\n        deletedData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[oldestIndex];\n \n    delete \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._storage[oldestIndex];\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._oldestIndex\x2b\x2b;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e deletedData;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在 dequeue( )的代码中，我们声明两个变量。 第一个变量 oldestIndex 给 this._oldestIndex 赋值。第二个变量 deletedData 被赋予 this._storage[oldestIndex] 的值。\x3c\/p\x3e\n\x3cp\x3e下一步，删除队列中最早的索引。之后将 this._oldestIndex 的值加1。最后返回刚刚被删除的数据。\x3c\/p\x3e\n\x3cp\x3e与栈的 pop() 方法第一次实现中出现的问题类似，dequeue() 在队列中没有数据的情况下不应该被执行。我们需要一些代码来处理这种情况。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Queue.prototype.dequeue = function() {\n    var oldestIndex = this._oldestIndex,\n        newestIndex = this._newestIndex,\n        deletedData;\n \n    if (oldestIndex !== newestIndex) {\n        deletedData = this._storage[oldestIndex];\n        delete this._storage[oldestIndex];\n        this._oldestIndex\x2b\x2b;\n \n        return deletedData;\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3eQueue.prototype.dequeue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldestIndex = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._oldestIndex,\n        \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._new\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e,\n        deletedData;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldestIndex !== \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e) {\n        deletedData = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._storage[oldestIndex];\n        delete \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._storage[oldestIndex];\n        \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._oldestIndex\x2b\x2b;\n \n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e deletedData;\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每当 oldestIndex 和 newestIndex 的值不相等时，我们就执行前面的逻辑。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e\x3cstrong\x3e队列的完整实现代码\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e到此为止，我们实现了一个完整的队列结构的逻辑。下面是全部代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Queue() {\n    this._oldestIndex = 1;\n    this._newestIndex = 1;\n    this._storage = {};\n}\n \nQueue.prototype.size = function() {\n    return this._newestIndex - this._oldestIndex;\n};\n \nQueue.prototype.enqueue = function(data) {\n    this._storage[this._newestIndex] = data;\n    this._newestIndex\x2b\x2b;\n};\n \nQueue.prototype.dequeue = function() {\n    var oldestIndex = this._oldestIndex,\n        newestIndex = this._newestIndex,\n        deletedData;\n \n    if (oldestIndex !== newestIndex) {\n        deletedData = this._storage[oldestIndex];\n        delete this._storage[oldestIndex];\n        this._oldestIndex\x2b\x2b;\n \n        return deletedData;\n    }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eQueue\x3c\/span\x3e\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._oldestIndex = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._new\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._storage = {};\n}\n \nQueue.prototype.size = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._new\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e - \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._oldestIndex;\n};\n \nQueue.prototype.enqueue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e(data) {\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._storage[\x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._new\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e] = data;\n    \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._new\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e\x2b\x2b;\n};\n \nQueue.prototype.dequeue = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldestIndex = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._oldestIndex,\n        \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._new\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e,\n        deletedData;\n \n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldestIndex !== \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e\x3cspan class=\x22hljs-type\x22\x3eestIndex\x3c\/span\x3e) {\n        deletedData = \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._storage[oldestIndex];\n        delete \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._storage[oldestIndex];\n        \x3cspan class=\x22hljs-built_in\x22\x3ethis\x3c\/span\x3e._oldestIndex\x2b\x2b;\n \n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e deletedData;\n    }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e\x3cstrong\x3e结束语\x3c\/strong\x3e\x3c\/h2\x3e\n\x3cp\x3e在本文中，我们探讨了两个线性数据结构：栈和队列。栈按照顺序存储数据，并删除最后添加的数据；队列按顺序存储数据，但删除最先的添加数据。\x3c\/p\x3e\n\x3cp\x3e如果这些数据结构的实现看起来微不足道，请提醒自己数据结构的用途。它们并没有被设计得过于复杂，它们是用来帮助我们组织数据的。在这种情况下，如果您发现有需要按顺序组织数据的场合，请考虑使用栈或队列。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e欢迎扫描二维码关注公众号，每天推送我翻译的技术文章。\x3c\/strong\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVRyYe?w=430\x26amp;h=430\x22 src=\x22https:\/\/static.alili.tech\/img\/bVRyYe?w=430\x26amp;h=430\x22 alt=\x22欢迎扫描二维码关注公众号，每天推送我翻译的技术文章\x22 title=\x22欢迎扫描二维码关注公众号，每天推送我翻译的技术文章\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>【译】JavaScript数据结构（2）：栈与队列</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010344706">https://segmentfault.com/a/1190000010344706</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/fw2oi43q3ka/" target="_blank">https://alili.tech/archive/fw2oi43q3ka/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>