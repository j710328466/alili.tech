<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JS中的观察者模式(发布订阅)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JS中的观察者模式(发布订阅) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/23ftsgrtzzc/",
				"appid": "1613049289050283", 
				"title": "JS中的观察者模式(发布订阅) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-29T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/6zyet64jeml/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/iuyeljg6lm/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f&text=JS%e4%b8%ad%e7%9a%84%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%28%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f&text=JS%e4%b8%ad%e7%9a%84%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%28%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f&title=JS%e4%b8%ad%e7%9a%84%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%28%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f&is_video=false&description=JS%e4%b8%ad%e7%9a%84%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%28%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JS%e4%b8%ad%e7%9a%84%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%28%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f&title=JS%e4%b8%ad%e7%9a%84%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%28%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f&title=JS%e4%b8%ad%e7%9a%84%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%28%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f&title=JS%e4%b8%ad%e7%9a%84%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%28%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f23ftsgrtzzc%2f&title=JS%e4%b8%ad%e7%9a%84%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%28%e5%8f%91%e5%b8%83%e8%ae%a2%e9%98%85%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JS中的观察者模式(发布订阅)</h1><div class="meta"><div class="postdate"><time datetime="2019-01-29" itemprop="datePublished">2019-01-29</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch4\x3e观察者模式\x3c\/h4\x3e\n\x3cblockquote\x3e\x3cp\x3e简介\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e观察者模式又称发布订阅模式，是一种最常用的设计模式之一了。讲道理，如果我们写的不是稍微底层的代码，可能不会用到它。 但是有了它会让代码更灵活，更加规整，减少冗余代码，方便分模块，分功能开发。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e引入\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e在前端业务中，可能用的比较多的地方可能就是自定义事件了。\x3cbr\x3e其实浏览器的事件也是观察者模式\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\ndiv.onclick = function click() {\n    console.log(\x27click\x27)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\ndiv.onclick = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eclick\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里function click 订阅了 div 的click 事件，当我们的鼠标点击操作，事件发布，对应的function就会执行。这个function click 就是一个观察者。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e具象化理解\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e其实单纯的看代码实现，也可以理解。但是万物都是有联系的，这些编程模式设计之初也是来源于生活经验吧，所以，具象的理解也是很重要的体验。\x3c\/p\x3e\n\x3cp\x3e我们举一个结婚办酒席的例子。比如你的一个好朋友要结婚了，\x27结婚\x27这件事情不是天天发生，一辈子就那么一... 两次(maybe more)，所以我们的\x27去参加他的婚礼\x27肯定不是天天发生，只是在特定的时候。我肯定不能天天去问他，\x27今天你结婚吗，我来参加酒席啊\x27。一次两次还行，天天问，sb啊。假如是一个找不到对象的单身汪，被你天天这么问，还不得杀了你。。\x3c\/p\x3e\n\x3cp\x3e那这里就需要有一个事件发布了，也就是\x27通知你\x27。 \x3c\/p\x3e\n\x3cp\x3e我作为一个观察者，去订阅他\x27结婚\x27 的这个事件，就是我们是好朋友，他的婚礼我肯定去，我们已经说好了。那么我就是观察者，\x27我去参加婚礼\x27就是对应而来的动作。当我订阅了\x27结婚\x27 这个事件，我就不需要天天去问他了，我该干嘛干嘛，该去泡妞，约饭，看电影，约...  就干嘛。\x3c\/p\x3e\n\x3cp\x3e当他发布\x27结婚\x27 这个事件，通知到我了，我就在特定的时候，去do\x27参加婚礼酒席\x27这个行为function ...\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/模拟代码\n\n\/\/我订阅了\x27marry\x27 事件\nwo.on(\x27marry\x27,function(){\n    \/\/去参加婚礼酒席\n})\n\n\/\/然后他发布。比如浏览器的点击\n\/\/ 对应的我的 function就会执行\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/模拟代码\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/我订阅了\x27marry\x27 事件\x3c\/span\x3e\nwo.on(\x3cspan class=\x22hljs-string\x22\x3e\x27marry\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/去参加婚礼酒席\x3c\/span\x3e\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/然后他发布。比如浏览器的点击\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对应的我的 function就会执行\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e解耦\/模块\/功能\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e其实在代码中是需要一个类似于中间服务的,管理发布订阅的中间者。\x3cbr\x3e比如浏览器中的事件处理程序，他提供了订阅的接口，然后接收\x27事件\x27 信号 发布给你。让js代码跟浏览器之间有了联系，互动。而本来是两个不同的东西。\x3c\/p\x3e\n\x3cp\x3e在我看来，观察者模式最大的好处就是在于解耦，会让我们一锅端的代码，分功能，分模块的抽离开，更加清晰，开发成本变低，也容易维护。\x3cbr\x3e比如：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3e我们项目里的view 展示层跟model(数据处理)逻辑层，最开始写页面，ajax，字符串拼接，请求回一个接口拼一下，然后给dom。可能我们一个js文件，一个function里面又请求了接口，又去负责 view 的展示。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = new XMLHttpRequest ()\n xhr.open(\x27get\x27,url)\n xhr.onreadystatechange = function () {\n   if(this.readyState !== 4) return\n   if(this.status === 200) {\n     divs.innerHTML = \x27\x3cp\x3e\x27 \x2b this.response \x2b \x27\x3c\/p\x3e\x27\n     \/\/\n   }\n }\n xhr.responseType = \x27json\x27\n xhr.send(null)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = new XMLHttpRequest ()\n xhr.\x3cspan class=\x22hljs-keyword\x22\x3eopen\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27get\x27\x3c\/span\x3e,url)\n xhr.onreadystatechange = function () {\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.readyState !== \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status === \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e) {\n     divs.innerHTML = \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;p\x26gt;\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.response \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;\/p\x26gt;\x27\x3c\/span\x3e\n     \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x3c\/span\x3e\n   }\n }\n xhr.responseType = \x3cspan class=\x22hljs-string\x22\x3e\x27json\x27\x3c\/span\x3e\n xhr.send(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e其实应该是请求跟 展示渲染分开的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 \/\/请求\n function getData () {\n      var xhr = new XMLHttpRequest ()\n    xhr.open(\x27get\x27,url)\n    xhr.onreadystatechange = function () {\n      if(this.readyState !== 4) return\n      if(this.status === 200) {\n        this.emit(\x27渲染\x27)\n        \/\/ 发布\n      }\n    }\n    xhr.responseType = \x27json\x27\n    xhr.send(null)\n }\n \n    \n \/\/渲染\n function view () {}\n \n xhr.on(\x27渲染\x27,view)\n     \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/请求\x3c\/span\x3e\n \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetData\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest ()\n    xhr.open(\x3cspan class=\x22hljs-string\x22\x3e\x27get\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-built_in\x22\x3eurl\x3c\/span\x3e)\n    xhr.onreadystatechange = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.readyState !== \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.status === \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27渲染\x27\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发布\x3c\/span\x3e\n      }\n    }\n    xhr.responseType = \x3cspan class=\x22hljs-string\x22\x3e\x27json\x27\x3c\/span\x3e\n    xhr.send(\x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e)\n }\n \n    \n \x3cspan class=\x22hljs-comment\x22\x3e\/\/渲染\x3c\/span\x3e\n \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eview\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n \n xhr.on(\x3cspan class=\x22hljs-string\x22\x3e\x27渲染\x27\x3c\/span\x3e,view)\n     \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e直接在状态码200那里放个callback，也能做到。但是，如果我有两个甚至渲染函数，处理不同的东西，我每次还要改成不同的函数吗。 这个相同请求的过程是不是还要写一遍。\x3cbr\x3e用观察者的话\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function view1 () {}\nfunction view2 () {}\nfunction view3 () {}\nfunction view4 () {}\n\nif(我要渲染view1) {\n    xhr.on(\x27渲染\x27,view1) \/\/订阅\n    xhr.on(\x27渲染\x27,view2)\n}else{\n    xhr.on(\x27渲染\x27,view3)\n    xhr.on(\x27渲染\x27,view4)\n}\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eview1\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eview2\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eview3\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eview4\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(我要渲染view1) {\n    xhr.on(\x3cspan class=\x22hljs-string\x22\x3e\x27渲染\x27\x3c\/span\x3e,view1) \x3cspan class=\x22hljs-comment\x22\x3e\/\/订阅\x3c\/span\x3e\n    xhr.on(\x3cspan class=\x22hljs-string\x22\x3e\x27渲染\x27\x3c\/span\x3e,view2)\n}\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e{\n    xhr.on(\x3cspan class=\x22hljs-string\x22\x3e\x27渲染\x27\x3c\/span\x3e,view3)\n    xhr.on(\x3cspan class=\x22hljs-string\x22\x3e\x27渲染\x27\x3c\/span\x3e,view4)\n}\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e好处就在于我的getData这个功能，方法就只负责请求数据，然后他会暴露一个接口，供我去添加方法。这样我的getData 就相对来说是比较完整的功能模块，就算我有再多的情况，我的getData 里面的代码是不会改动的了。\x3c\/p\x3e\n\x3cp\x3e有时候我们经常为了实现业务，添加一个新的功能，而去更改我们之前写好的代码，导致我们本来的功能模块被改的面目全非。\x3cbr\x3e而且会有好多的重复代码。\x3cbr\x3e过程？ or  模块？\x3c\/p\x3e\n\x3cp\x3e当然封好一个 好的完整的功能模块是挺难的一件事情，但我们起码要有个开始。\x3c\/p\x3e\n\x3cp\x3e订阅去添加方法，发布了事件池就执行。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\n\x3cp\x3eMV* 类框架\x3c\/p\x3e\n\x3cp\x3eMVC也是一种设计模式，这里面也都应用了观察者。\x3c\/p\x3e\n\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e他内部也都是各种发布订阅，好像是一个观察者模型，从而实现了一个模拟的内存中的dom改变，计算出那个DOM节点应该改变。当然具体实现要做好多事情...就不...\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eredux\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e简单实现一个createstore函数\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/这是一个工厂函数，可以创建store\n\nconst  createStore = (reducer) =\x3e {\n   let state; \/\/ 定义存储的state\n   let listeners = [];\n   \n  \/\/  getState的作用很简单就是返回当前是state\n  const  getState = ()=\x3e state;\n  \n    \/\/定义一个派发函数\n    \/\/当在外界调用此函数的时候，会修改状态\n  const dispatch = (action)=\x3e{\n      \/\/调用reducer函数修改状态，返回一新的状态并赋值给这个局部状态变量\n      state = reducer(state,action);\n      \/\/依次调用监听函数，通知所有的监听函数\n      listeners.forEach(listener =\x3e listener());\n  }\n   \/\/订阅此状态的函数，当状态发生变化的时候记得调用此监听函数\n  const subscribe = function(listener){\n      \/\/先把此监听 加到数组中\n      listeners.push(listener);\n      \n      \/\/返回一个函数，当调用它的时候将此监听函数从监听数组移除\n      return function(){\n          listeners = listeners.filter(l =\x3e l != listener);\n      }\n  }\n    \/\/默认调用一次dispatch给state赋一个初始值\n   dispatch();\n  return {\n      getState,\n      dispatch,\n      subscribe\n  }\n}\nlet store = createStore(reducer);\n\n\/\/把数据渲染到界面上\nconst render = () =\x3e {\n    document.body.innerText = store.getState();\n}\n\n\/\/ 订阅状态变化事件，当状态变化时用监听函数\nstore.subscribe(render);\nrender();\nvar INCREASE_ACTION = {type: \x27INCREMENT\x27};\ndocument.addEventListener(\x27click\x27, function (e) {\n    \/\/触发一个Action\n    store.dispatch(INCREASE_ACTION);\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/这是一个工厂函数，可以创建store\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e  createStore = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ereducer\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n   \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e state; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义存储的state\x3c\/span\x3e\n   \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e listeners = [];\n   \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/  getState的作用很简单就是返回当前是state\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e  getState = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e state;\n  \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/定义一个派发函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/当在外界调用此函数的时候，会修改状态\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dispatch = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eaction\x3c\/span\x3e)=\x26gt;\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/调用reducer函数修改状态，返回一新的状态并赋值给这个局部状态变量\x3c\/span\x3e\n      state = reducer(state,action);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/依次调用监听函数，通知所有的监听函数\x3c\/span\x3e\n      listeners.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e =\x26gt;\x3c\/span\x3e listener());\n  }\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/订阅此状态的函数，当状态发生变化的时候记得调用此监听函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e subscribe = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elistener\x3c\/span\x3e)\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/先把此监听 加到数组中\x3c\/span\x3e\n      listeners.push(listener);\n      \n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/返回一个函数，当调用它的时候将此监听函数从监听数组移除\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n          listeners = listeners.filter(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3el\x3c\/span\x3e =\x26gt;\x3c\/span\x3e l != listener);\n      }\n  }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/默认调用一次dispatch给state赋一个初始值\x3c\/span\x3e\n   dispatch();\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      getState,\n      dispatch,\n      subscribe\n  }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e store = createStore(reducer);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/把数据渲染到界面上\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e render = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.innerText = store.getState();\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅状态变化事件，当状态变化时用监听函数\x3c\/span\x3e\nstore.subscribe(render);\nrender();\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e INCREASE_ACTION = {\x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27INCREMENT\x27\x3c\/span\x3e};\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/触发一个Action\x3c\/span\x3e\n    store.dispatch(INCREASE_ACTION);\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e在node 中的作用 大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e实现一个可以发布订阅的类\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\nclass EmitterEvent {\n  constructor() {\n  \/\/构造器。实例上创建一个事件池\n    this._event = {}\n  }\n  \/\/on 订阅\n  on (eventName, handler) {\n  \/\/ 根据eventName，事件池有对应的事件数组，\n  就push添加，没有就新建一个。\n  \/\/ 严谨一点应该判断handler的类型，是不是function\n    if(this._event[eventName]) {\n      this._event[eventName].push(handler)\n    } else {\n      this._event[eventName] = [handler]\n    }\n  }\n  emit (eventName) {\n  \/\/ 根据eventName找到对应数组\n    var events = this._event[eventName];\n  \/\/  取一下传进来的参数，方便给执行的函数\n    var otherArgs = Array.prototype.slice.call(arguments,1)\n    var that = this\n    if(events) {\n      events.forEach((event) =\x3e {\n        event.apply(that, otherArgs)\n      })\n    }\n  }\n  \/\/ 解除订阅\n  off (eventName, handler) {\n    var events = this._event[eventName]\n    if(events) {\n      this._event[eventName] = events.filter((event) =\x3e {\n        return event !== handler\n      })\n    }\n  }\n  \/\/ 订阅以后，emit 发布执行一次后自动解除订阅\n  once (eventName, handler) {\n    var that = this\n    function func () {\n      var args = Array.prototype.slice.call(arguments,0)\n      handler.apply(that, args)\n      this.off(eventName,func)\n    }\n    this.on(eventName, func)\n  }\n}\n\nvar event = new EmitterEvent()\nfunction a (something) {\n  console.log(something,\x27aa-aa\x27)\n}\nfunction b (something) {\n  console.log(something)\n}\n event.once(\x27dosomething\x27,a)\n event.emit(\x27dosomething\x27, \x27chifan\x27)\n \n \/\/event.emit(\x27dosomething\x27)\n\n\/\/ event.on(\x27dosomething\x27,a)\n\/\/ event.on(\x27dosomething\x27,b)\n\/\/ event.emit(\x27dosomething\x27,\x27chifan\x27)\n\/\/ event.off(\x27dosomething\x27,a)\n\/\/ setTimeout(() =\x3e {\n\/\/   event.emit(\x27dosomething\x27,\x27hejiu\x27)\n\/\/ },2000)\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEmitterEvent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/构造器。实例上创建一个事件池\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._event = {}\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/on 订阅\x3c\/span\x3e\n  on (eventName, handler) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据eventName，事件池有对应的事件数组，\x3c\/span\x3e\n  就push添加，没有就新建一个。\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 严谨一点应该判断handler的类型，是不是function\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._event[eventName]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._event[eventName].push(handler)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._event[eventName] = [handler]\n    }\n  }\n  emit (eventName) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据eventName找到对应数组\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e events = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._event[eventName];\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/  取一下传进来的参数，方便给执行的函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e otherArgs = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e that = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(events) {\n      events.forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        event.apply(that, otherArgs)\n      })\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 解除订阅\x3c\/span\x3e\n  off (eventName, handler) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e events = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._event[eventName]\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(events) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._event[eventName] = events.filter(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e event !== handler\n      })\n    }\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅以后，emit 发布执行一次后自动解除订阅\x3c\/span\x3e\n  once (eventName, handler) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e that = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunc\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n      handler.apply(that, args)\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.off(eventName,func)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.on(eventName, func)\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e event = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e EmitterEvent()\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ea\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3esomething\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(something,\x3cspan class=\x22hljs-string\x22\x3e\x27aa-aa\x27\x3c\/span\x3e)\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eb\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3esomething\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(something)\n}\n event.once(\x3cspan class=\x22hljs-string\x22\x3e\x27dosomething\x27\x3c\/span\x3e,a)\n event.emit(\x3cspan class=\x22hljs-string\x22\x3e\x27dosomething\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27chifan\x27\x3c\/span\x3e)\n \n \x3cspan class=\x22hljs-comment\x22\x3e\/\/event.emit(\x27dosomething\x27)\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ event.on(\x27dosomething\x27,a)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ event.on(\x27dosomething\x27,b)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ event.emit(\x27dosomething\x27,\x27chifan\x27)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ event.off(\x27dosomething\x27,a)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ setTimeout(() =\x26gt; {\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/   event.emit(\x27dosomething\x27,\x27hejiu\x27)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ },2000)\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当我们需要用的时候，只需要继承一下这个EmitterEvent类。要操作的实例就可以用on,emit方法，也就是可以用发布订阅。比如XHR，组件...\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JS中的观察者模式(发布订阅)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007921198">https://segmentfault.com/a/1190000007921198</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/23ftsgrtzzc/" target="_blank">https://alili.tech/archive/23ftsgrtzzc/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>