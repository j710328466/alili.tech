<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="XCel 项目总结 - Electron 与 Vue 的性能优化"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>XCel 项目总结 - Electron 与 Vue 的性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/a7slcgcyv4/",
				"appid": "1613049289050283", 
				"title": "XCel 项目总结 - Electron 与 Vue 的性能优化 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-30T02:30:23"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/foopjzqqm5d/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7b773er03yn/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f&text=XCel%20%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20Electron%20%e4%b8%8e%20Vue%20%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f&text=XCel%20%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20Electron%20%e4%b8%8e%20Vue%20%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f&title=XCel%20%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20Electron%20%e4%b8%8e%20Vue%20%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f&is_video=false&description=XCel%20%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20Electron%20%e4%b8%8e%20Vue%20%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=XCel%20%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20Electron%20%e4%b8%8e%20Vue%20%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f&title=XCel%20%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20Electron%20%e4%b8%8e%20Vue%20%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f&title=XCel%20%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20Electron%20%e4%b8%8e%20Vue%20%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f&title=XCel%20%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20Electron%20%e4%b8%8e%20Vue%20%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fa7slcgcyv4%2f&title=XCel%20%e9%a1%b9%e7%9b%ae%e6%80%bb%e7%bb%93%20-%20Electron%20%e4%b8%8e%20Vue%20%e7%9a%84%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">XCel 项目总结 - Electron 与 Vue 的性能优化</h1><div class="meta"><div class="postdate"><time datetime="2019-01-30" itemprop="datePublished">2019-01-30</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGkdk?w=900\x26amp;h=500\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGkdk?w=900\x26amp;h=500\x22 alt=\x22poster.jpg\x22 title=\x22poster.jpg\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eXCEL 是一个 Excel 数据清洗工具，其通过可视化的方式让用户轻松地对 Excel 数据进行筛选。\x3c\/p\x3e\n\x3cp\x3eXCEL 基于 Electron 和 Vue 2.0 进行开发，充分利用 Electron 多进程任务处理等功能，使其拥有高性能、跨平台（windows 7\x2b、Mac 和 Linux）的特性。\x3c\/p\x3e\n\x3cp\x3e落地页：\x3ca href=\x22https:\/\/xcel.aotu.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/xcel.aotu.io\/\x3c\/a\x3e   ✨✨✨  \x3cbr\x3e项目地址：\x3ca href=\x22https:\/\/github.com\/o2team\/xcel\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/o2team\/xcel\x3c\/a\x3e   ✨✨✨\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e项目背景\x3c\/h2\x3e\n\x3cp\x3e用户研究的定量研究和轻量级数据处理中，均需对数据进行清洗处理，用以剔除异常数据，保证数据结果的信度和效度。目前因调研数据和轻量级数据的多变性，对轻量级数据清洗往往采取人工清洗，缺少统一、标准的清洗流程，但对于调研和轻量级的数据往往是需要保证数据稳定性的，因此，在对数据进行清洗的时候最好有可以标准化的清洗方式。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e特性一览\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e基于 Electron 研发并打包成为原生应用，用户体验良好；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e可视化操作 Excel 数据，支持文件的导入导出；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e拥有单列运算逻辑、多列运算逻辑和双列范围逻辑三种筛选方式，并且可通过“且”、“或”和“编组”的方式任意组合。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e思路与实现\x3c\/h2\x3e\n\x3cp\x3e结合用研组的需求，我们利用 Electron 和 Vue 的特性对该工具进行开发。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e技术选型\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eElectron：桌面端跨平台框架，为 Web 提供了原生接口的权限。打包后的程序兼容 Windows 7 及以上、Mac、Linux 的 32 \/ 64 位系统。\x3ca href=\x22http:\/\/electron.atom.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e详情\x26gt;\x26gt;\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue 全家桶：Vue 拥有数据驱动视图的特性，适合重数据交互的应用。\x3ca href=\x22http:\/\/vuejs.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e详情\x26gt;\x26gt;\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ejs-xlsx：各种电子表格格式的解析器和生成器。纯 JavaScript 实现，适用于 Node.js 和 Web 前端。\x3ca href=\x22https:\/\/github.com\/SheetJS\/js-xlsx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e详情\x26gt;\x26gt;\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e实现思路\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e通过 js-xlsx 解析 Excel 文件生成 JSON 格式\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e根据筛选条件对 JSON 数据进行筛选过滤\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将过滤后的 JSON 数据生成 js-xlsx 指定的数据结构\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e利用 js-xlsx 对转换后的数据生成 Excel 文件\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3e纸上得来终觉浅，绝知此事要躬行\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e相关技术\x3c\/h2\x3e\n\x3cp\x3e如果对某项技术比较熟悉可略读\/跳过。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eElectron\x3c\/h3\x3e\n\x3ch4\x3eElectron 是什么？\x3c\/h4\x3e\n\x3cp\x3eElectron 是一个能让你通过 \x3cstrong\x3eJavaScript、HTML 和 CSS\x3c\/strong\x3e 构建桌面应用的\x3cstrong\x3e框架\x3c\/strong\x3e。这些应用能打包到 Mac、Windows 和 Linux 电脑上运行，当然它们也能上架到 Mac 和 Windows 的 app stores。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eJavaScript、HTML 和 CSS\x3c\/strong\x3e 都是 Web 语言，这就意味着它们都是组成网站的一部分，浏览器（如 Chrome）能将这些代码转为可视化图像。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eElectron 是一个框架\x3c\/strong\x3e：Electron 对底层代码进行抽象和封装，让开发者能在此之上构建项目。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e为什么它如此重要？\x3c\/h4\x3e\n\x3cp\x3e通常来说，桌面应用都需要用每个操作系统对应的原生语言进行开发。这意味着需要拥有 3 个团队为这个应用编写 3 个相应的版本。Electron 则允许你通过 web 语言编写一次即可。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3cstrong\x3e原生（操作系统）语言\x3c\/strong\x3e：用于开发主流操作系统的应用的原生语言如下（大多数情况下）：Mac 对应 Objective C、Linux 对应 C、Windows 对应 C\x2b\x2b。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch4\x3e它由什么组成？\x3c\/h4\x3e\n\x3cp\x3eElectron 结合了 \x3cstrong\x3eChromium\x3c\/strong\x3e、\x3cstrong\x3eNode.js\x3c\/strong\x3e 和用于调用操作系统本地功能的 API（如打开文件窗口、通知、图标等）。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eChromium\x3c\/strong\x3e：Google 创造的一个开源库，并用于 Google 的浏览器 Chrome。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eNode.js（Node）\x3c\/strong\x3e：一个用于在服务器运行 JavaScript 的运行时（runtime），它拥有文件系统和网络的权限（你的电脑也可以是一台服务器！）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665165?w=1000\x26amp;h=563\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665165?w=1000\x26amp;h=563\x22 alt=\x22Electron 的组成\x22 title=\x22Electron 的组成\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e开发体验如何？\x3c\/h4\x3e\n\x3cp\x3e基于 Electron 的开发，就好像开发一个网页一样，而且能够无缝地 \x3cstrong\x3e使用 Node\x3c\/strong\x3e。或者说：就好像构建一个 Node app，并通过 HTML 和 CSS 构建界面。另外，你只需为一个浏览器（\x3cstrong\x3e最新的 Chrome\x3c\/strong\x3e）进行设计（即无需考虑兼容性）。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e使用内置的 Node\x3c\/strong\x3e：这还不是全部！除了 Node API，你还可以使用托管在 npm 上，超过 350,000 个的模块。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e一个浏览器\x3c\/strong\x3e：并非所有浏览器都提供一致的样式，因此 web 设计师和开发者时常不得不花费更多的精力去让一个网站在不同的浏览器上看起来一致。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e最新的 Chrome\x3c\/strong\x3e：可使用超过 90% 的 ES2015 特性和其它很酷的特性（如 CSS 变量）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch4\x3e两个进程（重点）\x3c\/h4\x3e\n\x3cp\x3eElectron 有两个种进程：『主进程』和『渲染进程』。有些模块只能工作在其中一个进程上，而有些则能工作在两个进程上。主进程更多地充当幕后角色，而渲染进程则是应用的每个窗口。   \x3cbr\x3ePS：可通过任务管理器（PC）\/活动监视器（Mac）查看进程的相关信息。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3cstrong\x3e模块\x3c\/strong\x3e：Electron 的 API 是根据它们的功能进行分组。例如：\x3ccode\x3edialog\x3c\/code\x3e 模块拥有所有原生 dialog 的 API，如打开文件、保存文件和弹窗。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch4\x3e主进程\x3c\/h4\x3e\n\x3cp\x3e主进程，通常是一个命名为 \x3ccode\x3emain.js\x3c\/code\x3e 的文件，该文件是每个 Electron 应用的入口。它控制了应用的生命周期（从打开到关闭）。它能\x3cstrong\x3e调用原生元素\x3c\/strong\x3e和创建新的（多个）渲染进程，而且整个 Node API 是内置其中的。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3cstrong\x3e调用原生元素\x3c\/strong\x3e：打开 diglog 和其它操作系统交互均是资源密集型操作（注：出于安全考虑，渲染进程是不能直接调用本地资源的），因此都需要在主进程完成。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665166?w=1000\x26amp;h=563\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665166?w=1000\x26amp;h=563\x22 alt=\x22主进程\x22 title=\x22主进程\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e渲染进程\x3c\/h4\x3e\n\x3cp\x3e渲染进程是应用的一个浏览器窗口。与主进程不同，它能存在多个（注：一个 Electron 应用只能有一个主进程）并且是\x3cstrong\x3e相互独立的\x3c\/strong\x3e。它们也能是\x3cstrong\x3e隐藏的\x3c\/strong\x3e。它通常被命名为 \x3ccode\x3eindex.html\x3c\/code\x3e。它们就像典型的 HTML 文件，但在 Electron 中，它们能获取完整的 Node API 特性。因此，这也是它与其它浏览器不同的地方。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e相互独立\x3c\/strong\x3e：每个渲染进程都是独立的，这意味着就算它们某个崩溃了，也不会影响其余的渲染进程。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e隐藏的\x3c\/strong\x3e：你可以设置一个窗口是隐藏的，然后让它只在背后执行代码（?）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665167?w=1000\x26amp;h=563\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665167?w=1000\x26amp;h=563\x22 alt=\x22渲染进程\x22 title=\x22渲染进程\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e把它们想象成这样\x3c\/h4\x3e\n\x3cp\x3e在 Chrome（或其它浏览器）中的每个标签页（tab） 和其内的页面，就好比 Electron 中的一个单独渲染进程。如果你关闭所有标签页，Chrome 依然存在，这好比 Electron 的主进程，而且你能打开一个新的窗口或关闭这个应用。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e注：一般情况下，在 Chrome 浏览器中，一个标签页（tab）中的页面（即除了浏览器本身部分，如搜索框、工具栏等）就是一个渲染进程。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665168?w=1000\x26amp;h=563\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665168?w=1000\x26amp;h=563\x22 alt=\x22把它们想象成这样\x22 title=\x22把它们想象成这样\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e相互通讯\x3c\/h4\x3e\n\x3cp\x3e尽管主进程和渲染进程都有各自的任务，但它们之间也有需要协同完成的任务。因此它们之间需要通讯。\x3cstrong\x3eIPC\x3c\/strong\x3e就为此而生，它提供了进程间的通讯。但它只能在主进程与渲染进程之间传递信息。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e\x3cstrong\x3eIPC\x3c\/strong\x3e：主进程和渲染进程都有一个 IPC 模块。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665169?w=1000\x26amp;h=563\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665169?w=1000\x26amp;h=563\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e汇成一句话\x3c\/h4\x3e\n\x3cp\x3eElectron 应用就像 Node 应用，它也依赖一个 \x3ccode\x3epackage.json\x3c\/code\x3e  文件。该文件定义了哪个文件作为主进程，并因此让 Electron  知道从何启动你的应用。然后主进程能创建渲染进程，并能使用 IPC 让两者间进行消息传递。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665170?w=1000\x26amp;h=563\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665170?w=1000\x26amp;h=563\x22 alt=\x22汇成一句话\x22 title=\x22汇成一句话\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e至此，Electron 的基础部分介绍完毕。该部分是基于我之前翻译的一篇文章\x3ca href=\x22http:\/\/jlord.us\/essential-electron\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《Essential Electron》\x3c\/a\x3e，译文可点击 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007503495\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e-----\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eVue 全家桶\x3c\/h3\x3e\n\x3cp\x3e目前，该工具应用了 Vue、Vuex、Vuex-router。在工具基本定型阶段，由 1.x 升级到了 2.0 （Vuex 暂未升级）。\x3c\/p\x3e\n\x3ch4\x3e为什么选择 Vue\x3c\/h4\x3e\n\x3cp\x3e对于我来说：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e简单易用，一般使用只需看官方文档。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e数据驱动视图，所以基本不用操作 DOM 了。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e框架的存在是为了帮助我们应对复杂度。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e全家桶的好处是：对于一般场景，我就不需要考虑用哪些个库（插件）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eVue 1.x -\x26gt; Vue 2.0 的版本迁移用 \x3ca href=\x22https:\/\/github.com\/vuejs\/vue-migration-helper\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue-migration-helper\x3c\/a\x3e 即可分析出大部分需要更改的地方。\x3c\/p\x3e\n\x3cp\x3e网上已经有很多关于 Vue 的信息了。至此，Vue 部分介绍完毕。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ejs-xlsx\x3c\/h3\x3e\n\x3cp\x3e该库支持各种电子表格格式的解析和生成。它由纯 JavaScript 实现，适用于前端和 Node。\x3ca href=\x22https:\/\/github.com\/SheetJS\/js-xlsx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e详情\x26gt;\x26gt;\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e支持读入的格式有：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eExcel 2007\x2b XML Formats (XLSX\/XLSM)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eExcel 2007\x2b Binary Format (XLSB)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eExcel 2003-2004 XML Format (XML \x22SpreadsheetML\x22)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eExcel 97-2004 (XLS BIFF8)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eExcel 5.0\/95 (XLS BIFF5)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eOpenDocument Spreadsheet (ODS)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e支持写的格式有：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eXLSX\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCSV (and general DSV)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eJSON and JS objects (various styles)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e只要能提供读（解析）和写，剩下的就是靠 JavaScript 处理解析出来的数据（JSON）了。目前该库提供了 \x3ccode\x3esheet_to_json\x3c\/code\x3e 方法，该方法能将读入的 Excel 数据转为 JSON 格式。由于导出时需要提供特定的 JSON 格式，因此这部分需要我们自己实现。\x3c\/p\x3e\n\x3cp\x3e更多关于 Excel 在 JavaScript 中处理的知识可关注：凹凸实验室的\x3ca href=\x22https:\/\/aotu.io\/notes\/2016\/04\/07\/node-excel\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《Node读写Excel文件探究实践》\x3c\/a\x3e。但该文章存在两处问题（均在 js-xlsx 实战的导出表格部分）：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e生成头部时，Excel 的列信息简单地通过 \x3ccode\x3eString.fromCharCode(65\x2bj)\x3c\/code\x3e 生成，但列大于 26 时就会出现问题。这个问题会在后面章节中给出解决方案；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e转换成 worksheet 需要的结构处，出现逻辑性错误，并且会导致严重的性能问题。逻辑问题在此不讲述，我们讲下性能问题：\x3cbr\x3e ECMAScript 的不断更新，让 JavaScript 更加强大和易用。尽管如此，我们还是要做到『物尽所用』，而不要『大材小用』，否则会得到反效果。这里导致性能问题的正是 \x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Object\/assign\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eObject.assign()\x3c\/a\x3e 方法，该方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。由于该方法自身的实现机制，会在这里产生大量的冗余操作。而这里的单元格信息是唯一的，所以直接通过 forEach 为一个空对象赋值即可。提升 N 倍性能的同时，也把逻辑性错误解决了。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e原来的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var result = 某数组.reduce((prev, next) =\x3e Object.assign({}, prev, {[next.position]: {v: next.v\x22}}\x22), {});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs moonscript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3evar result = 某数组.reduce(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(prev, \x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e Object.assign({}, prev, {[\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e.position]: {\x3cspan class=\x22hljs-name\x22\x3ev\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e.v\x22}}\x22), {});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e改为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var result = 某数组.forEach((v, i) =\x3e data[v.position]= {v: v.v})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3evar result = 某数组.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(v, i)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e data[v.position]= {v: v.v})\x3c\/code\x3e\x3c\/pre\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3e实践是检验真理的唯一标准\x3c\/strong\x3e\x3cbr\x3e在理解上述知识的前提下，下面就谈谈一些在实践中总结出来的\x3cstrong\x3e技巧、难点和重点\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3eCSS、JavaScript 和 Electron 相关的知识和技巧\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e高亮 table 的列\x3c\/h3\x3e\n\x3cp\x3eExcel 单元格采用 \x3ccode\x3etable\x3c\/code\x3e 展示。在 Excel 中，被选中的单元格会高亮相应的『行』和『列』，以提醒用户。在该应用中也有做相应处理，横向高亮采用 \x3ccode\x3etr:hover\x3c\/code\x3e 实现，而纵向呢？这里所采用的一个技巧是：\x3c\/p\x3e\n\x3cp\x3e假设 HTML 结构如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22div.container\n  table\n    tr\n      td\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.container\x3c\/span\x3e\n  \x3cspan class=\x22hljs-selector-tag\x22\x3etable\x3c\/span\x3e\n    \x3cspan class=\x22hljs-selector-tag\x22\x3etr\x3c\/span\x3e\n      td\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eCSS 代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22.container { overflow:hidden; }\ntd { position: relative; }\ntd:hover::after { \n  position: absolute; \n  left: 0; \n  right: 0; \n  top: -1个亿px; \/\/ 小目标达成，不过是负的?\n  bottom: -1个亿px; \n  z-index: -1; \/\/ 避免遮住自身和同列 td 的内容、border 等\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scss\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.container\x3c\/span\x3e { \x3cspan class=\x22hljs-attribute\x22\x3eoverflow\x3c\/span\x3e:hidden; }\n\x3cspan class=\x22hljs-selector-tag\x22\x3etd\x3c\/span\x3e { \x3cspan class=\x22hljs-attribute\x22\x3eposition\x3c\/span\x3e: relative; }\n\x3cspan class=\x22hljs-selector-tag\x22\x3etd\x3c\/span\x3e:hover::after { \n  \x3cspan class=\x22hljs-attribute\x22\x3eposition\x3c\/span\x3e: absolute; \n  \x3cspan class=\x22hljs-attribute\x22\x3eleft\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \n  \x3cspan class=\x22hljs-attribute\x22\x3eright\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \n  \x3cspan class=\x22hljs-attribute\x22\x3etop\x3c\/span\x3e: -\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e个亿px; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 小目标达成，不过是负的?\x3c\/span\x3e\n  \x3cspan class=\x22hljs-attribute\x22\x3ebottom\x3c\/span\x3e: -\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e个亿px; \n  \x3cspan class=\x22hljs-attribute\x22\x3ez-index\x3c\/span\x3e: -\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 避免遮住自身和同列 td 的内容、border 等\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e斜分割线\x3c\/h3\x3e\n\x3cp\x3e如图：\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665171?w=49\x26amp;h=45\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665171?w=49\x26amp;h=45\x22 alt=\x22斜分割线\x22 title=\x22斜分割线\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e分割线可以通过 \x3ccode\x3e::after\/::before\x3c\/code\x3e 伪类元素实现一条直线，然后通过 \x3ccode\x3etransform:rotate();\x3c\/code\x3e 旋转特定角度实现。但这种实现的一个问题是：由于宽度是不定的，因此需要通过 JavaScript 运算才能得到准确的对角分割线。\x3c\/p\x3e\n\x3cp\x3e因此，这里可以通过 CSS 线性渐变 \x3ccode\x3elinear-gradient(to top right, transparent, transparent calc(50% - .5px), #d3d6db calc(50% - .5px), #d3d6db calc(50% \x2b .5px), transparent calc(50% \x2b .5px))\x3c\/code\x3e 实现。无论宽高如何变，依然妥妥地自适应。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eExcel 的列转换\x3c\/h3\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eExcel 的列需要用『字母』表示，但不能简单地通过 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/String\/fromCharCode\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eString.fromCharCode()\x3c\/a\x3e 实现，因为当超出 \x3ccode\x3e26列\x3c\/code\x3e 时会产生问题（如：第 \x3ccode\x3e27\x3c\/code\x3e 列，\x3ccode\x3eString.fromCharCode(65\x2b26)\x3c\/code\x3e 得到的是 \x3ccode\x3e[\x3c\/code\x3e，而不是 \x3ccode\x3eAA\x3c\/code\x3e）。因此，这需要通过『十进制和26进制转换』算法来实现。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 将指定的自然数转换为26进制表示。映射关系：[0-25] -\x3e [A-Z]。\nfunction getCharCol(n) {\n    let temCol = \x27\x27,\n        s = \x27\x27,\n        m = 0\n    while (n \x3e= 0) {\n        m = n % 26 \x2b 1\n        s = String.fromCharCode(m \x2b 64) \x2b s\n        n = (n - m) \/ 26\n    }\n    return s\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将指定的自然数转换为26进制表示。映射关系：[0-25] -\x26gt; [A-Z]。\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetCharCol\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e temCol = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e,\n        s = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e,\n        m = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (n \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        m = n % \x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n        s = \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e.fromCharCode(m \x2b \x3cspan class=\x22hljs-number\x22\x3e64\x3c\/span\x3e) \x2b s\n        n = (n - m) \/ \x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e s\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 将指定的26进制转换为自然数。映射关系：[A-Z] -\x3e[0-25]。\nfunction getNumCol(s) {\n    if (!s) return 0\n    let n = 0\n    for (let i = s.length - 1, j = 1; i \x3e= 0; i-- , j *= 26) {\n        let c = s[i].toUpperCase()\n        if (c \x3c \x27A\x27 || c \x3e \x27Z\x27) return 0\n        n \x2b= (c.charCodeAt() - 64) * j\n    }\n    return n - 1\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将指定的26进制转换为自然数。映射关系：[A-Z] -\x26gt;[0-25]。\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetNumCol\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3es\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!s) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e n = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = s.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, j = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i-- , j *= \x3cspan class=\x22hljs-number\x22\x3e26\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e c = s[i].toUpperCase()\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (c \x26lt; \x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e || c \x26gt; \x3cspan class=\x22hljs-string\x22\x3e\x27Z\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n        n \x2b= (c.charCodeAt() - \x3cspan class=\x22hljs-number\x22\x3e64\x3c\/span\x3e) * j\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e n - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e为 DOM 的 File 对象增加了 path 属性\x3c\/h3\x3e\n\x3cp\x3eElectron 为 File 对象额外增了 path 属性，该属性可得到文件在文件系统上的真实路径。因此，你可以利用 Node 为所欲为?。应用场景有：拖拽文件后，通过 Node 提供的 File API 读取文件等。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e支持常见的编辑功能，如粘贴和复制\x3c\/h3\x3e\n\x3cp\x3eElectron 应用在 MacOS 中默认不支持『复制』『粘贴』等常见编辑功能，因此需要为 MacOS 显式地设置复制粘贴等编辑功能的菜单栏，并为此设置相应的快捷键。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ darwin 就是 MacOS\nif (process.platform === \x27darwin\x27) {\n    var template = [{\n      label: \x27FromScratch\x27,\n      submenu: [{\n        label: \x27Quit\x27,\n        accelerator: \x27CmdOrCtrl\x2bQ\x27,\n        click: function() { app.quit(); }\n      }]\n    }, {\n      label: \x27Edit\x27,\n      submenu: [{\n        label: \x27Undo\x27,\n        accelerator: \x27CmdOrCtrl\x2bZ\x27,\n        selector: \x27undo:\x27\n      }, {\n        label: \x27Redo\x27,\n        accelerator: \x27Shift\x2bCmdOrCtrl\x2bZ\x27,\n        selector: \x27redo:\x27\n      }, {\n        type: \x27separator\x27\n      }, {\n        label: \x27Cut\x27,\n        accelerator: \x27CmdOrCtrl\x2bX\x27,\n        selector: \x27cut:\x27\n      }, {\n        label: \x27Copy\x27,\n        accelerator: \x27CmdOrCtrl\x2bC\x27,\n        selector: \x27copy:\x27\n      }, {\n        label: \x27Paste\x27,\n        accelerator: \x27CmdOrCtrl\x2bV\x27,\n        selector: \x27paste:\x27\n      }, {\n        label: \x27Select All\x27,\n        accelerator: \x27CmdOrCtrl\x2bA\x27,\n        selector: \x27selectAll:\x27\n      }]\n    }];\n    var osxMenu = menu.buildFromTemplate(template);\n    menu.setApplicationMenu(osxMenu);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dockerfile\x22\x3e\x3ccode\x3e\/\/ darwin 就是 MacOS\nif (process.platform === \x3cspan class=\x22hljs-string\x22\x3e\x27darwin\x27\x3c\/span\x3e) {\n    var template = [{\n      \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27FromScratch\x27\x3c\/span\x3e,\n\x3c\/span\x3e      submenu: [{\n        \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Quit\x27\x3c\/span\x3e,\n\x3c\/span\x3e        accelerator: \x3cspan class=\x22hljs-string\x22\x3e\x27CmdOrCtrl\x2bQ\x27\x3c\/span\x3e,\n        click: function() { app.quit(); }\n      }]\n    }, {\n      \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Edit\x27\x3c\/span\x3e,\n\x3c\/span\x3e      submenu: [{\n        \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Undo\x27\x3c\/span\x3e,\n\x3c\/span\x3e        accelerator: \x3cspan class=\x22hljs-string\x22\x3e\x27CmdOrCtrl\x2bZ\x27\x3c\/span\x3e,\n        selector: \x3cspan class=\x22hljs-string\x22\x3e\x27undo:\x27\x3c\/span\x3e\n      }, {\n        \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Redo\x27\x3c\/span\x3e,\n\x3c\/span\x3e        accelerator: \x3cspan class=\x22hljs-string\x22\x3e\x27Shift\x2bCmdOrCtrl\x2bZ\x27\x3c\/span\x3e,\n        selector: \x3cspan class=\x22hljs-string\x22\x3e\x27redo:\x27\x3c\/span\x3e\n      }, {\n        type: \x3cspan class=\x22hljs-string\x22\x3e\x27separator\x27\x3c\/span\x3e\n      }, {\n        \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Cut\x27\x3c\/span\x3e,\n\x3c\/span\x3e        accelerator: \x3cspan class=\x22hljs-string\x22\x3e\x27CmdOrCtrl\x2bX\x27\x3c\/span\x3e,\n        selector: \x3cspan class=\x22hljs-string\x22\x3e\x27cut:\x27\x3c\/span\x3e\n      }, {\n        \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Copy\x27\x3c\/span\x3e,\n\x3c\/span\x3e        accelerator: \x3cspan class=\x22hljs-string\x22\x3e\x27CmdOrCtrl\x2bC\x27\x3c\/span\x3e,\n        selector: \x3cspan class=\x22hljs-string\x22\x3e\x27copy:\x27\x3c\/span\x3e\n      }, {\n        \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Paste\x27\x3c\/span\x3e,\n\x3c\/span\x3e        accelerator: \x3cspan class=\x22hljs-string\x22\x3e\x27CmdOrCtrl\x2bV\x27\x3c\/span\x3e,\n        selector: \x3cspan class=\x22hljs-string\x22\x3e\x27paste:\x27\x3c\/span\x3e\n      }, {\n        \x3cspan class=\x22hljs-keyword\x22\x3elabel\x3c\/span\x3e\x3cspan class=\x22bash\x22\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Select All\x27\x3c\/span\x3e,\n\x3c\/span\x3e        accelerator: \x3cspan class=\x22hljs-string\x22\x3e\x27CmdOrCtrl\x2bA\x27\x3c\/span\x3e,\n        selector: \x3cspan class=\x22hljs-string\x22\x3e\x27selectAll:\x27\x3c\/span\x3e\n      }]\n    }];\n    var osxMenu = menu.buildFromTemplate(template);\n    menu.setApplicationMenu(osxMenu);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e更贴近原生应用\x3c\/h3\x3e\n\x3cp\x3eElectron 的一个缺点是：即使你的应用是一个简单的时钟，但它也不得不包含完整的基础设施（如 Chromium、Node 等）。因此，一般情况，打包后的程序至少会达到几十兆（根据系统类型进行浮动）。当你的应用越复杂，就越可以忽略这部分了。\x3c\/p\x3e\n\x3cp\x3e众所周知，页面的渲染难免会导致『白屏』，而且这里采用了 Vue 框架，情况就更加糟糕了。另外，Electron 应用也避免不了『先打开浏览器，再渲染页面』的步骤。下面提供几种方法来减轻这种情况，以让程序更贴近原生应用。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e指定 BrowserWindow 的背景颜色；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e先隐藏窗口，直到页面加载后再显示；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e保存窗口的尺寸和位置，以让程序下次被打开时，依然保留的同样大小和出现在同样的位置上。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e对于第一点，若程序的背景不是纯白（#fff）的，那么可指定窗口的背景颜色与其一致，以避免突变。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22mainWindow = new BrowserWindow({\n    title: \x27XCel\x27,\n    backgroundColor: \x27#f5f5f5\x27,\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ebnf\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-attribute\x22\x3emainWindow\x3c\/span\x3e = new BrowserWindow({\n    title: \x3cspan class=\x22hljs-string\x22\x3e\x27XCel\x27\x3c\/span\x3e,\n    backgroundColor: \x3cspan class=\x22hljs-string\x22\x3e\x27#f5f5f5\x27\x3c\/span\x3e,\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于第二点，由于 Electron 本质是一个浏览器，需要加载非网页部分的资源。因此，我们可以先隐藏窗口。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var mainWindow = new BrowserWindow({\n    title: \x27ElectronApp\x27,\n    show: false,\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e mainWindow = \x3cspan class=\x22hljs-built_in\x22\x3enew\x3c\/span\x3e BrowserWindow({\n    \x3cspan class=\x22hljs-built_in\x22\x3etitle\x3c\/span\x3e: \x27ElectronApp\x27,\n    \x3cspan class=\x22hljs-built_in\x22\x3eshow\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e等到渲染进程开始渲染页面的那一刻，在 \x3ccode\x3eready-to-show\x3c\/code\x3e 的回调函数中显示窗口。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22mainWindow.on(\x27ready-to-show\x27, function() {\n    mainWindow.show();\n    mainWindow.focus();\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs delphi\x22\x3e\x3ccode\x3emainWindow.\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27ready-to-show\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e{\n    mainWindow.show();\n    mainWindow.focus();\n}\x3c\/span\x3e);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于第三点，我并没有实现，原因如下：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e用户一般是根据当时的情况对程序的尺寸和位置进行调整，即视情况而定。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e以上是我个人臆测，主要是我懒?。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e其实现方式，可参考\x3ca href=\x22https:\/\/blog.avocode.com\/blog\/4-must-know-tips-for-building-cross-platform-electron-apps\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《4 must-know tips for building cross platform Electron apps》\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e如何在渲染进程调用原生弹框？\x3c\/h3\x3e\n\x3cp\x3e在渲染进程中调用原本专属于主进程中的 API （如弹框）的方式有两种：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eIPC 通讯模块：先在主进程通过 ipcMain 进行监听，然后在渲染进程通过 ipcRenderer 进行触发；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eremote 模块：该模块提供了一种在渲染进程（网页）和主进程之间进行进程间通讯（IPC）的简便途径。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e对于第一种，有需要就在评论区留言；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3e对于第二种， 在渲染进程中，运行以下代码即可：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const remote = require(\x27electron\x27).remote\n\nremote.dialog.showMessageBox({\n    type: \x27question\x27,\n    buttons: [\x27不告诉你\x27, \x27没有梦想\x27],\n    defaultId: 0,\n    title: \x27XCel\x27,\n    message: \x27你的梦想是什么？\x27\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3econst remote = require(\x3cspan class=\x22hljs-string\x22\x3e\x27electron\x27\x3c\/span\x3e)\x3cspan class=\x22hljs-selector-class\x22\x3e.remote\x3c\/span\x3e\n\nremote\x3cspan class=\x22hljs-selector-class\x22\x3e.dialog\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.showMessageBox\x3c\/span\x3e({\n    type: \x3cspan class=\x22hljs-string\x22\x3e\x27question\x27\x3c\/span\x3e,\n    buttons: [\x3cspan class=\x22hljs-string\x22\x3e\x27不告诉你\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27没有梦想\x27\x3c\/span\x3e],\n    defaultId: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\n    title: \x3cspan class=\x22hljs-string\x22\x3e\x27XCel\x27\x3c\/span\x3e,\n    message: \x3cspan class=\x22hljs-string\x22\x3e\x27你的梦想是什么？\x27\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e自动更新\x3c\/h3\x3e\n\x3cp\x3e如果 Electron 应用没有了自动更新的功能，那么意味着用户想体验你新开发的功能或用上修复 Bug 后的新版本，只能靠自己主动地去官网下载，这无疑是糟糕的体验。Electron 提供的 \x3ca href=\x22http:\/\/electron.atom.io\/docs\/api\/auto-updater\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eautoUpdater\x3c\/a\x3e 模块可实现自动更新功能，该模块提供了第三方框架 \x3ca href=\x22https:\/\/github.com\/Squirrel\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSquirrel\x3c\/a\x3e 的接口，但 Electron 目前只内置了 \x3ca href=\x22https:\/\/github.com\/Squirrel\/Squirrel.Mac\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSquirrel.Mac\x3c\/a\x3e，且它与 \x3ca href=\x22https:\/\/github.com\/Squirrel\/Squirrel.Windows\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSquirrel.Windows\x3c\/a\x3e（需要额外引入）的处理方式也不一致（在客户端与服务器端两方面），因此如果刚接触该模块，会发现处理起来相对比较繁琐。具体可以参考我的一篇译文\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007616641\x22\x3e《Electron 自动更新的完整教程（Windows 和 OSX）》\x3c\/a\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e目前 Electron 的 autoUpdater 模块不支持 Linux 系统。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e另外，XCel 目前并没有采用 autoUpdater 模块实现自动更新功能，而是利用 Electron 的 \x3ca href=\x22http:\/\/electron.atom.io\/docs\/api\/download-item\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eDownloadItem\x3c\/a\x3e 模块实现。而服务器端则采用 \x3ca href=\x22https:\/\/nuts.gitbook.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNuts\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader18\x22\x3e为 Electron 应用生成 Windows 安装包\x3c\/h3\x3e\n\x3cp\x3e通过 electron-builder 即可直接生成常见的 MacOS 安装包，但它生成的 Windows 的安装包却略显简洁。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008010260?w=600\x26amp;h=473\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008010260?w=600\x26amp;h=473\x22 alt=\x22常见的MacOS 安装包\x22 title=\x22常见的MacOS 安装包\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3eMac 常见的安装模式，将“左侧的应用图标”拖拽到“右侧的 Applications”即可\x3c\/p\x3e\n\x3cp\x3e通过 electron-builder 生成的 Windows 安装包与我们在 Windows 上常见的软件安装界面不太一样，它没有安装向导和点击“下一步”的按钮，只有一个安装时的 gif 动画（默认的 gif 动画如下图，当然你也可以指定特定的 gif 动画），因此也就没有让用户选择安装路径等权利。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008010261?w=268\x26amp;h=167\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008010261?w=268\x26amp;h=167\x22 alt=\x22Windows 安装时默认的动画\x22 title=\x22Windows 安装时默认的动画\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3eWindows 安装时 \x3ca href=\x22https:\/\/github.com\/electron\/windows-installer\/blob\/master\/resources\/install-spinner.gif\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e默认显示的 gif 动画\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e如果你想为打包后的 Electron 应用（即通过 electron-packager\/electron-builder 生成的  、可直接运行的程序目录）生成需要点击“下一步”和可让用户指定安装路径的常见安装包，可以通过 NSIS 程序，具体可看这篇教程 \x3ca href=\x22http:\/\/seesawworld.blogspot.com\/2016\/02\/1-nsis.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《[教學]只要10分鐘學會使用 NSIS 包裝您的桌面軟體–安裝程式打包。完全免費。》\x3c\/a\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eNSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装程序制作程序。它提供了安装、卸载、系统设置、文件解压缩等功能。这如其名字所指出的那样，NSIS 是通过它的脚本语言来描述安装程序的行为和逻辑的。NSIS 的脚本语言和通常的编程语言有类似的结构和语法，但它是为安装程序这类应用所设计的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e至此，CSS、JavaScript 和 Electron 相关的知识和技巧 部分阐述完毕。\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader19\x22\x3e性能优化\x3c\/h2\x3e\n\x3cp\x3e下面谈谈『性能优化』，这部分涉及到\x3cstrong\x3e运行效率\x3c\/strong\x3e和\x3cstrong\x3e内存占用量\x3c\/strong\x3e。     \x3cbr\x3e注：以下内容均基于 Excel 样例文件（数据量为：1913 行 x 180 列）得出的结论。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader20\x22\x3e执行效率和渲染的优化\x3c\/h3\x3e\n\x3ch4\x3eVue 性能真的好？\x3c\/h4\x3e\n\x3cp\x3eVue 一直标榜着自己性能优异，但当数据量上升到一定量级时（如 1913 x 180 ≈ 34 万个数据单元），会出现严重的性能问题（不做相应优化的前提下）。\x3c\/p\x3e\n\x3cp\x3e如直接通过列表渲染 \x3ccode\x3ev-for\x3c\/code\x3e 渲染数据时，会导致程序卡死。   \x3cbr\x3e答：通过查阅相关资料可得（猜测）， \x3ccode\x3ev-for\x3c\/code\x3e 是通过一条条数据在构建后插入 DOM 的，这对于数据量较大时，无疑会造成严重的性能问题。   \x3c\/p\x3e\n\x3cp\x3e当时，我想到了两种解决思路：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eVue 是数据驱动视图的，对数据分段 push，即将一个庞大的任务分割为 N 份。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e自己拼接 HTML 字符串，再通过 innerHTML 一次性插入。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e最终，我选择了第二条，理由是：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e性能最佳，因为每次执行数据过滤时，Vue 都要进行 diff，性能不佳。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e更符合当前应用的需求：纯展示且无需动画过渡等。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e实现更简单\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e将原本繁重的 DOM 操作转移到了 JavaScript 的拼接字符串后，性能得到了很大提升（不会导致程序卡死而渲染不出视图）。这种实现原理难道不就是 Vue、React 等框架解决的问题之一吗？只不过框架考虑的场景更广，有些地方需要我们自己根据实际情况进行优化而已。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e在浏览器当中，JavaScript 的运算在现代的引擎中非常快，但 DOM 本身是非常缓慢的东西。当你调用原生 DOM API 的时候，浏览器需要在 JavaScript 引擎的语境下去接触原生的 DOM 的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实 DOM 的操作是最少的。 —— \x3ca href=\x22http:\/\/www.infoq.com\/cn\/articles\/vue-2-progressive-front-end-solution\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《Vue 2.0——渐进式前端解决方案》\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e当然，由于 JavaScript 天生单线程，即使执行数速度再快，也会导致页面有短暂的时间拒绝用户的输入。此处可通过 Web Worker 或其它方式解决，这也将是我们后续讲到的问题。\x3c\/p\x3e\n\x3cp\x3e也有网友提供了优化大量列表的方法：\x3ca href=\x22https:\/\/clusterize.js.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/clusterize.js.org\/\x3c\/a\x3e。 但在这里我并没有采用此方式。\x3c\/p\x3e\n\x3ch4\x3e强大的 GPU 加速\x3c\/h4\x3e\n\x3cp\x3e插入 DOM 后，又会出现了另外一个问题：滚动会很卡。猜想这是渲染问题，毕竟 34 万个单元格同时存在于界面中。\x3c\/p\x3e\n\x3cp\x3e添加 \x3ccode\x3etransform: translate3d(0, 0, 0) \/ translateZ(0)\x3c\/code\x3e 属性启动 GPU 渲染，即可解决这个渲染性能问题。再次感叹该属性的强大。?\x3c\/p\x3e\n\x3cp\x3e后来，考虑到用户并不需要查看全部数据，只需展示部分数据让用户进行参考即可。我们对此只渲染前 30\/50 行数据。这样即可提升用户体验，也能进一步优化性能（又是纯属臆测）。\x3c\/p\x3e\n\x3ch4\x3e记得关闭 Vuex 的严格模式\x3c\/h4\x3e\n\x3cp\x3e另外，由于自己学艺不精和粗心大意，忘记在生产环境关闭 Vuex 的『严格模式』。\x3cbr\x3eVuex 的严格模式要\x3cstrong\x3e在生产中关闭\x3c\/strong\x3e，否则会对 state 树进行一个深观察 (deep watch)，产生不必要的性能损耗。也许在数据量少时，不会注意到这个问题。\x3c\/p\x3e\n\x3cp\x3e我当时的情况是：导入 Excel 数据后，再进行交互（涉及 Vuex 的读写操作），则需要等几秒才会响应，而直接通过纯 DOM 监听的事件则无此问题。由此，判断出是 Vuex 问题。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const store = new Vuex.Store({\n  \/\/ ...\n  strict: process.env.NODE_ENV !== \x27production\x27\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e store = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vuex.Store({\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n  strict: \x3cspan class=\x22hljs-built_in\x22\x3eprocess\x3c\/span\x3e.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader21\x22\x3e多进程！！！\x3c\/h2\x3e\n\x3cp\x3e前面说道，JavaScript 天生单线程，即使再快，对于需要处理数据量较大的情况，也会出现拒绝响应的问题。因此需要 Web Worker 或类似的方案去解决。\x3c\/p\x3e\n\x3cp\x3e在这里我不选择 Web worker 的原因有如下几点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e有其它更好的替代方案：一个主进程能创建多个渲染进程，通过 IPC 即可进行数据交互；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eElectron 不支持 Web Worker！\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eElectron 作者在 2014.11.7 在《state of web worker support?》 issue 中回复了以下这一段：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eNode integration doesn\x27t work in web workers, and there is no plan to do. Workers in Chromium are implemented by starting a new thread, and Node is not thread safe. Back in past we had tried to add node integration to web workers in Atom, but it crashed too easily so we gave up on it.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e因此，我们最终采用了创建一个新的渲染进程 \x3ccode\x3ebackground process\x3c\/code\x3e 进行处理数据。由 Electron 章节可知，每个 Electron 渲染进程是独立的，因此它们不会互相影响。但这也带来了一个问题：它们不能相互通讯？\x3c\/p\x3e\n\x3cp\x3e错！下面有 3 种方式进行通讯：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/Storage\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eStorage API\x3c\/a\x3e：对某个标签页的 localStorage\/sessionStorage 对象进行增删改时，其他标签页能通过 window.storage 事件监听到。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/IndexedDB_API\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eIndexedDB\x3c\/a\x3e：IndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e通过主进程作为中转站：设主界面的渲染进程是 A，\x3ccode\x3ebackground process\x3c\/code\x3e 是 B，那么 A 先将 Excel 数据传递到主进程，然后主进程再转发到 B。B 处理完后再原路返回，具体如下图。当然，也可以将数据存储在主进程中，然后在多个渲染进程中使用 remote 模块来访问它。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e该工具采用了第三种方式的第一种情况：   \x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665172?w=1000\x26amp;h=563\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665172?w=1000\x26amp;h=563\x22 alt=\x22Multiprocessing\x22 title=\x22Multiprocessing\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e1、主页面渲染进程 A 的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/①\nipcRenderer.send(\x27filter-start\x27, {\n    filterTagList: this.filterTagList,\n    filterWay: this.filterWay,\n    curActiveSheetName: this.activeSheet.name\n})\n\n\/\/ ⑥ 在某处接收 filter-response 事件\nipcRenderer.on(\x26quot;filter-response\x26quot;, (arg) =\x3e {\n    \/\/ 得到处理数据\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/①\x3c\/span\x3e\nipcRenderer.send(\x3cspan class=\x22hljs-string\x22\x3e\x27filter-start\x27\x3c\/span\x3e, {\n    filterTagList: this\x3cspan class=\x22hljs-selector-class\x22\x3e.filterTagList\x3c\/span\x3e,\n    filterWay: this\x3cspan class=\x22hljs-selector-class\x22\x3e.filterWay\x3c\/span\x3e,\n    curActiveSheetName: this\x3cspan class=\x22hljs-selector-class\x22\x3e.activeSheet\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.name\x3c\/span\x3e\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ⑥ 在某处接收 filter-response 事件\x3c\/span\x3e\nipcRenderer.on(\x3cspan class=\x22hljs-string\x22\x3e\x22filter-response\x22\x3c\/span\x3e, (arg) =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 得到处理数据\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e2、作为中转站的主进程的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/②\nipcMain.on(\x26quot;filter-start\x26quot;, (event, arg) =\x3e {\n    \/\/ webContents 用于渲染和控制 web page\n    backgroundWindow.webContents.send(\x26quot;filter-start\x26quot;, arg)\n})\n\n\/\/ ⑤ 用于接收返回事件\nipcMain.on(\x26quot;filter-response\x26quot;, (event, arg) =\x3e {\n    mainWindow.webContents.send(\x26quot;filter-response\x26quot;, arg)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/②\x3c\/span\x3e\nipcMain.on(\x3cspan class=\x22hljs-string\x22\x3e\x22filter-start\x22\x3c\/span\x3e, (event, arg) =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ webContents 用于渲染和控制 web page\x3c\/span\x3e\n    backgroundWindow\x3cspan class=\x22hljs-selector-class\x22\x3e.webContents\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.send\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22filter-start\x22\x3c\/span\x3e, arg)\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ⑤ 用于接收返回事件\x3c\/span\x3e\nipcMain.on(\x3cspan class=\x22hljs-string\x22\x3e\x22filter-response\x22\x3c\/span\x3e, (event, arg) =\x26gt; {\n    mainWindow\x3cspan class=\x22hljs-selector-class\x22\x3e.webContents\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.send\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22filter-response\x22\x3c\/span\x3e, arg)\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e3、处理繁重数据的 \x3ccode\x3ebackground process\x3c\/code\x3e 渲染进程 B 的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ ③\nipcRenderer.on(\x27filter-start\x27, (event, arg) =\x3e {\n    \/\/ 进行运算\n    ... \n    \n    \/\/ ④ 运算完毕后，再通过 IPC 原路返回。主进程和渲染进程 A 也要建立相应的监听事件\n    ipcRenderer.send(\x27filter-response\x27, {\n        filRow: tempFilRow\n    })\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs less\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ ③\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3eipcRenderer\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.on\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27filter-start\x27\x3c\/span\x3e, (event, arg) =\x26gt; {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 进行运算\x3c\/span\x3e\n    ... \n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ④ 运算完毕后，再通过 IPC 原路返回。主进程和渲染进程 A 也要建立相应的监听事件\x3c\/span\x3e\n    \x3cspan class=\x22hljs-selector-tag\x22\x3eipcRenderer\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.send\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27filter-response\x27\x3c\/span\x3e, {\n        \x3cspan class=\x22hljs-attribute\x22\x3efilRow\x3c\/span\x3e: tempFilRow\n    })\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至此，我们将『读取文件』、『过滤数据』和『导出文件』三大耗时的数据操作均转移到了 \x3ccode\x3ebackground process\x3c\/code\x3e 中处理。\x3c\/p\x3e\n\x3cp\x3e这里，我们只创建了一个 \x3ccode\x3ebackground process\x3c\/code\x3e，如果想要做得更极致，我们可以新建『CPU 线程数- 1 』 个的 \x3ccode\x3ebackground process\x3c\/code\x3e 同时对数据进行处理，然后在主进程对处理后数据进行拼接，最后再将拼接后的数据返回到主页面的渲染进程。这样就可以充分榨干 CPU 了。当然，在此我不会进行这个优化。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e不要为了优化而优化，否则得不偿失。 —— 某网友\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader22\x22\x3e内存占有量过大\x3c\/h3\x3e\n\x3cp\x3e解决了执行效率和渲染的问题，发现也存在内存占用量过大的问题。当时猜测是以下几个原因：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e三大耗时操作均放置在 \x3ccode\x3ebackground process\x3c\/code\x3e 处理。在通讯传递数据的过程中，由于不是共享内存（因为 IPC 是基于 Socket 的），导致出现多份数据副本（在写该篇文章时才有了这相对确切的答案）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVuex 是以一个全局单例的模式进行管理，但它会是不是对数据做了某些封装，而导致性能的损耗呢？\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e由于 JavaScript 目前不具有主动回收资源的能力，所以只能主动对闲置对象设置为 \x3ccode\x3enull\x3c\/code\x3e，然后等待 GC 回收。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cblockquote\x3e\x3cp\x3e由于 Chromium 采用多进程架构，因此会涉及到进程间通信问题。Browser 进程在启动 Render 进程的过程中会建立一个以 UNIX Socket 为基础的 IPC 通道。有了 IPC 通道之后，接下来 Browser 进程与 Render 进程就以消息的形式进行通信。我们将这种消息称为 IPC 消息，以区别于线程消息循环中的消息。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e——\x3ca href=\x22http:\/\/blog.csdn.net\/luoshengyang\/article\/details\/47822689\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《Chromium的IPC消息发送、接收和分发机制分析》\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e定义：为了易于理解，以下『Excel 数据』均指 Excel 的全部有效单元格转为 JSON 格式后的数据。\x3c\/p\x3e\n\x3cp\x3e最容易处理的无疑是第三点，手动将不再需要的变量及时设置为 \x3ccode\x3enull\x3c\/code\x3e。但这效果并不明显。\x3c\/p\x3e\n\x3cp\x3e后来，通过系统的『活动监视器』对该工具的每阶段（打开时、导入文件时、筛选时和导出时）进行粗略的内存分析，得到以下报告（之前分析的、未作修改）： \x3c\/p\x3e\n\x3cp\x3e---------------- S：报告分割线 ----------------\x3cbr\x3e经观察，主要耗内存的是\x3cstrong\x3e页面进程\x3c\/strong\x3e。下面通过截图说明：  \x3cbr\x3e\x3ccode\x3ePID 15243\x3c\/code\x3e 是主进程  \x3cbr\x3e\x3ccode\x3ePID 15246\x3c\/code\x3e 是页面渲染进程  \x3cbr\x3e\x3ccode\x3ePID 15248\x3c\/code\x3e 是 background 渲染进程  \x3c\/p\x3e\n\x3cp\x3ea、首次启动程序时（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665173?w=815\x26amp;h=567\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665173?w=815\x26amp;h=567\x22 alt=\x22启动程序时\x22 title=\x22启动程序时\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eb、导入文件（第 5 行是主进程；第 2 行是页面渲染进程；第 4 行是 background 渲染进程 ）   \x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665174?w=815\x26amp;h=567\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665174?w=815\x26amp;h=567\x22 alt=\x22导入文件时\x22 title=\x22导入文件时\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3ec、筛选数据（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ）   \x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665175?w=815\x26amp;h=567\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665175?w=815\x26amp;h=567\x22 alt=\x22筛选数据时\x22 title=\x22筛选数据时\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e由于 JS 目前不具有主动回收资源的功能，所以只能主动将对象设置为 \x3ccode\x3enull\x3c\/code\x3e，然后等待 GC 回收。\x3c\/p\x3e\n\x3cp\x3e因此，经过一段时间等待后，内存占用如下：   \x3cbr\x3ed、一段时间后（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ）\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665176?w=815\x26amp;h=567\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665176?w=815\x26amp;h=567\x22 alt=\x22一段时间后\x22 title=\x22一段时间后\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e由上述可得，页面渲染进程由于页面元素和 Vue 等 UI 相关资源是固定的，占用内存较大且不能回收。主进程占用资源也不能得到很好释放，暂时不知道原因，而 background 渲染进程则较好地释放资源。\x3c\/p\x3e\n\x3cp\x3e---------------- E：报告分割线 ----------------\x3c\/p\x3e\n\x3cp\x3e根据报告，初步得出的结论是 Vue 和通讯时占用资源较大。\x3c\/p\x3e\n\x3cp\x3e根据该工具的实际应用场景：由于 Excel 数据只在『导入』和『过滤后』两个阶段需要展示，而且展示的只是通过 JavaScript 拼接的 HTML 字符串构成的 DOM 而已。因此将表格数据放置在 Vuex 中，有点滥用资源的嫌疑。\x3c\/p\x3e\n\x3cp\x3e另外，在 \x3ccode\x3ebackground process\x3c\/code\x3e 中也有存有一份 Excel 数据副本。因此，索性只在 \x3ccode\x3ebackground process\x3c\/code\x3e 存储一份 Excel 数据，然后每当数据变化时，通过 IPC 让 \x3ccode\x3ebackground process\x3c\/code\x3e 返回拼接好的 HTML 字符串即可。这样一来，内存占有量立刻下降许多。而且这也是一个一举多得的优化：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e字符串拼接操作也转移到了 \x3ccode\x3ebackground process\x3c\/code\x3e，页面的渲染进程进一步减少耗时的操作；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e内存占有量大大减小，响应速度也得到了提升。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e其实，这也有点像 Vuex 的『全局单例模式管理』，一份数据就好。\x3c\/p\x3e\n\x3cp\x3e当然，对于 Excel 的基本信息，如行列数、SheetName、标题组等均依然保存在 Vuex。\x3c\/p\x3e\n\x3cp\x3e优化后的内存占有量如下图。与上述报告的第三张图相比（同一阶段），内存占有量下降了 44.419%：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007665177?w=815\x26amp;h=567\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007665177?w=815\x26amp;h=567\x22 alt=\x22优化后内存占有量\x22 title=\x22优化后内存占有量\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e另外，对于不需要响应的数据，可通过 \x3ccode\x3eObject.freeze()\x3c\/code\x3e 冻结起来。这也是一种优化手段。但该工具目前并没有应用到。\x3c\/p\x3e\n\x3cp\x3e至此，优化部分也阐述完毕了！\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e该工具目前是开源的，欢迎大家使用或推荐给用研组等有需要的人。\x3c\/p\x3e\n\x3cp\x3e你们的反馈（可提交 \x3ca href=\x22https:\/\/github.com\/o2team\/xcel\/issues\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eissues\x3c\/a\x3e \/ \x3ca href=\x22https:\/\/github.com\/o2team\/xcel\/pulls\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epull request\x3c\/a\x3e）能让这个工具在使用和功能上不断完善。\x3c\/p\x3e\n\x3cp\x3e最后，感谢 \x3ca href=\x22https:\/\/github.com\/mamboer\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eLV\x3c\/a\x3e 在产品规划、界面设计和优化上的强力支持。全文完！\x3c\/p\x3e\n\x3cp\x3e感谢您的阅读，本文由 \x3ca href=\x22https:\/\/github.com\/JChehe\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJc\x3c\/a\x3e 原创提供。如若转载，请注明出处：凹凸实验室（\x3ca href=\x22https:\/\/aotu.io\/notes\/2016\/11\/15\/xcel\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/aotu.io\/notes\/2016\/11...\x3c\/a\x3e）\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>XCel 项目总结 - Electron 与 Vue 的性能优化</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007665162">https://segmentfault.com/a/1190000007665162</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/a7slcgcyv4/" target="_blank">https://alili.tech/archive/a7slcgcyv4/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>