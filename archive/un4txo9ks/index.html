<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React组件模型启示录"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React组件模型启示录 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/un4txo9ks/",
				"appid": "1613049289050283", 
				"title": "React组件模型启示录 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-09T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/bia7yhx661/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/vybp597kqhk/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f&text=React%e7%bb%84%e4%bb%b6%e6%a8%a1%e5%9e%8b%e5%90%af%e7%a4%ba%e5%bd%95"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f&text=React%e7%bb%84%e4%bb%b6%e6%a8%a1%e5%9e%8b%e5%90%af%e7%a4%ba%e5%bd%95"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f&title=React%e7%bb%84%e4%bb%b6%e6%a8%a1%e5%9e%8b%e5%90%af%e7%a4%ba%e5%bd%95"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f&is_video=false&description=React%e7%bb%84%e4%bb%b6%e6%a8%a1%e5%9e%8b%e5%90%af%e7%a4%ba%e5%bd%95"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e7%bb%84%e4%bb%b6%e6%a8%a1%e5%9e%8b%e5%90%af%e7%a4%ba%e5%bd%95&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f&title=React%e7%bb%84%e4%bb%b6%e6%a8%a1%e5%9e%8b%e5%90%af%e7%a4%ba%e5%bd%95"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f&title=React%e7%bb%84%e4%bb%b6%e6%a8%a1%e5%9e%8b%e5%90%af%e7%a4%ba%e5%bd%95"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f&title=React%e7%bb%84%e4%bb%b6%e6%a8%a1%e5%9e%8b%e5%90%af%e7%a4%ba%e5%bd%95"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fun4txo9ks%2f&title=React%e7%bb%84%e4%bb%b6%e6%a8%a1%e5%9e%8b%e5%90%af%e7%a4%ba%e5%bd%95"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React组件模型启示录</h1><div class="meta"><div class="postdate"><time datetime="2019-01-09" itemprop="datePublished">2019-01-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e这个话题很难写。\x3c\/p\x3e\n\x3cp\x3e但是反过来说，爱因斯坦有句名言：如果你不能把一个问题向一个六岁孩子解释清楚，那么你不真的明白它。\x3c\/p\x3e\n\x3cp\x3e所以解释清楚一个问题的关键，不是去扩大化，而是相反，最小化。\x3c\/p\x3e\n\x3cp\x3eLet\x27s begin.\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e组件\x3c\/h1\x3e\n\x3cp\x3e组件不是一个很清晰的编程概念。UML里的组件图基本上就是一个图示，远不能和具有数学完备性的State Diagram相比，也不能和静态结构的Class Diagram和时序交互的Sequence Diagram相比。但大家通常还是会画一个出来，便于程序员理解系统的运行时结构，或者代码结构。\x3c\/p\x3e\n\x3cp\x3e你很容易在Google里搜索到一些Component Diagram的图例，所以这里不贴图了。你在组件图上可以看到有这样一些概念是重要的：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eport，它指的是包含一组相关函数的接口，一个interface或者一个protocol；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3euser和provider，谁提供port和谁使用port；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这两个概念都不需要很复杂的阐述，直觉的理解没问题；\x3c\/p\x3e\n\x3cp\x3e但问题是他们定义得特别粗，接口怎么实现的？是function call？rpc？message passing？event？没说，事实上是都行。\x3c\/p\x3e\n\x3cp\x3e常见的Component Diagram画的一般是run-time的instance，black box逻辑，强调的是instance之间的依赖关系。\x3c\/p\x3e\n\x3cp\x3e另一种关于组件的常见说法，是组件是为了重用。这把问题聊到了另一个空间去了。重用是静态概念，它指的是代码里的一个模块，类、结构等等，而不是指run-time实例。\x3c\/p\x3e\n\x3cp\x3e但是这两种说法不矛盾。因为核心的问题，无论运行时还是静态代码，组件首先强调的是黑盒思维，这点不是问题，封装是开发者熟悉的逻辑；但是组件必须集成为系统，无论在静态代码层面还是运行时，组件之间都有依赖关系，在项目具有一定规模时这尤其重要。\x3c\/p\x3e\n\x3cp\x3e在静态代码层面，任何语言都有库和源码模块话机制，include，import，require等语法关键字或函数建立了这种依赖关系；在运行时，组件（或对象实例）之间可能有动态产生的绑定关系；A对象要具有B的引用，才能使用B的方法；或者要降低耦合，采用观察者模式，消息总线或消息路由，Pub\/Sub，等等。相对而言，后者更为重要一些，前者你总能通过分拆模块避免循环，静态依赖关系总归是比较清楚的，它定了就定了，不会运行时发生变化。\x3c\/p\x3e\n\x3cp\x3e所以这篇文章主要谈运行时组件依赖关系的处理，特指在一个应用之内，不是微服务或者多个服务器组成的分布式系统。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3eReact\x3c\/h1\x3e\n\x3cp\x3e可能可以不用一上来就谈React，但是这样做最简单。\x3c\/p\x3e\n\x3cp\x3eReact的基本代码单元称为React Component；它声称是View Component，但也可以是纯state的Component，在render方法里render其他view component即可；有经验的React开发者知道这被社区称为Container Component。\x3c\/p\x3e\n\x3cp\x3e如果从Component的角度看，React的Component有一个非常特别的设计：Component之间只有一种通讯机制！就是通过Props传递对象或函数，原则上Component之间是不会通过引用互相调用方法甚至发送消息的。换句话说，所有Component都是匿名的。开发者不该在运行时查找某个Component实例访问其数据或方法，调用其方法的只有React框架。\x3c\/p\x3e\n\x3cp\x3e从这个意义上说，React象一个Inversion of Control（IOC）模式，所有有态组件都插在React框架之上，他们可以在willReceiveProps或者render方法被调用时获得传递进来的数据或方法，他们也可以通过调用setState方法触发一次更新，但这几乎就是全部了。\x3c\/p\x3e\n\x3cp\x3eReact的官方开发者提供了一套叫做flux的数据流方式，需要持久化（生命周期比视图长）的状态存入store，社区也有很多改良的工作，包括流行的redux，mobx等等；但是本质上说，react自己具有完备的态处理能力，只要把两个有相关性的组件的关联状态放到他们的共同祖先即可；只是这样做，如果没有特殊的处理的化并不灵活，在设计变更时大量代码要修改，还不如使用redux等框架来得方便；anyway，这一点不是我们这篇文章要讨论的主题，它指的是静态代码层面的模块化问题，我找时间写文章专述。我们回到React组件是如何组合和互动这个话题上。\x3c\/p\x3e\n\x3cp\x3e我们重新强调一下React组件的匿名问题。对一个组件而言，它要能工作，当然需要和外部组件互动，但是React组件在这里做了一个极致的设计：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e一切依赖性都是注入的；注入的依赖性来自哪个外部组件，组件内部一无所知。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e依赖性注入（Dependency Injection）一词，对熟悉可测试性（tesability）的开发者来说不陌生，但大多数情况下这停留在测试领域，很少影响设计。绝大多数应用在顶层都有一些类似全局变量的模块，也就是组件图中表达的那些；使用这些模块的其他模块都能用全局的name找到它们，找到就可以使用了。但是在React里，NO! 即使在顶层，每个组件的外部依赖也都是注入的。\x3c\/p\x3e\n\x3cp\x3e所以你看到React的组件模型实际上只包含三个元素：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e父组件向子组件传递的prop是对象或值\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e父组件向子组件传递的prop是方法（bound）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e父子组件们用一个tree表示，是单向的传递数据或方法的（即层层注入）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3e观察者与资源建模\x3c\/h1\x3e\n\x3cp\x3e我们先说第一个要素：父组件向子组件传值。本质上，它是子组件对父组件或父组件可观察的某个资源状态的一个观察。\x3c\/p\x3e\n\x3cp\x3e从语法上来说，它比写Observer Pattern要来得方便，因为子组件没有Subscribe的负担，是反过来做的，父组件把子组件的依赖性（需要观察的对象）塞进来。\x3c\/p\x3e\n\x3cp\x3e因为React是function programming风格，这样写更方便；不方便的地方是观察变化的逻辑是在willReceiveProps里，需要自己比较新版本和副本的区别，如果有差别，调用setState方法更新自己。\x3c\/p\x3e\n\x3cp\x3e但是这种观察能实现所有需要的观察吗？比如SomethingStarted，SomethingResumed，SomethingOpened？\x3c\/p\x3e\n\x3cp\x3e确实可能遇到一些棘手的情况难以简单用值的变化来表述一种变化，但是我们反过来想这个问题，数据库是用CRUD实现的，Restful API设计采用资源建模也只有有限的verb，他们都工作的很好；工作的好的原因是他们都是用资源而不是行为建模的，如果确实需要为行为建模，我们也可以使用状态机，对单一模块而言，在各种粒度上状态机都是很好的建模方式；在状态机模型下，状态就一定可以用离散值来表示，比如运行状态可以是started, stopped, resumed, failed，等等。\x3c\/p\x3e\n\x3cp\x3e这样的建模方式是否比自己发明很多message类型更为有效呢？个人看法是的，这是一种远好于用行为语义定义事件的方式。无论crud还是restful都有极为广泛的实践，可以被认为是被证实可行的方式。\x3c\/p\x3e\n\x3cp\x3e从这些意义上说，React的组件建模方式具有类似crud或http verb的统一抽象，是避免出现大量程序员自己发明混乱语义的好办法。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3eBound方法传递\x3c\/h1\x3e\n\x3cp\x3e父组件向子组件传递的Bound方法，应该看作是父组件向子组件提供的一种触发状态变化的代理。比如你去酒店，你叫服务生来开门，这是一种类似function call或者message passing的机制，但是服务生也可以给你一张卡你自己去开门，这就是一种代理；和观察资源一样，因为使用了统一的Prop机制，在组件内部看，这种代理也是匿名的，组件并不知道到底是谁在提供这项功能，它只是在需要的时候使用而已。\x3c\/p\x3e\n\x3cp\x3e这件事情是前端特有的，受限制于HTML的结构。\x3c\/p\x3e\n\x3cp\x3e很多功能组件都不只是基于观察逻辑工作，他们还会需要提供功能性服务，功能性服务的入口从哪里触发，看应用和系统结构而定，它可能来自用户操作，可能来自操作系统，也可能来自API请求，后面我们还会仔细说这个问题。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3eTree\x3c\/h1\x3e\n\x3cp\x3e事实上绝大多数App，其组件都是可以用一个tree来表示的，只不过在项目规模不大的时候，大家更喜欢把顶层组件就堆在一起互相引用，这样变化的时候最灵活。\x3c\/p\x3e\n\x3cp\x3e但React组件的Composition结构更符合组件设计的原则：组件和组件可以方便的组合起来实现更大的组件，而且最重要的，它仍然是只有React定义的只有Prop传递的组件。一种自相似性。或者叫做Composability。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader5\x22\x3e组件更新\x3c\/h1\x3e\n\x3cp\x3e简单说一下React组件的更新过程；如果一个组件观察到变化，或者被子组件调用了方法，需要更新状态，这时如果变化只影响到自身和某些子组件，它只要直接setState触发变化即可，React回调用它的render方法触发一连串的变化，更新是自上至下的，所以比较容易做到更新收敛；如果变化会影响到组件树上某个非子组件的变化，那么应该通过上面传递下来的Bound方法触发更高层的组件先做状态迁移。这个设计会导致在状态设计上出现mediator模式，anyway，这也是常见模式和基本功了。\x3c\/p\x3e\n\x3cp\x3e这里需要强调的是，理论上这种更新是同步的，虽然React因为效率问题做了其他的工作，它的VDOM渲染实际上是有Batch和异步的，细节不说了。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader6\x22\x3e混乱的组件通讯\x3c\/h1\x3e\n\x3cp\x3e那么如果我们不说前端，如果写后端，或者写系统应用，用React的这个模式构建全部组件树可行吗？答案是不，也不必要。\x3c\/p\x3e\n\x3cp\x3e这一节的题目叫做混乱的组件通讯，我们来仔细掰扯一下细节，因为组件模型虽然很常说但是对通讯过程没有约定。\x3c\/p\x3e\n\x3cp\x3e第一个登场的是function call。\x3c\/p\x3e\n\x3cp\x3efunction call不管是同步的还是异步的，它没有区分（1）它是否改变了被调用对象的状态（2）它是否需要返回值。如果它不需要返回值，它就和emit了一个event没什么分别。如果它需要一个返回值，那么调用者是user角色，被调用者是provider角色，如果被调用者的状态发生了变化，这相当于crud里的cud，否则是read。\x3c\/p\x3e\n\x3cp\x3e理解了对function call的分类方式，那么event和message passing也就好理解了。message和function call一样是模棱两可的。在Sequence Diagram里，有去必然有回的message被称为synchronous message，有去无回的叫做asynchrnous；但是我们避免这个术语，和我们在JS里说的不是一回事。但是这个分类方式是对的。\x3c\/p\x3e\n\x3cp\x3e相比之下只有event很纯粹，它就是有去无回的。\x3c\/p\x3e\n\x3cp\x3eOK，你看我们的分类方法非常简单，就是单向的或者有去有回的。但是内在的故事不简单。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader7\x22\x3eState \x26amp; IO\x3c\/h1\x3e\n\x3cp\x3e单向的event，它有可能trigger一个模型内的state或者resource变化（后面统称为State）。\x3c\/p\x3e\n\x3cp\x3e双向的通讯，是一种承诺，即使是失败或错误也要有返回，我们称之为IO。注意这个定义是我自己发明的，它仅仅表示双向通讯。\x3c\/p\x3e\n\x3cp\x3e双向通讯难道就不会trigger模型内的state变化吗？这当然是非常可能的。但是问题的关键点就在这里：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e对于一个提供IO服务也可能因为IO改变其内部状态的模块，你是否在代码层面上把IO和State分离了呢？\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e我们专注于说JavaScript的事件模型；如果你把模块写成状态机，模块接收到的event会race吗？当然不会。IO呢？很可能。并发的本质就是IO的并发，event在单线程的事件模型下没有并发的概念。\x3c\/p\x3e\n\x3cp\x3e那么这里就有一个特别简单的建模方式，你可以脑补一个鸡蛋三明治。\x3c\/p\x3e\n\x3cp\x3e三明治两边的面包（其实只有一边有面包的逻辑也是一样的），可以看作一个是向外提供的IO服务，另一个是自己需要使用的IO服务；而中间的鸡蛋，是这个模块的State，全部State，状态机。\x3c\/p\x3e\n\x3cp\x3e进来的IO如果有资源冲突，可以排队；出去的IO如果有返回结果，返回结果要当作一个Event来处理。如果某些Event导致当前正在服务或者排队的IO请求失败，进来的IO请求队列清空，全部返回错误；如果对象出现生命周期结束，其发出的和服务的IO都要清空，返回失败或者abort。你看这超级容易，就是callback队列和handle队列而已。\x3c\/p\x3e\n\x3cp\x3e我们把中间这层鸡蛋，称为该模块的模型（model），它封装了共享资源，实现了内部和外部状态。\x3c\/p\x3e\n\x3cp\x3e在这个模型上前端和后端有没有区别呢？还是有的，虽然两者都可以看作在对外提供服务，一个是服务机器另一个是服务人。后端的服务在对外提供服务的那层面包上，前端呢，前端都是Event进来的。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader8\x22\x3e级联\x3c\/h1\x3e\n\x3cp\x3e在级联这个问题上，React的组件模型显示出了它的简单抽象的威力。如果我们能够把所有模块的鸡蛋部分，象React组件那样级联起来：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eReact的框架的render过程要自己手写，而且也不大现实搞成functional风格的，只要遵循其自上至下的更新逻辑即可。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eReact的依赖性全注入的组件形式是非常诱人的，但是在设计变更时要修改mediator在组件树上的所在位置也有些恼人。这里会有一些比较tricky的写法，但是好消息是对大多数应用而言，其实粗粒度的组件数量还没有一个React写的网页里的组件数量多，所以这件事情也不见得要做到极致去，组件数量不多的时候Pub\/Sub工作的也很好。但是对于明确的Leaf Node组件，这样写是推荐的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e同步更新。能全部组件同步更新鸡蛋层是非常值得追求的目标。因为它让你的模型具有一个全局的显式状态设计，包含组件相关的数据完整性定义；如果到处是异步状态更新，这个设计本身就有麻烦，其逻辑完备性不容易检验，状态机很容易根据State\/Event组合排查设计完备性和合理性，而同步更新是消灭态空间爆炸的利器，否则状态之间要排列组合了。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch1 id=\x22articleHeader9\x22\x3eEvent Model\x3c\/h1\x3e\n\x3cp\x3eJavaScript是Event Model。Event Model编程的核心就是用状态建模，状态同步更新容易保证数据完整性。建模的开始是看有那些共享资源需要封装，把组件一个一个写出来，然后组合起来。\x3c\/p\x3e\n\x3cp\x3e过程在这里是二等公民，它主要致力于上面说的面包层的IO处理。从这个意义上说，callback还是promise还是async根本不是重点，没有什么值得争执的，哪个合适用哪个。在状态建模之下，IO过程都被碎片化了，试图用长途奔袭的方式串联大量IO操作很难保障设计正确性，光写出来能跑几次成功测试的代码是没意义的，从这个意义上说我不赞同那些伪线程框架。\x3c\/p\x3e\n\x3cp\x3e事务锁的问题不是这篇讨论的重点。事件模型下用状态机和IO排队解决冲突是第一方法，90%以上用这个方法；剩下10%是用opportunistic lock的方式一次性commit多个数据更新状态，这个也很容易，但需要注意读入的数据是尽量同步的（有时这无法保证，但应该去detect非法组合和重试）。\x3c\/p\x3e\n\x3cp\x3e理想的事件模型应该是计算不消耗时间的；实际上这当然不可能。所以主进程的主要目的是维护全局状态层，即所有的鸡蛋；文件和网络IO操作Node大多做得很好，需要算力的任务要用Cluster\/Worker了，这是Node的短板，只是要求不高的情况下可用。\x3c\/p\x3e\n\x3cp\x3e如果你的后端或者系统应用是非常stateful的，包括文件持久化的资源，node是很好的选择；如果只是对称的无态逻辑，资源都在数据库里，node没什么意义；如果算力要求高，数据集也大，不适合在进程间抛来抛去，千万别用node，go\/java\/c\x2b\x2b都是好得多的选择。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader10\x22\x3eRx\x3c\/h1\x3e\n\x3cp\x3e我基本没有Rx的开发经验，只是看了半本书。\x3c\/p\x3e\n\x3cp\x3e上面说的全部文字，都可以看作是基于事件模型的reactive编程；但是rx框架是另一个故事，它没有事件模型假设，有很多语言实现，而且它考虑的问题不是一个应用级的，是分布式系统级的。\x3c\/p\x3e\n\x3cp\x3e但rx是不是一个好的选择呢？比如说只用于数据层？\x3c\/p\x3e\n\x3cp\x3e有可能。但是它用于组件层的话，它有几个问题：\x3c\/p\x3e\n\x3cp\x3e1，它没约定单向，这个只能自己来；\x3cbr\x3e2，它需要显式观察，即subscribe，个人认为这不如React的注入机制，后者真正让组件象乐高积木一样容易组合的，没有外部需求的组件才是真正的组件，才可能随意拆装使用；\x3c\/p\x3e\n\x3cp\x3e所以我觉得它写在组件内观察被注入进来的状态变化可能更合适，当然用于密集的异步IO更新的数据集是肯定没问题的。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader11\x22\x3eFinal\x3c\/h1\x3e\n\x3cp\x3e把关键点陈列一下，该说的前面都说过了。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e依赖性注入的组件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e状态机和资源建模\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e状态或资源变化即事件，不要额外发明语义了\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e理解State和IO的区别\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e全局级联的状态更新，同步！\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e～～～～～～～～～～～～～～～～\x3c\/p\x3e\n\x3cp\x3e题外话：\x3c\/p\x3e\n\x3cp\x3e最近在重构一个中等规模项目，在组件模型上想了很多；但是React的原作者们并没有特别的觉得他们的设计是unusual的。Jordan Walke的大部分视频都在谈react如何使用。\x3c\/p\x3e\n\x3cp\x3e但在我来看，或者从后端或者系统程序的角度看，react的组件模型在使用上真正符合了组件的定义：无外部依赖，这一点比node里的module们require来require去高明太多。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React组件模型启示录</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010114819">https://segmentfault.com/a/1190000010114819</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/un4txo9ks/" target="_blank">https://alili.tech/archive/un4txo9ks/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>