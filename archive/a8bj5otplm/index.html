<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="virtual-dom(Vue实现)简析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>virtual-dom(Vue实现)简析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/a8bj5otplm/",
				"appid": "1613049289050283", 
				"title": "virtual-dom(Vue实现)简析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-09T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/n42tijy1ive/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/yg15jcn4nfa/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f&text=virtual-dom%28Vue%e5%ae%9e%e7%8e%b0%29%e7%ae%80%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f&text=virtual-dom%28Vue%e5%ae%9e%e7%8e%b0%29%e7%ae%80%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f&title=virtual-dom%28Vue%e5%ae%9e%e7%8e%b0%29%e7%ae%80%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f&is_video=false&description=virtual-dom%28Vue%e5%ae%9e%e7%8e%b0%29%e7%ae%80%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=virtual-dom%28Vue%e5%ae%9e%e7%8e%b0%29%e7%ae%80%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f&title=virtual-dom%28Vue%e5%ae%9e%e7%8e%b0%29%e7%ae%80%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f&title=virtual-dom%28Vue%e5%ae%9e%e7%8e%b0%29%e7%ae%80%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f&title=virtual-dom%28Vue%e5%ae%9e%e7%8e%b0%29%e7%ae%80%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fa8bj5otplm%2f&title=virtual-dom%28Vue%e5%ae%9e%e7%8e%b0%29%e7%ae%80%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">virtual-dom(Vue实现)简析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-09" itemprop="datePublished">2019-01-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3ccode\x3evirtual-dom\x3c\/code\x3e(后文简称\x3ccode\x3evdom\x3c\/code\x3e)的概念大规模的推广还是得益于\x3ccode\x3ereact\x3c\/code\x3e出现，\x3ccode\x3evirtual-dom\x3c\/code\x3e也是\x3ccode\x3ereact\x3c\/code\x3e这个框架的非常重要的特性之一。相比于频繁的手动去操作\x3ccode\x3edom\x3c\/code\x3e而带来性能问题，\x3ccode\x3evdom\x3c\/code\x3e很好的将\x3ccode\x3edom\x3c\/code\x3e做了一层映射关系，进而将在我们本需要直接进行\x3ccode\x3edom\x3c\/code\x3e的一系列操作，映射到了操作\x3ccode\x3evdom\x3c\/code\x3e，而\x3ccode\x3evdom\x3c\/code\x3e上定义了关于真实\x3ccode\x3edom\x3c\/code\x3e的一些关键的信息，\x3ccode\x3evdom\x3c\/code\x3e完全是用\x3ccode\x3ejs\x3c\/code\x3e去实现，和宿主浏览器没有任何联系，此外得益于\x3ccode\x3ejs\x3c\/code\x3e的执行速度，将原本需要在真实\x3ccode\x3edom\x3c\/code\x3e进行的\x3ccode\x3e创建节点\x3c\/code\x3e,\x3ccode\x3e删除节点\x3c\/code\x3e,\x3ccode\x3e添加节点\x3c\/code\x3e等一系列复杂的\x3ccode\x3edom\x3c\/code\x3e操作全部放到\x3ccode\x3evdom\x3c\/code\x3e中进行，这样就通过操作\x3ccode\x3evdom\x3c\/code\x3e来提高直接操作的\x3ccode\x3edom\x3c\/code\x3e的效率和性能。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eVue\x3c\/code\x3e在\x3ccode\x3e2.0\x3c\/code\x3e版本也引入了\x3ccode\x3evdom\x3c\/code\x3e。其\x3ccode\x3evdom\x3c\/code\x3e算法是基于\x3ca href=\x22https:\/\/github.com\/snabbdom\/snabbdom\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esnabbdom算法\x3c\/a\x3e所做的修改。\x3c\/p\x3e\n\x3cp\x3e在\x3ccode\x3eVue\x3c\/code\x3e的整个应用生命周期当中，每次需要更新视图的时候便会使用\x3ccode\x3evdom\x3c\/code\x3e。那么在\x3ccode\x3eVue\x3c\/code\x3e当中，\x3ccode\x3evdom\x3c\/code\x3e是如何和\x3ccode\x3eVue\x3c\/code\x3e这个框架融合在一起工作的呢？以及大家常常提到的\x3ccode\x3evdom\x3c\/code\x3e的\x3ccode\x3ediff\x3c\/code\x3e算法又是怎样的呢？接下来就通过这篇文章简单的向大家介绍下\x3ccode\x3eVue\x3c\/code\x3e当中的\x3ccode\x3evdom\x3c\/code\x3e是如何去工作的。\x3c\/p\x3e\n\x3cp\x3e首先，我们还是来看下\x3ccode\x3eVue\x3c\/code\x3e生命周期当中初始化的最后阶段：将\x3ccode\x3evm\x3c\/code\x3e实例挂载到\x3ccode\x3edom\x3c\/code\x3e上，源码在\x3ca href=\x22http:\/\/www.baidu.com\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esrc\/core\/instance\x3c\/a\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    Vue.prototype._init = function () {\n        ...\n        vm.$mount(vm.$options.el)  \/\/ 实际上是调用了mountComponent方法\n        ...\n    }   \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    Vue.prototype._init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        ...\n        vm.$mount(vm.$options.el)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实际上是调用了mountComponent方法\x3c\/span\x3e\n        ...\n    }   \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3emountComponent\x3c\/code\x3e函数的定义是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function mountComponent (\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n): Component {\n  \/\/ vm.$el为真实的node\n  vm.$el = el\n  \/\/ 如果vm上没有挂载render函数\n  if (!vm.$options.render) {\n    \/\/ 空节点\n    vm.$options.render = createEmptyVNode\n  }\n  \/\/ 钩子函数\n  callHook(vm, \x27beforeMount\x27)\n\n  let updateComponent\n  \/* istanbul ignore if *\/\n  if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n    ...\n  } else {\n    \/\/ updateComponent为监听函数, new Watcher(vm, updateComponent, noop)\n    updateComponent = () =\x3e {\n      \/\/ Vue.prototype._render 渲染函数\n      \/\/ vm._render() 返回一个VNode\n      \/\/ 更新dom\n      \/\/ vm._render()调用render函数，会返回一个VNode，在生成VNode的过程中，会动态计算getter,同时推入到dep里面\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  \/\/ 新建一个_watcher对象\n  \/\/ vm实例上挂载的_watcher主要是为了更新DOM\n  \/\/ vm\/expression\/cb\n  vm._watcher = new Watcher(vm, updateComponent, noop)\n  hydrating = false\n\n  \/\/ manually mounted instance, call mounted on self\n  \/\/ mounted is called for render-created child components in its inserted hook\n  if (vm.$vnode == null) {\n    vm._isMounted = true\n    callHook(vm, \x27mounted\x27)\n  }\n  return vm\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emountComponent\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\n  vm: Component,\n  el: ?Element,\n  hydrating?: boolean\n\x3c\/span\x3e): \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vm.$el为真实的node\x3c\/span\x3e\n  vm.$el = el\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果vm上没有挂载render函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!vm.$options.render) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 空节点\x3c\/span\x3e\n    vm.$options.render = createEmptyVNode\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 钩子函数\x3c\/span\x3e\n  callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27beforeMount\x27\x3c\/span\x3e)\n\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e updateComponent\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; config.performance \x26amp;\x26amp; mark) {\n    ...\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ updateComponent为监听函数, new Watcher(vm, updateComponent, noop)\x3c\/span\x3e\n    updateComponent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vue.prototype._render 渲染函数\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vm._render() 返回一个VNode\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 更新dom\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vm._render()调用render函数，会返回一个VNode，在生成VNode的过程中，会动态计算getter,同时推入到dep里面\x3c\/span\x3e\n      vm._update(vm._render(), hydrating)\n    }\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新建一个_watcher对象\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vm实例上挂载的_watcher主要是为了更新DOM\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ vm\/expression\/cb\x3c\/span\x3e\n  vm._watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(vm, updateComponent, noop)\n  hydrating = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ manually mounted instance, call mounted on self\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ mounted is called for render-created child components in its inserted hook\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm.$vnode == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n    vm._isMounted = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27mounted\x27\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vm\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意上面的代码中定义了一个\x3ccode\x3eupdateComponent\x3c\/code\x3e函数，这个函数执行的时候内部会调用\x3ccode\x3evm._update(vm._render(), hyddrating)\x3c\/code\x3e方法，其中\x3ccode\x3evm._render\x3c\/code\x3e方法会返回一个新的\x3ccode\x3evnode\x3c\/code\x3e，(关于\x3ccode\x3evm_render\x3c\/code\x3e是如何生成\x3ccode\x3evnode\x3c\/code\x3e的建议大家看看\x3ccode\x3evue\x3c\/code\x3e的关于\x3ccode\x3ecompile\x3c\/code\x3e阶段的代码)，然后传入\x3ccode\x3evm._update\x3c\/code\x3e方法后，就用这个新的\x3ccode\x3evnode\x3c\/code\x3e和老的\x3ccode\x3evnode\x3c\/code\x3e进行\x3ccode\x3ediff\x3c\/code\x3e，最后完成\x3ccode\x3edom\x3c\/code\x3e的更新工作。那么\x3ccode\x3eupdateComponent\x3c\/code\x3e都是在什么时候去进行调用呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22vm._watcher = new Watcher(vm, updateComponent, noop)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3evm._watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(vm, updateComponent, noop)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实例化一个\x3ccode\x3ewatcher\x3c\/code\x3e，在求值的过程中\x3ccode\x3ethis.value = this.lazy ? undefined : this.get()\x3c\/code\x3e，会调用\x3ccode\x3ethis.get()\x3c\/code\x3e方法，因此在实例化的过程当中\x3ccode\x3eDep.target\x3c\/code\x3e会被设为这个\x3ccode\x3ewatcher\x3c\/code\x3e，通过调用\x3ccode\x3evm._render()\x3c\/code\x3e方法生成新的\x3ccode\x3eVnode\x3c\/code\x3e并进行\x3ccode\x3ediff\x3c\/code\x3e的过程中完成了模板当中变量依赖收集工作。即这个\x3ccode\x3ewatcher\x3c\/code\x3e被添加到了在模板当中所绑定变量的依赖当中。一旦\x3ccode\x3emodel\x3c\/code\x3e中的响应式的数据发生了变化，这些响应式的数据所维护的\x3ccode\x3edep\x3c\/code\x3e数组便会调用\x3ccode\x3edep.notify()\x3c\/code\x3e方法完成所有依赖遍历执行的工作，这里面就包括了视图的更新即\x3ccode\x3eupdateComponent\x3c\/code\x3e方法的调用。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eupdateComponent\x3c\/code\x3e方法的定义是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22updateComponent = () =\x3e {\n  vm._update(vm._render(), hydrating)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eupdateComponent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  vm._update(vm._render(), hydrating)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e完成视图的更新工作事实上就是调用了\x3ccode\x3evm._update\x3c\/code\x3e方法，这个方法接收的第一个参数是刚生成的\x3ccode\x3eVnode\x3c\/code\x3e，调用的\x3ccode\x3evm._update\x3c\/code\x3e方法的定义是\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {\n    const vm: Component = this\n    if (vm._isMounted) {\n      callHook(vm, \x27beforeUpdate\x27)\n    }\n    const prevEl = vm.$el\n    const prevVnode = vm._vnode\n    const prevActiveInstance = activeInstance\n    activeInstance = vm\n    \/\/ 新的vnode\n    vm._vnode = vnode\n    \/\/ Vue.prototype.__patch__ is injected in entry points\n    \/\/ based on the rendering backend used.\n    \/\/ 如果需要diff的prevVnode不存在，那么就用新的vnode创建一个真实dom节点\n    if (!prevVnode) {\n      \/\/ initial render\n      \/\/ 第一个参数为真实的node节点\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, false \/* removeOnly *\/,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      )\n    } else {\n      \/\/ updates\n      \/\/ 如果需要diff的prevVnode存在，那么首先对prevVnode和vnode进行diff,并将需要的更新的dom操作已patch的形式打到prevVnode上，并完成真实dom的更新工作\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n    activeInstance = prevActiveInstance\n    \/\/ update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm\n    }\n    \/\/ if parent is an HOC, update its $el as well\n    if (vm.$vnode \x26amp;\x26amp; vm.$parent \x26amp;\x26amp; vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eVue.prototype._update = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evnode: VNode, hydrating?: boolean\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e vm: Component = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm._isMounted) {\n      callHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27beforeUpdate\x27\x3c\/span\x3e)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e prevEl = vm.$el\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e prevVnode = vm._vnode\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e prevActiveInstance = activeInstance\n    activeInstance = vm\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 新的vnode\x3c\/span\x3e\n    vm._vnode = vnode\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vue.prototype.__patch__ is injected in entry points\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ based on the rendering backend used.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果需要diff的prevVnode不存在，那么就用新的vnode创建一个真实dom节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!prevVnode) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ initial render\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 第一个参数为真实的node节点\x3c\/span\x3e\n      vm.$el = vm.__patch__(\n        vm.$el, vnode, hydrating, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/* removeOnly *\/\x3c\/span\x3e,\n        vm.$options._parentElm,\n        vm.$options._refElm\n      )\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ updates\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果需要diff的prevVnode存在，那么首先对prevVnode和vnode进行diff,并将需要的更新的dom操作已patch的形式打到prevVnode上，并完成真实dom的更新工作\x3c\/span\x3e\n      vm.$el = vm.__patch__(prevVnode, vnode)\n    }\n    activeInstance = prevActiveInstance\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update __vue__ reference\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (prevEl) {\n      prevEl.__vue__ = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm.$el) {\n      vm.$el.__vue__ = vm\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ if parent is an HOC, update its $el as well\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm.$vnode \x26amp;\x26amp; vm.$parent \x26amp;\x26amp; vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个方法当中最为关键的就是\x3ccode\x3evm.__patch__\x3c\/code\x3e方法，这也是整个\x3ccode\x3evirtaul-dom\x3c\/code\x3e当中最为核心的方法，主要完成了\x3ccode\x3eprevVnode\x3c\/code\x3e和\x3ccode\x3evnode\x3c\/code\x3e的\x3ccode\x3ediff\x3c\/code\x3e过程并根据需要操作的\x3ccode\x3evdom\x3c\/code\x3e节点打\x3ccode\x3epatch\x3c\/code\x3e，最后生成新的真实\x3ccode\x3edom\x3c\/code\x3e节点并完成视图的更新工作。\x3c\/p\x3e\n\x3cp\x3e接下来就让我们看下\x3ccode\x3evm.__patch__\x3c\/code\x3e里面到底发生了什么：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    function patch (oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {\n        \/\/ 当oldVnode不存在时\n        if (isUndef(oldVnode)) {\n            \/\/ 创建新的节点\n            createElm(vnode, insertedVnodeQueue, parentElm, refElm)\n        } else {\n            const isRealElement = isDef(oldVnode.nodeType)\n            if (!isRealElement \x26amp;\x26amp; sameVnode(oldVnode, vnode)) {\n            \/\/ patch existing root node\n            \/\/ 对oldVnode和vnode进行diff，并对oldVnode打patch\n            patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n      } \n        }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epatch\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode, hydrating, removeOnly, parentElm, refElm\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当oldVnode不存在时\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldVnode)) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建新的节点\x3c\/span\x3e\n            createElm(vnode, insertedVnodeQueue, parentElm, refElm)\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isRealElement = isDef(oldVnode.nodeType)\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!isRealElement \x26amp;\x26amp; sameVnode(oldVnode, vnode)) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ patch existing root node\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对oldVnode和vnode进行diff，并对oldVnode打patch\x3c\/span\x3e\n            patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)\n      } \n        }\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在对\x3ccode\x3eoldVnode\x3c\/code\x3e和\x3ccode\x3evnode\x3c\/code\x3e类型判断中有个\x3ccode\x3esameVnode\x3c\/code\x3e方法，这个方法决定了是否需要对\x3ccode\x3eoldVnode\x3c\/code\x3e和\x3ccode\x3evnode\x3c\/code\x3e进行\x3ccode\x3ediff\x3c\/code\x3e及\x3ccode\x3epatch\x3c\/code\x3e的过程。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function sameVnode (a, b) {\n  return (\n    a.key === b.key \x26amp;\x26amp;\n    a.tag === b.tag \x26amp;\x26amp;\n    a.isComment === b.isComment \x26amp;\x26amp;\n    isDef(a.data) === isDef(b.data) \x26amp;\x26amp;\n    sameInputType(a, b)\n  )\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esameVnode\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ea, b\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n    a.key === b.key \x26amp;\x26amp;\n    a.tag === b.tag \x26amp;\x26amp;\n    a.isComment === b.isComment \x26amp;\x26amp;\n    isDef(a.data) === isDef(b.data) \x26amp;\x26amp;\n    sameInputType(a, b)\n  )\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e\x3ccode\x3esameVnode\x3c\/code\x3e会对传入的2个\x3ccode\x3evnode\x3c\/code\x3e进行基本属性的比较，只有当基本属性相同的情况下才认为这个2个\x3ccode\x3evnode\x3c\/code\x3e只是局部发生了更新，然后才会对这2个\x3ccode\x3evnode\x3c\/code\x3e进行\x3ccode\x3ediff\x3c\/code\x3e，如果2个\x3ccode\x3evnode\x3c\/code\x3e的基本属性存在不一致的情况，那么就会直接跳过\x3ccode\x3ediff\x3c\/code\x3e的过程，进而依据\x3ccode\x3evnode\x3c\/code\x3e新建一个真实的dom，同时删除老的\x3ccode\x3edom\x3c\/code\x3e节点。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3evnode\x3c\/code\x3e基本属性的定义可以参见源码:\x3ccode\x3esrc\/vdom\/vnode.js\x3c\/code\x3e里面对于\x3ccode\x3evnode\x3c\/code\x3e的定义。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22constructor (\n    tag?: string,\n    data?: VNodeData,         \/\/ 关于这个节点的data值，包括attrs,style,hook等\n    children?: ?Array\x3cVNode\x3e, \/\/ 子vdom节点\n    text?: string,        \/\/ 文本内容\n    elm?: Node,           \/\/ 真实的dom节点\n    context?: Component,  \/\/ 创建这个vdom的上下文\n    componentOptions?: VNodeComponentOptions\n  ) {\n    this.tag = tag\n    this.data = data\n    this.children = children\n    this.text = text\n    this.elm = elm\n    this.ns = undefined\n    this.context = context\n    this.functionalContext = undefined\n    this.key = data \x26amp;\x26amp; data.key\n    this.componentOptions = componentOptions\n    this.componentInstance = undefined\n    this.parent = undefined\n    this.raw = false\n    this.isStatic = false\n    this.isRootInsert = true\n    this.isComment = false\n    this.isCloned = false\n    this.isOnce = false\n  }\n\n  \/\/ DEPRECATED: alias for componentInstance for backwards compat.\n  \/* istanbul ignore next *\/\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (\n    tag?: string,\n    data?: VNodeData,         \/\/ 关于这个节点的data值，包括attrs,style,hook等\n    children?: ?Array\x26lt;VNode\x26gt;, \/\/ 子vdom节点\n    text?: string,        \/\/ 文本内容\n    elm?: Node,           \/\/ 真实的dom节点\n    context?: Component,  \/\/ 创建这个vdom的上下文\n    componentOptions?: VNodeComponentOptions\n  ) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tag = tag\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data = data\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.children = children\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.text = text\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.elm = elm\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.ns = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context = context\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.functionalContext = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.key = data \x26amp;\x26amp; data.key\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.componentOptions = componentOptions\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.componentInstance = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parent = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.raw = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isStatic = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isRootInsert = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isComment = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isCloned = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isOnce = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ DEPRECATED: alias for componentInstance for backwards compat.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore next *\/\x3c\/span\x3e\n  get child (): Component | \x3cspan class=\x22hljs-keyword\x22\x3evoid\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.componentInstance\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每一个\x3ccode\x3evnode\x3c\/code\x3e都映射到一个真实的\x3ccode\x3edom\x3c\/code\x3e节点上。其中几个比较重要的属性:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3etag\x3c\/code\x3e 属性即这个\x3ccode\x3evnode\x3c\/code\x3e的标签属性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3edata\x3c\/code\x3e 属性包含了最后渲染成真实\x3ccode\x3edom\x3c\/code\x3e节点后，节点上的\x3ccode\x3eclass\x3c\/code\x3e,\x3ccode\x3eattribute\x3c\/code\x3e,\x3ccode\x3estyle\x3c\/code\x3e以及绑定的事件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3echildren\x3c\/code\x3e 属性是\x3ccode\x3evnode\x3c\/code\x3e的子节点\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3etext\x3c\/code\x3e 属性是文本属性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eelm\x3c\/code\x3e 属性为这个\x3ccode\x3evnode\x3c\/code\x3e对应的真实\x3ccode\x3edom\x3c\/code\x3e节点\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ekey\x3c\/code\x3e 属性是\x3ccode\x3evnode\x3c\/code\x3e的标记，在\x3ccode\x3ediff\x3c\/code\x3e过程中可以提高\x3ccode\x3ediff\x3c\/code\x3e的效率，后文有讲解\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e比如，我定义了一个\x3ccode\x3evnode\x3c\/code\x3e，它的数据结构是:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    {\n        tag: \x27div\x27\n        data: {\n            id: \x27app\x27,\n            class: \x27page-box\x27\n        },\n        children: [\n            {\n                tag: \x27p\x27,\n                text: \x27this is demo\x27\n            }\n        ]\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    {\n        \x3cspan class=\x22hljs-attr\x22\x3etag\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27div\x27\x3c\/span\x3e\n        data: {\n            \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27app\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27page-box\x27\x3c\/span\x3e\n        },\n        \x3cspan class=\x22hljs-attr\x22\x3echildren\x3c\/span\x3e: [\n            {\n                \x3cspan class=\x22hljs-attr\x22\x3etag\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27p\x27\x3c\/span\x3e,\n                \x3cspan class=\x22hljs-attr\x22\x3etext\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27this is demo\x27\x3c\/span\x3e\n            }\n        ]\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后渲染出的实际的\x3ccode\x3edom\x3c\/code\x3e结构就是:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   \x3cdiv id=\x26quot;app\x26quot; class=\x26quot;page-box\x26quot;\x3e\n       \x3cp\x3ethis is demo\x3c\/p\x3e\n   \x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e   \x26lt;div id=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22page-box\x22\x3c\/span\x3e\x26gt;\n       \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3ethis is demo\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n   \x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/div\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e让我们再回到\x3ccode\x3epatch\x3c\/code\x3e函数当中，\x3cstrong\x3e在当\x3ccode\x3eoldVnode\x3c\/code\x3e不存在的时候\x3c\/strong\x3e，这个时候是\x3ccode\x3eroot节点\x3c\/code\x3e初始化的过程，因此调用了\x3ccode\x3ecreateElm(vnode, insertedVnodeQueue, parentElm, refElm)\x3c\/code\x3e方法去创建一个新的节点。\x3cstrong\x3e而当\x3ccode\x3eoldVnode\x3c\/code\x3e是\x3ccode\x3evnode\x3c\/code\x3e且\x3ccode\x3esameVnode(oldVnode, vnode)\x3c\/code\x3e2个节点的基本属性相同\x3c\/strong\x3e，那么就进入了2个节点的\x3ccode\x3ediff\x3c\/code\x3e过程。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ediff\x3c\/code\x3e的过程主要是通过调用\x3ccode\x3epatchVnode\x3c\/code\x3e方法进行的:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epatchVnode\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode, insertedVnodeQueue, removeOnly\x3c\/span\x3e) \x3c\/span\x3e{\n    ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (isDef(data) \x26amp;\x26amp; isPatchable(vnode)) {\n      \/\/ cbs保存了hooks钩子函数: \x27create\x27, \x27activate\x27, \x27update\x27, \x27remove\x27, \x27destroy\x27\n      \/\/ 取出cbs保存的update钩子函数，依次调用，更新attrs\/style\/class\/events\/directives\/refs等属性\n      for (i = 0; i \x3c cbs.update.length; \x2b\x2bi) cbs.update[i](oldVnode, vnode)\n      if (isDef(i = data.hook) \x26amp;\x26amp; isDef(i = i.update)) i(oldVnode, vnode)\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(data) \x26amp;\x26amp; isPatchable(vnode)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cbs保存了hooks钩子函数: \x27create\x27, \x27activate\x27, \x27update\x27, \x27remove\x27, \x27destroy\x27\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 取出cbs保存的update钩子函数，依次调用，更新attrs\/style\/class\/events\/directives\/refs等属性\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; cbs.update.length; \x2b\x2bi) cbs.update[i](oldVnode, vnode)\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(i = data.hook) \x26amp;\x26amp; isDef(i = i.update)) i(oldVnode, vnode)\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e更新真实\x3ccode\x3edom\x3c\/code\x3e节点的\x3ccode\x3edata\x3c\/code\x3e属性，相当于对\x3ccode\x3edom\x3c\/code\x3e节点进行了预处理的操作\x3c\/p\x3e\n\x3cp\x3e接下来:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    ...\n    const elm = vnode.elm = oldVnode.elm\n    const oldCh = oldVnode.children\n    const ch = vnode.children\n    \/\/ 如果vnode没有文本节点\n    if (isUndef(vnode.text)) {\n      \/\/ 如果oldVnode的children属性存在且vnode的属性也存在\n      if (isDef(oldCh) \x26amp;\x26amp; isDef(ch)) {\n        \/\/ updateChildren，对子节点进行diff\n        if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n      } else if (isDef(ch)) {\n        \/\/ 如果oldVnode的text存在，那么首先清空text的内容\n        if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, \x27\x27)\n        \/\/ 然后将vnode的children添加进去\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n      } else if (isDef(oldCh)) {\n        \/\/ 删除elm下的oldchildren\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n      } else if (isDef(oldVnode.text)) {\n        \/\/ oldVnode有子节点，而vnode没有，那么就清空这个节点\n        nodeOps.setTextContent(elm, \x27\x27)\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      \/\/ 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素\n      nodeOps.setTextContent(elm, vnode.text)\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    ...\n    const elm = vnode.elm = oldVnode.elm\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oldCh = oldVnode.children\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ch = vnode.children\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果vnode没有文本节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(vnode.text)) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果oldVnode的children属性存在且vnode的属性也存在\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldCh) \x26amp;\x26amp; isDef(ch)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ updateChildren，对子节点进行diff\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(ch)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果oldVnode的text存在，那么首先清空text的内容\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldVnode.text)) nodeOps.setTextContent(elm, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 然后将vnode的children添加进去\x3c\/span\x3e\n        addVnodes(elm, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, ch, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, ch.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, insertedVnodeQueue)\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldCh)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除elm下的oldchildren\x3c\/span\x3e\n        removeVnodes(elm, oldCh, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, oldCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldVnode.text)) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ oldVnode有子节点，而vnode没有，那么就清空这个节点\x3c\/span\x3e\n        nodeOps.setTextContent(elm, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldVnode.text !== vnode.text) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果oldVnode和vnode文本属性不同，那么直接更新真是dom节点的文本元素\x3c\/span\x3e\n      nodeOps.setTextContent(elm, vnode.text)\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这其中的\x3ccode\x3ediff\x3c\/code\x3e过程中又分了好几种情况，\x3ccode\x3eoldCh\x3c\/code\x3e为\x3ccode\x3eoldVnode\x3c\/code\x3e的子节点，\x3ccode\x3ech\x3c\/code\x3e为\x3ccode\x3eVnode\x3c\/code\x3e的子节点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e首先进行文本节点的判断，若\x3ccode\x3eoldVnode.text !== vnode.text\x3c\/code\x3e，那么就会直接进行文本节点的替换；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e在\x3ccode\x3evnode\x3c\/code\x3e没有文本节点的情况下，进入子节点的\x3ccode\x3ediff\x3c\/code\x3e；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当\x3ccode\x3eoldCh\x3c\/code\x3e和\x3ccode\x3ech\x3c\/code\x3e都存在且不相同的情况下，调用\x3ccode\x3eupdateChildren\x3c\/code\x3e对子节点进行\x3ccode\x3ediff\x3c\/code\x3e；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e若\x3ccode\x3eoldCh\x3c\/code\x3e不存在，\x3ccode\x3ech\x3c\/code\x3e存在，首先清空\x3ccode\x3eoldVnode\x3c\/code\x3e的文本节点，同时调用\x3ccode\x3eaddVnodes\x3c\/code\x3e方法将\x3ccode\x3ech\x3c\/code\x3e添加到\x3ccode\x3eelm\x3c\/code\x3e真实\x3ccode\x3edom\x3c\/code\x3e节点当中；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e若\x3ccode\x3eoldCh\x3c\/code\x3e存在，\x3ccode\x3ech\x3c\/code\x3e不存在，则删除\x3ccode\x3eelm\x3c\/code\x3e真实节点下的\x3ccode\x3eoldCh\x3c\/code\x3e子节点；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e若\x3ccode\x3eoldVnode\x3c\/code\x3e有文本节点，而\x3ccode\x3evnode\x3c\/code\x3e没有，那么就清空这个文本节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e这里着重分析下\x3ccode\x3eupdateChildren\x3c\/code\x3e方法，它也是整个\x3ccode\x3ediff\x3c\/code\x3e过程中最重要的环节:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    \/\/ 为oldCh和newCh分别建立索引，为之后遍历的依据\n    let oldStartIdx = 0\n    let newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx, idxInOld, elmToMove, refElm\n    \n    \/\/ 直到oldCh或者newCh被遍历完后跳出循环\n    while (oldStartIdx \x3c= oldEndIdx \x26amp;\x26amp; newStartIdx \x3c= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx] \/\/ Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n        newStartVnode = newCh[\x2b\x2bnewStartIdx]\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { \/\/ Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n        canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { \/\/ Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n        \/\/ 插入到老的开始节点的前面\n        canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[\x2b\x2bnewStartIdx]\n      } else {\n        \/\/ 如果以上条件都不满足，那么这个时候开始比较key值，首先建立key和index索引的对应关系\n        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null\n        \/\/ 如果idxInOld不存在\n        \/\/ 1. newStartVnode上存在这个key,但是oldKeyToIdx中不存在\n        \/\/ 2. newStartVnode上并没有设置key属性\n        if (isUndef(idxInOld)) { \/\/ New element\n          \/\/ 创建新的dom节点\n          \/\/ 插入到oldStartVnode.elm前面\n          \/\/ 参见createElm方法\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          newStartVnode = newCh[\x2b\x2bnewStartIdx]\n        } else {\n          elmToMove = oldCh[idxInOld]\n          \/* istanbul ignore if *\/\n          if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; !elmToMove) {\n            warn(\n              \x27It seems there are duplicate keys that is causing an update error. \x27 \x2b\n              \x27Make sure each v-for item has a unique key.\x27\n            )\n          \n          \/\/ 将找到的key一致的oldVnode再和newStartVnode进行diff\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)\n            oldCh[idxInOld] = undefined\n            \/\/ 移动node节点\n            canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          } else {\n            \/\/ same key but different element. treat as new element\n            \/\/ 创建新的dom节点\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          }\n        }\n      }\n    }\n    \/\/ 如果最后遍历的oldStartIdx大于oldEndIdx的话\n    if (oldStartIdx \x3e oldEndIdx) {        \/\/ 如果是老的vdom先被遍历完\n      refElm = isUndef(newCh[newEndIdx \x2b 1]) ? null : newCh[newEndIdx \x2b 1].elm\n      \/\/ 添加newVnode中剩余的节点到parentElm中\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } else if (newStartIdx \x3e newEndIdx) { \/\/ 如果是新的vdom先被遍历完，则删除oldVnode里面所有的节点\n      \/\/ 删除剩余的节点\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateChildren\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparentElm, oldCh, newCh, insertedVnodeQueue, removeOnly\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 为oldCh和newCh分别建立索引，为之后遍历的依据\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldStartIdx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newStartIdx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldEndIdx = oldCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldStartVnode = oldCh[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldEndVnode = oldCh[oldEndIdx]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newEndIdx = newCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newStartVnode = newCh[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newEndVnode = newCh[newEndIdx]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldKeyToIdx, idxInOld, elmToMove, refElm\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直到oldCh或者newCh被遍历完后跳出循环\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (oldStartIdx \x26lt;= oldEndIdx \x26amp;\x26amp; newStartIdx \x26lt;= newEndIdx) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode has been moved left\x3c\/span\x3e\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n        newStartVnode = newCh[\x2b\x2bnewStartIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newEndVnode)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode moved right\x3c\/span\x3e\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n        canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n        oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n        newEndVnode = newCh[--newEndIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newStartVnode)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode moved left\x3c\/span\x3e\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 插入到老的开始节点的前面\x3c\/span\x3e\n        canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n        oldEndVnode = oldCh[--oldEndIdx]\n        newStartVnode = newCh[\x2b\x2bnewStartIdx]\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果以上条件都不满足，那么这个时候开始比较key值，首先建立key和index索引的对应关系\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果idxInOld不存在\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1. newStartVnode上存在这个key,但是oldKeyToIdx中不存在\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2. newStartVnode上并没有设置key属性\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(idxInOld)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ New element\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建新的dom节点\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 插入到oldStartVnode.elm前面\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参见createElm方法\x3c\/span\x3e\n          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          newStartVnode = newCh[\x2b\x2bnewStartIdx]\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          elmToMove = oldCh[idxInOld]\n          \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; !elmToMove) {\n            warn(\n              \x3cspan class=\x22hljs-string\x22\x3e\x27It seems there are duplicate keys that is causing an update error. \x27\x3c\/span\x3e \x2b\n              \x3cspan class=\x22hljs-string\x22\x3e\x27Make sure each v-for item has a unique key.\x27\x3c\/span\x3e\n            )\n          \n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将找到的key一致的oldVnode再和newStartVnode进行diff\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)\n            oldCh[idxInOld] = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移动node节点\x3c\/span\x3e\n            canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ same key but different element. treat as new element\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建新的dom节点\x3c\/span\x3e\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          }\n        }\n      }\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果最后遍历的oldStartIdx大于oldEndIdx的话\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldStartIdx \x26gt; oldEndIdx) {        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是老的vdom先被遍历完\x3c\/span\x3e\n      refElm = isUndef(newCh[newEndIdx \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) ? \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e : newCh[newEndIdx \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].elm\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加newVnode中剩余的节点到parentElm中\x3c\/span\x3e\n      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newStartIdx \x26gt; newEndIdx) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是新的vdom先被遍历完，则删除oldVnode里面所有的节点\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除剩余的节点\x3c\/span\x3e\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在开始遍历\x3ccode\x3ediff\x3c\/code\x3e前，首先给\x3ccode\x3eoldCh\x3c\/code\x3e和\x3ccode\x3enewCh\x3c\/code\x3e分别分配一个\x3ccode\x3estartIndex\x3c\/code\x3e和\x3ccode\x3eendIndex\x3c\/code\x3e来作为遍历的索引，当\x3ccode\x3eoldCh\x3c\/code\x3e或者\x3ccode\x3enewCh\x3c\/code\x3e遍历完后(遍历完的条件就是\x3ccode\x3eoldCh\x3c\/code\x3e或者\x3ccode\x3enewCh\x3c\/code\x3e的\x3ccode\x3estartIndex \x26gt;= endIndex\x3c\/code\x3e)，就停止\x3ccode\x3eoldCh\x3c\/code\x3e和\x3ccode\x3enewCh\x3c\/code\x3e的\x3ccode\x3ediff\x3c\/code\x3e过程。接下来通过实例来看下整个\x3ccode\x3ediff\x3c\/code\x3e的过程(节点属性中不带\x3ccode\x3ekey\x3c\/code\x3e的情况):\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e首先从第一个节点开始比较，不管是\x3ccode\x3eoldCh\x3c\/code\x3e还是\x3ccode\x3enewCh\x3c\/code\x3e的起始或者终止节点都不存在\x3ccode\x3esameVnode\x3c\/code\x3e，同时节点属性中是不带\x3ccode\x3ekey\x3c\/code\x3e标记的，因此第一轮的\x3ccode\x3ediff\x3c\/code\x3e完后，\x3ccode\x3enewCh\x3c\/code\x3e的\x3ccode\x3estartVnode\x3c\/code\x3e被添加到\x3ccode\x3eoldStartVnode\x3c\/code\x3e的前面，同时\x3ccode\x3enewStartIndex\x3c\/code\x3e前移一位；\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu4K?w=1402\x26amp;h=752\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu4K?w=1402\x26amp;h=752\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第二轮的\x3ccode\x3ediff\x3c\/code\x3e中，满足\x3ccode\x3esameVnode(oldStartVnode, newStartVnode)\x3c\/code\x3e，因此对这2个\x3ccode\x3evnode\x3c\/code\x3e进行\x3ccode\x3ediff\x3c\/code\x3e，最后将\x3ccode\x3epatch\x3c\/code\x3e打到\x3ccode\x3eoldStartVnode\x3c\/code\x3e上，同时\x3ccode\x3eoldStartVnode\x3c\/code\x3e和\x3ccode\x3enewStartIndex\x3c\/code\x3e都向前移动一位\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu9d?w=1362\x26amp;h=736\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu9d?w=1362\x26amp;h=736\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第三轮的\x3ccode\x3ediff\x3c\/code\x3e中，满足\x3ccode\x3esameVnode(oldEndVnode, newStartVnode)\x3c\/code\x3e，那么首先对\x3ccode\x3eoldEndVnode\x3c\/code\x3e和\x3ccode\x3enewStartVnode\x3c\/code\x3e进行\x3ccode\x3ediff\x3c\/code\x3e，并对\x3ccode\x3eoldEndVnode\x3c\/code\x3e进行\x3ccode\x3epatch\x3c\/code\x3e，并完成\x3ccode\x3eoldEndVnode\x3c\/code\x3e移位的操作，最后\x3ccode\x3enewStartIndex\x3c\/code\x3e前移一位，\x3ccode\x3eoldStartVnode\x3c\/code\x3e后移一位；\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu44?w=1342\x26amp;h=820\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu44?w=1342\x26amp;h=820\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第四轮的\x3ccode\x3ediff\x3c\/code\x3e中，过程同步骤3；\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu5b?w=1322\x26amp;h=1012\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu5b?w=1322\x26amp;h=1012\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第五轮的\x3ccode\x3ediff\x3c\/code\x3e中，同过程1；\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu5c?w=1336\x26amp;h=1090\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu5c?w=1336\x26amp;h=1090\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e遍历的过程结束后，\x3ccode\x3enewStartIdx \x26gt; newEndIdx\x3c\/code\x3e，说明此时\x3ccode\x3eoldCh\x3c\/code\x3e存在多余的节点，那么最后就需要将这些多余的节点删除。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu9m?w=1344\x26amp;h=1134\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu9m?w=1344\x26amp;h=1134\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e在\x3ccode\x3evnode\x3c\/code\x3e不带\x3ccode\x3ekey\x3c\/code\x3e的情况下，每一轮的\x3ccode\x3ediff\x3c\/code\x3e过程当中都是\x3ccode\x3e起始\x3c\/code\x3e和\x3ccode\x3e结束\x3c\/code\x3e节点进行比较，直到\x3ccode\x3eoldCh\x3c\/code\x3e或者\x3ccode\x3enewCh\x3c\/code\x3e被遍历完。而当为\x3ccode\x3evnode\x3c\/code\x3e引入\x3ccode\x3ekey\x3c\/code\x3e属性后，在每一轮的\x3ccode\x3ediff\x3c\/code\x3e过程中，当\x3ccode\x3e起始\x3c\/code\x3e和\x3ccode\x3e结束\x3c\/code\x3e节点都没有找到\x3ccode\x3esameVnode\x3c\/code\x3e时，首先对\x3ccode\x3eoldCh\x3c\/code\x3e中进行\x3ccode\x3ekey\x3c\/code\x3e值与索引的映射:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\nidxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)\nidxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ecreateKeyToOldIdx\x3c\/code\x3e方法，用以将\x3ccode\x3eoldCh\x3c\/code\x3e中的\x3ccode\x3ekey\x3c\/code\x3e属性作为\x3ccode\x3e键\x3c\/code\x3e，而对应的节点的索引作为\x3ccode\x3e值\x3c\/code\x3e。然后再判断在\x3ccode\x3enewStartVnode\x3c\/code\x3e的属性中是否有\x3ccode\x3ekey\x3c\/code\x3e，且是否在\x3ccode\x3eoldKeyToIndx\x3c\/code\x3e中找到对应的节点。\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e如果不存在这个\x3ccode\x3ekey\x3c\/code\x3e，那么就将这个\x3ccode\x3enewStartVnode\x3c\/code\x3e作为新的节点创建且插入到原有的\x3ccode\x3eroot\x3c\/code\x3e的子节点中:\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (isUndef(idxInOld)) { \/\/ New element\n    \/\/ 创建新的dom节点\n    \/\/ 插入到oldStartVnode.elm前面\n    \/\/ 参见createElm方法\n    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          newStartVnode = newCh[\x2b\x2bnewStartIdx]\n        } \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(idxInOld)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ New element\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建新的dom节点\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 插入到oldStartVnode.elm前面\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参见createElm方法\x3c\/span\x3e\n    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n          newStartVnode = newCh[\x2b\x2bnewStartIdx]\n        } \x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e如果存在这个\x3ccode\x3ekey\x3c\/code\x3e，那么就取出\x3ccode\x3eoldCh\x3c\/code\x3e中的存在这个\x3ccode\x3ekey\x3c\/code\x3e的\x3ccode\x3evnode\x3c\/code\x3e，然后再进行\x3ccode\x3ediff\x3c\/code\x3e的过程:\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22elmToMove = oldCh[idxInOld]\n          \/* istanbul ignore if *\/\n          if (process.env.NODE_ENV !== \x27production\x27 \x26amp;\x26amp; !elmToMove) {\n          \n          \/\/ 将找到的key一致的oldVnode再和newStartVnode进行diff\n          if (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)\n            \/\/ 清空这个节点\n            oldCh[idxInOld] = undefined\n            \/\/ 移动node节点\n            canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          } else {\n            \/\/ same key but different element. treat as new element\n            \/\/ 创建新的dom节点\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eelmToMove = oldCh[idxInOld]\n          \x3cspan class=\x22hljs-comment\x22\x3e\/* istanbul ignore if *\/\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e \x26amp;\x26amp; !elmToMove) {\n          \n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将找到的key一致的oldVnode再和newStartVnode进行diff\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(elmToMove, newStartVnode)) {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue)\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 清空这个节点\x3c\/span\x3e\n            oldCh[idxInOld] = \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移动node节点\x3c\/span\x3e\n            canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ same key but different element. treat as new element\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建新的dom节点\x3c\/span\x3e\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)\n            newStartVnode = newCh[\x2b\x2bnewStartIdx]\n          }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过以上分析，给\x3ccode\x3evdom\x3c\/code\x3e上添加\x3ccode\x3ekey\x3c\/code\x3e属性后，遍历\x3ccode\x3ediff\x3c\/code\x3e的过程中，当\x3ccode\x3e起始点\x3c\/code\x3e, \x3ccode\x3e结束点\x3c\/code\x3e的\x3ccode\x3e搜寻\x3c\/code\x3e及\x3ccode\x3ediff\x3c\/code\x3e出现还是无法匹配的情况下时，就会用\x3ccode\x3ekey\x3c\/code\x3e来作为唯一标识，来进行\x3ccode\x3ediff\x3c\/code\x3e，这样就可以提高\x3ccode\x3ediff\x3c\/code\x3e效率。\x3c\/p\x3e\n\x3cp\x3e带有\x3ccode\x3eKey\x3c\/code\x3e属性的\x3ccode\x3evnode\x3c\/code\x3e的\x3ccode\x3ediff\x3c\/code\x3e过程可见下图：\x3c\/p\x3e\n\x3cp\x3e注意在第一轮的\x3ccode\x3ediff\x3c\/code\x3e过后\x3ccode\x3eoldCh\x3c\/code\x3e上的\x3ccode\x3eB节点\x3c\/code\x3e被删除了，但是\x3ccode\x3enewCh\x3c\/code\x3e上的\x3ccode\x3eB节点\x3c\/code\x3e上\x3ccode\x3eelm\x3c\/code\x3e属性保持对\x3ccode\x3eoldCh\x3c\/code\x3e上\x3ccode\x3eB节点\x3c\/code\x3e的\x3ccode\x3eelm\x3c\/code\x3e引用。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu6N?w=1296\x26amp;h=652\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu6N?w=1296\x26amp;h=652\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu6Q?w=1348\x26amp;h=694\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu6Q?w=1348\x26amp;h=694\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu6U?w=1348\x26amp;h=800\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu6U?w=1348\x26amp;h=800\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQvbx?w=1308\x26amp;h=1006\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQvbx?w=1308\x26amp;h=1006\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVQu6Y?w=1272\x26amp;h=1098\x22 src=\x22https:\/\/static.alili.tech\/img\/bVQu6Y?w=1272\x26amp;h=1098\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>virtual-dom(Vue实现)简析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010090659">https://segmentfault.com/a/1190000010090659</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/a8bj5otplm/" target="_blank">https://alili.tech/archive/a8bj5otplm/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>