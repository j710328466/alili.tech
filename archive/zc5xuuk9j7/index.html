<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="RTMP H5 直播流技术解析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>RTMP H5 直播流技术解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/zc5xuuk9j7/",
				"appid": "1613049289050283", 
				"title": "RTMP H5 直播流技术解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-05T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/qjy55u75wel/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/cmlfyaw6yif/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f&text=RTMP%20H5%20%e7%9b%b4%e6%92%ad%e6%b5%81%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f&text=RTMP%20H5%20%e7%9b%b4%e6%92%ad%e6%b5%81%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f&title=RTMP%20H5%20%e7%9b%b4%e6%92%ad%e6%b5%81%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f&is_video=false&description=RTMP%20H5%20%e7%9b%b4%e6%92%ad%e6%b5%81%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=RTMP%20H5%20%e7%9b%b4%e6%92%ad%e6%b5%81%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f&title=RTMP%20H5%20%e7%9b%b4%e6%92%ad%e6%b5%81%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f&title=RTMP%20H5%20%e7%9b%b4%e6%92%ad%e6%b5%81%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f&title=RTMP%20H5%20%e7%9b%b4%e6%92%ad%e6%b5%81%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fzc5xuuk9j7%2f&title=RTMP%20H5%20%e7%9b%b4%e6%92%ad%e6%b5%81%e6%8a%80%e6%9c%af%e8%a7%a3%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">RTMP H5 直播流技术解析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-05" itemprop="datePublished">2019-01-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e上一篇文章简单阐述了，在 H5 中，做直播需要哪些技术知识点，有哪些直播流协议和技术。通过对比，本篇主要聚焦于 RTMP 直播协议的相关内容，也就是说，本篇将会直接进行实际操作 Buffer 的练习和相关的学习。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eRTMP 是什么\x3c\/h2\x3e\n\x3cp\x3eRTMP 全称即是 \x3ccode\x3eReal-Time Messaging Protocol\x3c\/code\x3e。顾名思义就是用来作为实时通信的一种协议。该协议是 Adobe 搞出来的。主要是用来传递音视频流的。它通过一种自定义的协议，来完成对指定直播流的播放和相关的操作。和现行的直播流相比，RTMP 主要的特点就是高效，这里，我就不多费口舌了。我们先来了解一下 RTMP 是如何进行握手的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eRTMP 握手\x3c\/h2\x3e\n\x3cp\x3eRTMP 是基于 TCP 三次握手之后的，所以，RTMP 不是和 TCP 一个 level 的。它本身是基于 TCP 的可靠性连接。RTMP 握手的方式如图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519576\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519576\x22 alt=\x22image.png-50.3kB\x22 title=\x22image.png-50.3kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e（C 代表 Client，S 代表 Server）\x3c\/p\x3e\n\x3cp\x3e它主要是通过两端的字段内容协商，来完成可信度认证的。基本过程如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eclient: 客户端需要发 3 个包。C0,C1,C2\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eserver: 服务端也需要发同样 3 个包。 S0,S1,S2。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e整个过程如上图所述，但实际上有些细节需要注意。\x3c\/p\x3e\n\x3cp\x3e握手开始：\x3c\/p\x3e\n\x3cp\x3e【1】 客户端发送 C0,C1 包\x3c\/p\x3e\n\x3cp\x3e此时，客户端处于等待状态。客户端有两个限制：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e客户端在未接受到 S1 之前不能发送 C2 包\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e客户端在未接收到 S2 之前不能发送任何实际数据包\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e【2】 服务端在接受到 C0，发送 S0，S1 包。也可以等到接受到 C1 之后再一起发送，C1 包的等待不是必须的。\x3c\/p\x3e\n\x3cp\x3e此时，服务端处于等待状态。服务端有两个限制：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e服务端在未接受到 C1 之前不能发送 S2.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e服务端在未接收到 C2 之前不能发送任何实际数据包\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e【3】客户端接受到 S1\/S0 包后，发送 C2 包。\x3c\/p\x3e\n\x3cp\x3e【4】服务端接受到 C2 包后，返回 S2 包，并且此时握手已经完成。\x3c\/p\x3e\n\x3cp\x3e不过，在实际应用中，并不是严格按照上面的来。因为 RTMP 并不是强安全性的协议，所以，S2\/C2 包只需要 C1\/S1 中的内容，就可以完成内容的拼接。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519577\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519577\x22 alt=\x22实际握手\x22 title=\x22实际握手\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这么多限制，说白了，其实就是一种通用模式：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eC0\x2bC1\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eS0\x2bS1\x2bS2\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eC2\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e接下来，我们来具体看看 C\/S 012 包分别代表什么。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eC0 \x26amp;\x26amp; S0\x3c\/h3\x3e\n\x3cp\x3eC0 和 S0 其实区别不大，我这里主要讲解一下 C0，就差不多了。首先，C0 的长度为 1B。它的主要工作是确定 RTMP 的版本号。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eC0：客户端发送其所支持的 RTMP 版本号：3~31。一般都是写 3。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eS1：服务端返回其所支持的版本号。如果没有客户端的版本号，默认返回 3。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eC1 \x26amp;\x26amp; S1\x3c\/h3\x3e\n\x3cp\x3eC1\/S1 长度为 1536B。主要目的是确保握手的唯一性。格式为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519578\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519578\x22 alt=\x22image.png-107kB\x22 title=\x22image.png-107kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3etime: 发送时间戳，这个其实不是很重要，不过需要记住，不要超出 4B 的范围即可。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ezero: 保留值 0.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3erandom: 该字段长尾 1528B。主要内容就是随机值，不管你用什么产生都可以。它主要是为了保证此次握手的唯一性，和确定握手的对象。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eC2 \x26amp;\x26amp; S2\x3c\/h3\x3e\n\x3cp\x3eC2\/S2 的长度也是 1536B。相当于就是 S1\/C1 的响应值。上图也简单说明了就是，对应 C1\/S1 的 Copy 值，不过第二个字段有区别。基本格式为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519579\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519579\x22 alt=\x22image.png-105.1kB\x22 title=\x22image.png-105.1kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3etime: 时间戳，同上，也不是很重要\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3etime2: C1\/S1 发送的时间戳。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3erandom: S1\/C1 发送的随机数。长度为 1528B。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里需要提及的是，RTMP 默认都是使用 Big-Endian 进行写入和读取，除非强调对某个字段使用 Little-Endian 字节序。\x3c\/p\x3e\n\x3cp\x3e上面握手协议的顺序也是根据其中相关的字段来进行制定的。这样，看起来很容易啊哈，但是，我们并不仅仅停留在了解，而是要真正的了解，接下来，我们来实现一下，如果通过 Buffer 来进行 3 次握手。这里，我们作为 Client 端来进行请求的发起，假设 Server 端是按照标准进行发送即可。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eBuffer 实操握手\x3c\/h2\x3e\n\x3cp\x3e我们使用 Buffer 实操主要涉及两块，一个块是 request server 的搭建，还有一块是 Buffer 的拼接。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eRequest Server 搭建\x3c\/h3\x3e\n\x3cp\x3e这里的 Server 是直接使用底层的 TCP 连接。\x3c\/p\x3e\n\x3cp\x3e如下，一个简易的模板：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const client = new net.Socket();\n\nclient.connect({\n    port: 1935,\n    host: \x26quot;6721.myqcloud.com\x26quot;},\n    ()=\x3e{\n        console.log(\x26quot;connected\x26quot;);\n    });\n    \nclient.on(\x27data\x27,(data)=\x3e{\n    client.write(\x27hello\x27);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3econst client = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e net.Socket();\n\nclient.connect({\n    port: \x3cspan class=\x22hljs-number\x22\x3e1935\x3c\/span\x3e,\n    host: \x3cspan class=\x22hljs-string\x22\x3e\x226721.myqcloud.com\x22\x3c\/span\x3e},\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22connected\x22\x3c\/span\x3e);\n    });\n    \nclient.\x3cspan class=\x22hljs-literal\x22\x3eon\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(data)\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n    client.write(\x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不过，为了更好的进行实际演练，我们通过 \x3ccode\x3eEventEmitter\x3c\/code\x3e 的方式，来做一个筛选器。这里，我们使用 \x3ca href=\x22https:\/\/github.com\/developit\/mitt\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emitt\x3c\/a\x3e 模块来做代理。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Emitter = require(\x27mitt\x27)();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs ebnf\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-attribute\x22\x3econst Emitter\x3c\/span\x3e = require(\x3cspan class=\x22hljs-string\x22\x3e\x27mitt\x27\x3c\/span\x3e)();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后，我们只要分析的就是将要接受到的 S0\/1\/2 包。根据上面的字节包图，可以清楚的知道包里面的详细内容。这里，为了简单起见，我们排除其他协议的包头，只是针对 RTMP 里面的包。而且，我们针对的只有 3 种包，S0\/1\/2。为了达到这种目的，我们需要在 \x3ccode\x3edata\x3c\/code\x3e 时间中，加上相应的钩子才行。\x3c\/p\x3e\n\x3cp\x3e这里，我们借用 Now 直播的 RTMP 流来进行相关的 RTMP 直播讲解。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eBuffer 操作\x3c\/h3\x3e\n\x3cp\x3eServer 的搭建其实上网搜一搜，应该都可以搜索出来。关键点在于，如何针对 RTMP 的实操握手进行 encode\/decode。所以，这里，我们针对上述操作，来主要讲解一下。\x3c\/p\x3e\n\x3cp\x3e我们主要的工作量在于如何构造出 C0\/1\/2。根据上面格式的描述，大家应该可以清楚的知道 C0\/1\/2 里面的格式分别有啥。\x3c\/p\x3e\n\x3cp\x3e比如，C1 中的 time 和 random，其实并不是必须字段，所以，为了简单起见，我们可以默认设为 0。具体代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class C {\n    constructor() {\n        this.time;\n        this.random;\n    }\n    C0() {\n        let buf = Buffer.alloc(1);\n        buf[0] = 3;\n        return buf;\n    }\n    C1() {\n        let buf = Buffer.alloc(1536);\n        return buf;\n    }\n    \/**\n     * write C2 package\n     * @param {Number} time the 4B Number of time\n     * @param {Buffer} random 1528 byte\n     *\/\n    produceC2(){\n        let buf = Buffer.alloc(1536);\n        \/\/ leave empty value as origin time\n        buf.writeUInt32BE(this.time, 4);\n        this.random.copy(buf,8,0,1528);\n\n        return buf;\n    }\n    get getC01(){\n        return Buffer.concat([this.C0(),this.C1()]);\n    }\n    get C2(){\n        return this.produceC2();\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eC\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.time;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.random;\n    }\n    C0() {\n        let buf = Buffer.alloc(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n        buf[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e buf;\n    }\n    C1() {\n        let buf = Buffer.alloc(\x3cspan class=\x22hljs-number\x22\x3e1536\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e buf;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * write C2 package\n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {Number} time the 4B Number of time\n     * \x3cspan class=\x22hljs-doctag\x22\x3e@param\x3c\/span\x3e {Buffer} random 1528 byte\n     *\/\x3c\/span\x3e\n    produceC2(){\n        let buf = Buffer.alloc(\x3cspan class=\x22hljs-number\x22\x3e1536\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ leave empty value as origin time\x3c\/span\x3e\n        buf.writeUInt32BE(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.time, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.random.copy(buf,\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1528\x3c\/span\x3e);\n\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e buf;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e getC01(){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Buffer.concat([\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.C0(),\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.C1()]);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e C2(){\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.produceC2();\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来，我们来看一下，结合 server 完成的 RTMP 客户端服务。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Client = new net.Socket();\nconst RTMP_C = new C();\n\n\nClient.connect({\n    port: 1935,\n    host: \x26quot;6721.liveplay.myqcloud.com\x26quot;\n}, () =\x3e {\n    console.log(\x27connected\x27)\n    Client.write(RTMP_C.getC01);\n\n});\n\nClient.on(\x27data\x27,res=\x3e{\n    if(!res){\n        console.warn(\x27received empty Buffer \x27 \x2b res);\n        return;\n    }\n    \/\/ start to decode res package\n    if(!RTMP_C.S0 \x26amp;\x26amp; res.length\x3e0){\n        RTMP_C.S0 = res.readUInt8(0);\n        res = res.slice(1);\n    }\n\n    if(!RTMP_C.S1 \x26amp;\x26amp; res.length\x3e=1536){\n        RTMP_C.time = res.readUInt32BE(0);\n        RTMP_C.random = res.slice(8,1536);\n        RTMP_C.S1 = true;\n        res = res.slice(1536);\n        console.log(\x27send C2\x27);\n        Client.write(RTMP_C.C2);\n    }\n\n    if(!RTMP_C.S2 \x26amp;\x26amp; res.length \x3e= 1536){\n        RTMP_C.S2 = true;\n        res = res.slice(1536);\n    }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eClient\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e net.Socket();\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e RTMP_C = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e C();\n\n\n\x3cspan class=\x22hljs-built_in\x22\x3eClient\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3econnect\x3c\/span\x3e({\n    port: \x3cspan class=\x22hljs-number\x22\x3e1935\x3c\/span\x3e,\n    host: \x3cspan class=\x22hljs-string\x22\x3e\x226721.liveplay.myqcloud.com\x22\x3c\/span\x3e\n}, () =\x26gt; {\n    console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27connected\x27\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-built_in\x22\x3eClient\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3ewrite\x3c\/span\x3e(RTMP_C.getC01);\n\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3eClient\x3c\/span\x3e.on(\x3cspan class=\x22hljs-string\x22\x3e\x27data\x27\x3c\/span\x3e,res=\x26gt;{\n    \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e(!res){\n        console.warn(\x3cspan class=\x22hljs-string\x22\x3e\x27received empty Buffer \x27\x3c\/span\x3e \x2b res);\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ start to decode res package\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e(!RTMP_C.S0 \x26amp;\x26amp; res.length\x26gt;\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e){\n        RTMP_C.S0 = res.readUInt8(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n        res = res.slice(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n    }\n\n    \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e(!RTMP_C.S1 \x26amp;\x26amp; res.length\x26gt;=\x3cspan class=\x22hljs-number\x22\x3e1536\x3c\/span\x3e){\n        RTMP_C.time = res.readUInt32BE(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n        RTMP_C.\x3cspan class=\x22hljs-built_in\x22\x3erandom\x3c\/span\x3e = res.slice(\x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e1536\x3c\/span\x3e);\n        RTMP_C.S1 = true;\n        res = res.slice(\x3cspan class=\x22hljs-number\x22\x3e1536\x3c\/span\x3e);\n        console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27send C2\x27\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-built_in\x22\x3eClient\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3ewrite\x3c\/span\x3e(RTMP_C.C2);\n    }\n\n    \x3cspan class=\x22hljs-built_in\x22\x3eif\x3c\/span\x3e(!RTMP_C.S2 \x26amp;\x26amp; res.length \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e1536\x3c\/span\x3e){\n        RTMP_C.S2 = true;\n        res = res.slice(\x3cspan class=\x22hljs-number\x22\x3e1536\x3c\/span\x3e);\n    }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e详细代码可以参考 \x3ca href=\x22https:\/\/gist.github.com\/JimmyVV\/192fd9e45e3bd1ea7c88112a6c9e959c\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egist\x3c\/a\x3e\x3cbutton class=\x22btn btn-xs btn-default ml10 preview\x22 data-url=\x22JimmyVV\/192fd9e45e3bd1ea7c88112a6c9e959c\x22 data-typeid=\x221\x22\x3e点击预览\x3c\/button\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3eRTMP 基本架构\x3c\/h2\x3e\n\x3cp\x3eRTMP 整个内容，除了握手，其实剩下的就是一些列围绕 type id 的 message。为了让大家更清楚的看到整个架构，这里简单陈列了一份框架：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519580\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519580\x22 alt=\x22image.png-94.9kB\x22 title=\x22image.png-94.9kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在 Message 下的 3 个一级子 Item 就是我们现在将要大致讲解的内容。\x3c\/p\x3e\n\x3cp\x3e可以看到上面所有的 item 都有一个共同的父 Item--Message。它的基本结构为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eHeader: header 部分用来标识不同的 typeID，告诉客户端相应的 Message 类型。另外，还有个功效就是多路分发。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eBody: Body 内容就是相应发送的数据。这个根据不同的 typeID 来说，格式就完全不一样了。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e下面，我们先了解一下 Header 和不同 typeID 的内容：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3eHeader\x3c\/h3\x3e\n\x3cp\x3eRTMP 中的 Header 分为 Basic Header 和 Message Header。需要注意，他们两者并不是独立的，而是相互联系。Message Header 的结构由 Basic Header 的内容来决定。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519581\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519581\x22 alt=\x22image.png-41kB\x22 title=\x22image.png-41kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e接下来，先分开来讲解：\x3c\/p\x3e\n\x3ch4\x3eBasic Header\x3c\/h4\x3e\n\x3cp\x3eBH（基础头部）主要是定义了该 chunk stream ID 和 chunk type。需要注意的是，BH 是变长度的，即，它的长度范围是 1-3B。怎么讲呢？就是根据不同的 chunk stream ID 来决定具体的长度。CS ID（Chunk Stream ID）本身的支持的范围为 \x26lt;= 65597 ，差不多为 22bit。当然，为了节省这 3B 的内容。 Adobe 搞了一个比较绕的理论，即，通过如下格式中的 CS ID 来确定：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  0 1 2 3 4 5 6 7\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\n |fmt|   cs id   |\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\n |fmt|   cs id   |\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e即，通过 2-7 bit 位来确定整个 BH 的长度。怎么确定呢？\x3c\/p\x3e\n\x3cp\x3eRTMP 规定，CS ID 的 0，1，2 为保留字，你在设置 CS ID 的时候只能从 3 开始。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eCS ID: 0 ==\x26gt; 整个 BH 长为 2B，其中可以表示的 Stream ID 数量为 64-319。例如：\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  0 1\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\n |fmt|    0    |    cs id - 64   |\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n  \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\n |fmt|    \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e    |    cs id - \x3cspan class=\x22hljs-number\x22\x3e64\x3c\/span\x3e   |\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意上面的 cs id - 64。这个代表的就是，你通过切割第二个 byte 时，是将得到的值加上 64。即：\x3ccode\x3e2th byte \x2b 64 = CS ID\x3c\/code\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eCS ID: 1 ==\x26gt; 整个 BH 长为 3B。可以存储的 Stream ID 数量为 64-65599。例如：\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\n |fmt|    1      |           cs id - 64          |\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e8\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e9\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\n |fmt|    \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e      |           cs id - \x3cspan class=\x22hljs-number\x22\x3e64\x3c\/span\x3e          |\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然，后面 CS ID 的计算方法也是最后的结果加上 64。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eCS ID \x26gt;2 ==\x26gt; 整个 BH 长为 1B。可以存储的 Stream ID 数量为  3-63。例如：\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  0 1 2 3 4 5 6 7\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\n |fmt|  cs id    |\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e6\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e7\x3c\/span\x3e\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\n |fmt|  cs id    |\n \x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b-\x2b\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后强调一下，因为 RTMP 规定，CS ID 的 0,1,2 为保留字，所以，0,1,2 不作为 CS ID。综上所述，CS ID 的起始位为 3（并不代表它是 3 个 Stream）。\x3c\/p\x3e\n\x3cp\x3e上面我并没有提到 fmt 字段，这其实是用来定义 Message Header 的。\x3c\/p\x3e\n\x3ch4\x3eMessage Header\x3c\/h4\x3e\n\x3cp\x3e根据前面 BH 中 fmt 字段的定义，可以分为 4 种 MH（Message Header）。或者说，就是一种 MH 格式会存在从繁到简 4 种：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3efmt: 0\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e当 fmt 为 0 时，MH 的长度为 11B。该类型的 MH 必须要流的开头部分，这包括当进行快退或者点播时重新获取的流。该结构的整体格式如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519582\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519582\x22 alt=\x22image.png-58.8kB\x22 title=\x22image.png-58.8kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e也就是说，当 fmt 为 0 时，其格式是一个完整的 MH。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3etimestamp 是绝对时间戳。用来代表当前流编码。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3emessage length: 3B, 发送 message 的长度。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3etype id: 1B\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3estream id: 4B, 发送 message stream id 的值。是 little-endian 写入格式！\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3efmt: 1\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e当 fmt 为 1 时，MH 的长度为 7B。该类型的 MH 不带 msg stream id。msg stream id 由前面一个 package 决定。该数值主要由前一个 fmt 为 0 的 MH 决定。该类型的 MH 通常放在 fmt 为 0 之后。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519583\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519583\x22 alt=\x22image.png-16.7kB\x22 title=\x22image.png-16.7kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3efmt: 2\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e当 fmt 为 2 时，MH 的长度为 3B。该类型的 MH 只包括一个 timestamp delta 字段。其它的信息都是依照前面一个其他类型 MH 决定的。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3efmt: 3\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e当 fmt 为 3时，这其实 RTMP 里面就没有了 MH。官方定义，该类型主要全部都是 payload 的 chunk，其 Header 信息和第一个非 \x3ccode\x3etype:3\x3c\/code\x3e 的头一致。因为这主要用于 chunk 中，这些 chunk 都是从一个包里面切割出来的，所以除了第一个 chunk 外，其它的 chunk 都可以采用这种格式。当 fmt 为 3时，计算它的 timestamp 需要注意几点，如果前面一个 chunk 里面存在 \x3ccode\x3etimestrameDelta\x3c\/code\x3e，那么计算 fmt 为 3 的 chunk 时，就直接相加，如果没有，则是使用前一个 chunk 的 \x3ccode\x3etimestamp\x3c\/code\x3e 来进行相加，用代码表示为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22prevChunk.timeStamp \x2b= prevChunk.timeStampDelta || prevChunk.timeStamp;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3eprevChunk.timeStamp \x2b= prevChunk.timeStampDelta \x3cspan class=\x22hljs-string\x22\x3e|| prevChunk.timeStamp;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不过，当 fmt: 3 的情况一般很难遇到。因为，他要求前面几个包必须存在 fmt 为 0\/1\/2 的情况。\x3c\/p\x3e\n\x3cp\x3e接下来的就是 Message Body 部分。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eMessage Body\x3c\/h3\x3e\n\x3cp\x3e上面说的主要是 Message Header 的公用部分，但是，对于具体的 RTMP Message 来说，里面的 type 会针对不同的业务场景有不同的格式。Message 全部内容如上图所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519580\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519580\x22 alt=\x22image.png-94.9kB\x22 title=\x22image.png-94.9kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这里，我们根据流程图的一级子 item 来展开讲解。\x3c\/p\x3e\n\x3ch4\x3ePCM\x3c\/h4\x3e\n\x3cp\x3ePCM 全称为：Protocol Control Messages（协议控制消息）。主要使用来沟通 RTMP 初始状态的相关连接信息，比如，windows size，chunk size 等。\x3c\/p\x3e\n\x3cp\x3ePCM 中一共有 5 种不同的 Message 类型，是根据 Header 中的 type ID 决定的，范围是 1~6 （不包括 4）。另外，PCM 在构造的时候需要注意，它 Heaer 中的 message stream id 和 chunk stream id 需要设置为固定值：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3emessage stream ID 为 0\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3echunk stream ID 为 2\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如图所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519584\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519584\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eOK，我们接下来一个一个来介绍一下：\x3c\/p\x3e\n\x3ch5\x3eSet Chunk Size（1）\x3c\/h5\x3e\n\x3cp\x3e看名字大家应该都能猜到这类信息是用来干啥的。该类型的 PCM 就是用来设置 server 和 client 之间正式传输信息的 chunk 的大小，type ID 为 1。那这有啥用呢？\x3c\/p\x3e\n\x3cp\x3eSCS（Set Chunk Size） 是针对正式发送数据而进行数据大小的发送限制。一般默认为 128B。不过，如果 server 觉得太小了，想发送更大的包给你，比如 132B，那么 server 就需要给你发送一个 SCS，告知你，接下来“我发送给你的数据大小是 132B”。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519585\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519585\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e0: 只能设为 0 ，用来表示当前的 PCM 的类型。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3echunk size: 用来表示后面发送正式数据时的大小。范围为 1-16777215。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如下，提供过 wireshark 抓包的结果：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519586\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519586\x22 alt=\x22image.png-45.4kB\x22 title=\x22image.png-45.4kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch5\x3eAbort Message（2）\x3c\/h5\x3e\n\x3cp\x3e该类 PCM 是用来告诉 client，丢弃指定的 stream 中，已经加载到一半或者还未加载完成的 Chunk Message。它需要指定一个 chunk stream ID。\x3c\/p\x3e\n\x3cp\x3e基本格式为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519587\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519587\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3echunk stream id: 指定丢弃 chunk message 的 stream\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3ch5\x3eAcknowledgement（3）\x3c\/h5\x3e\n\x3cp\x3e该协议信息其实就是一个 ACK 包，在实际使用是并没有用到，它主要是用来作为一个 ACK 包，来表示两次 ACK 间，接收端所能接收的最大字节数。\x3c\/p\x3e\n\x3cp\x3e它基本格式为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519588\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519588\x22 alt=\x22image.png-52.1kB\x22 title=\x22image.png-52.1kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3esequence number[4B]: 大小为 4B\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e不过，该包在实际应用中，没有多高的出现频率。\x3c\/p\x3e\n\x3ch5\x3eWindow Acknowledgement Size（5）\x3c\/h5\x3e\n\x3cp\x3e这是用来协商发送包的大小的。这个和上面的 \x3ccode\x3echunk size\x3c\/code\x3e 不同，这里主要针对的是客户端可接受的最大数据包的值，而 chunk size 是指每次发送的包的大小。也可以叫做 \x3ccode\x3ewindow size\x3c\/code\x3e。一般电脑设置的大小都是 500000B。\x3c\/p\x3e\n\x3cp\x3e详细格式为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519589\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519589\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e通过，wireshark 抓包的结果为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519590\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519590\x22 alt=\x22image.png-56.2kB\x22 title=\x22image.png-56.2kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch5\x3eSet Peer Bandwidth（6）\x3c\/h5\x3e\n\x3cp\x3e这是 PCM 中，最后一个包。他做的工作主要是根据网速来改变发送包的大小。它的格式和 WAS 类似，不过后面带上了一个 \x3ccode\x3eType\x3c\/code\x3e 用来标明当前带宽限制算法。当一方接收到该信息后，如果设置的 window size 和前面的 WAS 不一致，需要返回一个 WAS 来进行显示改变。\x3c\/p\x3e\n\x3cp\x3e基本格式为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519591\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519591\x22 alt=\x22此处输入图片的描述\x22 title=\x22此处输入图片的描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其中 Limit Type 有 3 个取值：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e0: Hard，表示当前带宽需要和当前设置的 window size 匹配\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e1: Soft，将当前宽带设置为该信息定义的 window size，或者已经生效的 window size。主要取决于谁的 window size 更小\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e2: Dynamic，如果前一个 Limit Type 为 Hard 那么，继续使用 \x3ccode\x3eHard\x3c\/code\x3e 为基准，否则忽略该次协议信息。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e实际抓包情况可以参考：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519592\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519592\x22 alt=\x22image.png-56.8kB\x22 title=\x22image.png-56.8kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3eUCM\x3c\/h3\x3e\n\x3cp\x3e全称为：\x3ccode\x3eUser Control Message\x3c\/code\x3e（用户控制信息）。它的 Type ID 只能为 4。它主要是发送一些对视频的控制信息。其发送的条件也有一定的限制：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3emsg stream ID 为 0\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3echunk stream ID 为 2\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e它的 Body 部分的基本格式为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519593\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519593\x22 alt=\x22UCM\x22 title=\x22UCM\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eUCM 根据 Event Type 的不同，对流进行不同的设置。它的 Event Type 一共有 6 种格式 \x3ccode\x3eStream Begin(0)\x3c\/code\x3e，\x3ccode\x3eStream EOF(1)\x3c\/code\x3e，\x3ccode\x3eStreamDry(2)\x3c\/code\x3e，\x3ccode\x3eSetBuffer Length(3)\x3c\/code\x3e，\x3ccode\x3eStreamIs Recorded(4)\x3c\/code\x3e，\x3ccode\x3ePingRequest(6)\x3c\/code\x3e，\x3ccode\x3ePingResponse(7)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e这里，根据重要性划分，只介绍 Begin，EOF，SetBuffer Length 这 3 种。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eStream Begin: Event Type 为 0。它常常出现在，当客户端和服务端成功 \x3ccode\x3econnect\x3c\/code\x3e 后发送。Event Data 为 4B，内容是已经可以正式用来传输数据的 Stream ID（实际没啥用）。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519594\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519594\x22 alt=\x22image.png-50.7kB\x22 title=\x22image.png-50.7kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eStream EOF: Event Type 为 1。它常常出现在，当音视频流已经全部传输完时。 Event Data 为 4B，用来表示已经发送完音视频流的 Stream ID（实际没啥用）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eSet Buffer Length: Event Type 为 3。它主要是为了通知服务端，每毫秒用来接收流中 Buffer 的大小。Event Data 的前 4B 表示 stream ID，后面 4B 表示每毫秒 Buffer 的大小。通常为 3000ms\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eOK 剩下就是 Command Msg 里面的内容了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eCommand Msg\x3c\/h3\x3e\n\x3cp\x3eCommand Msg 里面的内容，其 type id 涵盖了 8~22 之间的值。具体内容，可以参考下表：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519595\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519595\x22 alt=\x22image.png-184.3kB\x22 title=\x22image.png-184.3kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e需要注意，为什么有些选项里面有两个 id，这主要和 AMF 版本选择有关。第一个 ID 表示 AMF0 的编解码方式，第二个 ID 表示 AMF3 的编解码方式。\x3cbr\x3e其中比较重要的是 command Msg，video，audio 这 3 个 Msg。为了让大家更好的理解 RTMP 流的解析，这里，先讲解一下 video 和 audio 两个 Msg。\x3c\/p\x3e\n\x3ch4\x3eVideo Msg\x3c\/h4\x3e\n\x3cp\x3e因为 RTMP 是 Adobe 开发的。理所当然，内部的使用格式肯定是 FLV 格式。不过，这和没说一样。因为，FLV 格式内部有很多的 tag 和相关的描述信息。那么，RTMP 是怎么解决的呢？是直接传一整个 FLV 文件，还自定义协议来分段传输 FLV Tag 呢？\x3c\/p\x3e\n\x3cp\x3e这个其实很好回答，因为 RTMP 协议是一个长连接，如果是传整个 FLV 文件，根本没必要用到这个，而且，RTMP 最常用在直播当中。直播中的视频都是分段播放的。综上所述，RTMP 是根据自己的自定义协议来分段传输 FLV Tag 的。那具体的协议是啥呢？\x3c\/p\x3e\n\x3cp\x3e这个在 RTMP 官方文档中其实也没有给出。它只是告诉我们 Video Msg 的 type ID 是 9 而已。\x3c\/p\x3e\n\x3cp\x3e因为，RTMP 只是一个传输工具，里面传什么还是由具体的流生成框架来决定的。所以，这里，我选择了一个非常具有代表性的 RTMP 直播流来进行讲解。\x3c\/p\x3e\n\x3cp\x3e通过 wireshark 抓包，可以捕获到以下的 RTMP 包数据：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519596\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519596\x22 alt=\x22image.png-60kB\x22 title=\x22image.png-60kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这里需要提及一点，因为 RTMP 是主动将 Video 和 Audio 分开传输，所以，它需要交叉发布 Video 和 Audio，以保证音视频的同步。那么具体每个 Video Data 里面的数据都是一样的吗？\x3c\/p\x3e\n\x3cp\x3e如果看 Tag 的话，他们传输的都是 VideoData Tag。先看一下 FLV VideoData Tag 的内容：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519597\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519597\x22 alt=\x22image.png-141kB\x22 title=\x22image.png-141kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这是 FLV Video 的协议格式。但，遇到第一个字段 \x3ccode\x3eFrameType\x3c\/code\x3e 的时候，我们就可能懵逼了，这 TM 有 5 种情况，难道 RTMP 会给你 5 种不同的包吗？\x3c\/p\x3e\n\x3cp\x3e答案是，有可能，但是，很大情况下，我们只需要支持 1\/2 即可。因为，视频中最重要的是 I 帧，它对应的 FrameType 就是 1。而 B\/P 则是剩下的 2。我们只要针对 1\/2 进行软解，即可实现视频所有信息的获取。\x3c\/p\x3e\n\x3cp\x3e所以，在 RTMP 中，也主要（或者大部分）都是传输上面两种 FrameType。我们通过实际抓包来讲解一下。\x3c\/p\x3e\n\x3cp\x3e这是 KeyFrame 的包，注意 Buffer 开头的 \x3ccode\x3e17\x3c\/code\x3e 数字。大家可以找到上面的 FrameType 对应找一找，看结果是不是一致的：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519598\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519598\x22 alt=\x22image.png-155.8kB\x22 title=\x22image.png-155.8kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这是 Inter-frame 的包。同上，大家也可以对比一下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519599\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519599\x22 alt=\x22image.png-135.9kB\x22 title=\x22image.png-135.9kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3eAudio Tag\x3c\/h4\x3e\n\x3cp\x3eAduio Tag 也是和 Video Tag 一样的蜜汁数据。通过观察 FLV Audio Tag 的内容：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519600\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519600\x22 alt=\x22image.png-224kB\x22 title=\x22image.png-224kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面这些字段全是相关的配置值，换句话说，你必须实现知道这些值才行。这里，RTMP 发送 Audio Tag 和 Video Tag 有点不同。因为 Audio Tag 已经不可能再细分为 Config Tag，所以，RTMP 会直接传递 上面的 audio Tag 内容。详细可以参考抓包内容：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519601\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519601\x22 alt=\x22image.png-60.9kB\x22 title=\x22image.png-60.9kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这也是所有的 Audio Msg 的内容。\x3c\/p\x3e\n\x3cp\x3e因为 Audio 和 Video 是分开发送的。所以，在后期进行拼接的时候，需要注意两者的同步。说道这里，顺便补充一下，音视频同步的相关知识点。\x3c\/p\x3e\n\x3ch4\x3e音视频同步\x3c\/h4\x3e\n\x3cp\x3e音视频同步简单来说有三种：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e以 Audio 为准，Video 同步 Audio\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e以 Video 为准，Audio 同步 Video\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e以外部时间戳为准，AV 同时同步\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e主要过程变量参考就是 \x3ccode\x3etimeStamp\x3c\/code\x3e 和 \x3ccode\x3eduration\x3c\/code\x3e。因为，这里主要是做直播的，推荐大家采用第二种方法，以 \x3ccode\x3eVideo\x3c\/code\x3e 为准。因为，在实际开发中，会遇到 MP4 文件生成时，必须要求第一帧为 \x3ccode\x3ekeyframe\x3c\/code\x3e，这就造成了，以 Audio 为参考的，会遇到两个变量的问题。一个是 timeStamp 一个是 keyframe。当然，解决办法也是有的，就是检查最后一个拼接的 Buffer 是不是 Keyframe，然后判断是否移到下一次同步处理。\x3c\/p\x3e\n\x3cp\x3e这里，我简单的说一下，以 Video 为准的同步方法。以 Video 同步，不需要管第一帧是不是 keyframe，也不需要关心 Audio 里面的数据，因为，Audio 数据是非常简单的 AAC 数据。下面我们通过伪代码来说明一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ known condition\nvideo.timeStamp \x26amp;\x26amp; video.perDuration \x26amp;\x26amp; video.wholeDuration\naudio.timeStamp \x26amp;\x26amp; audio.perDuration\n\n\/\/ start\nrefDuration = video.timeStamp \x2b video.wholeDuration\ndelta = refDuration - audio.timeStamp\naudioCount = Math.round(delta\/audio.perDuration);\naudDemuxArr = this._tmpArr.splice(0,audioCount);\n\n\/\/ begin to demux\nthis._remuxVideo(vidDemuxArr);\nthis._remuxAudio(audDemuxArr);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ known condition\x3c\/span\x3e\nvideo.timeStamp \x26amp;\x26amp; video.perDuration \x26amp;\x26amp; video.wholeDuration\naudio.timeStamp \x26amp;\x26amp; audio.perDuration\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ start\x3c\/span\x3e\nrefDuration = video.timeStamp \x2b video.wholeDuration\ndelta = refDuration - audio.timeStamp\naudioCount = Math.round(delta\/audio.perDuration);\naudDemuxArr = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._tmpArr.splice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,audioCount);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ begin to demux\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._remuxVideo(vidDemuxArr);\n\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._remuxAudio(audDemuxArr);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面算法可以避免判断 Aduio 和 Video timeStamp 的比较，保证 Video 一直在 Audio 前面并相差不远。下面，我们回到 RTMP 内容。来看看 Command Msg 里面的内容。\x3c\/p\x3e\n\x3ch4\x3eCommand Msg\x3c\/h4\x3e\n\x3cp\x3eCommand Msg 是 RTMP 里面的一个主要信息传递工具。常常用在 RTMP 前期和后期处理。Command Msg 是通过 AMF 的格式进行传输的（其实就是类似 JSON 的二进制编码规则）。Command Msg 主要分为 \x3ccode\x3enet connect\x3c\/code\x3e 和 \x3ccode\x3enet stream\x3c\/code\x3e 两大块。它的交流方式是双向的，即，你发送一次 \x3ccode\x3enet connect\x3c\/code\x3e 或者 \x3ccode\x3estream\x3c\/code\x3e 之后，另外一端都必须返回一个 \x3ccode\x3e_result\x3c\/code\x3e 或者 \x3ccode\x3e_error\x3c\/code\x3e 以表示收到信息。详细结构可以参考下图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519602\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519602\x22 alt=\x22image.png-58.4kB\x22 title=\x22image.png-58.4kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e后续，我们分为两块进行讲解：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3enetConnection\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3enetStream\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e里面的 _result 和 _error 会穿插在每个包中进行讲解。\x3c\/p\x3e\n\x3ch4\x3eNetConnection\x3c\/h4\x3e\n\x3cp\x3enetConnection 可以分为 4 种 Msg，\x3ccode\x3econnect\x3c\/code\x3e，\x3ccode\x3ecall\x3c\/code\x3e，\x3ccode\x3ecreateStream\x3c\/code\x3e，\x3ccode\x3eclose\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3econnect\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3econnect 是客户端向 Server 端发送播放请求的。里面的字段内容有：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eCommand Name[String]: 默认为 \x3ccode\x3econnect\x3c\/code\x3e。表示信息名称\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTransaction ID[Number]: 默认为 1。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCommand Object: 键值对的形式存放相关信息。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eOptional: 可选值。一般没有\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e那，Command Object 里面又可以存放些什么内容呢？\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eapp[String]: 服务端连接应用的名字。这个主要根据你的 RTMP 服务器设定来设置。比如：\x3ccode\x3elive\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eflashver[String]: Flash Player 的版本号。一般根据自己设备上的型号来确定即可。也可以设置为默认值：\x3ccode\x3eLNX 9,0,124,2\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3etcUrl[String]: 服务端的 URL 地址。简单来说，就是 protocol:\/\/host\/path。比如：\x3ccode\x3ertmp:\/\/6521.liveplay.myqcloud.com\/live\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3efpad[Boolean]: 表示是否使用代理。一般为 false。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eaudioCodecs[Number]: 客户端支持的音频解码。后续会介绍。默认可以设置为 \x3ccode\x3e4071\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3evideoCodecs[Number]: 客户端支持的视频解码。有自定义的标准。默认可以设置为 \x3ccode\x3e252\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3evideoFunction[Number]: 表明在服务端上调用那种特别的视频函数。默认可以设置为 \x3ccode\x3e1\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e简单来说，Command Object 就是起到 RTMP Route 的作用。用来请求特定的资源路径。实际数据，可以参考抓包结果：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519603\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519603\x22 alt=\x22image.png-163.1kB\x22 title=\x22image.png-163.1kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上面具体的取值主要是根据 rtmp 官方文档来决定。如果懒得查，可以直接使用上面的取值。上面的内容是兼容性比较高的值。当该包成功发送时，另外一端需要得到一个返回包来响应，具体格式为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eCommand Name[String]: 为 _result 或者 _error。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTransaction ID[Number]: 默认为 1。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCommand Object: 键值对的形式存放相关信息。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eInformation[Object]: 键值对的形式，来描述相关的 response 信息。里面存在的字段有：level,code,description\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e可以参考：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519604\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519604\x22 alt=\x22image.png-117.6kB\x22 title=\x22image.png-117.6kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3econnect 包发送的位置，主要是在 RTMP 握手结束之后。如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519605\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519605\x22 alt=\x22image.png-79.5kB\x22 title=\x22image.png-79.5kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ecall\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3ecall 包主要作用是用来远程执行接收端的程序（RPC, remote procedure calls)。不过，在我解 RTMP 的过程中，并没有实际用到过。这里简单介绍一下格式。它的内容和 \x3ccode\x3econnect\x3c\/code\x3e 类似：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eProcedure Name[String]: 调用处理程序的名字。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTransaction ID[Number]: 如果想要有返回，则我们需要制定一个 id。否则为 0。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCommand Object: 键值对的形式存放相关信息。AMF0\/3\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eOptional: 可选值。一般没有\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eCommand Object 里面的内容主要是针对程序，设置相关的调用参数。因为内容不固定，这里就不介绍了。\x3c\/p\x3e\n\x3cp\x3ecall 一般是需要有 response 来表明，远端程序是否执行，以及是否执行成功等。返回的格式为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eCommand Name[String]: 根据 call 中 Command Object 参数来决定的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTransaction ID[Number]: 如果想要有返回，则我们需要制定一个 id。否则为 0。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCommand Object: 键值对的形式存放相关信息。AMF0\/3\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eResponse[Object]: 响应的结果值\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3ecreateStream\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3ecreateStream 包只是用来告诉服务端，我们现在要创建一个 channel 开始进行流的交流了。格式和内容都不复杂：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eProcedure Name[String]: 调用处理程序的名字。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTransaction ID[Number]: 自己制定一个。一般可以设为 2\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCommand Object: 键值对的形式存放相关信息。AMF0\/3\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e当成功后，服务端会返回一个 \x3ccode\x3e_result\x3c\/code\x3e 或者 \x3ccode\x3e_error\x3c\/code\x3e 包来说明接收成功，详细内容为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eCommand Name[String]: 根据 call 中 Command Object 参数来决定的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTransaction ID[Number]: 如果想要有返回，则我们需要制定一个 id。否则为 0。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCommand Object: 键值对的形式存放相关信息。AMF0\/3。一般为 Null\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eStream ID: 返回的 stream ID 值。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e它的返回值很随意，参考抓包内容：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519606\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519606\x22 alt=\x22image.png-16.1kB\x22 title=\x22image.png-16.1kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e下面，我们来看一下 RTMP 中第二个比较重要的 command msg -- netStream msg。\x3c\/p\x3e\n\x3ch4\x3eNetStream Msg\x3c\/h4\x3e\n\x3cp\x3eNetStream 里面的 Msg 有很多，但在直播流中，比较重要的只有 \x3ccode\x3eplay\x3c\/code\x3e 包。所以，这里我们着重介绍一下 play 包。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eplay\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eplay 包主要是用来告诉 Server 正式播放音视频流。而且，由于 RTMP 天然是做多流分发的。如果遇到网络出现相应的波动，客户端可以根据网络条件多次调用 play 命令，来切换不同模式的流。\x3c\/p\x3e\n\x3cp\x3e其基本格式为：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eCommand Name[String]: 根据 call 中 Command Object 参数来决定的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eTransaction ID[Number]: 默认为 0。也可以设置为其他值\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eCommand Object: 不需要该字段，在该命令中，默认设为 \x3ccode\x3eNull\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eStream Name[String]: 用来指定播放的视频流文件。因为，RTMP 天生是支持 FLV 的，所以针对 FLV 文件来说，并不需要加额外的标识，只需要写明文件名即可。比如:\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22StreamName: \x276721_75994f92ce868a0cd3cc84600a97f75c\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3eStreamName:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x276721_75994f92ce868a0cd3cc84600a97f75c\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cp\x3e不过，如果想要支持其它的文件，那么则需要额外的表示。当然，音频和视频需要不同的支持：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e如果是播放音频文件，比如 mp3，那么则需要额外的前缀标识符-\x3ccode\x3emp3\x3c\/code\x3e。例如：\x3ccode\x3emp3:6721_75994f9\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果涉及到视频文件的话，不仅需要前缀，还需要后缀。比如播放的是 MP4 文件，则标识为：\x3ccode\x3emp4:6721_75994f9.mp4\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3estartNumber: 这个字段其实有点意思。它可以分为 3 类来讲解：-2，-1，\x26gt;=0。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e-2: 如果是该标识符，服务端会首先寻找是否有对应的 liveStream。没有的话，就找 record_stream。如果还没有的，这次请求会暂时挂起，直到获取到下一次 live_stream。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e-1: 只有 live_stream 才会播放。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cblockquote\x3e\x3cp\x3e=0: 相当于就是 seek video。它会直接找到 record_stream，并且根据该字段的值来确定播放开始时间。如果没有的话，则播放 list 中的下一个 video。\x3c\/p\x3e\x3c\/blockquote\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\n\x3cp\x3edurationNumber: 用来设置播放时长的。它里面也有几个参数需要讲解一下，-1，0，\x26gt;0。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e-1: 会一直播放到 live_stream 或者 record_stream 结束。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e0: 会播放一段一段的 frame。一般不用。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cblockquote\x3e\x3cp\x3e0: 会直接播放指定 duration 之内的流。如果超出，则会播放指定时间段内容的 record_stream。\x3c\/p\x3e\x3c\/blockquote\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ereset[Boolean]: 该字段没啥用，一般可以忽略。用来表示否是抛弃掉前面的 playlist。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e整个 \x3ccode\x3eplay\x3c\/code\x3e 包内容就已经介绍完了。我们可以看看实际的 play 抓包结果：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519607\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519607\x22 alt=\x22image.png-19.5kB\x22 title=\x22image.png-19.5kB\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e那 play 包是在那个环节发送，发送完之后需不需要对应的 _result 包呢？\x3c\/p\x3e\n\x3cp\x3eplay 包比较特殊，它是不需要 _result 回包的。因为，一旦 \x3ccode\x3eplay\x3c\/code\x3e 包成功接收后。server 端会直接开始进行 \x3ccode\x3estreamBegin\x3c\/code\x3e 的操作。\x3c\/p\x3e\n\x3cp\x3e整个流程为：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010519608\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010519608\x22 alt=\x22image.png-207.2kB\x22 title=\x22image.png-207.2kB\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e到这里，后续就可以开始正式接收 video 和 audio 的 stream。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>RTMP H5 直播流技术解析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010519573">https://segmentfault.com/a/1190000010519573</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/zc5xuuk9j7/" target="_blank">https://alili.tech/archive/zc5xuuk9j7/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/lfmj4xr00e/">2016年终总结--前端生涯从0到1的过程<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/ukfvl3yzohq/">ES6新语法疑点简析<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/adal5cm5rlr/">Icon 进化史<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/xwquh4g09bl/">JS 中 TDZ 的理解<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/13j072ppoyf/">Javascript 中 Y 组合子的推导<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/kn3l7fwd55/">Redux story-1:who creates it?<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/9gngp6sg77/">Redux概念之二: Redux的三大原则<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/ktc291v9lq/">V8 Object 内存结构与属性访问详解<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/62hk7sdq93k/">Vue&#43;MySQL&#43;Express小试牛刀<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/q9tzlra5qaj/">Vue2.0简易案例<aside class="dates">2019-01-27</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>