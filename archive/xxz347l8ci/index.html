<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="理解 JavaScript 的 async/await"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>理解 JavaScript 的 async/await | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/xxz347l8ci/",
				"appid": "1613049289050283", 
				"title": "理解 JavaScript 的 async/await | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-31T02:31:16"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/v3rwff199/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/rcmlmgo4g2f/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f&text=%e7%90%86%e8%a7%a3%20JavaScript%20%e7%9a%84%20async%2fawait"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f&text=%e7%90%86%e8%a7%a3%20JavaScript%20%e7%9a%84%20async%2fawait"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f&title=%e7%90%86%e8%a7%a3%20JavaScript%20%e7%9a%84%20async%2fawait"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f&is_video=false&description=%e7%90%86%e8%a7%a3%20JavaScript%20%e7%9a%84%20async%2fawait"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%90%86%e8%a7%a3%20JavaScript%20%e7%9a%84%20async%2fawait&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f&title=%e7%90%86%e8%a7%a3%20JavaScript%20%e7%9a%84%20async%2fawait"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f&title=%e7%90%86%e8%a7%a3%20JavaScript%20%e7%9a%84%20async%2fawait"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f&title=%e7%90%86%e8%a7%a3%20JavaScript%20%e7%9a%84%20async%2fawait"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fxxz347l8ci%2f&title=%e7%90%86%e8%a7%a3%20JavaScript%20%e7%9a%84%20async%2fawait"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">理解 JavaScript 的 async/await</h1><div class="meta"><div class="postdate"><time datetime="2019-01-31" itemprop="datePublished">2019-01-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e随着 \x3ca href=\x22https:\/\/nodejs.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNode 7\x3c\/a\x3e 的发布，越来越多的人开始研究据说是异步编程终级解决方案的 async\/await。我第一次看到这组关键字并不是在 JavaScript 语言里，而是在 c# 5.0 的语法中。C# 的 async\/await 需要在 .NET Framework 4.5 以上的版本中使用，因此我还很悲伤了一阵——为了要兼容 XP 系统，我们开发的软件不能使用高于 4.0 版本的 .NET Framework。\x3c\/p\x3e\n\x3cp\x3e我之前在\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000003742890\x22\x3e《闲谈异步调用“扁平”化》\x3c\/a\x3e 中就谈到了这个问题。无论是在 C# 还是 JavaScript 中，async\/await 都是非常棒的特性，它们也都是非常甜的语法糖。C# 的 async\/await 实现离不开 \x3ca href=\x22https:\/\/msdn.microsoft.com\/library\/dd321424.aspx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTask 或 Task\x26lt;Result\x26gt;\x3c\/a\x3e 类，而 JavaScript 的 async\/await 实现，也离不开 \x3ca href=\x22https:\/\/developer.mozilla.org\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/Promise\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e现在抛开 C# 和 .NET Framework，专心研究下 JavaScript 的 async\/await。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3easync 和 await 在干什么\x3c\/h2\x3e\n\x3cp\x3e任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。\x3c\/p\x3e\n\x3cp\x3e另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？\x3c\/p\x3e\n\x3cp\x3e如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……\x3c\/p\x3e\n\x3cp\x3e如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3easync 起什么作用\x3c\/h3\x3e\n\x3cp\x3e这个问题的关键在于，async 函数是怎么处理它的返回值的！\x3c\/p\x3e\n\x3cp\x3e我们当然希望它能直接通过 \x3ccode\x3ereturn\x3c\/code\x3e 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function testAsync() {\n    return \x26quot;hello async\x26quot;;\n}\n\nconst result = testAsync();\nconsole.log(result);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etestAsync\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22hello async\x22\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = testAsync();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(result);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e看到输出就恍然大悟了——输出的是一个 Promise 对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22c:\\var\\test\x3e node --harmony_async_await .\nPromise { \x27hello async\x27 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22bash hljs\x22\x3e\x3ccode class=\x22bash\x22\x3ec:\\var\\\x3cspan class=\x22hljs-built_in\x22\x3etest\x3c\/span\x3e\x26gt; node --harmony_async_await .\nPromise { \x3cspan class=\x22hljs-string\x22\x3e\x27hello async\x27\x3c\/span\x3e }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以，async 函数返回的是一个 Promise 对象。从\x3ca href=\x22https:\/\/developer.mozilla.org\/docs\/Web\/JavaScript\/Reference\/Statements\/async_function\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e文档\x3c\/a\x3e中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 \x3ccode\x3ereturn\x3c\/code\x3e 一个直接量，async 会把这个直接量通过 \x3ccode\x3ePromise.resolve()\x3c\/code\x3e 封装成 Promise 对象。\x3c\/p\x3e\n\x3cp\x3easync 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：\x3ccode\x3ethen()\x3c\/code\x3e 链来处理这个 Promise 对象，就像这样\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22testAsync().then(v =\x3e {\n    console.log(v);    \/\/ 输出 hello async\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3etestAsync().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ev\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(v);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出 hello async\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 \x3ccode\x3ePromise.resolve(undefined)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e联想一下 Promise 的特点——无等待，所以在没有 \x3ccode\x3eawait\x3c\/code\x3e 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。\x3c\/p\x3e\n\x3cp\x3e那么下一个关键点就在于 await 关键字了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eawait 到底在等啥\x3c\/h3\x3e\n\x3cp\x3e一般来说，都认为 await 是在等待一个 async 函数完成。不过按\x3ca href=\x22https:\/\/developer.mozilla.org\/docs\/Web\/JavaScript\/Reference\/Operators\/await\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e语法说明\x3c\/a\x3e，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\x3c\/p\x3e\n\x3cp\x3e因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function getSomething() {\n    return \x26quot;something\x26quot;;\n}\n\nasync function testAsync() {\n    return Promise.resolve(\x26quot;hello async\x26quot;);\n}\n\nasync function test() {\n    const v1 = await getSomething();\n    const v2 = await testAsync();\n    console.log(v1, v2);\n}\n\ntest();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egetSomething\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22something\x22\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etestAsync\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve(\x3cspan class=\x22hljs-string\x22\x3e\x22hello async\x22\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e v1 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getSomething();\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e v2 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e testAsync();\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(v1, v2);\n}\n\ntest();\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eawait 等到了要等的，然后呢\x3c\/h3\x3e\n\x3cp\x3eawait 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，\x3ccode\x3eawait\x3c\/code\x3e 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。\x3c\/p\x3e\n\x3cp\x3e如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。\x3c\/p\x3e\n\x3cp\x3e如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3easync\/await 帮我们干了啥\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e作个简单的比较\x3c\/h3\x3e\n\x3cp\x3e上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。\x3c\/p\x3e\n\x3cp\x3e现在举例，用 \x3ccode\x3esetTimeout\x3c\/code\x3e 模拟耗时的异步操作，先来看看不用 async\/await 会怎么写\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function takeLongTime() {\n    return new Promise(resolve =\x3e {\n        setTimeout(() =\x3e resolve(\x26quot;long_time_value\x26quot;), 1000);\n    });\n}\n\ntakeLongTime().then(v =\x3e {\n    console.log(\x26quot;got\x26quot;, v);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etakeLongTime\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e resolve(\x3cspan class=\x22hljs-string\x22\x3e\x22long_time_value\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n    });\n}\n\ntakeLongTime().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ev\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22got\x22\x3c\/span\x3e, v);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果改用 async\/await 呢，会是这样\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function takeLongTime() {\n    return new Promise(resolve =\x3e {\n        setTimeout(() =\x3e resolve(\x26quot;long_time_value\x26quot;), 1000);\n    });\n}\n\nasync function test() {\n    const v = await takeLongTime();\n    console.log(v);\n}\n\ntest();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etakeLongTime\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e resolve(\x3cspan class=\x22hljs-string\x22\x3e\x22long_time_value\x22\x3c\/span\x3e), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n    });\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e v = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e takeLongTime();\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(v);\n}\n\ntest();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e眼尖的同学已经发现 \x3ccode\x3etakeLongTime()\x3c\/code\x3e 没有申明为 \x3ccode\x3easync\x3c\/code\x3e。实际上，\x3ccode\x3etakeLongTime()\x3c\/code\x3e 本身就是返回的 Promise 对象，加不加 \x3ccode\x3easync\x3c\/code\x3e 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。\x3c\/p\x3e\n\x3cp\x3e又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async\/await 还需要多写一些代码，那它的优势到底在哪？\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3easync\/await 的优势在于处理 then 链\x3c\/h3\x3e\n\x3cp\x3e单一的 Promise 链并不能发现 async\/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async\/await 来进一步优化它）。\x3c\/p\x3e\n\x3cp\x3e假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 \x3ccode\x3esetTimeout\x3c\/code\x3e 来模拟异步操作：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n \x2b 200，这个值将用于下一步骤\n *\/\nfunction takeLongTime(n) {\n    return new Promise(resolve =\x3e {\n        setTimeout(() =\x3e resolve(n \x2b 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n \x2b 200，这个值将用于下一步骤\n *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etakeLongTime\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e resolve(n \x2b \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e), n);\n    });\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estep1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`step1 with \x3cspan class=\x22hljs-subst\x22\x3e${n}\x3c\/span\x3e`\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e takeLongTime(n);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estep2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`step2 with \x3cspan class=\x22hljs-subst\x22\x3e${n}\x3c\/span\x3e`\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e takeLongTime(n);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estep3\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`step3 with \x3cspan class=\x22hljs-subst\x22\x3e${n}\x3c\/span\x3e`\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e takeLongTime(n);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在用 Promise 方式来实现这三个步骤的处理\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function doIt() {\n    console.time(\x26quot;doIt\x26quot;);\n    const time1 = 300;\n    step1(time1)\n        .then(time2 =\x3e step2(time2))\n        .then(time3 =\x3e step3(time3))\n        .then(result =\x3e {\n            console.log(`result is ${result}`);\n            console.timeEnd(\x26quot;doIt\x26quot;);\n        });\n}\n\ndoIt();\n\n\/\/ c:\\var\\test\x3enode --harmony_async_await .\n\/\/ step1 with 300\n\/\/ step2 with 500\n\/\/ step3 with 700\n\/\/ result is 900\n\/\/ doIt: 1507.251ms\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoIt\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.time(\x3cspan class=\x22hljs-string\x22\x3e\x22doIt\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time1 = \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e;\n    step1(time1)\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3etime2\x3c\/span\x3e =\x26gt;\x3c\/span\x3e step2(time2))\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3etime3\x3c\/span\x3e =\x26gt;\x3c\/span\x3e step3(time3))\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`result is \x3cspan class=\x22hljs-subst\x22\x3e${result}\x3c\/span\x3e`\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x22doIt\x22\x3c\/span\x3e);\n        });\n}\n\ndoIt();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ c:\\var\\test\x26gt;node --harmony_async_await .\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ step1 with 300\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ step2 with 500\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ step3 with 700\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ result is 900\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ doIt: 1507.251ms\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e输出结果 \x3ccode\x3eresult\x3c\/code\x3e 是 \x3ccode\x3estep3()\x3c\/code\x3e 的参数 \x3ccode\x3e700 \x2b 200\x3c\/code\x3e = \x3ccode\x3e900\x3c\/code\x3e。\x3ccode\x3edoIt()\x3c\/code\x3e 顺序执行了三个步骤，一共用了 \x3ccode\x3e300 \x2b 500 \x2b 700 = 1500\x3c\/code\x3e 毫秒，和 \x3ccode\x3econsole.time()\/console.timeEnd()\x3c\/code\x3e 计算的结果一致。\x3c\/p\x3e\n\x3cp\x3e如果用 async\/await 来实现呢，会是这样\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function doIt() {\n    console.time(\x26quot;doIt\x26quot;);\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\x26quot;doIt\x26quot;);\n}\n\ndoIt();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoIt\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.time(\x3cspan class=\x22hljs-string\x22\x3e\x22doIt\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time1 = \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time2 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e step1(time1);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time3 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e step2(time2);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e step3(time3);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`result is \x3cspan class=\x22hljs-subst\x22\x3e${result}\x3c\/span\x3e`\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x22doIt\x22\x3c\/span\x3e);\n}\n\ndoIt();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e还有更酷的\x3c\/h3\x3e\n\x3cp\x3e现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(m, n) {\n    console.log(`step2 with ${m} and ${n}`);\n    return takeLongTime(m \x2b n);\n}\n\nfunction step3(k, m, n) {\n    console.log(`step3 with ${k}, ${m} and ${n}`);\n    return takeLongTime(k \x2b m \x2b n);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estep1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3en\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`step1 with \x3cspan class=\x22hljs-subst\x22\x3e${n}\x3c\/span\x3e`\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e takeLongTime(n);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estep2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3em, n\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`step2 with \x3cspan class=\x22hljs-subst\x22\x3e${m}\x3c\/span\x3e and \x3cspan class=\x22hljs-subst\x22\x3e${n}\x3c\/span\x3e`\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e takeLongTime(m \x2b n);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estep3\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ek, m, n\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`step3 with \x3cspan class=\x22hljs-subst\x22\x3e${k}\x3c\/span\x3e, \x3cspan class=\x22hljs-subst\x22\x3e${m}\x3c\/span\x3e and \x3cspan class=\x22hljs-subst\x22\x3e${n}\x3c\/span\x3e`\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e takeLongTime(k \x2b m \x2b n);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这回先用 async\/await 来写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function doIt() {\n    console.time(\x26quot;doIt\x26quot;);\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time1, time2);\n    const result = await step3(time1, time2, time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\x26quot;doIt\x26quot;);\n}\n\ndoIt();\n\n\/\/ c:\\var\\test\x3enode --harmony_async_await .\n\/\/ step1 with 300\n\/\/ step2 with 800 = 300 \x2b 500\n\/\/ step3 with 1800 = 300 \x2b 500 \x2b 1000\n\/\/ result is 2000\n\/\/ doIt: 2907.387ms\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoIt\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.time(\x3cspan class=\x22hljs-string\x22\x3e\x22doIt\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time1 = \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time2 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e step1(time1);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time3 = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e step2(time1, time2);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e step3(time1, time2, time3);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`result is \x3cspan class=\x22hljs-subst\x22\x3e${result}\x3c\/span\x3e`\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x22doIt\x22\x3c\/span\x3e);\n}\n\ndoIt();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ c:\\var\\test\x26gt;node --harmony_async_await .\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ step1 with 300\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ step2 with 800 = 300 \x2b 500\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ step3 with 1800 = 300 \x2b 500 \x2b 1000\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ result is 2000\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ doIt: 2907.387ms\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function doIt() {\n    console.time(\x26quot;doIt\x26quot;);\n    const time1 = 300;\n    step1(time1)\n        .then(time2 =\x3e {\n            return step2(time1, time2)\n                .then(time3 =\x3e [time1, time2, time3]);\n        })\n        .then(times =\x3e {\n            const [time1, time2, time3] = times;\n            return step3(time1, time2, time3);\n        })\n        .then(result =\x3e {\n            console.log(`result is ${result}`);\n            console.timeEnd(\x26quot;doIt\x26quot;);\n        });\n}\n\ndoIt();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoIt\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.time(\x3cspan class=\x22hljs-string\x22\x3e\x22doIt\x22\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e time1 = \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e;\n    step1(time1)\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3etime2\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e step2(time1, time2)\n                .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3etime3\x3c\/span\x3e =\x26gt;\x3c\/span\x3e [time1, time2, time3]);\n        })\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3etimes\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e [time1, time2, time3] = times;\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e step3(time1, time2, time3);\n        })\n        .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`result is \x3cspan class=\x22hljs-subst\x22\x3e${result}\x3c\/span\x3e`\x3c\/span\x3e);\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.timeEnd(\x3cspan class=\x22hljs-string\x22\x3e\x22doIt\x22\x3c\/span\x3e);\n        });\n}\n\ndoIt();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e洗洗睡吧\x3c\/h2\x3e\n\x3cp\x3e就目前来说，已经理解 async\/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理3个步骤，再等待所有结果，又该怎么处理呢？\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2015\/05\/async.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阮一峰老师已经说过了\x3c\/a\x3e，我就懒得说了。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>理解 JavaScript 的 async/await</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007535316">https://segmentfault.com/a/1190000007535316</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/xxz347l8ci/" target="_blank">https://alili.tech/archive/xxz347l8ci/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>