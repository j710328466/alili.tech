<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="唠叨一下js对象与哈希表那些事"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>唠叨一下js对象与哈希表那些事 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/pmkr8f26r6/",
				"appid": "1613049289050283", 
				"title": "唠叨一下js对象与哈希表那些事 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-30T02:30:23"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/027no4mqznte/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/vnfjnyhpi3l/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f&text=%e5%94%a0%e5%8f%a8%e4%b8%80%e4%b8%8bjs%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%93%88%e5%b8%8c%e8%a1%a8%e9%82%a3%e4%ba%9b%e4%ba%8b"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f&text=%e5%94%a0%e5%8f%a8%e4%b8%80%e4%b8%8bjs%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%93%88%e5%b8%8c%e8%a1%a8%e9%82%a3%e4%ba%9b%e4%ba%8b"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f&title=%e5%94%a0%e5%8f%a8%e4%b8%80%e4%b8%8bjs%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%93%88%e5%b8%8c%e8%a1%a8%e9%82%a3%e4%ba%9b%e4%ba%8b"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f&is_video=false&description=%e5%94%a0%e5%8f%a8%e4%b8%80%e4%b8%8bjs%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%93%88%e5%b8%8c%e8%a1%a8%e9%82%a3%e4%ba%9b%e4%ba%8b"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%94%a0%e5%8f%a8%e4%b8%80%e4%b8%8bjs%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%93%88%e5%b8%8c%e8%a1%a8%e9%82%a3%e4%ba%9b%e4%ba%8b&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f&title=%e5%94%a0%e5%8f%a8%e4%b8%80%e4%b8%8bjs%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%93%88%e5%b8%8c%e8%a1%a8%e9%82%a3%e4%ba%9b%e4%ba%8b"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f&title=%e5%94%a0%e5%8f%a8%e4%b8%80%e4%b8%8bjs%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%93%88%e5%b8%8c%e8%a1%a8%e9%82%a3%e4%ba%9b%e4%ba%8b"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f&title=%e5%94%a0%e5%8f%a8%e4%b8%80%e4%b8%8bjs%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%93%88%e5%b8%8c%e8%a1%a8%e9%82%a3%e4%ba%9b%e4%ba%8b"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpmkr8f26r6%2f&title=%e5%94%a0%e5%8f%a8%e4%b8%80%e4%b8%8bjs%e5%af%b9%e8%b1%a1%e4%b8%8e%e5%93%88%e5%b8%8c%e8%a1%a8%e9%82%a3%e4%ba%9b%e4%ba%8b"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">唠叨一下js对象与哈希表那些事</h1><div class="meta"><div class="postdate"><time datetime="2019-01-30" itemprop="datePublished">2019-01-30</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cstrong\x3e最近在整理数据结构和算法相关的知识，小茄专门在github上开了个repo \x3ca href=\x22https:\/\/github.com\/qieguo2016\/algorithm\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/qieguo2016...\x3c\/a\x3e，后续内容也会更新到这里，欢迎围观加星星！\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3ejs对象\x3c\/h2\x3e\n\x3cp\x3ejs中的对象是基于哈希表结构的，而哈希表的查找时间复杂度为O(1)，所以很多人喜欢用对象来做映射，减少遍历循环。\x3c\/p\x3e\n\x3cp\x3e比如常见的数组去重：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function arrayUnique(target) {\n  var result = [target[0]];\n  var temp = {};\n  temp[target[0]] = true;\n  for (var i = 1, targetLen = target.length; i \x3c targetLen; i\x2b\x2b) {\n    if (typeof temp[target[i]] === \x27undefined\x27) {\n      result.push(target[i]);\n      temp[target[i]] = true;\n    }\n  }\n  return result;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3earrayUnique\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [target[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]];\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e temp = {};\n  temp[target[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, targetLen = target.length; i \x26lt; targetLen; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e temp[target[i]] === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n      result.push(target[i]);\n      temp[target[i]] = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里使用了一个temp对象来保存出现过的元素，在循环中每次只需要判断当前元素是否在temp对象内即可判断出该元素是否已经出现过。\x3c\/p\x3e\n\x3cp\x3e上面的代码看起来没有问题，但有点经验的同学可能会说了，假如目标数组是[1,\x271\x27], 这是2个不同类型元素，所以我们的期望值应该是原样输出的。但结果却是[1]。\x3cbr\x3e同理的还有true、null等，也就是说对象中的key在obj[key]时都被自动转成了字符串类型。\x3cbr\x3e所以，如果要区分出不同的类型的话，temp里面的属性值就不能是一个简单的true了，而是要包含几种数据类型。比如可以是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    temp[target[0]]={};\n    temp[target[0]][(typeof temp[target[i]])] = 1;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    temp[target[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]]={};\n    temp[target[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]][(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e temp[target[i]])] = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在判断的时候除了要判断键是否存在之外，也要判断对应的数据类型计数是否大于1，以此来判断元素是否重复。\x3c\/p\x3e\n\x3cp\x3e另外，上面的代码语法也有点问题，不知道你发现了没？\x3cbr\x3e我们造的这个temp对象并不是完全空白，他是基于Object原型链继承而来的，所以自带了一个__proto__属性，如果你的目标数组里面恰好有\x22__proto__\x22这个值，返回的结果就有问题了，具体结果可以自己测试确认。解决方法有两种：\x3c\/p\x3e\n\x3cp\x3e1） 想办法去掉这个磨人的__proto__。显然，我们需要去掉原型链，那么可以使用\x3ccode\x3eObject.create(null)\x3c\/code\x3e的方式来创建一个完全空白、无原型的空对象。\x3c\/p\x3e\n\x3cp\x3e\x3cdel\x3e2） 使用\x3ccode\x3e!temp.hasOwnProperty(target[i])\x3c\/code\x3e代替\x3ccode\x3etypeof temp[target[i]] === \x27undefined\x27\x3c\/code\x3e，这时候代表原型链的__proto__属性就不能干扰到我们的结果判断了。\x3c\/del\x3e  感谢@天生爱走神的指正，\x3ccode\x3eobj.hasOwnProperty(__proto__)\x3c\/code\x3e会得到false，但是假如我们的目标数组里面包含\x3ccode\x3e__proto__\x3c\/code\x3e的话，就不能对\x3ccode\x3e__proto__\x3c\/code\x3e进行去重了。\x3c\/p\x3e\n\x3cp\x3e上面说了js中使用对象的一点小窍门，核心在于对象的\x3ccode\x3ehashmap\x3c\/code\x3e结构，那\x3ccode\x3ehashmap\x3c\/code\x3e是怎样的一个结构呢？且听小茄细细道来。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eHash Map\x3c\/h2\x3e\n\x3cp\x3e在真实世界中，我们描述一个事物最常用的方式是使用\x3ccode\x3e属性\x3c\/code\x3e-\x3ccode\x3e值\x3c\/code\x3e（\x3ccode\x3ekey\x3c\/code\x3e-\x3ccode\x3evalue\x3c\/code\x3e）这样的键值对数据，面向对象编程中对象的定义和js中的对象都是这种模式。比如我们描述一个人是这样的：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGp74?w=262\x26amp;h=342\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGp74?w=262\x26amp;h=342\x22 alt=\x22一个对象\x22 title=\x22一个对象\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e那在计算机中怎么保存这样的数据呢？\x3c\/h4\x3e\n\x3cp\x3e计算机存储空间有两个属性：\x3ccode\x3e存储地址\x3c\/code\x3e和所存储的\x3ccode\x3e值\x3c\/code\x3e，机器可以根据给定的\x3ccode\x3e存储地址\x3c\/code\x3e去读写该地址下的\x3ccode\x3e值\x3c\/code\x3e。根据这种结构，假如我们将一块存储空间分成一个一个的格子，然后将这些数据依次塞到每个格子里，接下来我们就可以根据格子编号直接访问格子的内容了。这种方式就是数组（也叫线性连续表）：数组头保存整个数组储存空间的起始地址，不同下标代表不同的储存地址的偏移量，访问不同下标所对应的地址就能实现数组元素的读写。所以，很自然就会想到将上述的键值对数据的\x3ccode\x3ekey\x3c\/code\x3e映射成数组下标，接着读写数组就变成了读写\x3ccode\x3evalue\x3c\/code\x3e值。将\x3ccode\x3ekey\x3c\/code\x3e的字符串转换成代表下标数值比较简单，可以用特定的码表（如ASCII）进行转换。\x3c\/p\x3e\n\x3cp\x3e上述小明的属性名（\x3ccode\x3ekey\x3c\/code\x3e）经过变换，可能就变成了这样：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGqaW?w=630\x26amp;h=402\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGqaW?w=630\x26amp;h=402\x22 alt=\x22属性名转换\x22 title=\x22属性名转换\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e由于key的值不同长度不一，所以转换后的下标的值也相差巨大，另外\x3ccode\x3ekey\x3c\/code\x3e的个数不确定，也就意味着下标的个数也有很大的范围，甚至无穷多，就有了下面的问题：\x3c\/p\x3e\n\x3ch4\x3e怎么将一组值相差范围巨大，个数波动范围很大的下标放入特定的数组空间呢？\x3c\/h4\x3e\n\x3cp\x3e如果我们直接取下标值作为存储数组的下标，虽然简单，但是你会发现这个长度为10010的数组只存了8个值，太浪费！如果我们想要缩短数组的长度，比如缩为10，最简单的方式可以使用取模的方式来确定下标：\x3ccode\x3e69 % 10 = 9，7 % 10 = 7, 198 % 10 = 8……\x3c\/code\x3e。这个取模就是\x3ccode\x3e哈希算法\x3c\/code\x3e、也叫\x3ccode\x3e散列算法\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e通过这样的方式得到的下标分别为\x3ccode\x3e9、7、8、3、6、2、0\x3c\/code\x3e，可以得到保存小明数据的数组：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGqbI?w=586\x26amp;h=147\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGqbI?w=586\x26amp;h=147\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e但是这种方式很容易出现重复，假如我们增加一个属性\x3ccode\x3ephone\x3c\/code\x3e，对应的映射值是29，那么29跟69算出来的下标就重复了。也就是哈希算法中的\x3ccode\x3e冲突\x3c\/code\x3e，也叫\x3ccode\x3e碰撞\x3c\/code\x3e。好的哈希算法能极大减少\x3ccode\x3e冲突\x3c\/code\x3e，但由于输入几乎是无穷的，而输出却要求在有限的空间内，所以\x3ccode\x3e冲突\x3c\/code\x3e是不可避免的。\x3c\/p\x3e\n\x3ch4\x3e那如何处理冲突呢？\x3c\/h4\x3e\n\x3cp\x3e还是上面这个例子，29和69发生了冲突，但是我们可以将他们组成一个链表，链表的头部放在数组中，得到。链表结构中，每个元素（除单向链表的尾部）都包含了相连元素的内存地址和本身的值，上文中的冲突放入一个链表中，可以得到这样的结构：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVGqdH?w=737\x26amp;h=469\x22 src=\x22https:\/\/static.alili.tech\/img\/bVGqdH?w=737\x26amp;h=469\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e最终得到的这个数据结构，也就是我们常说\x3ccode\x3e哈希表\x3c\/code\x3e了。这种将数组与链表结合生成哈希表的方法，叫\x3ccode\x3e拉链法\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch4\x3e哈希表数据的查找\x3c\/h4\x3e\n\x3cp\x3e比如想知道小明的\x3ccode\x3ename\x3c\/code\x3e属性，即\x3ccode\x3e小明.name\x3c\/code\x3e。流程是这样的：\x3c\/p\x3e\n\x3cp\x3e1）根据字符映射关系得到映射值为69\x3cbr\x3e2）使用哈希算法得到下标 index=hash(69)=9\x3cbr\x3e3）遍历数组中下标为9的链表，链表的第一个元素的\x3ccode\x3ekey\x3c\/code\x3e刚好就是我们要找的\x3ccode\x3ename\x3c\/code\x3e，所以返回\x3ccode\x3evalue\x3c\/code\x3e值\x3ccode\x3e小明\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e哈希表中增删一个元素并不会影响到其他的元素，不像数组一样需要改变后面所有的元素下标。在拉链式的哈希表中，属性的增删就是链表的增删，非常方便。而在纯数组形式的哈希表中，对属性的删并不是真的删除，而是做一个空标志而已，所以不影响其他元素。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eHash Map的扩展知识\x3c\/h2\x3e\n\x3cp\x3e对于哈希表来说，最重要的莫过于生成哈希串的哈希算法和处理冲突的策略了。下面进行简单的介绍。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e哈希算法（散列算法）\x3c\/h3\x3e\n\x3cp\x3e根据上面的例子得知，哈希算法的目的就是将不定的输入转换成特定范围的输出，并且要求输出尽量均匀分布。由于散列算法是应用在每一次数据定位中的，它的使用频率非常的高，这意味着我们必须要选择简单的算法。散列算法有很多，这里简单介绍几种。\x3c\/p\x3e\n\x3cp\x3e1，除法散列法\x3cbr\x3e最直观的一种，小茄上文使用的就是这种散列法，公式：\x3cbr\x3eindex = key % 16\x3c\/p\x3e\n\x3cp\x3e2，平方散列法\x3cbr\x3e求\x3ccode\x3eindex\x3c\/code\x3e是非常频繁的操作，而乘法的运算要比除法来得省时（对现在的CPU来说，估计我们感觉不出来），所以我们考虑把除法换成乘法和一个位移操作。公式：\x3cbr\x3eindex = (key * key) \x26gt;\x26gt; 28\x3cbr\x3e如果数值分配比较均匀的话这种方法能得到不错的结果，另外\x3ccode\x3ekey\x3c\/code\x3e如果很大，\x3ccode\x3ekey\x3c\/code\x3e * \x3ccode\x3ekey\x3c\/code\x3e会发生溢出。但我们这个乘法不关心溢出，因为我们根本不是为了获取相乘结果，而是为了获取\x3ccode\x3eindex\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e3，斐波那契（Fibonacci）散列法\x3cbr\x3e平方散列法的缺点是显而易见的，所以我们能不能找出一个理想的乘数，而不是拿value本身当作乘数呢？答案是肯定的。\x3c\/p\x3e\n\x3cp\x3e1，对于16位整数而言，这个乘数是40503\x3cbr\x3e2，对于32位整数而言，这个乘数是2654435769\x3cbr\x3e3，对于64位整数而言，这个乘数是11400714819323198485\x3c\/p\x3e\n\x3cp\x3e这几个“理想乘数”是如何得出来的呢？这跟一个法则有关，叫黄金分割法则，而描述黄金分割法则的最经典表达式无疑就是著名的斐波那契数列，即如此形式的序列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,233, 377, 610， 987, 1597, 2584, 4181, 6765, 10946，…。\x3c\/p\x3e\n\x3cp\x3e对我们常见的32位整数而言，公式：\x3cbr\x3eindex = (key* 2654435769) \x26gt;\x26gt; 28\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e处理冲突的策略\x3c\/h3\x3e\n\x3cp\x3e上文介绍了拉链法来处理冲突，处理冲突的方法其实也有很多，下面简单介绍一下另外几种：\x3c\/p\x3e\n\x3cp\x3e1）拉链法变种。由于链表的查找需要遍历，如果我们将链表换成树或者哈希表结构，那么就能大幅提高冲突元素的查找效率。不过这样做则会加大哈希表构造的复杂度，也就是构建哈希表时的效率会变差。\x3c\/p\x3e\n\x3cp\x3e2）开放寻址： 当关键字\x3ccode\x3ekey\x3c\/code\x3e的哈希地址\x3ccode\x3ep=H（key）\x3c\/code\x3e出现冲突时，以\x3ccode\x3ep\x3c\/code\x3e为基础，产生另一个哈希地址\x3ccode\x3ep1\x3c\/code\x3e，如果\x3ccode\x3ep1\x3c\/code\x3e仍然冲突，再以\x3ccode\x3ep\x3c\/code\x3e为基础，产生另一个哈希地址\x3ccode\x3ep2\x3c\/code\x3e，…，直到找出一个不冲突的哈希地址\x3ccode\x3epi\x3c\/code\x3e，将相应元素存入其中。这种方法有一个通用的函数形式：\x3c\/p\x3e\n\x3cp\x3eHi=（H（key）\x2bdi）% m   i=1，2，…，n\x3c\/p\x3e\n\x3cp\x3e根据\x3ccode\x3edi\x3c\/code\x3e的不同，又可以分为线性的、平方的、随机数之类的。。。这里不再展开。\x3c\/p\x3e\n\x3cp\x3e开发寻址的好处是存储空间更加紧凑，利用率高。但是这种方式让冲突元素之间产生了联系，在删除元素的时候，不能直接删除，否则就打乱了冲突元素的寻址链。\x3c\/p\x3e\n\x3cp\x3e3）再哈希法\x3c\/p\x3e\n\x3cp\x3e这种方法会预先定义一组哈希算法，发生冲突的时候，调用下一个哈希算法计算一直计算到不发生冲突的时候则插入元素，这种方法跟开放寻址的方法优缺点类似。函数表达式：\x3c\/p\x3e\n\x3cp\x3eindex=Hi（key）  ,  i=1，2，…，n\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e哈希相关的应用实践\x3c\/h3\x3e\n\x3cp\x3e哈希算法常用的场景除了上文所说的快速查找之外，还有一个非常重要的应用就是加密算法，这个加密更准确的说法是加签，也即是“消息摘要”。\x3c\/p\x3e\n\x3cp\x3e根据上文的基础介绍可知，哈希算法就是将任意数据转换成一定范围数据的算法，这种算法的副作用就是会产生冲突。但是呢，在快速查找中出现的副作用，却是加密功能中的核心，因为有冲突，所以从结果就无法逆推出输入值，这样就实现了数据的单向加密。而输入数据的变化却又会影响到哈希串的值，所以我们可以用哈希串来进行数据的校验。\x3c\/p\x3e\n\x3cp\x3e关于js对象与哈希相关的东西就说到这里了，用文字总结一下之后发现很多知识点都明确了很多，尤其是要用最平白的语言组织出来，就必须有自己的理解才行。任何一个细节都可以看出很多东西，谨以此文与君共勉！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>唠叨一下js对象与哈希表那些事</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007692754">https://segmentfault.com/a/1190000007692754</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/pmkr8f26r6/" target="_blank">https://alili.tech/archive/pmkr8f26r6/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>