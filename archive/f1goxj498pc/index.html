<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript中this绑定详解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript中this绑定详解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/f1goxj498pc/",
				"appid": "1613049289050283", 
				"title": "JavaScript中this绑定详解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-02T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fpk9tyls8sb/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/d31ygsiurr7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f&text=JavaScript%e4%b8%adthis%e7%bb%91%e5%ae%9a%e8%af%a6%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f&text=JavaScript%e4%b8%adthis%e7%bb%91%e5%ae%9a%e8%af%a6%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f&title=JavaScript%e4%b8%adthis%e7%bb%91%e5%ae%9a%e8%af%a6%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f&is_video=false&description=JavaScript%e4%b8%adthis%e7%bb%91%e5%ae%9a%e8%af%a6%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%e4%b8%adthis%e7%bb%91%e5%ae%9a%e8%af%a6%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f&title=JavaScript%e4%b8%adthis%e7%bb%91%e5%ae%9a%e8%af%a6%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f&title=JavaScript%e4%b8%adthis%e7%bb%91%e5%ae%9a%e8%af%a6%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f&title=JavaScript%e4%b8%adthis%e7%bb%91%e5%ae%9a%e8%af%a6%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2ff1goxj498pc%2f&title=JavaScript%e4%b8%adthis%e7%bb%91%e5%ae%9a%e8%af%a6%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript中this绑定详解</h1><div class="meta"><div class="postdate"><time datetime="2019-02-02" itemprop="datePublished">2019-02-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e转载请注明出处 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007101339\x22\x3ehttps:\/\/segmentfault.com\/a\/11...\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3ccode\x3ethis\x3c\/code\x3e 可以说是 javascript 中最耐人寻味的一个特性，就像高中英语里各种时态，比如被动时态，过去时，现在时，过去进行时一样，无论弄错过多少次，下一次依然可能弄错。本文启发于《你不知道的JavaScript上卷》,对 javasript 中的 \x3ccode\x3ethis\x3c\/code\x3e 进行一个总结。\x3c\/p\x3e\n\x3cp\x3e学习 \x3ccode\x3ethis\x3c\/code\x3e 的第一步就是明白 \x3ccode\x3ethis\x3c\/code\x3e 既不是指向函数自身也不指向函数的作用域。\x3ccode\x3ethis\x3c\/code\x3e 实际上是在函数被调用时发生的绑定，它指向什么地方完全取决于函数在哪里被调用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e默认绑定\x3c\/h3\x3e\n\x3cp\x3e在 javascript 中 ，最常用的函数调用类型就是\x3cstrong\x3e独立函数调用\x3c\/strong\x3e，因此可以把这条规则看作是无法应用其他规则时的默认规则。如果在调用函数的时候，函数不带任何修饰，也就是“光秃秃”的调用，那就会应用\x3cstrong\x3e默认绑定规则\x3c\/strong\x3e, 默认绑定的指向的是全局作用域。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function sayLocation() {\n    console.log(this.atWhere)\n}\n\nvar atWhere = \x26quot;I am in global\x26quot;\n\nsayLocation() \/\/ 默认绑定，this绑定在全局对象,输出 “I am in global”\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esayLocation\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.atWhere)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e atWhere = \x3cspan class=\x22hljs-string\x22\x3e\x22I am in global\x22\x3c\/span\x3e\n\nsayLocation() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 默认绑定，this绑定在全局对象,输出 “I am in global”\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再看一个例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var name = \x26quot;global\x26quot;\nfunction person() {\n    console.log(this.name) \/\/  (1) \x26quot;global\x26quot;\n      person.name = \x27inside\x27\n    function sayName() {\n        console.log(this.name) \/\/ (2) \x26quot;global\x26quot;  不是 \x26quot;inside\x26quot;\n    }\n    sayName() \/\/ 在person函数内部执行sayName函数,this指向的同样是全局的对象\n}\nperson()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = \x3cspan class=\x22hljs-string\x22\x3e\x22global\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eperson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name) \x3cspan class=\x22hljs-comment\x22\x3e\/\/  (1) \x22global\x22\x3c\/span\x3e\n      person.name = \x3cspan class=\x22hljs-string\x22\x3e\x27inside\x27\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esayName\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ (2) \x22global\x22  不是 \x22inside\x22\x3c\/span\x3e\n    }\n    sayName() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在person函数内部执行sayName函数,this指向的同样是全局的对象\x3c\/span\x3e\n}\nperson()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个例子中，\x3ccode\x3eperson\x3c\/code\x3e 函数在全局作用域中被调用，因此第(1)句中的 \x3ccode\x3ethis\x3c\/code\x3e 就绑定在了全局对象上（在浏览器中是是\x3ccode\x3ewindow\x3c\/code\x3e，在node中就是\x3ccode\x3eglobal\x3c\/code\x3e）,因此第(1)句自然输出的是一个全局对象的 \x3ccode\x3ename\x3c\/code\x3e 属性，当然就是\x3ccode\x3e\x22global\x22\x3c\/code\x3e了。\x3ccode\x3esayName\x3c\/code\x3e函数在person函数内调用，即使这样第(2)句中的\x3ccode\x3ethis\x3c\/code\x3e指代的仍然是全局对象，即使 \x3ccode\x3eperson\x3c\/code\x3e 函数设置了 name 属性。\x3c\/p\x3e\n\x3cp\x3e这就是\x3cstrong\x3e默认绑定规则\x3c\/strong\x3e,它是 javascript 中最常见的一种函数调用模式，\x3ccode\x3ethis\x3c\/code\x3e 的绑定规则也是四种绑定规则中最简单的一种，就是\x3cstrong\x3e绑定在全局作用域上\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch4\x3e默认绑定里的严格模式\x3c\/h4\x3e\n\x3cp\x3e在 javascript 中，如果使用了严格模式，则 \x3ccode\x3ethis\x3c\/code\x3e 不能绑定到全局对象。还是以第一个例子，只不过这次加上了严格模式声明\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x27use strict\x27\nfunction sayLocation() {\n    console.log(this.atWhere)\n}\nvar atWhere = \x26quot;I am in global\x26quot;\nsayLocation()\n\/\/ Uncaught TypeError: Cannot read property \x27atWhere\x27 of undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x27use strict\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esayLocation\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.atWhere)\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e atWhere = \x3cspan class=\x22hljs-string\x22\x3e\x22I am in global\x22\x3c\/span\x3e\nsayLocation()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Uncaught TypeError: Cannot read property \x27atWhere\x27 of undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看出，在严格模式下，把 \x3ccode\x3ethis\x3c\/code\x3e 绑定到全局对象上时，实际上绑定的是 \x3ccode\x3eundefined\x3c\/code\x3e ,因此上面这段代码会报错。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e隐式绑定\x3c\/h3\x3e\n\x3cp\x3e当函数在调用时，如果函数有所谓的“落脚点”,即有上下文对象时，隐式绑定规则会把函数中的 \x3ccode\x3ethis\x3c\/code\x3e 绑定到这个上下文对象。如果觉得上面这段话不够直白的话，还是来看代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function say() {\n    console.log(this.name)\n}\nvar obj1 = {\n    name: \x26quot;zxt\x26quot;,\n    say: say\n}\n\nvar obj2 = {\n    name: \x26quot;zxt1\x26quot;,\n    say: say\n}\nobj1.say() \/\/ zxt\nobj2.say() \/\/ zxt1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esay\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name)\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22zxt\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: say\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22zxt1\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: say\n}\nobj1.say() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ zxt\x3c\/span\x3e\nobj2.say() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ zxt1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很简单是不是。在上面这段代码中，\x3ccode\x3eobj1\x3c\/code\x3e , \x3ccode\x3eobj2\x3c\/code\x3e 就是所谓的 \x3ccode\x3esay\x3c\/code\x3e 函数的落脚点，专业一点的说法就是上下文对象，当给函数指定了这个上下文对象时，函数内部的\x3ccode\x3ethis\x3c\/code\x3e 自然指向了这个上下文对象。这也是很常见的一种函数调用模式。\x3c\/p\x3e\n\x3ch4\x3e隐式绑定时丢失上下文\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function say() {\n    console.log(this.name)\n}\nvar name = \x26quot;global\x26quot;\nvar obj = {\n    name: \x26quot;inside\x26quot;,\n    say: say\n}\nvar alias = obj.say \/\/ 设置一个简写   (1) \nalias() \/\/ 函数调用 输出\x26quot;global\x26quot;  (2)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esay\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name)\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = \x3cspan class=\x22hljs-string\x22\x3e\x22global\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22inside\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3esay\x3c\/span\x3e: say\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e alias = obj.say \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置一个简写   (1) \x3c\/span\x3e\nalias() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 函数调用 输出\x22global\x22  (2)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到这里输出的是 \x3ccode\x3e”global“\x3c\/code\x3e ，为什么就和上例中不一样，我们明明只是给 \x3ccode\x3eobj.say\x3c\/code\x3e 换了个名字而已？\x3cbr\x3e首先我们来看上面第(1)句代码，由于在 javascript 中，函数是对象，对象之间是引用传递，而不是值传递。因此，第(1)句代码只是 \x3ccode\x3ealias = obj.say = say\x3c\/code\x3e ，也就是 \x3ccode\x3ealias = say\x3c\/code\x3e ，\x3ccode\x3eobj.say\x3c\/code\x3e 只是起了一个桥梁的作用，\x3ccode\x3ealias\x3c\/code\x3e 最终引用的是 \x3ccode\x3esay\x3c\/code\x3e 函数的地址，而与 obj 这个对象无关了。这就是所谓的”丢失上下文“。最终执行 \x3ccode\x3ealias\x3c\/code\x3e 函数，只不过简单的执行了\x3ccode\x3esay\x3c\/code\x3e函数，输出\x3ccode\x3e\x22global\x22\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e显式绑定\x3c\/h3\x3e\n\x3cp\x3e显式绑定，顾名思义，显示地将this绑定到一个上下文，javascript中，提供了三种显式绑定的方法，\x3ccode\x3eapply\x3c\/code\x3e,\x3ccode\x3ecall\x3c\/code\x3e,\x3ccode\x3ebind\x3c\/code\x3e。\x3ccode\x3eapply\x3c\/code\x3e和\x3ccode\x3ecall\x3c\/code\x3e的用法基本相似，它们之间的区别是：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3eapply(obj,[arg1,arg2,arg3,...]\x3c\/code\x3e 被调用函数的参数以数组的形式给出  \x3cbr\x3e\x3ccode\x3ecall(obj,arg1,arg2,arg3,...)\x3c\/code\x3e 被调用函数的参数依次给出\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e而\x3ccode\x3ebind\x3c\/code\x3e函数执行后，返回的是一个新函数。下面以代码说明。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 不带参数\nfunction speak() {\n    console.log(this.name)\n}\n\nvar name = \x26quot;global\x26quot;\nvar obj1 = {\n    name: \x27obj1\x27\n}\nvar obj2 = {\n    name: \x27obj2\x27\n}\n\nspeak() \/\/ global 等价于speak.call(window)\nspeak.call(window)\n\nspeak.call(obj1) \/\/ obj1\nspeak.call(obj2) \/\/ obj2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不带参数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3espeak\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = \x3cspan class=\x22hljs-string\x22\x3e\x22global\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27obj1\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27obj2\x27\x3c\/span\x3e\n}\n\nspeak() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ global 等价于speak.call(window)\x3c\/span\x3e\nspeak.call(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e)\n\nspeak.call(obj1) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ obj1\x3c\/span\x3e\nspeak.call(obj2) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ obj2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此可以看出，\x3ccode\x3eapply\x3c\/code\x3e, \x3ccode\x3ecall\x3c\/code\x3e 的作用就是给函数绑定一个执行上下文，且是显式绑定的。因此，函数内的this自然而然的绑定在了 \x3ccode\x3ecall\x3c\/code\x3e 或者 \x3ccode\x3eapply\x3c\/code\x3e 所调用的对象上面。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 带参数\nfunction count(num1, num2) {\n    console.log(this.a * num1 \x2b num2)\n}\n\nvar obj1 = {\n    a: 2\n}\nvar obj2 = {\n    a: 3\n}\n\ncount.call(obj1, 1, 2) \/\/ 4\ncount.apply(obj1, [1, 2]) \/\/ 4\n\ncount.call(obj2, 1, 2) \/\/ 5\ncount.apply(obj2, [1, 2]) \/\/ 5\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 带参数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecount\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enum1, num2\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a * num1 \x2b num2)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n}\n\ncount.call(obj1, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\ncount.apply(obj1, [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\n\ncount.call(obj2, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5\x3c\/span\x3e\ncount.apply(obj2, [\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这个例子则说明了 \x3ccode\x3eapply\x3c\/code\x3e 和 \x3ccode\x3ecall\x3c\/code\x3e 用法上的差异。  \x3cbr\x3e而 \x3ccode\x3ebind\x3c\/code\x3e 函数，则返回一个绑定了指定的执行上下文的新函数。还是以上面这段代码为例\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 带参数\nfunction count(num1, num2) {\n    console.log(this.a * num1 \x2b num2)\n}\n\nvar obj1 = {\n    a: 2\n}\n\nvar bound1 = count.bind(obj1) \/\/ 未指定参数\nbound1(1, 2) \/\/ 4\n\nvar bound2 = count.bind(obj1, 1) \/\/ 指定了一个参数\nbound2(2) \/\/ 4 \n\nvar bound3 = count.bind(obj1, 1, 2) \/\/ 指定了两个参数\nbound3() \/\/4\n\nvar bound4 = count.bind(obj1, 1, 2, 3) \/\/ 指定了多余的参数,多余的参数会被忽略\nbound4() \/\/ 4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 带参数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecount\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enum1, num2\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a * num1 \x2b num2)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bound1 = count.bind(obj1) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 未指定参数\x3c\/span\x3e\nbound1(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bound2 = count.bind(obj1, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定了一个参数\x3c\/span\x3e\nbound2(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4 \x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bound3 = count.bind(obj1, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定了两个参数\x3c\/span\x3e\nbound3() \x3cspan class=\x22hljs-comment\x22\x3e\/\/4\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bound4 = count.bind(obj1, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 指定了多余的参数,多余的参数会被忽略\x3c\/span\x3e\nbound4() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 4\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以，\x3ccode\x3ebind\x3c\/code\x3e 方法只是返回了一个新的函数，这个函数内的this指定了执行上下文，而返回这个新函数可以接受参数。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3enew 绑定\x3c\/h3\x3e\n\x3cp\x3e最后要讲的一种 \x3ccode\x3ethis\x3c\/code\x3e 绑定规则，是指通过 \x3ccode\x3enew\x3c\/code\x3e 操作符调用构造函数时发生的 \x3ccode\x3ethis\x3c\/code\x3e 绑定。首先要明确一点的是，在 javascript 中并没有其他语言那样的类的概念。构造函数也仅仅是普通的函数而已，只不过构造函数的函数名以大写字母开头，也只不过它可以通过 \x3ccode\x3enew\x3c\/code\x3e 操作符调用而已.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person(name,age) {\n    this.name = name\n    this.age = age\n    console.log(\x26quot;我也只不过是个普通函数\x26quot;)\n}\nPerson(\x26quot;zxt\x26quot;,22) \/\/ \x26quot;我也只不过是个普通函数\x26quot;\nconsole.log(name) \/\/ \x26quot;zxt\x26quot;\nconsole.log(age) \/\/ 22\n\nvar zxt = new Person(\x26quot;zxt\x26quot;,22) \/\/ \x26quot;我也只不过是个普通函数\x26quot;\nconsole.log(zxt.name) \/\/ \x26quot;zxt\x26quot;\nconsole.log(zxt.age) \/\/ 22\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,age\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22我也只不过是个普通函数\x22\x3c\/span\x3e)\n}\nPerson(\x3cspan class=\x22hljs-string\x22\x3e\x22zxt\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22我也只不过是个普通函数\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(name) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22zxt\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(age) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 22\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e zxt = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22zxt\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22我也只不过是个普通函数\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(zxt.name) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22zxt\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(zxt.age) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这个例子中，首先定义了一个 \x3ccode\x3ePerson\x3c\/code\x3e 函数，既可以普通调用，也可以以构造函数的形式的调用。当普通调用时，则按照正常的函数执行，输出一个字符串。 如果是通过一个\x3ccode\x3enew\x3c\/code\x3e操作符,则构造了一个新的对象。那么，接下来我们再看看两种调用方式， \x3ccode\x3ethis\x3c\/code\x3e 分别绑定在了何处首先普通调用时，前面已经介绍过，此时应用默认绑定规则，\x3ccode\x3ethis\x3c\/code\x3e绑定在了全局对象上，此时全局对象上会分别增加 \x3ccode\x3ename\x3c\/code\x3e 和 \x3ccode\x3eage\x3c\/code\x3e 两个属性。当通过\x3ccode\x3enew\x3c\/code\x3e操作符调用时，函数会返回一个对象，从输出结果上来看 \x3ccode\x3ethis\x3c\/code\x3e 对象绑定在了这个返回的对象上。  \x3cbr\x3e因此，所谓的\x3ccode\x3enew\x3c\/code\x3e绑定是指通过\x3ccode\x3enew\x3c\/code\x3e操作符来调用函数时，会产生一个新对象，并且会把构造函数内的\x3ccode\x3ethis\x3c\/code\x3e绑定到这个对象上。  \x3cbr\x3e事实上，在\x3ccode\x3ejavascript\x3c\/code\x3e中，使用\x3ccode\x3enew\x3c\/code\x3e来调用函数，会自动执行下面的操作。\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e创建一个全新的对象\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e这个新对象会被执行原型连接\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e这个新对象会绑定到函数调用的\x3ccode\x3ethis\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果函数没有返回其他对象，那么\x3ccode\x3enew\x3c\/code\x3e表达式中的函数调用会自动返回这个新对象\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e四种绑定的优先级\x3c\/h3\x3e\n\x3cp\x3e上面讲述了\x3ccode\x3ejavascript\x3c\/code\x3e中四种\x3ccode\x3ethis\x3c\/code\x3e绑定规则，这四种绑定规则基本上涵盖了所有函数调用情况。但是如果同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四种绑定的优先级顺序又是怎么样的。  \x3cbr\x3e首先，很容易理解，\x3cstrong\x3e默认绑定的优先级是最低的\x3c\/strong\x3e。这是因为只有在无法应用其他\x3ccode\x3ethis\x3c\/code\x3e绑定规则的情况下，才会调用默认绑定。那隐式绑定和显式绑定呢？还是上代码吧，代码可从来不会说谎。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function speak() {\n    console.log(this.name)\n}\n\nvar obj1 = {\n    name: \x27obj1\x27,\n    speak: speak\n}\nvar obj2 = {\n    name: \x27obj2\x27\n}\n\nobj1.speak() \/\/ obj1 (1)\nobj1.speak.call(obj2) \/\/ obj2 (2)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3espeak\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name)\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27obj1\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3espeak\x3c\/span\x3e: speak\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj2 = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27obj2\x27\x3c\/span\x3e\n}\n\nobj1.speak() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ obj1 (1)\x3c\/span\x3e\nobj1.speak.call(obj2) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ obj2 (2)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以在上面代码中，执行了\x3ccode\x3eobj1.speak()\x3c\/code\x3e,\x3ccode\x3espeak\x3c\/code\x3e函数内部的\x3ccode\x3ethis\x3c\/code\x3e指向了\x3ccode\x3eobj1\x3c\/code\x3e，因此(1)处代码输出的当然就是\x3ccode\x3eobj1\x3c\/code\x3e，但是当显式绑定了\x3ccode\x3espeak\x3c\/code\x3e函数内的\x3ccode\x3ethis\x3c\/code\x3e到\x3ccode\x3eobj2\x3c\/code\x3e上，输出结果就变成了\x3ccode\x3eobj2\x3c\/code\x3e，所有从这个结果可以看出\x3cstrong\x3e显式绑定\x3c\/strong\x3e的优先级是要高于\x3cstrong\x3e隐式绑定\x3c\/strong\x3e的。事实上我们可以这么理解\x3ccode\x3eobj1.speak.call(obj2)\x3c\/code\x3e这行代码，\x3ccode\x3eobj1.speak\x3c\/code\x3e只是间接获得了\x3ccode\x3espeak\x3c\/code\x3e函数的引用，这就有点像前面所说的\x3cstrong\x3e隐式绑定丢失了上下文\x3c\/strong\x3e。好，既然\x3cstrong\x3e显式绑定\x3c\/strong\x3e的优先级要高于\x3cstrong\x3e隐式绑定\x3c\/strong\x3e，那么接下来再来比较一下new 绑定和显式绑定。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(something) {\n    this.a = something\n}\n\nvar obj1 = {}\nvar bar = foo.bind(obj1)  \/\/ 返回一个新函数bar，这个新函数内的this指向了obj1  (1)\nbar(2) \/\/ this绑定在了Obj1上，所以obj1.a === 2\nconsole.log(obj1.a)\n\nvar baz = new bar(3)  \/\/ 调用new 操作符后，bar函数的this指向了返回的新实例baz  (2)\n\nconsole.log(obj1.a)\nconsole.log(baz.a) \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3esomething\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = something\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj1 = {}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = foo.bind(obj1)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回一个新函数bar，这个新函数内的this指向了obj1  (1)\x3c\/span\x3e\nbar(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this绑定在了Obj1上，所以obj1.a === 2\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj1.a)\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e baz = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e bar(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用new 操作符后，bar函数的this指向了返回的新实例baz  (2)\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(obj1.a)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(baz.a) \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以看到，在(1)处，\x3ccode\x3ebar\x3c\/code\x3e函数内部的\x3ccode\x3ethis\x3c\/code\x3e原本指向的是\x3ccode\x3eobj1\x3c\/code\x3e，但是在(2)处，由于经过了\x3ccode\x3enew\x3c\/code\x3e操作符调用，\x3ccode\x3ebar\x3c\/code\x3e函数内部的\x3ccode\x3ethis\x3c\/code\x3e却重新指向了返回的实例，这就可以说明\x3cstrong\x3enew 绑定\x3c\/strong\x3e的优先级是要高于\x3cstrong\x3e显式绑定\x3c\/strong\x3e的。  \x3cbr\x3e至此，四种绑定规则的优先级排序就已经得出了,分别是\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3enew 绑定 \x26gt; 显式绑定 \x26gt; 隐式绑定 \x26gt; 默认绑定\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e箭头函数中的this绑定\x3c\/h3\x3e\n\x3cp\x3e箭头函数是ES6里一个重要的特性。\x3cbr\x3e箭头函数的\x3ccode\x3ethis\x3c\/code\x3e是根据外层的（函数或者全局）作用域来决定的。函数体内的\x3ccode\x3ethis\x3c\/code\x3e对象指的是定义时所在的对象，而不是之前介绍的调用时绑定的对象。举一个例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var a = 1\nvar foo = () =\x3e {\n    console.log(this.a) \/\/ 定义在全局对象中，因此this绑定在全局作用域\n}\n\nvar obj = {\n    a: 2\n}\nfoo() \/\/ 1 ,在全局对象中调用\nfoo.call(obj) \/\/ 1,显示绑定，由obj对象来调用，但根本不影响结果\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义在全局对象中，因此this绑定在全局作用域\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n}\nfoo() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1 ,在全局对象中调用\x3c\/span\x3e\nfoo.call(obj) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1,显示绑定，由obj对象来调用，但根本不影响结果\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上面这个例子看出，箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如\x3ccode\x3eapply\x3c\/code\x3e,\x3ccode\x3ecall\x3c\/code\x3e方法来修改。在来看下面这个例子\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 定义一个构造函数\nfunction Person(name,age) {\n    this.name = name\n    this.age = age \n    this.speak = function (){\n        console.log(this.name)\n        \/\/ 普通函数（非箭头函数),this绑定在调用时的作用域\n    }\n    this.bornYear = () =\x3e {\n        \/\/ 本文写于2016年，因此new Date().getFullYear()得到的是2016\n        \/\/ 箭头函数，this绑定在实例内部\n        console.log(new Date().getFullYear() - this.age)\n        }\n    }\n}\n\nvar zxt = new Person(\x26quot;zxt\x26quot;,22)\n\nzxt.speak() \/\/ \x26quot;zxt\x26quot;\nzxt.bornYear() \/\/ 1994\n\n\/\/ 到这里应该大家应该都没什么问题\n\nvar xiaoMing = {\n    name: \x26quot;xiaoming\x26quot;,\n    age: 18  \/\/ 小明永远18岁\n}\n\nzxt.speak.call(xiaoMing)\n\/\/ \x26quot;xiaoming\x26quot; this绑定的是xiaoMing这个对象\nzxt.bornYear.call(xiaoMing)\n\/\/ 1994 而不是 1998,这是因为this永远绑定的是zxt这个实例\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义一个构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename,age\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age = age \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.speak = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name)\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 普通函数（非箭头函数),this绑定在调用时的作用域\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.bornYear = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 本文写于2016年，因此new Date().getFullYear()得到的是2016\x3c\/span\x3e\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 箭头函数，this绑定在实例内部\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e().getFullYear() - \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.age)\n        }\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e zxt = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x22zxt\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e22\x3c\/span\x3e)\n\nzxt.speak() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22zxt\x22\x3c\/span\x3e\nzxt.bornYear() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1994\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 到这里应该大家应该都没什么问题\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xiaoMing = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22xiaoming\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e18\x3c\/span\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 小明永远18岁\x3c\/span\x3e\n}\n\nzxt.speak.call(xiaoMing)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22xiaoming\x22 this绑定的是xiaoMing这个对象\x3c\/span\x3e\nzxt.bornYear.call(xiaoMing)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1994 而不是 1998,这是因为this永远绑定的是zxt这个实例\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此 ES6 的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 \x3ccode\x3ethis\x3c\/code\x3e ，具体来说就是，箭头函数会继承 \x3cem\x3e外层函数调用的this绑定\x3c\/em\x3e ，而无论外层函数的\x3ccode\x3ethis\x3c\/code\x3e绑定到哪里。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e小结\x3c\/h3\x3e\n\x3cp\x3e以上就是\x3ccode\x3ejavascript\x3c\/code\x3e中所有\x3ccode\x3ethis\x3c\/code\x3e绑定的情况，在es6之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6标准实施以后，对于函数的扩展新增了箭头函数，与之前不同的是，\x3cstrong\x3e箭头函数的作用域位于箭头函数定义时所在的作用域\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e而对于之前的四种绑定规则来说，掌握每种规则的调用条件就能很好的理解\x3ccode\x3ethis\x3c\/code\x3e到底是绑定在了哪个作用域。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e全文完\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript中this绑定详解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007101339">https://segmentfault.com/a/1190000007101339</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/f1goxj498pc/" target="_blank">https://alili.tech/archive/f1goxj498pc/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/dc9tmbt89lc/">CSS3 巧妙实现聊天气泡<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/awfhylei7vr/">Element 一套优雅的 Vue 2 组件库是如何开发的<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/5n6e7oj31zb/">Ionic2入坑基础教程和安装指南<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/k9uktrr2ck/">JavaScript arguments 对象全面介绍<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/d31ygsiurr7/">JavaScript 版俄罗斯方块——重构<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/fpk9tyls8sb/">Markcook2.0，使用Vue2.0和Vuex2.0进行完全重构升级<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/rnj4z8l02t/">N3-components - 强劲的 Vue UI组件库<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/7njdijhy2um/">Node.js &#43; React Native 毕设：农业物联网监测系统的开发手记<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/f8zzbybr4tl/">Redux、Flux、Vuex<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/xzp69diczjq/">SegmentFault 技术周刊 Vol.8 - React，“5 分钟快速入门”<aside class="dates">2019-02-02</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>