<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="对react技术栈的一些理解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>对react技术栈的一些理解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/wauj2axq1i/",
				"appid": "1613049289050283", 
				"title": "对react技术栈的一些理解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-25T02:30:24"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/a66ddf878b/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/vj5kbpcbu1/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f&text=%e5%af%b9react%e6%8a%80%e6%9c%af%e6%a0%88%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f&text=%e5%af%b9react%e6%8a%80%e6%9c%af%e6%a0%88%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f&title=%e5%af%b9react%e6%8a%80%e6%9c%af%e6%a0%88%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f&is_video=false&description=%e5%af%b9react%e6%8a%80%e6%9c%af%e6%a0%88%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%af%b9react%e6%8a%80%e6%9c%af%e6%a0%88%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f&title=%e5%af%b9react%e6%8a%80%e6%9c%af%e6%a0%88%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f&title=%e5%af%b9react%e6%8a%80%e6%9c%af%e6%a0%88%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f&title=%e5%af%b9react%e6%8a%80%e6%9c%af%e6%a0%88%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fwauj2axq1i%2f&title=%e5%af%b9react%e6%8a%80%e6%9c%af%e6%a0%88%e7%9a%84%e4%b8%80%e4%ba%9b%e7%90%86%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">对react技术栈的一些理解</h1><div class="meta"><div class="postdate"><time datetime="2019-01-25" itemprop="datePublished">2019-01-25</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e目的\x3c\/h2\x3e\n\x3cp\x3e本篇文章主要帮助大家了解下\x3ccode\x3ereact\x3c\/code\x3e技术栈相关的概念，以及为什么我们需要引入这些，他们能解决什么问题。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eReact\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e为什么选择react，而不是vue2\x3c\/h3\x3e\n\x3ch4\x3evue2的优点\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3evue1\x3c\/code\x3e没有加入虚拟\x3ccode\x3eDOM\x3c\/code\x3e，做服务端渲染很难，所以\x3ccode\x3evue2\x3c\/code\x3e引入了虚拟\x3ccode\x3eDOM\x3c\/code\x3e的机制，而且由于\x3ccode\x3evue2\x3c\/code\x3e的响应式原理，所以天然的就比\x3ccode\x3ereact\x3c\/code\x3e的性能好，\x3ccode\x3ereact\x3c\/code\x3e的更新是通过顶层组件的\x3ccode\x3estate\x3c\/code\x3e变化触发整个组件的重新渲染，而\x3ccode\x3evue2\x3c\/code\x3e由于其是通过\x3ccode\x3egetter\/setter\x3c\/code\x3e来进行数据管理，所以可以准确的定位到需要重新渲染的节点，避免了无效的\x3ccode\x3ere-render\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3evue2的缺点\x3c\/h3\x3e\n\x3cp\x3e\x3cstrong\x3e\x3ccode\x3enative\x3c\/code\x3e端支持不好，\x3ccode\x3eweex\x3c\/code\x3e很厉害但是目前只有阿里用于生产环境，而\x3ccode\x3ereact native\x3c\/code\x3e有着大量的成熟案例，如手机QQ\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e为什么没有选择riot\x3c\/h3\x3e\n\x3ch4\x3eriot的优点\x3c\/h4\x3e\n\x3cp\x3e小，用在移动端很合适\x3c\/p\x3e\n\x3ch4\x3eriot的缺点\x3c\/h4\x3e\n\x3cp\x3e小的缺点很多，但是比较好克服，最大的缺点还是在于\x3ccode\x3enative\x3c\/code\x3e端，如果想用\x3ccode\x3eriot\x3c\/code\x3e实现\x3ccode\x3enative\x3c\/code\x3e端的话，需要造轮子，写就是自己写一套\x3ccode\x3e Native Bridge\x3c\/code\x3e，来进行\x3ccode\x3ejs\x3c\/code\x3e与\x3ccode\x3eObjective C\x3c\/code\x3e通信，难度太大，需要引入\x3ccode\x3ejs引擎\x3c\/code\x3e等高大上的东西（\x3ccode\x3eNative Bridge\x3c\/code\x3e基本上可以理解为一个浏览器内核，而且肯定是\x3ccode\x3eC\x2b\x2b\x3c\/code\x3e写）。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3enative的基本原理\x3c\/h3\x3e\n\x3cp\x3e一个线程为\x3ccode\x3ejs\x3c\/code\x3e引擎，执行打包好的\x3ccode\x3ejs\x3c\/code\x3e，主线程负责\x3ccode\x3eUI\x3c\/code\x3e绘制，\x3ccode\x3ejs\x3c\/code\x3e需要绘制\x3ccode\x3eUI\x3c\/code\x3e时会向主线程发出一个命令，主线程接收到命令后执行相应的绘制逻辑，\x3ccode\x3eObjective C\x3c\/code\x3e执行的结果会经过层层回调通过\x3ccode\x3ejs\x3c\/code\x3e引擎传回给\x3ccode\x3ejs\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eredux\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3ereact \x2b redux的缺点\x3c\/h3\x3e\n\x3cp\x3e利用\x3ccode\x3eredux\x3c\/code\x3e做数据管理的话，\x3ccode\x3eredux\x3c\/code\x3e的\x3ccode\x3estore\x3c\/code\x3e会被放置到最顶层组件的\x3ccode\x3estate\x3c\/code\x3e中，也就是\x3ccode\x3ereact-redux\x3c\/code\x3e为我们提供的\x3ccode\x3eProvider\x3c\/code\x3e组件。这样就是意味着每次\x3ccode\x3estore\x3c\/code\x3e发生变化就会重新渲染整个应用，也就是触发所有组件的\x3ccode\x3erender\x3c\/code\x3e方法，每次都会触发\x3ccode\x3ediff\x3c\/code\x3e，但是这种大多是无意义的，这也是产生性能瓶颈的地方：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVJMFq?w=928\x26amp;h=422\x22 src=\x22https:\/\/static.alili.tech\/img\/bVJMFq?w=928\x26amp;h=422\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e如下面代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22render() {\n    const { child1Data, child2Data } = this.props.store;\n    return (\n        \x3cdiv\x3e\n            \x3cChild1 data=\x26quot;child1Data\x26quot; \/\x3e\n            \x3cChild2 data=\x26quot;child2Data\x26quot; \/\x3e\n        \x3c\/div\x3e\n    );\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3erender() {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { child1Data, child2Data } = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.store;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\n        \x26lt;div\x26gt;\n            \x26lt;Child1 data=\x22child1Data\x22 \/\x26gt;\n            \x26lt;Child2 data=\x22child2Data\x22 \/\x26gt;\n        \x26lt;\/div\x26gt;\n    );\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e假如只有\x3ccode\x3echild1Data\x3c\/code\x3e发生变化，而\x3ccode\x3echild2Data\x3c\/code\x3e并没有发生变化，理论上来说我们只想触发\x3ccode\x3eChild1\x3c\/code\x3e的\x3ccode\x3erender\x3c\/code\x3e，但事实上我们同时会触发\x3ccode\x3eChild2\x3c\/code\x3e的\x3ccode\x3erender\x3c\/code\x3e，这次显然是无意义的，所以需要来解决这个问题。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e引入purerender\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3ereact\x3c\/code\x3e的生命周期函数中有一个\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e，根据其返回的值来决定是否需要来触发组件的\x3ccode\x3erender\x3c\/code\x3e，\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e默认返回的是\x3ccode\x3etrue\x3c\/code\x3e，也就是无论什么情况都会触发\x3ccode\x3erender\x3c\/code\x3e，\x3ccode\x3epurerender\x3c\/code\x3e改善的就是这个生命周期，根据传入的\x3ccode\x3estate\x3c\/code\x3e和\x3ccode\x3eprops\x3c\/code\x3e来进行简单的判断，从而决定是否需要进行\x3ccode\x3erender\x3c\/code\x3e，为什么说只是进行了简单的判断，来看其判断部分代码：\x3cbr\x3e（注：\x3cstrong\x3e利用connect将组件与\x3ccode\x3eredux\x3c\/code\x3e关联起来的容器不需要加\x3ccode\x3epurerender\x3c\/code\x3e ，因为这个工作\x3ccode\x3ereact-redux\x3c\/code\x3e已经替我们做好了\x3c\/strong\x3e）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ is可以理解为Object.is()\nfunction shallowEqual(objA, objB) {\n    if (is(objA, objB)) {\n        return true;\n    }\n    \/\/ 非引用类型,且不相等直接返回\n    if (typeof objA !== \x27object\x27 || objA === null ||\n        typeof objB !== \x27object\x27 || objB === null) {\n        return false;\n    }\n    const keysA = Object.keys(objA),\n        keysB = Object.keys(objB);\n\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    \/\/ 问题所在,仅仅是比较了第一层,假设引用没变,不会触发更新\n    for (let i = 0; i \x3c keysA.length; i\x2b\x2b) {\n        if (\n            !hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysB][i])\n        ) {\n            return false;\n        }\n    }\n    return true;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ is可以理解为Object.is()\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eshallowEqual\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobjA, objB\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (is(objA, objB)) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 非引用类型,且不相等直接返回\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e objA !== \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || objA === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e ||\n        \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e objB !== \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e || objB === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keysA = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(objA),\n        keysB = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(objB);\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (keysA.length !== keysB.length) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 问题所在,仅仅是比较了第一层,假设引用没变,不会触发更新\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; keysA.length; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n            !hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysB][i])\n        ) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注意：\x3cstrong\x3e使用\x3ccode\x3ereact\x3c\/code\x3e时一定注意不要在\x3ccode\x3erender\x3c\/code\x3e函数中进行函数的\x3ccode\x3ebind\x3c\/code\x3e，因为这样每次\x3ccode\x3eprops\x3c\/code\x3e中会有属性的引用改变，一定会触发更新\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e对于一般的情况来说\x3ccode\x3epurerender\x3c\/code\x3e已经足够，可以减少一些\x3ccode\x3ere-render\x3c\/code\x3e，但是不是很彻底，比如：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e情况一：\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 之前的数据：\nlet person = {\n    name: \x27zp1996\x27,\n    age: 21\n};\n\/\/ 改变引用\nperson = {\n    name: \x27zp1996\x27,\n    age: 21\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 之前的数据：\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e person = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27zp1996\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 改变引用\x3c\/span\x3e\nperson = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27zp1996\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e（注：上面场景我做了下简化，真实中可能是从服务器端获得的数据，比如帖子列表这种）\x3cbr\x3e明显的引用发生了改变，所以会触发\x3ccode\x3ere-render\x3c\/code\x3e，但是明显的是我的数据完全没有变化，根本不用进行\x3ccode\x3ediff\x3c\/code\x3e。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e情况二：\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const data = {\n    person: {\n        students: [{\n            name: \x27zp1996\x27,\n            age: 21\n        }]\n    }\n};\n\/\/ 加入一个新的学生，数据结构会变成这样\n{\n    person: {\n        students: [{\n            name: \x27zp1996\x27,\n            age: 20\n        }, {\n            name: \x27zpy\x27,\n            age: 21\n        }]\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = {\n    \x3cspan class=\x22hljs-attr\x22\x3eperson\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3estudents\x3c\/span\x3e: [{\n            \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27zp1996\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e\n        }]\n    }\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加入一个新的学生，数据结构会变成这样\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3eperson\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3estudents\x3c\/span\x3e: [{\n            \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27zp1996\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e\n        }, {\n            \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27zpy\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e\n        }]\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e假如是这种情况，引用根本没有发生变化，所以就不会触发\x3ccode\x3ere-render\x3c\/code\x3e，每次改变一个小的地方，就需要将整个的数据重新生成一个，这样造成了内存的不必要的浪费。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e利用immutable解决\x3c\/h3\x3e\n\x3cp\x3e很容易想到的是在\x3ccode\x3eshouldComponentUpdate\x3c\/code\x3e中进行深度比较，用递归的方式来进行比较，这样的代价同样很大，并不是一个有效的解决方案。为了解决这个问题，需要引入另一个库——\x3ccode\x3eimmutable\x3c\/code\x3e，其思想是强调不可变数据，一个\x3ccode\x3eImmutable Data\x3c\/code\x3e的创建就是一个不可变的，需要变化时不是利用深拷贝，而是仅仅改变这个变化的节点和其父节点，其余节点仍是共享内存。同样的这样的一个强大的框架也是非常大，压缩过后仍然有\x3ccode\x3e50k\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e还有问题吗？\x3c\/h3\x3e\n\x3cp\x3e我们希望的是\x3ccode\x3ereducer\x3c\/code\x3e中保持简单，从服务端请求回来的数据直接存在\x3ccode\x3estore\x3c\/code\x3e中，看个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 从服务端拉回来的数据\n{\n    students: {\n        \x27id_111\x27: {\n            name: \x27zp1996\x27,\n            age: 21\n        }\n    }\n}\n\/\/ 最终组件希望我们传入这样的数据\n{\n    students: [{\n        name: \x27zp1996\x27,\n        age: 21,\n        id: \x27id_111\x27\n    }]\n}\n\/\/ 一般会在connect中对数据进行整理\nconst mapStateToProp = state =\x3e {\n    const { students } = state,\n        res = [];\n    for (let key in students) {\n        if (students.hasOwnProperty(key)) {\n            let obj = students[key];\n            obj[id] = key;\n            res.push(obj);\n        }\n    }  \n    return res;  \n};\n@connect(\n    mapStateToProp,   \/\/ 被叫做selector \n);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从服务端拉回来的数据\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3estudents\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-string\x22\x3e\x27id_111\x27\x3c\/span\x3e: {\n            \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27zp1996\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e\n        }\n    }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 最终组件希望我们传入这样的数据\x3c\/span\x3e\n{\n    \x3cspan class=\x22hljs-attr\x22\x3estudents\x3c\/span\x3e: [{\n        \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27zp1996\x27\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eage\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e21\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27id_111\x27\x3c\/span\x3e\n    }]\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一般会在connect中对数据进行整理\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mapStateToProp = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3estate\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { students } = state,\n        res = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e students) {\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (students.hasOwnProperty(key)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e obj = students[key];\n            obj[id] = key;\n            res.push(obj);\n        }\n    }  \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e res;  \n};\n@connect(\n    mapStateToProp,   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 被叫做selector \x3c\/span\x3e\n);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每次\x3ccode\x3estore\x3c\/code\x3e变化后，也就是执行一次\x3ccode\x3edispatch\x3c\/code\x3e之后都会执行利用\x3ccode\x3esubscribe\x3c\/code\x3e方法注册的回调（注册的回调就是\x3ccode\x3econnect\x3c\/code\x3e的第一个参数，也就是\x3ccode\x3eselector\x3c\/code\x3e），这样就意味着，尽管\x3ccode\x3estudents\x3c\/code\x3e并没有发生变化还是会触发一次数据结构的重整，这种显然是一种浪费，所以这个过程也需要优化：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVJM4z?w=1127\x26amp;h=662\x22 src=\x22https:\/\/static.alili.tech\/img\/bVJM4z?w=1127\x26amp;h=662\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eredux\x3c\/code\x3e强调的是函数式编程，对于函数式编程来说有一个很明显的特点就是易于缓存，对于一个函数而言，给定相同的输入肯定会得到相同的输出，而\x3ccode\x3eselector\x3c\/code\x3e也全部为纯函数，同时\x3ccode\x3econnect\x3c\/code\x3e的\x3ccode\x3emapStateToProp\x3c\/code\x3e参数也支持返回一个函数。\x3ccode\x3ereselect\x3c\/code\x3e库就是这个思想，先来看看基本用法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ createSelector的最后一个参数作为计算函数\nconst state = { num: 10 },\n    selector = state =\x3e state.num,\n    reSelector = createSelector(\n        selector,\n        a =\x3e {\n            console.log(\x27被调用了\x27)\n            return a * a;\n        }\n    );\n\nconsole.log(reSelector(state));    \/\/ 第一次计算\nconsole.log(reSelector(state));    \/\/ 拿缓存\nconsole.log(reSelector(state));    \/\/ 拿缓存\nstate.num = 100;\nconsole.log(reSelector(state));    \/\/ 值发生改变,计算\nconsole.log(reSelector(state));    \/\/ 拿缓存   \nconsole.log(reSelector(state));    \/\/ 拿缓存       \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3e\/\/ createSelector的最后一个参数作为计算函数\nconst \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e = { num: \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e },\n    selector = \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.num,\n    reSelector = createSelector(\n        selector,\n        a =\x26gt; {\n            console.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(\x27被调用了\x27)\n            return a * a;\n        }\n    );\n\nconsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(reSelector(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e));    \/\/ 第一次计算\nconsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(reSelector(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e));    \/\/ 拿缓存\nconsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(reSelector(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e));    \/\/ 拿缓存\n\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e.num = \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e;\nconsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(reSelector(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e));    \/\/ 值发生改变,计算\nconsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(reSelector(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e));    \/\/ 拿缓存   \nconsole.\x3cspan class=\x22hljs-keyword\x22\x3elog\x3c\/span\x3e(reSelector(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e));    \/\/ 拿缓存       \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实现也是非常简单，就是对传入的参数进行判断，如果与之前一样则直接返回结果\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function defaultMemoize(func, equalityCheck = defaultEqualityCheck) {\n    let lastArgs = null,    \n        lastResult = null;\n    const isEqualToLastArg = (value, index) =\x3e equalityCheck(value, lastArgs[index]);\n    return (...args) =\x3e {\n        \/\/ 检测输入是否相等，不等或者第一次执行的话执行函数，反之拿之间的结果\n        if (\n            lastArgs === null ||\n            lastArgs.length !== args.length ||\n            !args.every(isEqualToLastArg)\n        ) {\n            lastResult = func(...args);\n        }\n        lastArgs = args;\n        return lastResult;\n    };\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefaultMemoize\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efunc, equalityCheck = defaultEqualityCheck\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e lastArgs = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,    \n        lastResult = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isEqualToLastArg = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3evalue, index\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e equalityCheck(value, lastArgs[index]);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e...args\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检测输入是否相等，不等或者第一次执行的话执行函数，反之拿之间的结果\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\n            lastArgs === \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e ||\n            lastArgs.length !== args.length ||\n            !args.every(isEqualToLastArg)\n        ) {\n            lastResult = func(...args);\n        }\n        lastArgs = args;\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e lastResult;\n    };\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3eredux太复杂？尝试mobx\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eredux\x3c\/code\x3e会引入很多的概念，同时代码量也会很多，而\x3ccode\x3emobx\x3c\/code\x3e要更为简单。\x3ccode\x3emobx\x3c\/code\x3e给我的感觉就像是把\x3ccode\x3evue\x3c\/code\x3e的响应式数据那一套给拿了出来，给了我们极大的自由度，可以利用\x3ccode\x3eOOP\x3c\/code\x3e那一套来建立模型，而用\x3ccode\x3eredux\x3c\/code\x3e必须利用\x3ccode\x3eredux\x3c\/code\x3e的那些套路写代码；同时在性能上也会有一些提升。但是同时也会带来很大的问题：\x3ccode\x3estate\x3c\/code\x3e满天飞是避免不了的，但是提供了一个\x3ccode\x3estrict\x3c\/code\x3e模式，要求数据必须利用\x3ccode\x3eaction\x3c\/code\x3e来进行更改，\x3cstrong\x3e但是我用了之后发现并没有什么作用，而且组件外是可以随意更改数据的。\x3c\/strong\x3e 还有一个小问题就是热更新，根本没有找到热更新的解决方案，每次还得手动刷新页面。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e最后\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3eredux\x3c\/code\x3e还有一块很重要的部分，那就是异步处理，目前本人只用过\x3ccode\x3eredux-thunk\x3c\/code\x3e，所以关于这个方面没（水）有（平）讲（不）到（够），同时哪里有错误也请大家指出。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>对react技术栈的一些理解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008491558">https://segmentfault.com/a/1190000008491558</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/wauj2axq1i/" target="_blank">https://alili.tech/archive/wauj2axq1i/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>