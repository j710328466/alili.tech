<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React高阶组件(HOC)模型理论与实践"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React高阶组件(HOC)模型理论与实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/jz8mfdr5gc/",
				"appid": "1613049289050283", 
				"title": "React高阶组件(HOC)模型理论与实践 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-28T02:30:09"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/fvz9beqcfku/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/7mrz66muqqn/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f&text=React%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e6%a8%a1%e5%9e%8b%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f&text=React%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e6%a8%a1%e5%9e%8b%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f&title=React%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e6%a8%a1%e5%9e%8b%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f&is_video=false&description=React%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e6%a8%a1%e5%9e%8b%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e6%a8%a1%e5%9e%8b%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f&title=React%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e6%a8%a1%e5%9e%8b%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f&title=React%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e6%a8%a1%e5%9e%8b%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f&title=React%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e6%a8%a1%e5%9e%8b%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjz8mfdr5gc%2f&title=React%e9%ab%98%e9%98%b6%e7%bb%84%e4%bb%b6%28HOC%29%e6%a8%a1%e5%9e%8b%e7%90%86%e8%ae%ba%e4%b8%8e%e5%ae%9e%e8%b7%b5"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React高阶组件(HOC)模型理论与实践</h1><div class="meta"><div class="postdate"><time datetime="2019-01-28" itemprop="datePublished">2019-01-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e什么是HOC?\x3c\/h2\x3e\n\x3cp\x3eHOC(全称Higher-order component)是一种React的进阶使用方法，主要还是为了便于组件的复用。HOC就是一个方法，获取一个组件，返回一个更高级的组件。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e什么时候使用HOC?\x3c\/h2\x3e\n\x3cp\x3e在React开发过程中，发现有很多情况下，组件需要被\x22增强\x22，比如说给组件添加或者修改一些特定的props，一些权限的管理，或者一些其他的优化之类的。而如果这个功能是针对多个组件的，同时每一个组件都写一套相同的代码，明显显得不是很明智，所以就可以考虑使用HOC。\x3c\/p\x3e\n\x3cp\x3e栗子：react-redux的connect方法就是一个HOC，他获取wrappedComponent，在connect中给wrappedComponent添加需要的props。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eHOC的简单实现\x3c\/h2\x3e\n\x3cp\x3eHOC不仅仅是一个方法，确切说应该是一个组件工厂，获取低阶组件，生成高阶组件。\x3c\/p\x3e\n\x3cp\x3e一个最简单的HOC实现是这个样子的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function HOCFactory(WrappedComponent) {\n  return class HOC extends React.Component {\n    render(){\n      return \x3cWrappedComponent {...this.props} \/\x3e\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHOCFactory\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHOC\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render(){\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWrappedComponent\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...this.props\x3c\/span\x3e} \/\x26gt;\x3c\/span\x3e\n    }\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eHOC可以做什么？\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e代码复用，代码模块化\x3c\/li\x3e\n\x3cli\x3e增删改props\x3c\/li\x3e\n\x3cli\x3e渲染劫持\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e其实，除了代码复用和模块化，HOC做的其实就是\x3cstrong\x3e劫持\x3c\/strong\x3e，由于传入的wrappedComponent是作为一个child进行渲染的，上级传入的props都是直接传给HOC的，所以HOC组件拥有很大的权限去修改props和控制渲染。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e增删改props\x3c\/h3\x3e\n\x3cp\x3e可以通过对传入的props进行修改，或者添加新的props来达到增删改props的效果。\x3c\/p\x3e\n\x3cp\x3e比如你想要给wrappedComponent增加一个props，可以这么搞：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function control(wrappedComponent) {\n  return class Control extends React.Component {\n    render(){\n      let props = {\n        ...this.props,\n        message: \x26quot;You are under control\x26quot;\n      };\n      return \x3cwrappedComponent {...props} \/\x3e\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econtrol\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ewrappedComponent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eControl\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render(){\n      \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e props = {\n        ...this.props,\n        \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22You are under control\x22\x3c\/span\x3e\n      };\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ewrappedComponent\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...props\x3c\/span\x3e} \/\x26gt;\x3c\/span\x3e\n    }\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，你就可以在你的组件中使用message这个props:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class MyComponent extends React.Component {\n  render(){\n    return \x3cdiv\x3e{this.props.message}\x3c\/div\x3e\n  }\n}\n\nexport default control(MyComponent);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e{this.props.message}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n  }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e control(MyComponent);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e渲染劫持\x3c\/h3\x3e\n\x3cp\x3e这里的渲染劫持并不是你能控制它渲染的细节，而是控制是否去渲染。由于细节属于组件内部的render方法控制，所以你无法控制渲染细节。\x3c\/p\x3e\n\x3cp\x3e比如，组件要在data没有加载完的时候，现实loading...，就可以这么写：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function loading(wrappedComponent) {\n  return class Loading extends React.Component {\n    render(){\n      if(!this.props.data) {\n        return \x3cdiv\x3eloading...\x3c\/div\x3e\n      }\n      return \x3cwrappedComponent {...props} \/\x3e\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eloading\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ewrappedComponent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLoading\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render(){\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.data) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3eloading...\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ewrappedComponent\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...props\x3c\/span\x3e} \/\x26gt;\x3c\/span\x3e\n    }\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个样子，在父级没有传入data的时候，这一块儿就只会显示loading...,不会显示组件的具体内容\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class MyComponent extends React.Component {\n  render(){\n    return \x3cdiv\x3e{this.props.data}\x3c\/div\x3e\n  }\n}\n\nexport default control(MyComponent);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMyComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;{\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.data}\x26lt;\/div\x26gt;\n  }\n}\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e control(\x3cspan class=\x22hljs-type\x22\x3eMyComponent\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eHOC有什么用例？\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eReact Redux\x3c\/h3\x3e\n\x3cp\x3e最经典的就是React Redux的connect方法(具体在\x3ca href=\x22https:\/\/github.com\/reactjs\/react-redux\/blob\/master\/src\/components\/connectAdvanced.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3econnectAdvanced\x3c\/a\x3e中实现)。\x3c\/p\x3e\n\x3cp\x3e通过这个HOC方法，监听redux store，然后把下级组件需要的state(通过mapStateToProps获取)和action creator(通过mapDispatchToProps获取)绑定到wrappedComponent的props上。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3elogger和debugger\x3c\/h3\x3e\n\x3cp\x3e这个是\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/higher-order-components.html#dont-mutate-the-original-component.-use-composition.\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官网上的一个示例\x3c\/a\x3e，可以用来监控父级组件传入的props的改变:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function logProps(WrappedComponent) {\n  return class extends React.Component {\n    componentWillReceiveProps(nextProps) {\n      console.log(`WrappedComponent: ${WrappedComponent.displayName}, Current props: `, this.props);\n      console.log(`WrappedComponent: ${WrappedComponent.displayName}, Next props: `, nextProps);\n    }\n    render() {\n      \/\/ Wraps the input component in a container, without mutating it. Good!\n      return \x3cWrappedComponent {...this.props} \/\x3e;\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3elogProps\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    componentWillReceiveProps(nextProps) {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`WrappedComponent: \x3cspan class=\x22hljs-subst\x22\x3e${WrappedComponent.displayName}\x3c\/span\x3e, Current props: `\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props);\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`WrappedComponent: \x3cspan class=\x22hljs-subst\x22\x3e${WrappedComponent.displayName}\x3c\/span\x3e, Next props: `\x3c\/span\x3e, nextProps);\n    }\n    render() {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Wraps the input component in a container, without mutating it. Good!\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eWrappedComponent\x3c\/span\x3e {\x3cspan class=\x22hljs-attr\x22\x3e...this.props\x3c\/span\x3e} \/\x26gt;\x3c\/span\x3e;\n    }\n  }\n}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e页面权限管理\x3c\/h3\x3e\n\x3cp\x3e可以通过HOC对组件进行包裹，当跳转到当前页面的时候，检查用户是否含有对应的权限。如果有的话，渲染页面。如果没有的话，跳转到其他页面(比如无权限页面，或者登陆页面)。\x3c\/p\x3e\n\x3cp\x3e也可以给当前组件提供权限的API，页面内部也可以进行权限的逻辑判断。\x3c\/p\x3e\n\x3cp\x3e本来准备把详细代码当个栗子贴出来的，结果突然想到公司保密协议，所以。。。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e使用HOC需要注意什么？\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e尽量不要随意修改下级组件需要的props\x3c\/h3\x3e\n\x3cp\x3e之所以这么说，是因为修改父级传给下级的props是有一定风险的，可能会造成下级组件发生错误。比如，原本需要一个name的props，但是在HOC中给删掉了，那么下级组件或许就无法正常渲染，甚至报错。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eRef无法获取你想要的ref\x3c\/h3\x3e\n\x3cp\x3e以前你在父组件中使用\x3ccode\x3e\x26lt;component ref=\x22component\x22\/\x26gt;\x3c\/code\x3e的时候，你可以直接通过\x3ccode\x3ethis.refs.component\x3c\/code\x3e进行获取。但是因为这里的component经过HOC的封装，已经是HOC里面的那个component了，所以你无法获取你想要的那个ref(wrappedComponent的ref)。\x3c\/p\x3e\n\x3cp\x3e要解决这个问题，这里有两个方法：\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3ea)\x3c\/strong\x3e 像React Redux的connect方法一样，在里面添加一个参数，比如\x3ccode\x3ewithRef\x3c\/code\x3e，组件中检查到这个flag了，就给下级组件添加一个ref，并通过getWrappedInstance方法获取。\x3c\/p\x3e\n\x3cp\x3e栗子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function HOCFactory(wrappedComponent) {\n  return class HOC extends React.Component {\n    getWrappedInstance = ()=\x3e{\n      if(this.props.widthRef) {\n        return this.wrappedInstance;\n      }\n    }\n\n    setWrappedInstance = (ref)=\x3e{\n      this.wrappedInstance = ref;\n    }\n\n    render(){\n      let props = {\n        ...this.props\n      };\n\n      if(this.props.withRef) {\n        props.ref = this.setWrappedInstance;\n      }\n\n      return \x3cwrappedComponent {...props} \/\x3e\n    }\n  }\n}\n\nexport default HOCFactory(MyComponent);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3efunction \x3cspan class=\x22hljs-type\x22\x3eHOCFactory\x3c\/span\x3e(wrappedComponent) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHOC\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    getWrappedInstance = ()=\x26gt;{\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.widthRef) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrappedInstance;\n      }\n    }\n\n    setWrappedInstance = (ref)=\x26gt;{\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrappedInstance = ref;\n    }\n\n    render(){\n      let props = {\n        ...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n      };\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.withRef) {\n        props.ref = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setWrappedInstance;\n      }\n\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;wrappedComponent {...props} \/\x26gt;\n    }\n  }\n}\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eHOCFactory\x3c\/span\x3e(\x3cspan class=\x22hljs-type\x22\x3eMyComponent\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样子你就可以在父组件中这样获取MyComponent的ref值了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ParentCompoent extends React.Component {\n  doSomethingWithMyComponent(){\n    let instance = this.refs.child.getWrappedInstance();\n    \/\/ ....\n  }\n\n  render(){\n    return \x3cMyComponent ref=\x26quot;child\x26quot; withRef \/\x3e\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParentCompoent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  doSomethingWithMyComponent(){\n    let instance = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.refs.child.getWrappedInstance();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ....\x3c\/span\x3e\n  }\n\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eMyComponent\x3c\/span\x3e ref=\x3cspan class=\x22hljs-string\x22\x3e\x22child\x22\x3c\/span\x3e withRef \/\x26gt;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3eb)\x3c\/strong\x3e 还有一种方法，在\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/higher-order-components.html#refs-arent-passed-through\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官网中有提到过\x3c\/a\x3e：\x3cbr\x3e父级通过传递一个方法，来获取ref，具体看栗子：\x3c\/p\x3e\n\x3cp\x3e先看父级组件：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class ParentCompoent extends React.Component {\n  getInstance = (ref)=\x3e{\n    this.wrappedInstance = ref;\n  }\n\n  render(){\n    return \x3cMyComponent getInstance={this.getInstance} \/\x3e\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParentCompoent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n  getInstance = (ref)=\x26gt;{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.wrappedInstance = ref;\n  }\n\n  render(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;\x3cspan class=\x22hljs-type\x22\x3eMyComponent\x3c\/span\x3e getInstance={\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getInstance} \/\x26gt;\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eHOC里面把getInstance方法当作ref的方法传入就好\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function HOCFactory(wrappedComponent) {\n  return class HOC extends React.Component {\n    render(){\n      let props = {\n        ...this.props\n      };\n\n      if(typeof this.props.getInstance === \x26quot;function\x26quot;) {\n        props.ref = this.props.getInstance;\n      }\n\n      return \x3cwrappedComponent {...props} \/\x3e\n    }\n  }\n}\n\nexport default HOCFactory(MyComponent);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3efunction \x3cspan class=\x22hljs-type\x22\x3eHOCFactory\x3c\/span\x3e(wrappedComponent) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eHOC\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render(){\n      let props = {\n        ...\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props\n      };\n\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(typeof \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.getInstance === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e) {\n        props.ref = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.getInstance;\n      }\n\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;wrappedComponent {...props} \/\x26gt;\n    }\n  }\n}\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eHOCFactory\x3c\/span\x3e(\x3cspan class=\x22hljs-type\x22\x3eMyComponent\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e感谢@wmzy的指出，在上面的两个方法\x3ccode\x3egetInstance\x3c\/code\x3e和\x3ccode\x3esetWrappedInstance\x3c\/code\x3e，由于\x3ccode\x3eES6 class\x3c\/code\x3e的写法并不会自动绑定\x3ccode\x3ethis\x3c\/code\x3e，所以\x3ccode\x3e需要用bind(this)\x3c\/code\x3e到两个方法上，确保\x3ccode\x3ethis\x3c\/code\x3e的正确性。或者使用箭头函数来写两个方法，ES6的箭头函数会自动绑定\x3ccode\x3ethis\x3c\/code\x3e。\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3eComponent上面绑定的Static方法会丢失\x3c\/h3\x3e\n\x3cp\x3e比如，你原来在Component上面绑定了一些static方法\x3ccode\x3eMyComponent.staticMethod = o=\x26gt;o\x3c\/code\x3e。但是由于经过HOC的包裹，父级组件拿到的已经不是原来的组件了，所以当然无法获取到staticMethod方法了。\x3c\/p\x3e\n\x3cp\x3e官网上的示例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 定义一个static方法\nWrappedComponent.staticMethod = function() {\/*...*\/}\n\/\/ 利用HOC包裹\nconst EnhancedComponent = enhance(WrappedComponent);\n\n\/\/ 返回的方法无法获取到staticMethod\ntypeof EnhancedComponent.staticMethod === \x27undefined\x27 \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义一个static方法\x3c\/span\x3e\nWrappedComponent.staticMethod = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/*...*\/\x3c\/span\x3e}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 利用HOC包裹\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e EnhancedComponent = enhance(WrappedComponent);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回的方法无法获取到staticMethod\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e EnhancedComponent.staticMethod === \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有一个解决方法，就是\x3ccode\x3ehoist-non-react-statics\x3c\/code\x3e组件，这个组件会自动把所有绑定在对象上的非React方法都绑定到新的对象上：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import hoistNonReactStatic from \x27hoist-non-react-statics\x27;\nfunction enhance(WrappedComponent) {\n  class Enhance extends React.Component {\/*...*\/}\n  hoistNonReactStatic(Enhance, WrappedComponent);\n  return Enhance;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scala\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e hoistNonReactStatic from \x3cspan class=\x22hljs-symbol\x22\x3e\x27hoist\x3c\/span\x3e-non-react-statics\x27;\nfunction enhance(\x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e) {\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eEnhance\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/*...*\/\x3c\/span\x3e}\n  hoistNonReactStatic(\x3cspan class=\x22hljs-type\x22\x3eEnhance\x3c\/span\x3e, \x3cspan class=\x22hljs-type\x22\x3eWrappedComponent\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eEnhance\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e结束语\x3c\/h2\x3e\n\x3cp\x3e当你需要做React插件的时候，HOC模型是一个很实用的模型。\x3c\/p\x3e\n\x3cp\x3e希望这篇文章能帮你对HOC有一个大概的了解和启发。\x3c\/p\x3e\n\x3cp\x3e另外，\x3ca href=\x22https:\/\/medium.com\/@franleplant\/react-higher-order-components-in-depth-cf9032ee6c3e#.wwp0tbukh\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这篇medium上的文章\x3c\/a\x3e会给你更多的启发，在这篇文章中，我这里讲的被分为Props Proxy HOC，还有另外一种Inheritance Inversion HOC，强烈推荐看一看。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React高阶组件(HOC)模型理论与实践</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008112017">https://segmentfault.com/a/1190000008112017</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/jz8mfdr5gc/" target="_blank">https://alili.tech/archive/jz8mfdr5gc/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>