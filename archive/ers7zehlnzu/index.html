<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="静态NodeList 和 动态NodeList的区别"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>静态NodeList 和 动态NodeList的区别 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ers7zehlnzu/",
				"appid": "1613049289050283", 
				"title": "静态NodeList 和 动态NodeList的区别 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-18T02:30:34"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/6kesofq8r0w/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/0imobok9cq6/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f&text=%e9%9d%99%e6%80%81NodeList%20%e5%92%8c%20%e5%8a%a8%e6%80%81NodeList%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f&text=%e9%9d%99%e6%80%81NodeList%20%e5%92%8c%20%e5%8a%a8%e6%80%81NodeList%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f&title=%e9%9d%99%e6%80%81NodeList%20%e5%92%8c%20%e5%8a%a8%e6%80%81NodeList%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f&is_video=false&description=%e9%9d%99%e6%80%81NodeList%20%e5%92%8c%20%e5%8a%a8%e6%80%81NodeList%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e9%9d%99%e6%80%81NodeList%20%e5%92%8c%20%e5%8a%a8%e6%80%81NodeList%e7%9a%84%e5%8c%ba%e5%88%ab&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f&title=%e9%9d%99%e6%80%81NodeList%20%e5%92%8c%20%e5%8a%a8%e6%80%81NodeList%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f&title=%e9%9d%99%e6%80%81NodeList%20%e5%92%8c%20%e5%8a%a8%e6%80%81NodeList%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f&title=%e9%9d%99%e6%80%81NodeList%20%e5%92%8c%20%e5%8a%a8%e6%80%81NodeList%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fers7zehlnzu%2f&title=%e9%9d%99%e6%80%81NodeList%20%e5%92%8c%20%e5%8a%a8%e6%80%81NodeList%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">静态NodeList 和 动态NodeList的区别</h1><div class="meta"><div class="postdate"><time datetime="2019-01-18" itemprop="datePublished">2019-01-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3eps：了解这个知识点的原因\x3c\/h2\x3e\n\x3cp\x3e前两天我在重温js dom编程的时候，看到了获取dom元素这一章，然后看到了getElementsByTagName()和getElementsByClassName()，之后又了解到了现代浏览器新出的一个DOM API--querySelectorAll().以我的性格，看到这些方法之后我肯定是想了解一下它们的不同点啦，所以我就翻阅资料，就看到了stackoverflow上面的一个问题\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var temp = document.querySelectorAll(\x26quot;.class\x26quot;);\nfor (var i=0, max=temp.length; i\x3cmax; i\x2b\x2b) { \n     temp[i].className = \x26quot;new_class\x26quot;;\n}\n\nvar temp = document.getElementsByClassName(\x26quot;class\x26quot;);\nfor (var i=0, max=temp.length; i\x3cmax; i\x2b\x2b) { \n     temp[i].className = \x26quot;new_class\x26quot;;\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e temp = document.querySelectorAll(\x3cspan class=\x22hljs-string\x22\x3e\x22.class\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e=temp.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; i\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e; i\x2b\x2b) { \n     temp[i].className = \x3cspan class=\x22hljs-string\x22\x3e\x22new_class\x22\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e temp = document.getElementsByClassName(\x3cspan class=\x22hljs-string\x22\x3e\x22class\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e=temp.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; i\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e; i\x2b\x2b) { \n     temp[i].className = \x3cspan class=\x22hljs-string\x22\x3e\x22new_class\x22\x3c\/span\x3e;\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e运行上述这两段代码，假如获取到的temp的长度都为3，那么第一段代码能将三个元素的className全部更改为new_class\x22，而第二段代码只能讲第一个元素和第三个元素的className更改为\x22new_class\x22.这里面的原因就是动态nodelist和静态nodelist的区别。\x3cbr\x3e然后我又翻阅资料查找什么是动态nodelist，什么是静态nodelist。于是乎，就有了下面的长篇大论。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e说说NodeList,HTMLCollection以及NamedNodeMap\x3c\/h2\x3e\n\x3cp\x3e在不同版本的浏览器中，如果调用获取多元素的DOM方法（getElement...()），有的会得到NodeList（多为旧浏览器），有的会得到HTMLCollection（多为新浏览器）。使用Node Interface的方法，如childNodes，得到的通常是NodeList，而使用其他Interface的方法，又有可能得到HTMLCollection。而NamedNodeMap又和前面两者返回的东西类型也不相同，所以有必要了解一下这三者的区别。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e1. 三者的相同点\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e1.1 三者都具有length属性\x3c\/p\x3e\n\x3cp\x3e1.2 三者都有item()方法\x3c\/p\x3e\n\x3cp\x3e1.3 三个集合都是\x22动态的\x22，如果对NodeList和HTMLCollection中的元素进行操作都会直接反映到DOM中，因此如果一次性直接在集合中进行DOM操作的话，开销非常大。(这会在讲解动态的时候详细解释)\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e2. 三者的不同点\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e2.1 nodeList里面包含了所有的节点类型，比如元素节点，文本节点等\x3c\/p\x3e\n\x3cp\x3e2.2 HTMLCollection里面只包含元素节点\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv\x3e\n    \x3c!-- Comment --\x3e\n    \x3cp\x3eThis is Some Text\x3c\/p\x3e\n\x3c\/div\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- Comment --\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3eThis is Some Text\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e上面这段代码，如果作为NodeList返回，那么浏览器最多会给这个列表5个元素\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e1.一个\x3ccode\x3e\x26lt;div\x26gt;\x3c\/code\x3e和注释间的断行和空格（或tab）作为text node（没错，标签之间的空白符号也可以被解析为text node\x3c\/p\x3e\n\x3cp\x3e2.注释作为comment node\x3c\/p\x3e\n\x3cp\x3e3.注释和\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e之间的断行和空格（或tab）作为text node,p作为element\x3c\/p\x3e\n\x3cp\x3e4.\x3ccode\x3e\x26lt;\/p\x26gt;\x3c\/code\x3e和\x3ccode\x3e\x26lt;\/div\x26gt;\x3c\/code\x3e之间的断行和空格（或tab）作为text node\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3e但是如果是作为HTMLCollection返回的话，那么就一个\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e元素这么简单\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e2.3 NamedNodeMap里面包含了\x22Attribute\x22的集合，例如id，title，name等，集合中的每一个元素都是attr类型。\x3c\/p\x3e\n\x3cp\x3e2.4 三个集合所提供的方法也不相同，例如HTMLCollection中提供了namedItem(),而其它两个集合就没有提供这个方法\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e扩展点：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3eitem和namedItem都可以通过[]的缩写进行调用，有的浏览器还支持用()的缩写进行调用（也就是可以list[index]，list[key]或者list(index)，list(key)），以及直接用dot notation调用namedItem（比如list.key）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eIE8及以下版本浏览器中，注释属于HTMLCommentElement,算作Element,因此会出现在HTMLCollection里\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e我们可以用alert\/console.log(document.getElement...)打印出来看下返回的是什么类型的集合，下面这个链接中讲的也算详细，可以参考下：\x3ca href=\x22http:\/\/www.jb51.net\/article\/25747.htm\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.jb51.net\/article\/2...\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3eps:以上知识点参考链接：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/joyeecheung\/p\/4067927.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.cnblogs.com\/joyeec...\x3c\/a\x3e,\x3cbr\x3e\x3ca href=\x22http:\/\/stackoverflow.com\/questions\/15763358\/difference-between-htmlcollection-nodelists-and-arrays-of-objects\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/stackoverflow.com\/ques...\x3c\/a\x3e,\x3cbr\x3e\x3ca href=\x22http:\/\/stackoverflow.com\/questions\/26047844\/getelementsbyclassname-vs-queryselectorall\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/stackoverflow.com\/ques...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e说了这么多，那么到底什么是动态NodeList?什么是静态NodeList呢？它们之间有什么区别？\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e动态NodeList\x3c\/h3\x3e\n\x3cp\x3e上面我们说到NodeList,HTMLCollection以及NamedNodeMap都是动态的。也就是说，对底层文档结构的修改会动态地反映到相关的结合NodeList,HTMLCollection以及NamedNodeMap中。例如：如果先获取了某个元素的子元素的动态集合NodeList对象，然后又在其他地方对这个元素进行操作(添加，修改，删除子元素等操作)，这些更改将自动反射到NodeList中，不需要手动进行操作。\x3c\/p\x3e\n\x3cp\x3e因为getElementsByTagName(所有getElement...方法都会返回动态NodeList)方法返回的是一个动态集合，所以只要document发生变化，就会自动更新对应的元素。因此，下面的代码是一个死循环：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var divs = document.getElementsByTagName(\x26quot;div\x26quot;);\nvar i=0;\nwhile(i \x3c divs.length){\n  document.body.appendChild(document.createElement(\x26quot;div\x26quot;));\n  i\x2b\x2b;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e divs = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementsByTagName(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(i \x26lt; divs.length){\n  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.appendChild(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e));\n  i\x2b\x2b;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e死循环的原因是每次循环都会重新计算divs.length.每次迭代都会添加一个新的\x3ccode\x3e\x26lt;div\x26gt;\x3c\/code\x3e,所以每次i\x2b\x2b，对应的divs.length也在增加，所以i永远比divs.length小，循环终止条件也就永远不会触发。\x3c\/p\x3e\n\x3cp\x3e解决上述代码死循环的办法可以是用一个变量存储divs.length或者改用querySelectorAll()：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var divs = document.getElementsByTagName(\x26quot;div\x26quot;);\nvar i=0,len = divs.length;\nwhile(i \x3c len){\n    document.body.appendChild(document.createElement(\x26quot;div\x26quot;));\n    i\x2b\x2b;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e divs = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementsByTagName(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,len = divs.length;\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(i \x26lt; len){\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.appendChild(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e));\n    i\x2b\x2b;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你可能会觉得这种动态集合是个坏主意, 但通过动态集合可以保证某些使用非常普遍的对象在各种情况下都是同一个,而且动态NodeList比静态NodeList快很多很多(下面解释原因)\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e静态NodeList\x3c\/h3\x3e\n\x3cp\x3equerySelectorAll()和querySelector()方法返回的是一个静态的NodeList,所谓静态NodeList就是对底层document的更改不会影响到返回的这个NodeList对象.此时返回的NodeList只是querySelectorAll()方法被调用时的文档状态的快照。所以下面的代码不会是死循环：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var divs = document.querySelectorAll(\x26quot;div\x26quot;);\nvar i=0;\nwhile(i \x3c divs.length){\n    document.body.appendChild(document.createElement(\x26quot;div\x26quot;));\n    i\x2b\x2b;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e divs = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3equerySelectorAll\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(i \x26lt; divs.length){\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.appendChild(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e));\n    i\x2b\x2b;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这种情况下没有死循环, divs.length的值永远不会改变, 所以只要不满足循环条件, 就退出循环。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e为什么动态NodeList更快呢？\x3c\/h2\x3e\n\x3cp\x3e我在某篇文章中看到有人测试了一下getElementsByTagName()比querySelectorAll()快好多倍。\x3c\/p\x3e\n\x3cp\x3e原因是：动态NodeList对象在浏览器中可以更快地被创建并返回，因为他们不需要预先获取所有的信息，而静态NodeList对象从一开始就需要取得并封装所有相关的数据。两种对象类型的创建方式是完全不同的。\x3c\/p\x3e\n\x3cp\x3eDynamicNodeList(动态NodeList)对象通过在cache缓存中注册它的存在并创建。从本质上讲，创建一个新的DynamicNodeList是非常轻量级的，因为不需要做任何的前期工作。每次访问 DynamicNodeList 时, 必须查询 document 的变化, length 属性 以及 item() 方法证明了这一点\x3c\/p\x3e\n\x3cp\x3e相比之下，StaticNodeList对象实例由另外一个文件创建，然后循环填充所有的数据。在document中执行静态查询的前期成本相比DynamicNodeList要显著提高很多倍。\x3c\/p\x3e\n\x3cp\x3e如果真正的查看WebKit的源码,你会发现他为 querySelectorAll() 明确地 创建一个返回对象 ,在其中又使用一个循环来获取每一个结果,并创建最终返回的一个 NodeList.\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e结论\x3c\/h2\x3e\n\x3cp\x3egetElementsTagName()方法速度比querySelectorAll()方法快的根本原因在于动态NodeList和静态NodeList对象不同。在获取NodeList时不需要执行很多前期处理操作的动态列表总比获取返回之前完成各种处理的静态NodeList要快很多。哪个方法更好用还是看你的需求。如果不需要获取快照，就使用getElement...方法；如果需要静态快照结果，或者需要使用更复杂的css查询，则可以考虑querySelectAll()方法\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e对开头题目讲解\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**通过querySelectorAll()获取到的元素集合temp是静态的快照，所以temp长度不会变化，max始终为3，所以通过for循环3个对应元素的class名字都被改成\x26quot;new_class\x26quot;**\/\nvar temp = document.querySelectorAll(\x26quot;.class\x26quot;);\nfor (var i=0, max=temp.length; i\x3cmax; i\x2b\x2b) { \n     temp[i].className = \x26quot;new_class\x26quot;;\n}\n\/**通过getElementsByClassName()获取到的元素集合temp是动态的，所以我们对元素任何的更改都会直接反映到对应的NodeList中；\n刚开始temp长度为3，也就是max为3，这里i=0的时候，更改了temp[0]的className为\x26quot;new_class\x26quot;，所以temp的长度马上发生变化，max变为2；\n继续循环，i=1的时候，temp[1]实际上是没变化前的temp[2]。此时又更改了temp[1]的className为\x26quot;new_class\x26quot;，所以temp的长度又发生变化，max变为1；\n继续循环，i=2的时候，不满足条件，循环结束；\n所以temp[0],temp[2]的className都变为\x26quot;new_class\x26quot;，而temp[1]没改变**\/\nvar temp = document.getElementsByClassName(\x26quot;class\x26quot;);\nfor (var i=0, max=temp.length; i\x3cmax; i\x2b\x2b) { \n     temp[i].className = \x26quot;new_class\x26quot;;\n} \n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs excel\x22\x3e\x3ccode\x3e\/**通过querySelectorAll()获取到的元素集合temp是静态的快照，所以temp长度不会变化，\x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e始终为\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e，所以通过for循环\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e个对应元素的class名字都被改成\x3cspan class=\x22hljs-string\x22\x3e\x22new_class\x22\x3c\/span\x3e**\/\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e temp = document.querySelectorAll(\x3cspan class=\x22hljs-string\x22\x3e\x22.class\x22\x3c\/span\x3e);\nfor (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e=temp.length; i\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e; i\x2b\x2b) { \n     temp[i].className = \x3cspan class=\x22hljs-string\x22\x3e\x22new_class\x22\x3c\/span\x3e;\n}\n\/**通过getElementsByClassName()获取到的元素集合temp是动态的，所以我们对元素任何的更改都会直接反映到对应的NodeList中；\n刚开始temp长度为\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e，也就是\x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e为\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e，这里i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e的时候，更改了temp[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]的className为\x3cspan class=\x22hljs-string\x22\x3e\x22new_class\x22\x3c\/span\x3e，所以temp的长度马上发生变化，\x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e变为\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e；\n继续循环，i=\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e的时候，temp[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]实际上是没变化前的temp[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]。此时又更改了temp[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]的className为\x3cspan class=\x22hljs-string\x22\x3e\x22new_class\x22\x3c\/span\x3e，所以temp的长度又发生变化，\x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e变为\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e；\n继续循环，i=\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e的时候，不满足条件，循环结束；\n所以temp[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e],temp[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]的className都变为\x3cspan class=\x22hljs-string\x22\x3e\x22new_class\x22\x3c\/span\x3e，而temp[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]没改变**\/\n\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e temp = document.getElementsByClassName(\x3cspan class=\x22hljs-string\x22\x3e\x22class\x22\x3c\/span\x3e);\nfor (\x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e=temp.length; i\x26lt;\x3cspan class=\x22hljs-built_in\x22\x3emax\x3c\/span\x3e; i\x2b\x2b) { \n     temp[i].className = \x3cspan class=\x22hljs-string\x22\x3e\x22new_class\x22\x3c\/span\x3e;\n} \n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e参考资料链接：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/cncounter\/translation\/blob\/master\/tiemao_2014\/NodeList\/NodeList.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/cncounter\/...\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>静态NodeList 和 动态NodeList的区别</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008829267">https://segmentfault.com/a/1190000008829267</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ers7zehlnzu/" target="_blank">https://alili.tech/archive/ers7zehlnzu/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/lfmj4xr00e/">2016年终总结--前端生涯从0到1的过程<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/ukfvl3yzohq/">ES6新语法疑点简析<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/adal5cm5rlr/">Icon 进化史<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/xwquh4g09bl/">JS 中 TDZ 的理解<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/13j072ppoyf/">Javascript 中 Y 组合子的推导<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/kn3l7fwd55/">Redux story-1:who creates it?<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/9gngp6sg77/">Redux概念之二: Redux的三大原则<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/ktc291v9lq/">V8 Object 内存结构与属性访问详解<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/62hk7sdq93k/">Vue&#43;MySQL&#43;Express小试牛刀<aside class="dates">2019-01-27</aside></a></li><li><a href="/archive/q9tzlra5qaj/">Vue2.0简易案例<aside class="dates">2019-01-27</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>