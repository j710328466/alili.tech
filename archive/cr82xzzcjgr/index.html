<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="匠心打造canvas签名组件"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>匠心打造canvas签名组件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/cr82xzzcjgr/",
				"appid": "1613049289050283", 
				"title": "匠心打造canvas签名组件 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-09T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/er7ntmx7kip/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/4vzftx4i1hu/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f&text=%e5%8c%a0%e5%bf%83%e6%89%93%e9%80%a0canvas%e7%ad%be%e5%90%8d%e7%bb%84%e4%bb%b6"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f&text=%e5%8c%a0%e5%bf%83%e6%89%93%e9%80%a0canvas%e7%ad%be%e5%90%8d%e7%bb%84%e4%bb%b6"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f&title=%e5%8c%a0%e5%bf%83%e6%89%93%e9%80%a0canvas%e7%ad%be%e5%90%8d%e7%bb%84%e4%bb%b6"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f&is_video=false&description=%e5%8c%a0%e5%bf%83%e6%89%93%e9%80%a0canvas%e7%ad%be%e5%90%8d%e7%bb%84%e4%bb%b6"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%8c%a0%e5%bf%83%e6%89%93%e9%80%a0canvas%e7%ad%be%e5%90%8d%e7%bb%84%e4%bb%b6&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f&title=%e5%8c%a0%e5%bf%83%e6%89%93%e9%80%a0canvas%e7%ad%be%e5%90%8d%e7%bb%84%e4%bb%b6"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f&title=%e5%8c%a0%e5%bf%83%e6%89%93%e9%80%a0canvas%e7%ad%be%e5%90%8d%e7%bb%84%e4%bb%b6"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f&title=%e5%8c%a0%e5%bf%83%e6%89%93%e9%80%a0canvas%e7%ad%be%e5%90%8d%e7%bb%84%e4%bb%b6"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcr82xzzcjgr%2f&title=%e5%8c%a0%e5%bf%83%e6%89%93%e9%80%a0canvas%e7%ad%be%e5%90%8d%e7%bb%84%e4%bb%b6"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">匠心打造canvas签名组件</h1><div class="meta"><div class="postdate"><time datetime="2019-01-09" itemprop="datePublished">2019-01-09</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cstrong\x3e本文首发于CSDN网站，下面的版本又经过进一步的修订。\x3c\/strong\x3e\x3cbr\x3e原文：\x3ca href=\x22http:\/\/louiszhai.github.io\/2017\/07\/07\/canvas-draw\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e匠心打造canvas签名组件\x3c\/a\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e\x3cstrong\x3e导读\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e6月又是项目吃紧的时候，一大波需求袭来，猝不及防。\x3c\/p\x3e\n\x3cp\x3e度过了漫长而煎熬的6月，是时候总结一波。最近移动端的一款产品原计划是引入第三方的签名插件，该插件依赖复杂，若干个js使用\x3ccode\x3edocument.write\x3c\/code\x3e顺序加载，插件源码是ES5的，甚至说是ES3都不为过。为了能够顺利嵌入我们的VUE项目，我阅读了两天插件的源码（demo及文档不全，囧），然后花了一天多点的时间使用ES6引用它。鉴于单页应用中，任何非全局资源都不该提前加载的指导性原则，为了做到动态加载，我甚至还专门写了一个simple的vue组件\x3ca href=\x22https:\/\/github.com\/Louiszhai\/canvas-draw\/blob\/master\/src\/utils\/iload.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eiload.js\x3c\/a\x3e去顺序加载这些资源并执行回调。一切看似很完美，结果发现demo引用的一个压缩的js中居然写死了插件相关DOM节点的id和style，此刻我的内心几乎是崩溃的。这样的一个插件我怕是无力引入了吧。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010120562\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010120562\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e虽然嘴上这么说，身体还是很诚实的，费尽千辛万苦我还是把这个插件用在了项目中。随着项目推进，业务上经过多次沟通，我们砍掉了该签名插件的数字证书验证部分。也就是说，这么大的一个插件，只剩下用户签名的功能，我完全可以自己做啊。于是我悄悄移除了这个插件，为这几天的调研和码字过程划上了一个完美的句号（深藏功与名）。\x3c\/p\x3e\n\x3cp\x3e签名是若干操作的集合，起于用户手写姓名，终于签名图片上传，中间还包含图片的处理，比如说减少锯齿、旋转、缩小、预览等。canvas几乎是最适合的解决方案。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e\x3cstrong\x3e手写\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e从交互上看，用户签名的过程，只有开始的手写部分是有交互的，后面是自动处理。为了完成手写，需要监听画布的两个事件：touchstart、touchmove（移动端touchend在touchmove之后不触发）。前者定义起始点，后者不停地描线。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const canvas = document.getElementById(\x27canvas\x27);\nconst touchstart = (e) =\x3e {\n  \/* TODO 定义起点 *\/\n};\nconst touchmove = (e) =\x3e {\n  \/* TODO 连点成线，并且填充颜色 *\/\n};\ncanvas.addEventListener(\x27touchstart\x27, touchstart);\ncanvas.addEventListener(\x27touchmove\x27, touchmove);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e canvas = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27canvas\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e touchstart = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* TODO 定义起点 *\/\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e touchmove = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/* TODO 连点成线，并且填充颜色 *\/\x3c\/span\x3e\n};\ncanvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27touchstart\x27\x3c\/span\x3e, touchstart);\ncanvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27touchmove\x27\x3c\/span\x3e, touchmove);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注： 以下默认canvas和context对象已有。\x3c\/p\x3e\n\x3cp\x3e可以先戳这里体验把后面将要提到的签名组件 \x3ca href=\x22http:\/\/louiszhai.github.io\/res\/canvasDraw\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecanvas-draw\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3e描线\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e既然要连点成线，自然需要一个变量来存储这些点。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const point = {};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e point = {};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来就是画线的部分。canvas画线只需4行代码：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e开始路径（beginPath）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e定位起点（moveTo）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e移动画笔（lineTo）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e绘制路径（stroke）\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e考虑到start和move两个动作，那么一个描线的方法就呼之欲出了，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const paint = (signal) =\x3e {\n  switch (signal) {\n    case 1: \/\/ 开始路径\n      context.beginPath();\n      context.moveTo(point.x, point.y);\n    case 2: \/\/ 前面之所以没有break语句，是为了点击时就能描画出一个点\n      context.lineTo(point.x, point.y);\n      context.stroke();\n      break;\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e paint = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3esignal\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (signal) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e: \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开始路径\x3c\/span\x3e\n      context.beginPath();\n      context.moveTo(point.x, point.y);\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e: \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 前面之所以没有break语句，是为了点击时就能描画出一个点\x3c\/span\x3e\n      context.lineTo(point.x, point.y);\n      context.stroke();\n      \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\x3cstrong\x3e绑定事件\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3e为了兼容PC端的类似需求，我们有必要区分下平台。移动端，使用手指操作，需要绑定的是touchstart和touchmove；PC端，使用鼠标操作，需要绑定的是mousedown和mousemove。如下一行代码可用于判断是否移动端：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const isMobile = \/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)\/i.test(navigator.userAgent);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e isMobile = \x3cspan class=\x22hljs-regexp\x22\x3e\/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)\/i\x3c\/span\x3e.test(navigator.userAgent);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e描线的方法准备妥当后，剩下的就是在适当的时候，记录当前划过的点，并且调用paint方法进行绘制。这里可以抽象出一个事件生成器：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let pressed = false; \/\/ 标示是否发生鼠标按下或者手指按下事件\nconst create = signal =\x3e (e) =\x3e {\n  if (signal === 1) {\n    pressed = true;\n  }\n  if (signal === 1 || pressed) {\n    e = isMobile ? e.touches[0] : e;\n    point.x = e.clientX - left \x2b 0.5; \/\/ 不加0.5，整数坐标处绘制直线，直线宽度将会多1px(不理解的不妨谷歌下)\n    point.y = e.clientY - top \x2b 0.5;\n    paint(signal);\n  }\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e pressed = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 标示是否发生鼠标按下或者手指按下事件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e create = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3esignal\x3c\/span\x3e =\x26gt;\x3c\/span\x3e (e) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (signal === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    pressed = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (signal === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e || pressed) {\n    e = isMobile ? e.touches[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] : e;\n    point.x = e.clientX - left \x2b \x3cspan class=\x22hljs-number\x22\x3e0.5\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不加0.5，整数坐标处绘制直线，直线宽度将会多1px(不理解的不妨谷歌下)\x3c\/span\x3e\n    point.y = e.clientY - top \x2b \x3cspan class=\x22hljs-number\x22\x3e0.5\x3c\/span\x3e;\n    paint(signal);\n  }\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码中的left和top并非内置变量，它们分别表示着画布距屏幕左边和顶部的像素距离，主要用于将屏幕坐标点转换为画布坐标点。以下是一种获取方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { left, top } = canvas.getBoundingClientRect();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { left, top } = canvas.getBoundingClientRect();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很明显，上述的事件生成器是一个高阶函数，用于固化signal参数并返回一个新的Function。基于此，start和move回调便呈现了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const start = create(1);\nconst move = create(2);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e start = create(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e move = create(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了避免UI过度绘制，让move操作执行得更加流畅，requestAnimationFrame优化自然是少不了的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const requestAnimationFrame = window.requestAnimationFrame;\nconst optimizedMove = requestAnimationFrame ? (e) =\x3e {\n  requestAnimationFrame(() =\x3e {\n    move(e);\n  });\n} : move;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e requestAnimationFrame = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.requestAnimationFrame;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e optimizedMove = requestAnimationFrame ? \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  requestAnimationFrame(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    move(e);\n  });\n} : move;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e剩下的也是绑定事件中关键的一步。PC端中，mousedown和mousemove没有先后顺序，不是每一次画布之上的鼠标移动都是有效的操作，因此我们使用pressed变量来保证mousemove事件回调只在mousedown事件之后执行。实际上，设置后的pressed变量总需要还原，还原的契机就是mouseup和mouseleave回调，由于mouseup事件并不总能触发（比如说鼠标移动到别的节点上才弹起，此时触发的是其他节点的mouseup事件），mouseleave便是鼠标移出画布时的兜底逻辑。而移动端的touch事件，其天然的连续性，保证了touchmove只会在touchstart之后触发，因此无须设置pressed变量，也不需要还原它。代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (isMobile) {\n  canvas.addEventListener(\x27touchstart\x27, start);\n  canvas.addEventListener(\x27touchmove\x27, optimizedMove);\n} else {\n  canvas.addEventListener(\x27mousedown\x27, start);\n  canvas.addEventListener(\x27mousemove\x27, optimizedMove);\n  [\x27mouseup\x27, \x27mouseleave\x27].forEach((event) =\x3e {\n    canvas.addEventListener(event, () =\x3e {\n      pressed = false;\n    });\n  });\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isMobile) {\n  canvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27touchstart\x27\x3c\/span\x3e, start);\n  canvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27touchmove\x27\x3c\/span\x3e, optimizedMove);\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  canvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27mousedown\x27\x3c\/span\x3e, start);\n  canvas.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27mousemove\x27\x3c\/span\x3e, optimizedMove);\n  [\x3cspan class=\x22hljs-string\x22\x3e\x27mouseup\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27mouseleave\x27\x3c\/span\x3e].forEach(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    canvas.addEventListener(event, () =\x26gt; {\n      pressed = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    });\n  });\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e\x3cstrong\x3e旋转\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e想要在移动端签名，往往面临着屏幕宽度不够的尴尬。竖屏下写不了几个汉字，甚至三个都够呛。如果app webview或浏览器不支持横屏展示，此时并不是意味着没有了办法，起码我们可以将整个网页旋转90°。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e方案一：起初我的想法是将画布也一同旋转90°，后来发现难以处理旋转后的坐标系和屏幕坐标系的对应关系，因此我采取了旋转90°绘制页面，但是正常布局画布的方案，从而保证坐标系的一致性（这样就不用重新纠正canvas画布的坐标系了，关于纠正坐标系后续还有方案二，请耐心阅读）。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e由于用户是横屏操作画布的，完成签名后，图片需要逆时针旋转90°才能保上传到服务器。因此还差一个旋转的方法。实际上，rotate方法可以旋转画布，drawImage方法可以在新的画布中绘制一张图片或老的画布，这种绘制的定制化程度很高。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3erotate\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3erotate用于旋转当前的画布。\x3c\/p\x3e\n\x3cp\x3e语法： \x3ccode\x3erotate(angle)\x3c\/code\x3e，angle表示旋转的弧度，这里需要将角度转换为弧度计算，比如顺时针旋转90°，angle的值就等于-\x3ccode\x3e90 * Math.PI \/ 180\x3c\/code\x3e。ratate旋转时默认以画布左上角为中心，如果需要以画布中心位置为中心，需要在rotate方法执行前将画布的坐标原点移至中心位置，旋转完成后，再移动回来。如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { width, height } = canvas;\ncontext.translate(width \/ 2, height \/ 2); \/\/ 坐标原点移至画布中心\ncontext.rotate(90 * Math.PI \/ 180); \/\/ 顺时针旋转90°\ncontext.translate(-width \/ 2, -height \/ 2); \/\/ 坐标原点还原到起始位置\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { width, height } = canvas;\ncontext.translate(width \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, height \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 坐标原点移至画布中心\x3c\/span\x3e\ncontext.rotate(\x3cspan class=\x22hljs-number\x22\x3e90\x3c\/span\x3e * \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.PI \/ \x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 顺时针旋转90°\x3c\/span\x3e\ncontext.translate(-width \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, -height \/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 坐标原点还原到起始位置\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实际上，这种变换处理，使用\x3ccode\x3etransform(Math.cos(90 * Math.PI \/ 180), 1, -1, Math.cos(90 * Math.PI \/ 180), 0, 0)\x3c\/code\x3e同样可以顺时针旋转90°。\x3c\/p\x3e\n\x3ch4\x3e\x3cstrong\x3edrawImage\x3c\/strong\x3e\x3c\/h4\x3e\n\x3cp\x3edrawImage用于绘制图片、画布或者视频，可自定义宽高、位置、甚至局部裁剪。它有三种形态的api：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3edrawImage(img,x,y)\x3c\/code\x3e，x，y为画布中的坐标，img可以是图片、画布或视频资源，表示在画布的指定坐标处绘制。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3edrawImage(img,x,y,width,height)\x3c\/code\x3e，width，height表示指定图片绘制后的宽高（可以任意缩放或调整宽高比例）。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3econtext.drawImage(img,sx,sy,swidth,sheight,x,y,width,height)\x3c\/code\x3e，sx，sy表示从指定的坐标位置裁剪原始图片，并且裁剪swidth的宽度和sheight的高度。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e通常情况下，我们可能需要旋转一张图片90°、180°或者-90°。代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const rotate = (degree, image) =\x3e {\n  degree = ~~degree;\n  if (degree !== 0) {\n    const maxDegree = 180;\n    const minDegree = -90;\n    if (degree \x3e maxDegree) {\n      degree = maxDegree;\n    } else if (degree \x3c minDegree) {\n      degree = minDegree;\n    }\n\n    const canvas = document.createElement(\x27canvas\x27);\n    const context = canvas.getContext(\x272d\x27);\n    const height = image.height;\n    const width = image.width;\n    const angle = (degree * Math.PI) \/ 180;\n\n    switch (degree) {\n      \/\/ 逆时针旋转90°\n      case -90:\n        canvas.width = height;\n        canvas.height = width;\n        context.rotate(angle);\n        context.drawImage(image, -width, 0);\n        break;\n      \/\/ 顺时针旋转90°\n      case 90:\n        canvas.width = height;\n        canvas.height = width;\n        context.rotate(angle);\n        context.drawImage(image, 0, -height);\n        break;\n      \/\/ 顺时针旋转180°\n      case 180:\n        canvas.width = width;\n        canvas.height = height;\n        context.rotate(angle);\n        context.drawImage(image, -width, -height);\n        break;\n    }\n    image = canvas;\n  }\n  return image;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e rotate = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edegree, image\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  degree = ~~degree;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (degree !== \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e maxDegree = \x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e minDegree = \x3cspan class=\x22hljs-number\x22\x3e-90\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (degree \x26gt; maxDegree) {\n      degree = maxDegree;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (degree \x26lt; minDegree) {\n      degree = minDegree;\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e canvas = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27canvas\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e context = canvas.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x272d\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e height = image.height;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e width = image.width;\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e angle = (degree * \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.PI) \/ \x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (degree) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 逆时针旋转90°\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-90\x3c\/span\x3e:\n        canvas.width = height;\n        canvas.height = width;\n        context.rotate(angle);\n        context.drawImage(image, -width, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 顺时针旋转90°\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e90\x3c\/span\x3e:\n        canvas.width = height;\n        canvas.height = width;\n        context.rotate(angle);\n        context.drawImage(image, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, -height);\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 顺时针旋转180°\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e:\n        canvas.width = width;\n        canvas.height = height;\n        context.rotate(angle);\n        context.drawImage(image, -width, -height);\n        \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n    }\n    image = canvas;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e image;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e\x3cstrong\x3e缩放\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e旋转后的画布，通常需要进一步格式化其宽高才能上传。此处还是利用drawImage去改变画布宽高，以达到缩小和放大的目的。如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const scale = (width, height) =\x3e {\n  const w = canvas.width;\n  const h = canvas.height;\n  width = width || w;\n  height = height || h;\n  if (width !== w || height !== h) {\n    const tmpCanvas = document.createElement(\x27canvas\x27);\n    const tmpContext = tmpCanvas.getContext(\x272d\x27);\n    tmpCanvas.width = width;\n    tmpCanvas.height = height;\n    tmpContext.drawImage(canvas, 0, 0, w, h, 0, 0, width, height);\n    canvas = tmpCanvas;\n  }\n  return canvas;\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e scale = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ewidth, height\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e w = canvas.width;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e h = canvas.height;\n  width = width || w;\n  height = height || h;\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (width !== w || height !== h) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e tmpCanvas = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27canvas\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e tmpContext = tmpCanvas.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x272d\x27\x3c\/span\x3e);\n    tmpCanvas.width = width;\n    tmpCanvas.height = height;\n    tmpContext.drawImage(canvas, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, w, h, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, width, height);\n    canvas = tmpCanvas;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e canvas;\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e\x3cstrong\x3e上传\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e我们做了这么多的操作和转换，最终的目的还是上传图片。\x3c\/p\x3e\n\x3cp\x3e首先，获取画布中的图片：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const getPNGImage = () =\x3e {\n  return canvas.toDataURL(\x27image\/png\x27);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e getPNGImage = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e canvas.toDataURL(\x3cspan class=\x22hljs-string\x22\x3e\x27image\/png\x27\x3c\/span\x3e);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3egetPNGImage方法返回的是dataURL，需要转换为Blob对象才能上传。如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const dataURLtoBlob = (dataURL) =\x3e {\n  const arr = dataURL.split(\x27,\x27);\n  const mime = arr[0].match(\/:(.*?);\/)[1];\n  const bStr = atob(arr[1]);\n  let n = bStr.length;\n  const u8arr = new Uint8Array(n);\n  while (n--) {\n    u8arr[n] = bStr.charCodeAt(n);\n  }\n  return new Blob([u8arr], { type: mime });\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e dataURLtoBlob = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edataURL\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e arr = dataURL.split(\x3cspan class=\x22hljs-string\x22\x3e\x27,\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mime = arr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e].match(\x3cspan class=\x22hljs-regexp\x22\x3e\/:(.*?);\/\x3c\/span\x3e)[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e bStr = atob(arr[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e n = bStr.length;\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e u8arr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eUint8Array\x3c\/span\x3e(n);\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (n--) {\n    u8arr[n] = bStr.charCodeAt(n);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Blob([u8arr], { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: mime });\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e完成了上面这些，才能一波ajax请求（xhr、fetch、axios都可）带走签名图片。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const upload = (blob, url, callback) =\x3e {\n  const formData = new FormData();\n  const xhr = new XMLHttpRequest();\n  xhr.withCredentials = true;\n  formData.append(\x27image\x27, blob, \x27sign\x27);\n\n  xhr.open(\x27POST\x27, url, true);\n  xhr.onload = () =\x3e {\n    if ((xhr.status \x3e= 200 \x26amp;\x26amp; xhr.status \x3c 300) || xhr.status === 304) {\n      callback(xhr.responseText);\n    }\n  };\n  xhr.onerror = (e) =\x3e {\n    console.log(`upload img error: ${e}`);\n  };\n  xhr.send(formData);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e upload = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eblob, url, callback\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e formData = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e FormData();\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest();\n  xhr.withCredentials = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n  formData.append(\x3cspan class=\x22hljs-string\x22\x3e\x27image\x27\x3c\/span\x3e, blob, \x3cspan class=\x22hljs-string\x22\x3e\x27sign\x27\x3c\/span\x3e);\n\n  xhr.open(\x3cspan class=\x22hljs-string\x22\x3e\x27POST\x27\x3c\/span\x3e, url, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n  xhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ((xhr.status \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e \x26amp;\x26amp; xhr.status \x26lt; \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e) || xhr.status === \x3cspan class=\x22hljs-number\x22\x3e304\x3c\/span\x3e) {\n      callback(xhr.responseText);\n    }\n  };\n  xhr.onerror = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`upload img error: \x3cspan class=\x22hljs-subst\x22\x3e${e}\x3c\/span\x3e`\x3c\/span\x3e);\n  };\n  xhr.send(formData);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e\x3cstrong\x3e设置\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e完成了上述功能，一个签名插件就已经成型了。除非你迫不及待想要发布，否则，这样的代码我是不建议拿出去的。一些必要的设置通常是不能忽略的。\x3c\/p\x3e\n\x3cp\x3e通常画布中的直线是1px大小，这么细的线，是不能模拟笔触的，可如果你要放大至10px，便会发现，绘制的直线其实是矩形。这在签名过程中也是不合适的，我们期望的是圆滑的笔触，因此需要尽量模拟手写。实际上，lineCap就可指定直线首尾圆滑，lineJoin可以指定线条交汇时的边角圆滑。如下是一个simple的设置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22context.lineWidth = 10;         \/\/ 直线宽度\ncontext.strokeStyle = \x27black\x27;     \/\/ 路径的颜色\ncontext.lineCap = \x27round\x27;         \/\/ 直线首尾端圆滑\ncontext.lineJoin = \x27round\x27;     \/\/ 当两条线条交汇时，创建圆形边角\ncontext.shadowBlur = 1;         \/\/ 边缘模糊，防止直线边缘出现锯齿\ncontext.shadowColor = \x27black\x27;  \/\/ 边缘颜色\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3econtext.lineWidth = \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直线宽度\x3c\/span\x3e\ncontext.strokeStyle = \x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e;     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 路径的颜色\x3c\/span\x3e\ncontext.lineCap = \x3cspan class=\x22hljs-string\x22\x3e\x27round\x27\x3c\/span\x3e;         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 直线首尾端圆滑\x3c\/span\x3e\ncontext.lineJoin = \x3cspan class=\x22hljs-string\x22\x3e\x27round\x27\x3c\/span\x3e;     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当两条线条交汇时，创建圆形边角\x3c\/span\x3e\ncontext.shadowBlur = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 边缘模糊，防止直线边缘出现锯齿\x3c\/span\x3e\ncontext.shadowColor = \x3cspan class=\x22hljs-string\x22\x3e\x27black\x27\x3c\/span\x3e;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 边缘颜色\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e\x3cstrong\x3e优化\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e一切看似很完美，直到遇到了retina屏幕。retina屏是用4个物理像素绘制一个虚拟像素，屏幕宽度相同的画布，其每个像素点都会由4倍物理像素去绘制，画布中点与点之间的距离增加，会产生较为明显的锯齿，可通过放大画布然后压缩展示来解决这个问题。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22let { width, height } = window.getComputedStyle(canvas, null);\nwidth = width.replace(\x27px\x27, \x27\x27);\nheight = height.replace(\x27px\x27, \x27\x27);\n\n\/\/ 根据设备像素比优化canvas绘图\nconst devicePixelRatio = window.devicePixelRatio;\nif (devicePixelRatio) {\n  canvas.style.width = `${width}px`;\n  canvas.style.height = `${height}px`;\n  canvas.height = height * devicePixelRatio; \/\/ 画布宽高放大\n  canvas.width = width * devicePixelRatio;\n  context.scale(devicePixelRatio, devicePixelRatio); \/\/ 画布内容放大相同的倍数\n} else {\n  canvas.width = width;\n  canvas.height = height;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e { width, height } = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.getComputedStyle(canvas, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e);\nwidth = width.replace(\x3cspan class=\x22hljs-string\x22\x3e\x27px\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\nheight = height.replace(\x3cspan class=\x22hljs-string\x22\x3e\x27px\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 根据设备像素比优化canvas绘图\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e devicePixelRatio = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.devicePixelRatio;\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (devicePixelRatio) {\n  canvas.style.width = \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${width}\x3c\/span\x3epx`\x3c\/span\x3e;\n  canvas.style.height = \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${height}\x3c\/span\x3epx`\x3c\/span\x3e;\n  canvas.height = height * devicePixelRatio; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 画布宽高放大\x3c\/span\x3e\n  canvas.width = width * devicePixelRatio;\n  context.scale(devicePixelRatio, devicePixelRatio); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 画布内容放大相同的倍数\x3c\/span\x3e\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  canvas.width = width;\n  canvas.height = height;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e\x3cstrong\x3e重置坐标系\x3c\/strong\x3e\x3c\/h3\x3e\n\x3cp\x3e由于采取了方案一，签名的工作流变成了：『页面顺时针旋转90°绘制、画布正常竖屏绘制』—\x26gt;『手写签名』—\x26gt;『逆时针旋转画布90°』—\x26gt; 『合理缩放画布至屏幕宽度』—\x26gt; 『导出图片并上传』。由此可见方案一流程复杂，处理起来也比较麻烦。\x3c\/p\x3e\n\x3cp\x3e换个角度想想，既然画布是可以旋转的，我刚好可以利用这种坐标系的反向旋转去抵消页面的正向旋转，这样页面上点的坐标就可以映射到画布本身的坐标上。于是有了方案二。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e方案二：页面顺时针旋转90°，画布跟随着一起旋转（画布的坐标系也跟着旋转90°）；然后再逆向旋转画布90°，重置画布的坐标系，使之与页面坐标系映射起来。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e顺时针旋转90°的页面如下所示：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010120563\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010120563\x22 alt=\x22页面顺时针旋转90°\x22 title=\x22页面顺时针旋转90°\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e此时canvas画布也随着页面顺时针旋转90°，想要重置画布坐标系，可借由rotate逆向旋转90°，然后由translate平移坐标系。以下代码包含了顺逆时针旋转90°、180° 的处理（为了便于描述，假设画布充满屏幕）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22context.rotate((degree * Math.PI) \/ 180);\nswitch (degree) {\n  \/\/ 页面顺时针旋转90°后，画布左上角的原点位置落到了屏幕的右上角（此时宽高互换），围绕原点逆时针旋转90°后，画布与原位置垂直，居于屏幕右侧，需要向左平移画布当前高度相同的距离。\n  case -90:\n    context.translate(-height, 0);\n    break;\n  \/\/ 页面逆时针旋转90°后，画布左上角的原点位置落到了屏幕的左下角（此时宽高互换），围绕原点顺时针旋转90°后，画布与原位置垂直，居于屏幕下侧，需要向上平移画布当前宽度相同的距离。\n  case 90:\n    context.translate(0, -width);\n    break;\n  \/\/ 页面顺逆时针旋转180°回到了同一个位置（即页面倒立），画布左上角的原点位置落到了屏幕的右下角（此时宽高不变），围绕原点反方向旋转180°后，画布与原位置平行，居于屏幕右侧的下侧，需要向左平移画布宽度相同的距离，向右平移画布高度的距离。\n  case -180:\n  case 180:\n    context.translate(-width, -height);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3econtext.rotate((degree * \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.PI) \/ \x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (degree) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 页面顺时针旋转90°后，画布左上角的原点位置落到了屏幕的右上角（此时宽高互换），围绕原点逆时针旋转90°后，画布与原位置垂直，居于屏幕右侧，需要向左平移画布当前高度相同的距离。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-90\x3c\/span\x3e:\n    context.translate(-height, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 页面逆时针旋转90°后，画布左上角的原点位置落到了屏幕的左下角（此时宽高互换），围绕原点顺时针旋转90°后，画布与原位置垂直，居于屏幕下侧，需要向上平移画布当前宽度相同的距离。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e90\x3c\/span\x3e:\n    context.translate(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, -width);\n    \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 页面顺逆时针旋转180°回到了同一个位置（即页面倒立），画布左上角的原点位置落到了屏幕的右下角（此时宽高不变），围绕原点反方向旋转180°后，画布与原位置平行，居于屏幕右侧的下侧，需要向左平移画布宽度相同的距离，向右平移画布高度的距离。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-180\x3c\/span\x3e:\n  \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e180\x3c\/span\x3e:\n    context.translate(-width, -height);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e拥有了对画布坐标系重置的能力，我们能够将画布逆时针旋转90°、甚至180°，都是可行的。如下：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010120564\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010120564\x22 alt=\x22页面逆时针旋转90°\x22 title=\x22页面逆时针旋转90°\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010120565\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010120565\x22 alt=\x22页面顺时针旋转180°\x22 title=\x22页面顺时针旋转180°\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e当然重置画布坐标系后，需要注意清屏时，清屏的范围也有可能发生变化，需要稍作如下处理。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const clear = () =\x3e {\n  let width;\n  let height;\n  switch (this.degree) { \/\/ this.degree是画布坐标系旋转的度数\n    case -90:\n    case 90:\n      width = this.height; \/\/ 画布旋转之前的高度\n      height = this.width; \/\/ 画布选择之前的宽度\n      break;\n    default:\n      width = this.width;\n      height = this.height;\n  }\n  this.context.clearRect(0, 0, width, height);\n};\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e clear = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e width;\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e height;\n  \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.degree) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.degree是画布坐标系旋转的度数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e-90\x3c\/span\x3e:\n    \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e90\x3c\/span\x3e:\n      width = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.height; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 画布旋转之前的高度\x3c\/span\x3e\n      height = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.width; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 画布选择之前的宽度\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e:\n      width = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.width;\n      height = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.height;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.context.clearRect(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, width, height);\n};\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e方案一简单粗暴，布局上，canvas画布虽然不需要旋转，但需要单独绝对定位布局，给页面视觉展示带来不便，同时，上传图片之前需要对图片做旋转、缩放等处理，流程复杂。\x3c\/p\x3e\n\x3cp\x3e方案二用纠正画布坐标系的方式，省去了布局和图片上的特殊处理，一步到位，因此方案二更佳。\x3c\/p\x3e\n\x3cp\x3e以上，涉及的代码可以在这里找到：\x3ca href=\x22https:\/\/github.com\/Louiszhai\/canvas-draw\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecanvas-draw\x3c\/a\x3e，这是一个借助vue cli 搭建起来的壳，主要是为了方便调试，核心代码见 \x3ca href=\x22https:\/\/github.com\/Louiszhai\/canvas-draw\/blob\/master\/src\/utils\/draw.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecanvas-draw\/draw.js\x3c\/a\x3e，喜欢的同学不妨轻点star。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e本问就讨论这么多内容,大家有什么问题或好的想法欢迎在下方参与留言和评论.\x3c\/p\x3e\n\x3cp\x3e本文作者：\x3ca href=\x22https:\/\/github.com\/Louiszhai\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3elouis\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e本文链接: \x3ca href=\x22http:\/\/louiszhai.github.io\/2017\/07\/07\/canvas-draw\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/louiszhai.github.io\/20...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e参考文章：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/hemei\/p\/4252817.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eHTML5 canvas transform与矩阵\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/fangsmile\/p\/5647390.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCanvas之平移translate、旋转rotate、缩放scale\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>匠心打造canvas签名组件</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010120557">https://segmentfault.com/a/1190000010120557</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/cr82xzzcjgr/" target="_blank">https://alili.tech/archive/cr82xzzcjgr/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>