<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="javascript原生一步步实现bind分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>javascript原生一步步实现bind分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/pzonaco1jtf/",
				"appid": "1613049289050283", 
				"title": "javascript原生一步步实现bind分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-01T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/xupzg5qj5e/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/6ky6j3hsnx5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f&text=javascript%e5%8e%9f%e7%94%9f%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ae%9e%e7%8e%b0bind%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f&text=javascript%e5%8e%9f%e7%94%9f%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ae%9e%e7%8e%b0bind%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f&title=javascript%e5%8e%9f%e7%94%9f%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ae%9e%e7%8e%b0bind%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f&is_video=false&description=javascript%e5%8e%9f%e7%94%9f%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ae%9e%e7%8e%b0bind%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=javascript%e5%8e%9f%e7%94%9f%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ae%9e%e7%8e%b0bind%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f&title=javascript%e5%8e%9f%e7%94%9f%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ae%9e%e7%8e%b0bind%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f&title=javascript%e5%8e%9f%e7%94%9f%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ae%9e%e7%8e%b0bind%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f&title=javascript%e5%8e%9f%e7%94%9f%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ae%9e%e7%8e%b0bind%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fpzonaco1jtf%2f&title=javascript%e5%8e%9f%e7%94%9f%e4%b8%80%e6%ad%a5%e6%ad%a5%e5%ae%9e%e7%8e%b0bind%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">javascript原生一步步实现bind分析</h1><div class="meta"><div class="postdate"><time datetime="2019-02-01" itemprop="datePublished">2019-02-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3ebind\x3c\/h1\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e官方描述\x3c\/h2\x3e\n\x3cp\x3ebind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。\x3ccode\x3e一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。\x3c\/code\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e使用介绍\x3c\/h2\x3e\n\x3cp\x3e由于\x3ccode\x3ejavascript\x3c\/code\x3e中作用域是由其运行时候所处的环境决定的，所以往往函数定义和实际运行的时候所处环境不一样，那么作用域也会发生相应的变化。\x3cbr\x3e例如下面这个情况：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var id = \x27window\x27;\n\/\/定义一个函数，但是不立即执行\nvar test = function(){\n    console.log(this.id)\n}\ntest() \/\/ window\n\/\/把test作为参数传递\nvar obj = {\n    id:\x27obj\x27,\n    hehe:test\n}\n\/\/此时test函数运行环境发生了改变\nobj.hehe() \/\/ \x27obj\x27\n\/\/为了避免这种情况，javascript里面有一个bind方法可以在函数运行之前就绑定其作用域，修改如下\n\nvar id = \x27window\x27;\nvar test = function(){\n    console.log(this.id)\n}.bind(window)\nvar obj = {\n    id:\x27obj\x27,\n    hehe:test\n}\ntest() \/\/ window\nobj.hehe() \/\/ window\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e id = \x3cspan class=\x22hljs-string\x22\x3e\x27window\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/定义一个函数，但是不立即执行\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e test = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id)\n}\ntest() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ window\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/把test作为参数传递\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27obj\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ehehe\x3c\/span\x3e:test\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/此时test函数运行环境发生了改变\x3c\/span\x3e\nobj.hehe() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27obj\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/为了避免这种情况，javascript里面有一个bind方法可以在函数运行之前就绑定其作用域，修改如下\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e id = \x3cspan class=\x22hljs-string\x22\x3e\x27window\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e test = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id)\n}.bind(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27obj\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ehehe\x3c\/span\x3e:test\n}\ntest() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ window\x3c\/span\x3e\nobj.hehe() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ window\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面介绍了\x3ccode\x3ebind\x3c\/code\x3e方法的一个重要作用就是为一个函数绑定作用域，但是\x3ccode\x3ebind\x3c\/code\x3e方法在低版本浏览器不兼容，这里我们可以手动实现一下。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e拆分一下关键思路\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e因为bind方法不会立即执行函数，需要返回一个待执行的函数（这里用到闭包，可以返回一个函数）\x3ccode\x3ereturn function(){}\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e作用域绑定，这里可以使用apply或者call方法来实现 \x3ccode\x3exx.call(yy)\/xx.apply(yy)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e参数传递，由于参数的不确定性，需要用apply传递数组（\x3ccode\x3e实例更明了\x3c\/code\x3e）\x3ccode\x3exx.apply(yy,[...Array...])，如果用call就不太方便了，因为call后面的参数需要一个个列出来\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e实现\x3c\/h2\x3e\n\x3cp\x3e有了上述的思路，大致的雏形已经明了了，代码应该也很容易实现\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e绑定作用域，绑定传参\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Function.prototype.testBind = function(that){\n    var _this = this,\n        \/*\n        *由于参数的不确定性，统一用arguments来处理，这里的arguments只是一个类数组对象，有length属性\n        *可以用数组的slice方法转化成标准格式数组，除了作用域对象that以外，\n        *后面的所有参数都需要作为数组参数传递\n        *Array.prototype.slice.apply(arguments,[1])\/Array.prototype.slice.call(arguments,1)\n        *\/\n        slice = Array.prototype.slice,\n        args = slice.apply(arguments,[1]);\n    \/\/返回函数    \n    return function(){\n        \/\/apply绑定作用域，进行参数传递\n        return _this.apply(that,args)\n    }    \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e.prototype.testBind = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ethat\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/*\n        *由于参数的不确定性，统一用arguments来处理，这里的arguments只是一个类数组对象，有length属性\n        *可以用数组的slice方法转化成标准格式数组，除了作用域对象that以外，\n        *后面的所有参数都需要作为数组参数传递\n        *Array.prototype.slice.apply(arguments,[1])\/Array.prototype.slice.call(arguments,1)\n        *\/\x3c\/span\x3e\n        slice = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice,\n        args = slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/返回函数    \x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/apply绑定作用域，进行参数传递\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this.apply(that,args)\n    }    \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e测试\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var test = function(a,b){\n    console.log(\x27作用域绑定 \x27\x2b this.value)\n    console.log(\x27testBind参数传递 \x27\x2b a.value2)\n    console.log(\x27调用参数传递 \x27 \x2b b)\n}\nvar obj = {\n    value:\x27ok\x27\n}\nvar fun_new = test.testBind(obj,{value2:\x27also ok\x27})\n\nfun_new (\x27hello bind\x27)\n\/\/ 作用域绑定 ok\n\/\/ testBind参数传递 also ok\n\/\/ 调用参数传递  undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e test = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea,b\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27作用域绑定 \x27\x3c\/span\x3e\x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value)\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27testBind参数传递 \x27\x3c\/span\x3e\x2b a.value2)\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27调用参数传递 \x27\x3c\/span\x3e \x2b b)\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27ok\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fun_new = test.testBind(obj,{\x3cspan class=\x22hljs-attr\x22\x3evalue2\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27also ok\x27\x3c\/span\x3e})\n\nfun_new (\x3cspan class=\x22hljs-string\x22\x3e\x27hello bind\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 作用域绑定 ok\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ testBind参数传递 also ok\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用参数传递  undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e动态参数\x3c\/h2\x3e\n\x3cp\x3e上面已经实现了\x3ccode\x3ebind\x3c\/code\x3e方法的作用域绑定，但是美中不足的是，既然我们返回的是一个函数，调用的时候应该支持传递参数，很显然，上面的 \x3ccode\x3efun_new\x3c\/code\x3e 调用的时候并不支持传参，只能在 \x3ccode\x3etestBind\x3c\/code\x3e 绑定的时候传递参数，因为我们最终调用的是这个返回函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function(){\n        return _this.apply(that,args)\n    }    \n\n这里面的args在绑定的时候就已经确定了，调用的时候值已经固定，\n我们并没有处理这个function传递的参数。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this.apply(that,args)\n    }    \n\n这里面的args在绑定的时候就已经确定了，调用的时候值已经固定，\n我们并没有处理这个\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3c\/span\x3e传递的参数。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们对其进行改造\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22return function(){\n        return _this.apply(that,\n            args.concat(Array.prototype.slice.apply(arguments,[0]))\n        )\n    }    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this.apply(that,\n            args.concat(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]))\n        )\n    }    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的 \x3ccode\x3eArray.prototype.slice.apply(arguments,[0])\x3c\/code\x3e 指的是这个返回函数执行的时候传递的一系列参数，所以是从第一个参数开始 \x3ccode\x3e[0]\x3c\/code\x3e ,之前的\x3ccode\x3eargs = slice.apply(arguments,[1])\x3c\/code\x3e指的是 \x3ccode\x3etestBind\x3c\/code\x3e方法执行时候传递的参数，所以从第二个开始 \x3ccode\x3e[1]\x3c\/code\x3e，两则有本质区别，不能搞混，\x3ccode\x3e只有两者合并了之后才是返回函数的完整参数\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e所以有如下实现\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Function.prototype.testBind = function(that){\n    var _this = this,\n        slice = Array.prototype.slice,\n        args = slice.apply(arguments,[1]);\n    return function(){\n        return _this.apply(that,\n                    args.concat(Array.prototype.slice.apply(arguments,[0]))\n                )\n    }    \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e.prototype.testBind = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ethat\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\n        slice = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice,\n        args = slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this.apply(that,\n                    args.concat(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]))\n                )\n    }    \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e测试\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var test = function(a,b){\n    console.log(\x27作用域绑定 \x27\x2b this.value)\n    console.log(\x27testBind参数传递 \x27\x2b a.value2)\n    console.log(\x27调用参数传递 \x27 \x2b b)\n}\nvar obj = {\n    value:\x27ok\x27\n}\nvar fun_new = test.testBind(obj,{value2:\x27also ok\x27})\n\nfun_new (\x27hello bind\x27)\n\/\/ 作用域绑定 ok\n\/\/ testBind参数传递 also ok\n\/\/ 调用参数传递  hello bind\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e test = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea,b\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27作用域绑定 \x27\x3c\/span\x3e\x2b \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value)\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27testBind参数传递 \x27\x3c\/span\x3e\x2b a.value2)\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27调用参数传递 \x27\x3c\/span\x3e \x2b b)\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = {\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27ok\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fun_new = test.testBind(obj,{\x3cspan class=\x22hljs-attr\x22\x3evalue2\x3c\/span\x3e:\x3cspan class=\x22hljs-string\x22\x3e\x27also ok\x27\x3c\/span\x3e})\n\nfun_new (\x3cspan class=\x22hljs-string\x22\x3e\x27hello bind\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 作用域绑定 ok\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ testBind参数传递 also ok\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用参数传递  hello bind\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在以上2种传参方式中，\x3ccode\x3ebind\x3c\/code\x3e的优先级高，从 \x3ccode\x3eargs.concat(Array.prototype.slice.apply(arguments,[0]))\x3c\/code\x3e 也可以看出来，\x3ccode\x3ebind\x3c\/code\x3e的参数在数组前面。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e原型链\x3c\/h2\x3e\n\x3cp\x3e官方文档上有一句话:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22A bound function may also be constructed using the new operator: doing\nso acts as though the target function had instead been constructed.\nThe provided this value is ignored, while prepended arguments are\nprovided to the emulated function.\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode\x3eA bound \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emay\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ealso\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebe\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econstructed\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eusing\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ethe\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eoperator\x3c\/span\x3e: \x3cspan class=\x22hljs-title\x22\x3edoing\x3c\/span\x3e\x3c\/span\x3e\nso acts \x3cspan class=\x22hljs-keyword\x22\x3eas\x3c\/span\x3e though \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e target \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ehad\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einstead\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebeen\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econstructed\x3c\/span\x3e.\x3c\/span\x3e\nThe provided this \x3cspan class=\x22hljs-built_in\x22\x3evalue\x3c\/span\x3e is ignored, \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e prepended arguments are\nprovided \x3cspan class=\x22hljs-built_in\x22\x3eto\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e emulated \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e.\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e说明绑定过后的函数被\x3ccode\x3enew\x3c\/code\x3e实例化之后，需要继承原函数的原型链方法，且绑定过程中提供的this被忽略（继承原函数的this对象），但是参数还是会使用。\x3cbr\x3e这里就需要一个中转函数把原型链传递下去\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fNOP = function () {} \/\/创建一个中转函数\nfNOP.prototype = this.prototype;\nxx.prototype = new fNOP() \n修改如下\nFunction.prototype.testBind = function(that){\n    var _this = this,\n        slice = Array.prototype.slice,\n        args = slice.apply(arguments,[1]),\n        fNOP = function () {},\n        \/\/所以调用官方bind方法之后 有一个name属性值为 \x27bound \x27\n        bound = function(){\n            return _this.apply(that,\n                args.concat(Array.prototype.slice.apply(arguments,[0]))\n            )\n        }    \n\n    fNOP.prototype = _this.prototype;\n\n    bound.prototype = new fNOP();\n\n    return bound;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3efNOP = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{} \x3cspan class=\x22hljs-comment\x22\x3e\/\/创建一个中转函数\x3c\/span\x3e\nfNOP.prototype = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.prototype;\nxx.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e fNOP() \n修改如下\n\x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e.prototype.testBind = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ethat\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\n        slice = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice,\n        args = slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]),\n        fNOP = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{},\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/所以调用官方bind方法之后 有一个name属性值为 \x27bound \x27\x3c\/span\x3e\n        bound = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this.apply(that,\n                args.concat(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]))\n            )\n        }    \n\n    fNOP.prototype = _this.prototype;\n\n    bound.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e fNOP();\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bound;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而且\x3ccode\x3ebind\x3c\/code\x3e方法的第一个参数\x3ccode\x3ethis\x3c\/code\x3e是可以不传的，需要分2种情况\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e直接调用bind之后的方法\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var f = function () { console.log(\x27不传默认为\x27\x2bthis)  };f.bind()()\n\/\/ 不传默认为 Window \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e f = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27不传默认为\x27\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)  };f.bind()()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不传默认为 Window \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e所以直接调用绑定方法时候\x3c\/code\x3e  \x3ccode\x3eapply(that,\x3c\/code\x3e 建议改为 \x3ccode\x3eapply(that||window,\x3c\/code\x3e，其实不改也可以，因为不传默认指向window\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e使用\x3ccode\x3enew\x3c\/code\x3e实例化被绑定的方法\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3e容易糊涂，重点在于弄清楚标准的bind方法在new的时候做的事情，然后就可以清晰的实现\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e这里我们需要看看 \x3ccode\x3enew\x3c\/code\x3e 这个方法做了哪些操作  比如说  \x3ccode\x3evar  a  = new  b()\x3c\/code\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e创建一个空对象 \x3ccode\x3ea = {}\x3c\/code\x3e，并且\x3ccode\x3ethis\x3c\/code\x3e变量引用指向到这个空对象\x3ccode\x3ea\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e继承被实例化函数的原型 ：\x3ccode\x3ea.__proto__ = b.prototype\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e被实例化方法\x3ccode\x3eb\x3c\/code\x3e的\x3ccode\x3ethis\x3c\/code\x3e对象的属性和方法将被加入到这个新的 \x3ccode\x3ethis\x3c\/code\x3e 引用的对象中： \x3ccode\x3eb\x3c\/code\x3e的属性和方法被加入的 \x3ccode\x3ea\x3c\/code\x3e里面\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e新创建的对象由 \x3ccode\x3ethis\x3c\/code\x3e 所引用 ：\x3ccode\x3eb.call(a)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e通过以上可以得知，如果是\x3ccode\x3evar after_new =  new bindFun();\x3c\/code\x3e 由于这种行为是把原函数当成构造器，那么那么最终实例化之后的对象 \x3ccode\x3ethis\x3c\/code\x3e需要继承自原函数, 而这里的 \x3ccode\x3ebindFun\x3c\/code\x3e 目前是\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function(){\n            return _this.apply(that || window,\n                args.concat(Array.prototype.slice.apply(arguments,[0]))\n            )\n        }    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this.apply(that || \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e,\n                args.concat(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]))\n            )\n        }    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里\x3ccode\x3eapply\x3c\/code\x3e的作用域是绑定的\x3ccode\x3ethat || window\x3c\/code\x3e，在执行 \x3ccode\x3etestBind()\x3c\/code\x3e的时候就已经固定，并没有把原函数的this对象继承过来，不符合我们的要求，我们需要根据apply的特性解决这个问题：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22在一个子构造函数中，你可以通过调用父构造函数的 `apply\/call` 方法来实现继承\n\n例如\n\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs autohotkey\x22\x3e\x3ccode\x3e在一个子构造函数中，你可以通过调用父构造函数的 `apply\/call` 方法来实现继承\n\n例如\n\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Product(name, price) {\n  this.name = name;\n  this.price = price;\n\n  if (price \x3c 0) {\n    throw RangeError(\x27Cannot create product \x27 \x2b\n                      this.name \x2b \x27 with a negative price\x27);\n  }\n}\n\nfunction Food(name, price) {\n  Product.call(this, name, price); \n  this.category = \x27food\x27;\n}\n\n\/\/等同于（其实就是把Product放在Food内部执行了一次）\nfunction Food(name, price) { \n    this.name = name;\n    this.price = price;\n    if (price \x3c 0) {\n        throw RangeError(\x27Cannot create product \x27 \x2b\n                this.name \x2b \x27 with a negative price\x27);\n    }\n\n    this.category = \x27food\x27; \n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eProduct\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, price\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.price = price;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (price \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRangeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot create product \x27\x3c\/span\x3e \x2b\n                      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 with a negative price\x27\x3c\/span\x3e);\n  }\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFood\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, price\x3c\/span\x3e) \x3c\/span\x3e{\n  Product.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, name, price); \n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.category = \x3cspan class=\x22hljs-string\x22\x3e\x27food\x27\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/等同于（其实就是把Product放在Food内部执行了一次）\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFood\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, price\x3c\/span\x3e) \x3c\/span\x3e{ \n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.price = price;\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (price \x26lt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRangeError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Cannot create product \x27\x3c\/span\x3e \x2b\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 with a negative price\x27\x3c\/span\x3e);\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.category = \x3cspan class=\x22hljs-string\x22\x3e\x27food\x27\x3c\/span\x3e; \n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所以在\x3ccode\x3enew\x3c\/code\x3e新的实例的时候实时将这个新的\x3ccode\x3ethis\x3c\/code\x3e对象 进行 \x3ccode\x3eapply\x3c\/code\x3e 继承原函数的 \x3ccode\x3ethis\x3c\/code\x3e 对象，就可以达到  \x3ccode\x3enew\x3c\/code\x3e 方法里面的第 3 步的结果\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22apply(that||window,\n\/\/修改为 如果是new的情况，需要绑定new之后的作用域，this指向新的实例对象\napply(isNew ?　this : that||window,  ==\x3e\n\nFunction.prototype.testBind = function(that){\n    var _this = this,\n        slice = Array.prototype.slice,\n        args = slice.apply(arguments,[1]),\n        fNOP = function () {},\n        \/\/所以调用官方bind方法之后 有一个name属性值为 \x27bound \x27\n        bound = function(){\n            return _this.apply(isNew ?　this : that||window,\n                args.concat(Array.prototype.slice.apply(arguments,[0]))\n            )\n        }    \n\n    fNOP.prototype = _this.prototype;\n\n    bound.prototype = new fNOP();\n\n    return bound;\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3eapply(that||\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e,\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/修改为 如果是new的情况，需要绑定new之后的作用域，this指向新的实例对象\x3c\/span\x3e\napply(isNew ?　\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e : that||\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e,  ==\x26gt;\n\n\x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e.prototype.testBind = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ethat\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\n        slice = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice,\n        args = slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]),\n        fNOP = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{},\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/所以调用官方bind方法之后 有一个name属性值为 \x27bound \x27\x3c\/span\x3e\n        bound = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this.apply(isNew ?　\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e : that||\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e,\n                args.concat(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]))\n            )\n        }    \n\n    fNOP.prototype = _this.prototype;\n\n    bound.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e fNOP();\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bound;\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的 \x3ccode\x3eisNew\x3c\/code\x3e 是区分 \x3ccode\x3ebindFun\x3c\/code\x3e 是直接调用还是被 \x3ccode\x3enew\x3c\/code\x3e 之后再调用，通过原型链的继承关系可以知道，\x3cbr\x3e\x3ccode\x3ebindFun\x3c\/code\x3e 属于 \x3ccode\x3eafter_new\x3c\/code\x3e的父类，所以 \x3ccode\x3eafter_new instanceof  bindFun 为 true,\x3c\/code\x3e同时\x3cbr\x3e\x3ccode\x3ebindFun.prototype = new fNOP()\x3c\/code\x3e 原型继承; 所以 \x3ccode\x3efNOP\x3c\/code\x3e 也是 \x3ccode\x3eafter_new\x3c\/code\x3e的父类， \x3ccode\x3eafter_new instanceof  fNOP 为 true\x3c\/code\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e最终结果\x3c\/h2\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Function.prototype.testBind = function(that){\n        var _this = this,\n            slice = Array.prototype.slice,\n            args = slice.apply(arguments,[1]),\n            fNOP = function () {},\n            bound = function(){\n                \/\/这里的this指的是调用时候的环境\n                return _this.apply(this instanceof  fNOP ?　this : that||window,\n                    args.concat(Array.prototype.slice.apply(arguments,[0]))\n                )\n            }    \n        fNOP.prototype = _this.prototype;\n    \n        bound.prototype = new fNOP();\n    \n        return bound;\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3eFunction\x3c\/span\x3e.prototype.testBind = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ethat\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e _this = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e,\n            slice = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice,\n            args = slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]),\n            fNOP = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{},\n            bound = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里的this指的是调用时候的环境\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e _this.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e  fNOP ?　\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e : that||\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e,\n                    args.concat(\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.apply(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e,[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]))\n                )\n            }    \n        fNOP.prototype = _this.prototype;\n    \n        bound.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e fNOP();\n    \n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e bound;\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我看到有些地方写的是\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this instanceof fNOP \x26amp;\x26amp; that ? this : that || window,\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livescript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e fNOP \x26amp;\x26amp; \x3cspan class=\x22hljs-literal\x22\x3ethat\x3c\/span\x3e ? \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e : \x3cspan class=\x22hljs-literal\x22\x3ethat\x3c\/span\x3e || \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e,\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我个人觉得这里有点不正确，如果绑定时候不传参数，那么\x3ccode\x3ethat\x3c\/code\x3e就为空，那无论怎样就只能绑定 window作用域了。\x3c\/p\x3e\n\x3cp\x3e以上是个人见解，不对的地方望指导，谢谢！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>javascript原生一步步实现bind分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007342882">https://segmentfault.com/a/1190000007342882</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/pzonaco1jtf/" target="_blank">https://alili.tech/archive/pzonaco1jtf/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>