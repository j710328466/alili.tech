<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="我所认识的JavaScript作用域链和原型链"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>我所认识的JavaScript作用域链和原型链 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/hkl9q5ubbg9/",
				"appid": "1613049289050283", 
				"title": "我所认识的JavaScript作用域链和原型链 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-10T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/pqz91ilw7h/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/lbjnuilqrt/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f&text=%e6%88%91%e6%89%80%e8%ae%a4%e8%af%86%e7%9a%84JavaScript%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be%e5%92%8c%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f&text=%e6%88%91%e6%89%80%e8%ae%a4%e8%af%86%e7%9a%84JavaScript%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be%e5%92%8c%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f&title=%e6%88%91%e6%89%80%e8%ae%a4%e8%af%86%e7%9a%84JavaScript%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be%e5%92%8c%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f&is_video=false&description=%e6%88%91%e6%89%80%e8%ae%a4%e8%af%86%e7%9a%84JavaScript%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be%e5%92%8c%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%88%91%e6%89%80%e8%ae%a4%e8%af%86%e7%9a%84JavaScript%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be%e5%92%8c%e5%8e%9f%e5%9e%8b%e9%93%be&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f&title=%e6%88%91%e6%89%80%e8%ae%a4%e8%af%86%e7%9a%84JavaScript%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be%e5%92%8c%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f&title=%e6%88%91%e6%89%80%e8%ae%a4%e8%af%86%e7%9a%84JavaScript%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be%e5%92%8c%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f&title=%e6%88%91%e6%89%80%e8%ae%a4%e8%af%86%e7%9a%84JavaScript%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be%e5%92%8c%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhkl9q5ubbg9%2f&title=%e6%88%91%e6%89%80%e8%ae%a4%e8%af%86%e7%9a%84JavaScript%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%93%be%e5%92%8c%e5%8e%9f%e5%9e%8b%e9%93%be"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">我所认识的JavaScript作用域链和原型链</h1><div class="meta"><div class="postdate"><time datetime="2019-01-10" itemprop="datePublished">2019-01-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e　　毕业也整整一年了，看着很多学弟都毕业了，忽然心中颇有感慨，时间一去不复还呀。记得从去年这个时候接触到JavaScript,从一开始就很喜欢这门语言，当时迷迷糊糊看完了《JavaScript高级程序设计》这本书，似懂非懂。这几天又再次回顾了这本书，之前很多不理解的内容似乎开始有些豁然开朗了。为了防止之后自己又开始模糊，所以自己来总结一下JavaScript中关于 作用域链和原型链的知识，并将二者相比较看待进一步加深理解。以下内容都纯属于自己的理解，有不对的地方欢迎指正。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e作用域链\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e作用域\x3c\/h3\x3e\n\x3cp\x3e　　首先我们需要了解的是作用域做什么的？当JavaScript引擎在某一作用域中遇见\x3cstrong\x3e变量\x3c\/strong\x3e和\x3cstrong\x3e函数\x3c\/strong\x3e的时候，需要能够明确变量和函数所对应的值是什么，所以就需要作用域来对变量和函数进行查找，并且还需要确定当前代码是否对该变量具有访问权限。也就是说作用域主要有以下的任务:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e收集并维护所有声明的标识符(变量和函数)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e依照特定的规则对标识符进行查找\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e确定当前的代码对标识符的访问权限\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e　　举一个例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(a) {\n    console.log( a ); \/\/ 2\n}\n\nfoo( 2 );\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log( a ); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\n}\n\nfoo( \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e );\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　对于上述代码，JavaScript引擎需要对作用域发出以下的命令\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e查询标识符\x3ccode\x3efoo\x3c\/code\x3e,得到变量后执行该变量\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e查询标识符\x3ccode\x3ea\x3c\/code\x3e,得到变量后对其赋值为2\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e查询标识符\x3ccode\x3econsole\x3c\/code\x3e,得到变量后准备执行属性\x3ccode\x3elog\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e查询标识符\x3ccode\x3ea\x3c\/code\x3e,得到变量后，作为参数传入\x3ccode\x3econsole.log\x3c\/code\x3e执行\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e　　我们省略了函数\x3ccode\x3econsole.log\x3c\/code\x3e内部的执行过程，我们可以看到对JavaScript引擎来说，作用域最重要的功能就是查询标识符。从上面的例子来看，引擎对变量的使用其实不是都一样的。比如第一步引擎得到标识符\x3ccode\x3efoo\x3c\/code\x3e的目的是执行它(或者说是为了拿到标识符里存储的值)。\x3cbr\x3e但第二步中引擎查找标识符\x3ccode\x3ea\x3c\/code\x3e的目的是为了对其赋值(也就是改变存储的值)。所以查找也分为两种：\x3cstrong\x3e\x3ccode\x3eLHS\x3c\/code\x3e\x3c\/strong\x3e和\x3cstrong\x3e\x3ccode\x3eRHS\x3c\/code\x3e\x3c\/strong\x3e。\x3c\/p\x3e\n\x3cp\x3e　　我在之前的一篇文章中\x3ca href=\x22https:\/\/github.com\/MrErHu\/blog\/issues\/12\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e从LHS与RHS角度浅谈Js变量声明与赋值\x3c\/a\x3e曾经介绍过\x3ccode\x3eLHS\x3c\/code\x3e与\x3ccode\x3eRHS\x3c\/code\x3e,这两个看起来很高大上的名词其实非常简单。\x3ccode\x3eLHS\x3c\/code\x3e指的是\x3ccode\x3eLeft-hand Side\x3c\/code\x3e，而\x3ccode\x3eRHS\x3c\/code\x3e指的是\x3ccode\x3eRight-hand Side\x3c\/code\x3e。分别对应于两种不同目的的词法查询。\x3ccode\x3eLHS\x3c\/code\x3e所查询的目的是为了赋值(类似于该变量会位于赋值符号\x3ccode\x3e=\x3c\/code\x3e的左边)，例如第二步查找变量\x3ccode\x3ea\x3c\/code\x3e的过程。而\x3ccode\x3eRHS\x3c\/code\x3e所查询的目的是为了引用(类似于变量会位于赋值符号\x3ccode\x3e=\x3c\/code\x3e的右边)，例如第一步查找变量\x3ccode\x3efoo\x3c\/code\x3e的过程。\x3cbr\x3e　　\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e作用域链\x3c\/h3\x3e\n\x3cp\x3e　　我们知道代码不仅仅可以访问当前的作用域的变量，对于嵌套的父级作用域中的变量也可以访问。我们先只在ES5中表述，我们知道JavaScript在ES5中是没有块级作用域的，只有函数可以创建作用域。举个例子:\x3cbr\x3e　　\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Outer(){\n    var outer = \x27outer\x27;\n    Inner();\n    function Inner(){\n        var inner = \x27inner\x27;\n        console.log(outer,inner) \/\/ outer inner\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eOuter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e outer = \x3cspan class=\x22hljs-string\x22\x3e\x27outer\x27\x3c\/span\x3e;\n    Inner();\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eInner\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inner = \x3cspan class=\x22hljs-string\x22\x3e\x27inner\x27\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(outer,inner) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ outer inner\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　当引擎执行到函数\x3ccode\x3eInner\x3c\/code\x3e内部的时候，不仅可以访问当前作用域而且可以访问到\x3ccode\x3eOuter\x3c\/code\x3e的作用域，从而可以访问到标识符\x3ccode\x3eouter\x3c\/code\x3e。因此我们发现当多个作用域相互嵌套的时候，就形成了作用域链。词法作用域在查找标识符的时候，优先在本作用域中查找。如果在本作用域没有找到标识符，会继续向上一级查找，当抵达最外层的全局作用域仍然没有找到，则会停止对标识符的搜索。如果没有查找到标识符，会根据不同的查找方式作出不同的反应。如果是\x3ccode\x3eRHS\x3c\/code\x3e,则会抛出\x3ccode\x3eUncaught ReferenceError\x3c\/code\x3e的错误，如果是\x3ccode\x3eLHS\x3c\/code\x3e,则会在查找最外层的作用域声明该变量，这就解释了为什么对未声明的变量赋值后该变量会成为全局变量。所以上面的代码执行\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3econsole.log(outer,inner)\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e的时候，引擎会首先要求\x3ccode\x3eInner\x3c\/code\x3e函数的词法作用域查找(\x3ccode\x3eRHS\x3c\/code\x3e)标识符\x3ccode\x3eouter\x3c\/code\x3e，被告知该词法作用域不存在该标识符，然后引擎会要求嵌套的上一级\x3ccode\x3eOuter\x3c\/code\x3e词法作用域查找(\x3ccode\x3eRHS\x3c\/code\x3e)标识符\x3ccode\x3eouter\x3c\/code\x3e,\x3ccode\x3eOuter\x3c\/code\x3e词法作用域的查找成功并将结果返回给引擎。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e换个角度理解作用域链\x3c\/h3\x3e\n\x3cp\x3e　　上面我们理解作用域链都是从作用域链查找变量的角度去考虑的，其实这已经足够了，大部分作用域链的场景都是查找标识符。但是我们可以换一个角度去理解作用域链。其实JavaScript的每个函数都有对应的\x3cstrong\x3e执行环境\x3c\/strong\x3e(execution context)。当执行流进入进入一个函数时，该函数的执行环境就会被推入环境栈，当函数执行结束之后，该函数的执行环境就会被弹出环境栈，执行环境被变更为之前的执行环境。而每创建一个执行环境时，会同时生成一个\x3cstrong\x3e变量对象\x3c\/strong\x3e(variable object)(函数生成的是\x3cstrong\x3e活动变量\x3c\/strong\x3e(activation object))，用来存储当前执行环境中定义的变量和函数，当执行环境结束时，当前的变量(活动)对象就会被销毁(全局的变量对象是一直存在的，不会被销毁)。虽然我们无法访问到变量(活动)对象，但词法作用域查找标识符会使用它。\x3cbr\x3e　　当对于函数的执行环境生成的活动对象，初始化就会存在两个变量:\x3ccode\x3ethis\x3c\/code\x3e和\x3ccode\x3earguments\x3c\/code\x3e，因此我们在函数中就直接可以使用这两个变量。对于作用域链存储都是变量(活动)对象，而当前执行环境的变量对象就存储在作用域链的最前端，优先被查找。从这个角度看，标识符解析是沿着作用域链一级一级地在变量(活动)对象中搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止。\x3cbr\x3e　　\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e闭包\x3c\/h2\x3e\n\x3cp\x3e　　这年头出去面试JavaScript的岗位，各个都要问你闭包的问题，开始的时候觉得闭包的概念蛮高级的，后来觉得这个也没啥东西可讲的。老早的之前就写过一篇关于闭包的文章\x3ca href=\x22https:\/\/github.com\/MrErHu\/blog\/issues\/11\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e浅谈JavaScript闭包\x3c\/a\x3e,讲到现在我觉得把闭包放到作用域链一起将会更好。还是继续讲个例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fn(){\n    var a = \x27JavaScript\x27;\n    function func(){\n        console.log(a);\n    }\n    return func;\n}\n\nvar func = fn();\nfunc(); \/\/JavaScript\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-string\x22\x3e\x27JavaScript\x27\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e func;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e func = fn();\nfunc(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/JavaScript\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　首先明确一下什么是闭包？我认为闭包最好的概念解释就是:\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e函数在定义的词法作用域以外的地方被调用，闭包使得函数可以继续访问定义时的词法作用域。\x3c\/strong\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e　　\x3ccode\x3efunc\x3c\/code\x3e函数执行的位置和定义的位置是不相同的，\x3ccode\x3efunc\x3c\/code\x3e是在函数\x3ccode\x3efn\x3c\/code\x3e中定义的，但执行却是在全局环境中，虽然是在全局函数中执行的，但函数仍然可以访问当定义时的词法作用域。如下图所示:\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009965289?w=722\x26amp;h=528\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009965289?w=722\x26amp;h=528\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e　　我们之前说过，当函数执行结束后其活动变量就会被销毁，但是在上面的例子中却不是这个样子。但函数\x3ccode\x3efn\x3c\/code\x3e执行结束之后，\x3ccode\x3efn\x3c\/code\x3e对象的活动变量并没有被销毁，这是因为\x3ccode\x3efn\x3c\/code\x3e返回的函数\x3ccode\x3efunc\x3c\/code\x3e的作用域链还保持着\x3ccode\x3efn\x3c\/code\x3e的活动变量，因此JavaScript的垃圾回收机制不会回收\x3ccode\x3efn\x3c\/code\x3e活动变量。虽然返回的函数\x3ccode\x3efunc\x3c\/code\x3e是在全局环境下执行的，但是其作用域链的存储的活动(变量)对象的顺序分别是:\x3ccode\x3efunc\x3c\/code\x3e的活动变量、\x3ccode\x3efn\x3c\/code\x3e的活动变量、全局变量对象。因此在\x3ccode\x3efunc\x3c\/code\x3e函数执行时，会顺着作用域链查找标识符，也就能访问到\x3ccode\x3efn\x3c\/code\x3e所定义的词法作用域(即\x3ccode\x3efn\x3c\/code\x3e函数的活动变量)也就不足为奇了。这样看起来是不是觉得闭包也是非常的简单。\x3cbr\x3e　　\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e原型链\x3c\/h2\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e原型\x3c\/h2\x3e\n\x3cp\x3e　　说完了作用域链，我们来讲讲\x3cstrong\x3e原型链\x3c\/strong\x3e。首先也是要明确什么是原型？所有的函数都有一个特殊的属性: \x3cstrong\x3e\x3ccode\x3eprototype\x3c\/code\x3e(原型)\x3c\/strong\x3e，\x3ccode\x3eprototype\x3c\/code\x3e属性是一个指针，指向的是一个对象(原型对象)，原型对象中的方法和属性都可以\x3cstrong\x3e被函数的实例\x3c\/strong\x3e所共享。所谓的\x3cstrong\x3e函数实例\x3c\/strong\x3e是指以函数作为构造函数创建的对象，这些对象实例都可以共享构造函数的原型的方法。举个例子:\x3cbr\x3e　　\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Person = function(name){\n    this.name = name;\n}\nPerson.prototype.sayName = function(){\n    console.log(\x27name: \x27,this.name)\n};\n\nvar person = new Person(\x27JavaScript\x27);\nperson.sayName(); \/\/JavaScript\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Person = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n}\nPerson.prototype.sayName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27name: \x27\x3c\/span\x3e,\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name)\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e person = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person(\x3cspan class=\x22hljs-string\x22\x3e\x27JavaScript\x27\x3c\/span\x3e);\nperson.sayName(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/JavaScript\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　在上面的例子中，对象\x3ccode\x3eperson\x3c\/code\x3e是构造函数\x3ccode\x3ePerson\x3c\/code\x3e创建的实例。所谓的构造函数也只不过是普通的函数通过操作符\x3ccode\x3enew\x3c\/code\x3e来调用。在使用\x3ccode\x3enew\x3c\/code\x3e操作符调用函数时主要执行以下几个步骤:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e创建新的对象，并将函数的this指向新创建的对象\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行函数\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e返回新创建的对象\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e　　通过构造函数返回的对象，其中含有一个内部指针\x3ccode\x3e[[Prototype]]\x3c\/code\x3e指向构造函数的原型对象，当然我们是无法访问到这个标准的内部指针\x3ccode\x3e[[Prototype]]\x3c\/code\x3e,但是在Firefox、Safari和Chrome在上都支持一个属性\x3cstrong\x3e\x3ccode\x3e__proto__\x3c\/code\x3e\x3c\/strong\x3e，用来指向构造函数的原型对象。下图就解释了上面的结构:\x3c\/p\x3e\n\x3cp\x3e　　\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009965290?w=624\x26amp;h=296\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009965290?w=624\x26amp;h=296\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e　　我们可以看到，构造函数\x3ccode\x3ePerson\x3c\/code\x3e的\x3ccode\x3eprototype\x3c\/code\x3e属性指向\x3ccode\x3ePrototype\x3c\/code\x3e的原型对象。而\x3ccode\x3eperson\x3c\/code\x3e作为构造函数\x3ccode\x3ePerson\x3c\/code\x3e创建的实例，其中存在内部指针也指向\x3ccode\x3ePerson\x3c\/code\x3e的原型对象。需要注意的是，在\x3ccode\x3ePerson\x3c\/code\x3e的原型对象中存在一个特殊的属性\x3ccode\x3econstructor\x3c\/code\x3e，指向构造函数\x3ccode\x3ePerson\x3c\/code\x3e。在我们的例子中，执行到:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22person.sayName(); \/\/JavaScript\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eperson.sayName(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/JavaScript\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　当执行\x3ccode\x3eperson\x3c\/code\x3e的\x3ccode\x3esayName\x3c\/code\x3e属性时，首先会在对象实例中查找\x3ccode\x3esayName\x3c\/code\x3e属性，当发现对象实例中不存在\x3ccode\x3esayName\x3c\/code\x3e时，会转而去搜索\x3ccode\x3eperson\x3c\/code\x3e内部指针\x3ccode\x3e[[Prototpe]]\x3c\/code\x3e所指向的原型对象，当发现原型对象中存在\x3ccode\x3esayName\x3c\/code\x3e属性时，执行该属性。关于函数\x3ccode\x3esayName\x3c\/code\x3e中\x3ccode\x3ethis\x3c\/code\x3e的指向，有兴趣可以戳这篇文章\x3ca href=\x22https:\/\/github.com\/MrErHu\/blog\/issues\/10om\/Prototype1.png\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e一个小小的JavaScript题目\x3c\/a\x3e。\x3cbr\x3e　　\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e原型链\x3c\/h3\x3e\n\x3cp\x3e　　讲完了原型，再讲讲原型链，其实我们上面的图并不完整，因为\x3cstrong\x3e所有函数的默认原型都是Object的实例\x3c\/strong\x3e，所以函数原型实例的内部指针\x3ccode\x3e[[Prototype]]\x3c\/code\x3e指向的是\x3ccode\x3eObject.prototype\x3c\/code\x3e,让我们继续来完善一下:\x3cbr\x3e　　\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000009965291?w=962\x26amp;h=555\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000009965291?w=962\x26amp;h=555\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e　　\x3cbr\x3e　　这就是完整的原型链，假如我们执行下面代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22person.toString()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eperson.toString()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　\x3cbr\x3e　　执行上面代码时，首先会在对象实例\x3ccode\x3eperson\x3c\/code\x3e中查找属性\x3ccode\x3etoString\x3c\/code\x3e方法，我们发现实例中不存在\x3ccode\x3etoString\x3c\/code\x3e属性。然后我们转到\x3ccode\x3eperson\x3c\/code\x3e内部指针\x3ccode\x3e[[Prototype]]\x3c\/code\x3e指向的\x3ccode\x3ePerson\x3c\/code\x3e原型对象去寻找\x3ccode\x3etoString\x3c\/code\x3e属性，结果是仍然不存在。这找不到我们就放弃了？开玩笑，我们这么有毅力。我们会再接着到\x3ccode\x3ePerson\x3c\/code\x3e原型对象的内部指针\x3ccode\x3e[[Prototype]]\x3c\/code\x3e指向的\x3ccode\x3eObject\x3c\/code\x3e原型对象中查找，这次我们发现其中确实存在\x3ccode\x3etoString\x3c\/code\x3e属性，然后我们执行\x3ccode\x3etoString\x3c\/code\x3e方法。发现了没有，这一连串的原型形成了一条链，这就是\x3cstrong\x3e原型链\x3c\/strong\x3e。\x3cbr\x3e　　\x3cbr\x3e　　其实我们上面例子中对属性\x3ccode\x3etoString\x3c\/code\x3e查找属于\x3ccode\x3eRHS\x3c\/code\x3e,以\x3ccode\x3eRHS\x3c\/code\x3e方式寻找属性时，会在原型链中依次查找，如果在当前的原型中已经查找到所需要的属性，那么就会停止搜索，否则会一直向后查找原型链，直到原型链的结尾(这一点有点类似于作用域链)，如果直到原型链结尾仍未找到，那么该属性就是\x3ccode\x3eundefined\x3c\/code\x3e。但执行\x3ccode\x3eLHS\x3c\/code\x3e方式的查找却截然不同，当发现对象实例本身不存在该属性，直接在该对象实例中声明变量，而不会去查找原型链。例如:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22person.toString = function(){\n    console.log(\x27person\x27)\n}\nperson.toString(); \/\/person\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eperson.toString = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27person\x27\x3c\/span\x3e)\n}\nperson.toString(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/person\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e　　当对\x3ccode\x3eperson\x3c\/code\x3e执行\x3ccode\x3eLHS\x3c\/code\x3e的方式查找\x3ccode\x3etoString\x3c\/code\x3e属性时，我们发现\x3ccode\x3eperson\x3c\/code\x3e中并不存在\x3ccode\x3etoString\x3c\/code\x3e，这时会直接在\x3ccode\x3eperson\x3c\/code\x3e中声明属性，而不会去查找原型链，接着我们执行\x3ccode\x3eperson.toString()\x3c\/code\x3e时，我们在实例中找到了\x3ccode\x3etoString\x3c\/code\x3e属性并将其执行，这样实例中的\x3ccode\x3etoString\x3c\/code\x3e就屏蔽了原型链中的\x3ccode\x3etoString\x3c\/code\x3e属性。\x3cbr\x3e　　\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e作用域链和原型链的比较\x3c\/h2\x3e\n\x3cp\x3e　　讲完了作用域链和原型链，我们可以比较一下。作用域链的作用主要用于\x3cstrong\x3e查找标识符\x3c\/strong\x3e，当作用域需要查询变量的时候会沿着作用域链依次查找，如果找到标识符就会停止搜索，否则将会沿着作用域链依次向后查找，直到作用域链的结尾。而原型链是用于\x3cstrong\x3e查找引用类型的属性\x3c\/strong\x3e，查找属性会沿着原型链依次进行，如果找到该属性会停止搜索并做相应的操作，否则将会沿着原型链依次查找直到结尾。\x3cbr\x3e　　　　\x3cbr\x3e　　如果觉得阅读完了本篇文章对你有些许帮助，欢迎大家我关注我的掘金账号或者star我的Github的\x3ca href=\x22https:\/\/github.com\/MrErHu\/blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eblog\x3c\/a\x3e项目，也算是对我的鼓励啦！\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>我所认识的JavaScript作用域链和原型链</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009965278">https://segmentfault.com/a/1190000009965278</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/hkl9q5ubbg9/" target="_blank">https://alili.tech/archive/hkl9q5ubbg9/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>