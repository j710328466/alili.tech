<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="fetch使用的常见问题及其解决办法"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>fetch使用的常见问题及其解决办法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/het77a8r625/",
				"appid": "1613049289050283", 
				"title": "fetch使用的常见问题及其解决办法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-26T02:30:18"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/hfszvrcjmqm/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/qa2c1jrsv1/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f&text=fetch%e4%bd%bf%e7%94%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f&text=fetch%e4%bd%bf%e7%94%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f&title=fetch%e4%bd%bf%e7%94%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f&is_video=false&description=fetch%e4%bd%bf%e7%94%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=fetch%e4%bd%bf%e7%94%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f&title=fetch%e4%bd%bf%e7%94%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f&title=fetch%e4%bd%bf%e7%94%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f&title=fetch%e4%bd%bf%e7%94%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fhet77a8r625%2f&title=fetch%e4%bd%bf%e7%94%a8%e7%9a%84%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98%e5%8f%8a%e5%85%b6%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">fetch使用的常见问题及其解决办法</h1><div class="meta"><div class="postdate"><time datetime="2019-01-26" itemprop="datePublished">2019-01-26</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e首先声明一下，本文不是要讲解fetch的具体用法，不清楚的可以参考\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/API\/GlobalFetch\/fetch\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN fetch教程\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e引言\x3c\/h2\x3e\n\x3cp\x3e说道fetch就不得不提XMLHttpRequest了，XHR在发送web请求时需要开发者配置相关请求信息和成功后的回调，尽管开发者只关心请求成功后的业务处理，但是也要配置其他繁琐内容，导致配置和调用比较混乱，也不符合关注分离的原则；fetch的出现正是为了解决XHR存在的这些问题。例如下面代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fetch(url).then(function(response) {\n  return response.json();\n}).then(function(data) {\n  console.log(data);\n}).catch(function(e) {\n  console.log(\x26quot;Oops, error\x26quot;);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22Javascript\x22\x3efetch(url).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e response.json();\n}).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(data);\n}).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Oops, error\x22\x3c\/span\x3e);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面这段代码让开发者只关注请求成功后的业务逻辑处理，其他的不用关心，相当简单；也比较符合现代Promise形式，比较友好。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3efetch是基于Promise设计的\x3c\/strong\x3e，从上面代码也能看得出来，这就要求fetch要配合Promise一起使用。正是这种设计，fetch所带来的优点正如\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000003810652\x22\x3e传统 Ajax 已死，Fetch 永生\x3c\/a\x3e总结的一样：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e语法简单，更加语义化\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e基于标准的Promise实现，支持async\/await\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e使用\x3ca href=\x22https:\/\/github.com\/matthew-andrews\/isomorphic-fetch\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eisomorphic-fetch\x3c\/code\x3e\x3c\/a\x3e可以方便同构\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e不过话说回来，fetch虽然有很多优点，但是使用fetch来进行项目开发时，也是有一些常见问题的，下面就来说说fetch使用的常见问题。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3efetch兼容性\x3c\/h2\x3e\n\x3cp\x3efetch是相对较新的技术，当然就会存在浏览器兼容性的问题，借用上面应用文章的一幅图加以说明fetch在各种浏览器的原生支持情况：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000008484073?w=756\x26amp;h=411\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000008484073?w=756\x26amp;h=411\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从上图可以看出，在各个浏览器低版本的情况下都是不被支持的。\x3c\/p\x3e\n\x3cp\x3e那么问题来了，如何在所有浏览器中通用fetch呢，当然就要考虑fetch的polyfill了。\x3c\/p\x3e\n\x3cp\x3e上面说过，fetch是基于Promise来实现的，所以在低版本浏览器中Promise可能也未被原生支持，所以还需要Promise的polyfill；\x3cstrong\x3e大多数情况下\x3c\/strong\x3e，实现fetch的polyfill需要涉及到的：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3epromise的polyfill\x3c\/strong\x3e，例如es6-promise、babel-polyfill提供的promise实现。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3efetch的polyfill实现\x3c\/strong\x3e，例如isomorphic-fetch和whatwg-fetch\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这样是否就可以安全的使用fetch来进行前后端通信了？上面说了在大多数情况下是这样，但是IE8\/9则比较特殊：IE8它使用的是ES3，而IE9则对ES5部分支持。这种情况下还需要\x3cstrong\x3eES5的polyfill\x3c\/strong\x3e \x3ca href=\x22https:\/\/github.com\/es-shims\/es5-shim\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3ees5-shim\x3c\/code\x3e\x3c\/a\x3e支持了。\x3c\/p\x3e\n\x3cp\x3e上述有关promise的polyfill实现，需要说明的是：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3ebabel-runtime是不能作为Promise的polyfill的实现的，否则在IE8\/9下使用fetch会报\x3ccode\x3ePromise未定义\x3c\/code\x3e。为什么？我想大家猜到了，因为babel-runtime实现的polyfill是局部实现而不是全局实现，fetch底层实现用到Promise就是从全局中去取的，拿不到这报上述错误。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e另外，顺便补充一下fetch的polyfill实现思路是：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e首先判断浏览器是否原生支持fetch，否则结合Promise使用XMLHttpRequest的方式来实现；这正是\x3ca href=\x22https:\/\/github.com\/github\/fetch\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3ewhatwg-fetch\x3c\/code\x3e\x3c\/a\x3e的实现思路，而同构应用中使用的\x3ca href=\x22https:\/\/github.com\/matthew-andrews\/isomorphic-fetch\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e\x3ccode\x3eisomorphic-fetch\x3c\/code\x3e\x3c\/a\x3e，其客户端fetch的实现是直接require whatwg-fetch来实现的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3efetch默认不携带cookie\x3c\/h2\x3e\n\x3cp\x3efetch发送请求默认是不发送cookie的，不管是同域还是跨域；那么问题就来了，对于那些需要权限验证的请求就可能无法正常获取数据，这时可以配置其\x3ccode\x3ecredentials\x3c\/code\x3e项，其有3个值：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eomit\x3c\/code\x3e: 默认值，忽略cookie的发送\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3esame-origin\x3c\/code\x3e: 表示cookie只能同域发送，不能跨域发送\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3einclude\x3c\/code\x3e:  cookie既可以同域发送，也可以跨域发送\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3ccode\x3ecredentials\x3c\/code\x3e所表达的含义，其实与XHR2中的\x3ccode\x3ewithCredentials\x3c\/code\x3e属性类似，表示请求是否携带cookie；具体可以参考阮一峰老师的\x3ca href=\x22http:\/\/www.ruanyifeng.com\/blog\/2016\/04\/cors.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e跨域资源共享 CORS 详解\x3c\/a\x3e中withCredentials一节的介绍；\x3c\/p\x3e\n\x3cp\x3e这样，若要fetch请求携带cookie信息，只需设置一下credentials选项即可，例如\x3ccode\x3efetch(url, {credentials: \x27include\x27})\x3c\/code\x3e;\x3c\/p\x3e\n\x3cp\x3e另外补充一点：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3efetch默认对服务端通过\x3ccode\x3eSet-Cookie\x3c\/code\x3e头设置的cookie也会忽略，若想选择接受来自服务端的cookie信息，也必须要配置credentials选项；\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3efetch请求对某些错误http状态不会reject\x3c\/h2\x3e\n\x3cp\x3e这主要是由fetch返回promise导致的，因为fetch返回的promise在某些错误的http状态下如400、500等不会reject，相反它会被resolve；只有网络错误会导致请求不能完成时，fetch 才会被 reject；所以一般会对fetch请求做一层封装，例如下面代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function checkStatus(response) {\n  if (response.status \x3e= 200 \x26amp;\x26amp; response.status \x3c 300) {\n    return response;\n  }\n  const error = new Error(response.statusText);\n  error.response = response;\n  throw error;\n}\nfunction parseJSON(response) {\n  return response.json();\n}\nexport default function request(url, options) {\n  let opt = options||{};\n  return fetch(url, {credentials: \x27include\x27, ...opt})\n    .then(checkStatus)\n    .then(parseJSON)\n    .then((data) =\x3e ( data ))\n    .catch((err) =\x3e ( err ));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckStatus\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (response.status \x26gt;= \x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e \x26amp;\x26amp; response.status \x26lt; \x3cspan class=\x22hljs-number\x22\x3e300\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e response;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e error = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(response.statusText);\n  error.response = response;\n  \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e error;\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eparseJSON\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e response.json();\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3erequest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl, options\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e opt = options||{};\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fetch(url, {\x3cspan class=\x22hljs-attr\x22\x3ecredentials\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27include\x27\x3c\/span\x3e, ...opt})\n    .then(checkStatus)\n    .then(parseJSON)\n    .then(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e ( data ))\n    .catch(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e ( err ));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3efetch不支持超时timeout处理\x3c\/h2\x3e\n\x3cp\x3e用过fetch的都知道，fetch不像大多数ajax库那样对请求设置超时timeout，它没有有关请求超时的feature，这一点比较蛋疼。所以在fetch标准添加超时feature之前，都需要polyfill该特性。\x3c\/p\x3e\n\x3cp\x3e实际上，我们真正需要的是\x3ccode\x3eabort()\x3c\/code\x3e， timeout可以通过\x3ccode\x3etimeout\x2babort\x3c\/code\x3e方式来实现，起到真正超时丢弃当前的请求。\x3c\/p\x3e\n\x3cp\x3e而在目前的fetch指导规范中，fetch并不是一个具体实例，而只是一个方法；其返回的promise实例根据Promise指导规范标准是不能abort的，也不能手动改变promise实例的状态，只能由内部来根据请求结果来改变promise的状态。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e既然不能手动控制fetch方法执行后返回的promise实例状态，那么是不是可以创建一个可以手动控制状态的新Promise实例呢\x3c\/strong\x3e。所以：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22实现fetch的timeout功能，其思想就是新创建一个可以手动控制promise状态的实例，根据不同情况来对新promise实例进行resolve或者reject，从而达到实现timeout的功能；\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode\x3e实现fetch的\x3cspan class=\x22hljs-keyword\x22\x3etimeout\x3c\/span\x3e功能，其思想就是新创建一个可以手动控制promise状态的实例，根据不同情况来对新promise实例进行resolve或者reject，从而达到实现\x3cspan class=\x22hljs-keyword\x22\x3etimeout\x3c\/span\x3e的功能；\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根据github上\x3ca href=\x22https:\/\/github.com\/github\/fetch\/issues\/175\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3etimeout handling\x3c\/a\x3e上的讨论，目前可以有两种不同的解决方法：\x3c\/p\x3e\n\x3ch4\x3e方法一：单纯setTimeout方式\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var oldFetchfn = fetch; \/\/拦截原始的fetch方法\nwindow.fetch = function(input, opts){\/\/定义新的fetch方法，封装原有的fetch方法\n    return new Promise(function(resolve, reject){\n        var timeoutId = setTimeout(function(){\n            reject(new Error(\x26quot;fetch timeout\x26quot;))\n        }, opts.timeout);\n        oldFetchfn(input, opts).then(\n            res=\x3e{\n                clearTimeout(timeoutId);\n                resolve(res)\n            },\n            err=\x3e{\n                clearTimeout(timeoutId);\n                reject(err)\n            }\n        )\n    })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldFetchfn = fetch; \x3cspan class=\x22hljs-comment\x22\x3e\/\/拦截原始的fetch方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.fetch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einput, opts\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/\/定义新的fetch方法，封装原有的fetch方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e timeoutId = setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22fetch timeout\x22\x3c\/span\x3e))\n        }, opts.timeout);\n        oldFetchfn(input, opts).then(\n            \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eres\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n                clearTimeout(timeoutId);\n                resolve(res)\n            },\n            err=\x26gt;{\n                clearTimeout(timeoutId);\n                reject(err)\n            }\n        )\n    })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当然在上面基础上可以模拟类似XHR的\x3ccode\x3eabort\x3c\/code\x3e功能：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var oldFetchfn = fetch; \nwindow.fetch = function(input, opts){\n    return new Promise(function(resolve, reject){\n        var abort_promise = function(){\n            reject(new Error(\x26quot;fetch abort\x26quot;))\n        };\n        var p = oldFetchfn(input, opts).then(resolve, reject);\n        p.abort = abort_promise;\n        return p;\n    })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldFetchfn = fetch; \n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.fetch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einput, opts\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e abort_promise = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22fetch abort\x22\x3c\/span\x3e))\n        };\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e p = oldFetchfn(input, opts).then(resolve, reject);\n        p.abort = abort_promise;\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e p;\n    })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e方法二：利用Promise.race方法\x3c\/h4\x3e\n\x3cp\x3ePromise.race方法接受一个promise实例数组参数，表示多个promise实例中任何一个最先改变状态，那么race方法返回的promise实例状态就跟着改变，具体可以参考\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/promise#Promise-race\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var oldFetchfn = fetch; \/\/拦截原始的fetch方法\nwindow.fetch = function(input, opts){\/\/定义新的fetch方法，封装原有的fetch方法\n    var fetchPromise = oldFetchfn(input, opts);\n    var timeoutPromise = new Promise(function(resolve, reject){\n        setTimeout(()=\x3e{\n             reject(new Error(\x26quot;fetch timeout\x26quot;))\n        }, opts.timeout)\n    });\n    retrun Promise.race([fetchPromise, timeoutPromise])\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldFetchfn = fetch; \x3cspan class=\x22hljs-comment\x22\x3e\/\/拦截原始的fetch方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.fetch = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einput, opts\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/\/定义新的fetch方法，封装原有的fetch方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fetchPromise = oldFetchfn(input, opts);\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e timeoutPromise = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresolve, reject\x3c\/span\x3e)\x3c\/span\x3e{\n        setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n             reject(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22fetch timeout\x22\x3c\/span\x3e))\n        }, opts.timeout)\n    });\n    retrun \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.race([fetchPromise, timeoutPromise])\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后，对fetch的timeout的上述实现方式补充几点：\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3etimeout不是请求连接超时的含义，它表示请求的response时间，包括请求的连接、服务器处理及服务器响应回来的时间；\x3c\/p\x3e\n\x3cp\x3efetch的timeout即使超时发生了，本次请求也不会被abort丢弃掉，它在后台仍然会发送到服务器端，只是本次请求的响应内容被丢弃而已；\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3efetch不支持JSONP\x3c\/h2\x3e\n\x3cp\x3efetch是与服务器端进行异步交互的，而\x3cstrong\x3eJSONP是外链一个javascript资源，并不是真正ajax\x3c\/strong\x3e，所以fetch与JSONP没有什么直接关联，当然至少目前是不支持JSONP的。\x3c\/p\x3e\n\x3cp\x3e这里我们把JSONP与fetch关联在一起有点差强人意，fetch只是一个ajax库，我们不可能使fetch支持JSONP；只是我们要实现一个JSONP，只不过这个JSONP的实现要与fetch的实现类似，\x3ccode\x3e即基于Promise来实现一个JSONP\x3c\/code\x3e；而其外在表现给人感觉是fetch支持JSONP一样；\x3c\/p\x3e\n\x3cp\x3e目前比较成熟的开源JSONP实现\x3ca href=\x22https:\/\/github.com\/camsong\/fetch-jsonp\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efetch-jsonp\x3c\/a\x3e给我们提供了解决方案，想了解可以自行前往。不过再次想唠叨一下其JSONP的实现步骤，因为在本人面试的前端候选人中大部分人对JSONP的实现语焉不详；\x3c\/p\x3e\n\x3cp\x3e使用它非常简单，首先需要用npm安装fetch-jsonp\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22 npm install fetch-jsonp --save-dev\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e npm install fetch-jsonp --save-dev\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然后在像下面一样使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fetchJsonp(\x27\/users.jsonp\x27, {\n    timeout: 3000,\n    jsonpCallback: \x27custom_callback\x27\n  })\n  .then(function(response) {\n    return response.json()\n  }).catch(function(ex) {\n    console.log(\x27parsing failed\x27, ex)\n  })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3efetchJsonp(\x3cspan class=\x22hljs-string\x22\x3e\x27\/users.jsonp\x27\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3etimeout\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3000\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ejsonpCallback\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27custom_callback\x27\x3c\/span\x3e\n  })\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e response.json()\n  }).catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eex\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27parsing failed\x27\x3c\/span\x3e, ex)\n  })\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3efetch不支持progress事件\x3c\/h2\x3e\n\x3cp\x3eXHR是原生支持progress事件的，例如下面代码这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var xhr = new XMLHttpRequest()\nxhr.open(\x27POST\x27, \x27\/uploads\x27)\nxhr.onload = function() {}\nxhr.onerror = function() {}\nfunction updateProgress (event) {\n  if (event.lengthComputable) {\n    var percent = Math.round((event.loaded \/ event.total) * 100)\n    console.log(percent)\n  }\nxhr.upload.onprogress =updateProgress; \/\/上传的progress事件\nxhr.onprogress = updateProgress; \/\/下载的progress事件\n}\nxhr.send();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest()\nxhr.open(\x3cspan class=\x22hljs-string\x22\x3e\x27POST\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27\/uploads\x27\x3c\/span\x3e)\nxhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\nxhr.onerror = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateProgress\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (event.lengthComputable) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e percent = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.round((event.loaded \/ event.total) * \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(percent)\n  }\nxhr.upload.onprogress =updateProgress; \x3cspan class=\x22hljs-comment\x22\x3e\/\/上传的progress事件\x3c\/span\x3e\nxhr.onprogress = updateProgress; \x3cspan class=\x22hljs-comment\x22\x3e\/\/下载的progress事件\x3c\/span\x3e\n}\nxhr.send();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是\x3cstrong\x3efetch是不支持有关\x3ccode\x3eprogress\x3c\/code\x3e事件的\x3c\/strong\x3e；不过可喜的是，根据fetch的指导规范标准，其内部设计实现了\x3ccode\x3eRequest\x3c\/code\x3e和\x3ccode\x3eResponse\x3c\/code\x3e类；其中Response封装一些方法和属性，通过Response实例可以访问这些方法和属性，例如\x3ccode\x3eresponse.json()\x3c\/code\x3e、\x3ccode\x3eresponse.body\x3c\/code\x3e等等；\x3c\/p\x3e\n\x3cp\x3e值得关注的地方是，\x3ccode\x3eresponse.body\x3c\/code\x3e是一个可读字节流对象，其实现了一个\x3ccode\x3egetRender()\x3c\/code\x3e方法，其具体作用是：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3egetRender()\x3c\/code\x3e方法用于读取响应的原始字节流，该字节流是可以循环读取的，直至body内容传输完成；\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e因此，利用到这点可以模拟出fetch的progress，具体可以参考这篇文章\x3ca href=\x22https:\/\/jakearchibald.com\/2016\/streams-ftw\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e2016 - the year of web streams\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e代码实现如下，在线demo请参考\x3ca href=\x22https:\/\/labs.jxck.io\/fetch\/progress.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efetch progress demo\x3c\/a\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ fetch() returns a promise that resolves once headers have been received\nfetch(url).then(response =\x3e {\n  \/\/ response.body is a readable stream.\n  \/\/ Calling getReader() gives us exclusive access to the stream\x27s content\n  var reader = response.body.getReader();\n  var bytesReceived = 0;\n\n  \/\/ read() returns a promise that resolves when a value has been received\n  reader.read().then(function processResult(result) {\n    \/\/ Result objects contain two properties:\n    \/\/ done  - true if the stream has already given you all its data.\n    \/\/ value - some data. Always undefined when done is true.\n    if (result.done) {\n      console.log(\x26quot;Fetch complete\x26quot;);\n      return;\n    }\n\n    \/\/ result.value for fetch streams is a Uint8Array\n    bytesReceived \x2b= result.value.length;\n    console.log(\x27Received\x27, bytesReceived, \x27bytes of data so far\x27);\n\n    \/\/ Read some more, and call this function again\n    return reader.read().then(processResult);\n  });\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ fetch() returns a promise that resolves once headers have been received\x3c\/span\x3e\nfetch(url).then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ response.body is a readable stream.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Calling getReader() gives us exclusive access to the stream\x27s content\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e reader = response.body.getReader();\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bytesReceived = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ read() returns a promise that resolves when a value has been received\x3c\/span\x3e\n  reader.read().then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprocessResult\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eresult\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Result objects contain two properties:\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ done  - true if the stream has already given you all its data.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ value - some data. Always undefined when done is true.\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (result.done) {\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22Fetch complete\x22\x3c\/span\x3e);\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ result.value for fetch streams is a Uint8Array\x3c\/span\x3e\n    bytesReceived \x2b= result.value.length;\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Received\x27\x3c\/span\x3e, bytesReceived, \x3cspan class=\x22hljs-string\x22\x3e\x27bytes of data so far\x27\x3c\/span\x3e);\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Read some more, and call this function again\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e reader.read().then(processResult);\n  });\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e另外，github上也有使用\x3ccode\x3ePromise\x2bXHR\x3c\/code\x3e结合的方式实现类fetch的progress效果(当然这跟fetch完全不搭边）可以参考\x3ca href=\x22https:\/\/github.com\/github\/fetch\/issues\/89#issuecomment-256610849\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e这里\x3c\/a\x3e，具体代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fetchProgress(url, opts={}, onProgress){\n    return new Promise(funciton(resolve, reject){\n        var xhr = new XMLHttpRequest();\n        xhr.open(opts.method || \x27get\x27, url);\n        for(var key in opts.headers || {}){\n            xhr.setRequestHeader(key, opts.headers[key]);\n        }\n\n        xhr.onload = e =\x3e resolve(e.target.responseText)\n        xhr.onerror = reject;\n        if (xhr.upload \x26amp;\x26amp; onProgress){\n            xhr.upload.onprogress = onProgress; \/\/上传\n        }\n        if (\x27onprogerss\x27 in xhr \x26amp;\x26amp; onProgress){\n            xhr.onprogress = onProgress; \/\/下载\n        }\n        xhr.send(opts.body)\n    })\n}\nfetchProgress(\x27\/upload\x27).then(console.log)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efetchProgress\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eurl, opts={}, onProgress\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(funciton(resolve, reject){\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e xhr = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e XMLHttpRequest();\n        xhr.open(opts.method || \x3cspan class=\x22hljs-string\x22\x3e\x27get\x27\x3c\/span\x3e, url);\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e opts.headers || {}){\n            xhr.setRequestHeader(key, opts.headers[key]);\n        }\n\n        xhr.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e =\x26gt;\x3c\/span\x3e resolve(e.target.responseText)\n        xhr.onerror = reject;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (xhr.upload \x26amp;\x26amp; onProgress){\n            xhr.upload.onprogress = onProgress; \x3cspan class=\x22hljs-comment\x22\x3e\/\/上传\x3c\/span\x3e\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-string\x22\x3e\x27onprogerss\x27\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e xhr \x26amp;\x26amp; onProgress){\n            xhr.onprogress = onProgress; \x3cspan class=\x22hljs-comment\x22\x3e\/\/下载\x3c\/span\x3e\n        }\n        xhr.send(opts.body)\n    })\n}\nfetchProgress(\x3cspan class=\x22hljs-string\x22\x3e\x27\/upload\x27\x3c\/span\x3e).then(\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3efetch跨域问题\x3c\/h2\x3e\n\x3cp\x3e既然是ajax库，就不可避免与\x3cstrong\x3e跨域\x3c\/strong\x3e扯上关系；XHR2是支持跨域请求的，只不过要\x3cstrong\x3e满足浏览器端支持\x3ccode\x3eCORS\x3c\/code\x3e，服务器通过\x3ccode\x3eAccess-Control-Allow-Origin\x3c\/code\x3e来允许指定的源进行跨域\x3c\/strong\x3e，仅此一种方式。\x3c\/p\x3e\n\x3cp\x3e与XHR2一样，fetch也是支持跨域请求的，只不过其跨域请求做法与XHR2一样，需要客户端与服务端支持；另外，fetch还支持一种跨域，不需要服务器支持的形式，具体可以通过其\x3ccode\x3emode\x3c\/code\x3e的配置项来说明。\x3c\/p\x3e\n\x3cp\x3efetch的\x3ccode\x3emode\x3c\/code\x3e配置项有3个值，如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3esame-origin\x3c\/code\x3e：该模式是不允许跨域的，它需要遵守同源策略，否则浏览器会返回一个error告知不能跨域；其对应的response type为\x3ccode\x3ebasic\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecors\x3c\/code\x3e: 该模式支持跨域请求，顾名思义它是以CORS的形式跨域；当然该模式也可以同域请求不需要后端额外的CORS支持；其对应的response type为\x3ccode\x3ecors\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eno-cors\x3c\/code\x3e: 该模式用于跨域请求但是服务器不带CORS响应头，也就是服务端不支持CORS；这也是fetch的特殊跨域请求方式；其对应的response type为\x3ccode\x3eopaque\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e针对跨域请求，cors模式是常见跨域请求实现，但是fetch自带的\x3ccode\x3eno-cors\x3c\/code\x3e跨域请求模式则较为陌生，该模式有一个比较明显的特点：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e该模式允许浏览器发送本次跨域请求，但是不能访问响应返回的内容，这也是其response type为opaque透明的原因。\x3c\/strong\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这与\x3ccode\x3e\x26lt;img\/\x26gt;\x3c\/code\x3e发送的请求类似，只是该模式不能访问响应的内容信息；但是它可以被其他APIs进行处理，例如ServiceWorker。另外，该模式返回的repsonse可以在Cache API中被存储起来以便后续的对它的使用，这点对script、css和图片的CDN资源是非常合适的，因为这些资源响应头中都没有CORS头。\x3c\/p\x3e\n\x3cp\x3e总的来说，fetch的跨域请求是使用CORS方式，需要浏览器和服务端的支持。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e参考文献\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/jakearchibald.com\/2015\/thats-so-fetch\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ethats-so-fetch\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000003810652\x22\x3e传统 Ajax 已死，Fetch 永生\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/louiszhai.github.io\/2016\/11\/02\/fetch\/#u5C1D_u8BD5_u4E00_u4E2Afetch\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFetch进阶指南\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/jakearchibald.com\/2016\/streams-ftw\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e2016 - the year of web streams\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/bubkoo.com\/2015\/05\/08\/introduction-to-fetch\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3efetch API 简介\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>fetch使用的常见问题及其解决办法</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008484070">https://segmentfault.com/a/1190000008484070</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/het77a8r625/" target="_blank">https://alili.tech/archive/het77a8r625/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/t42iv2yle7e/">2016-我的前端之路:工具化与工程化<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/xlhryjzdso/">2016年总结--成长<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/4wvjfeus9ur/">2016年末总结，我的前端之路<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/w7062tmcw3/">3D 视差效果<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/5jt1iw1t77b/">AlloyTouch实战--60行代码搞定QQ看点资料卡<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/kquf0fxkw2j/">ES6，你不得不学！<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/r5b6g4133jh/">Emmet-前端开发神器<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/5dbaikv4emi/">FreeCodeCamp中级算法题答案<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/iuyeljg6lm/">JSONP是什么<aside class="dates">2019-01-29</aside></a></li><li><a href="/archive/23ftsgrtzzc/">JS中的观察者模式(发布订阅)<aside class="dates">2019-01-29</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>