<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="弄清Classs,Symbols,Objects拓展 和 Decorators"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>弄清Classs,Symbols,Objects拓展 和 Decorators | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6nnz6mampkt/",
				"appid": "1613049289050283", 
				"title": "弄清Classs,Symbols,Objects拓展 和 Decorators | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-07T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/nmj8sm4ty0q/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/pbpnzzebxho/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f&text=%e5%bc%84%e6%b8%85Classs%2cSymbols%2cObjects%e6%8b%93%e5%b1%95%20%e5%92%8c%20Decorators"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f&text=%e5%bc%84%e6%b8%85Classs%2cSymbols%2cObjects%e6%8b%93%e5%b1%95%20%e5%92%8c%20Decorators"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f&title=%e5%bc%84%e6%b8%85Classs%2cSymbols%2cObjects%e6%8b%93%e5%b1%95%20%e5%92%8c%20Decorators"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f&is_video=false&description=%e5%bc%84%e6%b8%85Classs%2cSymbols%2cObjects%e6%8b%93%e5%b1%95%20%e5%92%8c%20Decorators"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e5%bc%84%e6%b8%85Classs%2cSymbols%2cObjects%e6%8b%93%e5%b1%95%20%e5%92%8c%20Decorators&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f&title=%e5%bc%84%e6%b8%85Classs%2cSymbols%2cObjects%e6%8b%93%e5%b1%95%20%e5%92%8c%20Decorators"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f&title=%e5%bc%84%e6%b8%85Classs%2cSymbols%2cObjects%e6%8b%93%e5%b1%95%20%e5%92%8c%20Decorators"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f&title=%e5%bc%84%e6%b8%85Classs%2cSymbols%2cObjects%e6%8b%93%e5%b1%95%20%e5%92%8c%20Decorators"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6nnz6mampkt%2f&title=%e5%bc%84%e6%b8%85Classs%2cSymbols%2cObjects%e6%8b%93%e5%b1%95%20%e5%92%8c%20Decorators"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">弄清Classs,Symbols,Objects拓展 和 Decorators</h1><div class="meta"><div class="postdate"><time datetime="2019-01-07" itemprop="datePublished">2019-01-07</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e本文翻译自 Nicolas Bevacqua 的书籍\x26nbsp;\x3ca href=\x22https:\/\/ponyfoo.com\/books\/practical-modern-javascript\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《Practical Modern JavaScript》\x3c\/a\x3e,这是该书的第三章。翻译采用意译并进行一定的删减和拓展，部分内容与原书有所不同。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e类（\x3ccode\x3eclasses\x3c\/code\x3e)可能是ES6提供的，我们使用最广的新功能之一了，它以原型链为基础，为我们提供了一种基于类编程的模式。\x3ccode\x3eSymbol\x3c\/code\x3e是一种新的基本类型（JS中的第七种基本类型，另外六种为\x3ccode\x3eundefined\x3c\/code\x3e、\x3ccode\x3enull\x3c\/code\x3e、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）），它可以用来定义不可变值。本章，我们将首先讨论类和符号，之后我们还将对ES6对对象的拓展及处于\x3ccode\x3estage2\x3c\/code\x3e阶段的装饰器进行简单的讲解。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e类\x3c\/h2\x3e\n\x3cp\x3e我们知道，JavaScript是一门基于原型链的语言，ES6中的类和其它面向对象语言中的类在本质上有很大的不同，JavaScript中，类实际上是一种基于原型链的语法糖。\x3c\/p\x3e\n\x3cp\x3e虽然如此，JavaScript中的类还是给我们的很多操作带来了方便，比如说可以轻易拓展其它类，通过简单的语法我们就可以拓展内置的\x3ccode\x3eArray\x3c\/code\x3e了，在下文中我们将详细说明如何使用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e类基础\x3c\/h3\x3e\n\x3cp\x3e基于已有的知识学习新知识是一种非常好的学习方法，对比学习可以让我们对新知识有更深的印象。由于JS中类实际上是一种基于原型链的语法糖，我们先简单复习基于原型链的JavaScript构造器要怎么使用，然后我们用ES6中类语法实现相同的功能作为对比。\x3c\/p\x3e\n\x3cp\x3e下面代码中，我们新建了构造函数\x3ccode\x3eFruit\x3c\/code\x3e用以表示某种水果。该构造函数接收两个参数，水果的名称 -- \x3ccode\x3ename\x3c\/code\x3e，水果的卡路里含量 -- \x3ccode\x3ecalaries\x3c\/code\x3e。在\x3ccode\x3eFruit\x3c\/code\x3e构造函数中我们设置了默认的块数 \x3ccode\x3epieces=1\x3c\/code\x3e ,通过原型链，我们还为该构造函数添加了两种方法：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3echop\x3c\/code\x3e 方法（切水果，每次调用会使得块数加一）；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ebite\x3c\/code\x3e方法（接收一个名为\x3ccode\x3eperson\x3c\/code\x3e的参数，它是一个对象，每次调用，该 \x3ccode\x3eperson\x3c\/code\x3e 将吃掉一块水果，\x3ccode\x3eperson\x3c\/code\x3e 的饱腹感 \x3ccode\x3eperson.satiety \x3c\/code\x3e 将相应的增加，增加值为一块水果的\x3ccode\x3ecalaries\x3c\/code\x3e值，水果的总的卡路里值 \x3ccode\x3ethis.calories\x3c\/code\x3e将减少相应的值）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Fruit(name, calories) {\n  this.name = name\n  this.calories = calories\n  this.pieces = 1\n}\nFruit.prototype.chop = function () {\n  this.pieces\x2b\x2b\n}\nFruit.prototype.bite = function (person) {\n  if (this.pieces \x3c 1) {\n    return\n  }\n  const calories = this.calories \/ this.pieces\n  person.satiety \x2b= calories\n  this.calories -= calories\n  this.pieces--\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFruit\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename, calories\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.calories = calories\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n}\nFruit.prototype.chop = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces\x2b\x2b\n}\nFruit.prototype.bite = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eperson\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces \x26lt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e calories = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.calories \/ \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces\n  person.satiety \x2b= calories\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.calories -= calories\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces--\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来我们创建一个\x3ccode\x3eFruit\x3c\/code\x3e构造函数的实例，调用三次 \x3ccode\x3echop\x3c\/code\x3e 方法将实例 \x3ccode\x3eapple\x3c\/code\x3e 分为四块，新建\x3ccode\x3eperson\x3c\/code\x3e对象，传入并调用三次\x3ccode\x3ebite\x3c\/code\x3e方法，把\x3ccode\x3eapple\x3c\/code\x3e 吃掉三块。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const person = { satiety: 0 }\nconst apple = new Fruit(\x27apple\x27, 140)\napple.chop()\napple.chop()\napple.chop()\napple.bite(person)\napple.bite(person)\napple.bite(person)\nconsole.log(person.satiety)\n\/\/ \x3c- 105\nconsole.log(apple.pieces)\n\/\/ \x3c- 1\nconsole.log(apple.calories)\n\/\/ \x3c- 35\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e person = { \x3cspan class=\x22hljs-attr\x22\x3esatiety\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e }\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e apple = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Fruit(\x3cspan class=\x22hljs-string\x22\x3e\x27apple\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e140\x3c\/span\x3e)\napple.chop()\napple.chop()\napple.chop()\napple.bite(person)\napple.bite(person)\napple.bite(person)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person.satiety)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 105\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(apple.pieces)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 1\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(apple.calories)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 35\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e作为对比，接下来我们使用类语法来实现上述代码一样的过程。在类中，我们显式使用\x3ccode\x3econstructor\x3c\/code\x3e方法做为构造方法（其中\x3ccode\x3ethis\x3c\/code\x3e指向类的实例），在类中定义方法类似在对象字面量中定义方法，见下述代码中\x3ccode\x3echop\x3c\/code\x3e,\x3ccode\x3ebite\x3c\/code\x3e的定义。类所有的方法都声明在\x3ccode\x3eclass\x3c\/code\x3e的块中，不需要再使用\x3ccode\x3eFruit.prototype\x3c\/code\x3e这类样本代码，从这个角度看与基于原型的语法比起来，类语法语义清晰，使用起来也显得简洁。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Fruit {\n  constructor(name, calories) {\n    this.name = name\n    this.calories = calories\n    this.pieces = 1\n  }\n  chop() {\n    this.pieces\x2b\x2b\n  }\n  bite(person) {\n    if (this.pieces \x3c 1) {\n      return\n    }\n    const calories = this.calories \/ this.pieces\n    person.satiety \x2b= calories\n    this.calories -= calories\n    this.pieces--\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFruit\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name, calories) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.calories = calories\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n  }\n  chop() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces\x2b\x2b\n  }\n  bite(person) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces \x26lt; \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e calories = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.calories \/ \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces\n    person.satiety \x2b= calories\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.calories -= calories\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces--\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e虽然在类中定义方法和使用对象字面量类似，但是也有一个较大的不同点，那就是类中 \x3cstrong\x3e方法之间不能使用逗号\x3c\/strong\x3e ，这是类语法的要求。这种要求帮助我们避免混用对象和类，类和对象本来也不一样，这种要求的另外一个好处在于为未来类的改进做下了铺垫，未来JS的类中可能还会添加\x3ccode\x3epublic\x3c\/code\x3e或\x3ccode\x3eprivate\x3c\/code\x3e等。\x3c\/p\x3e\n\x3cp\x3e和普通函数声明不同的是，类声明并\x3cstrong\x3e不会被提升到作用域的顶部\x3c\/strong\x3e，因此提前调用会报错。\x3c\/p\x3e\n\x3cp\x3e类声明有两种方法，一种是像函数声明和函数表达式一样，声明为表达式，如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const Person = class {\n  constructor(name) {\n    this.name = name\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Person = \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e类声明的另外一种语法如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const class Person{\n  constructor(name) {\n    this.name = name\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(name) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e类还可以作为函数的返回值，这使得创建类工厂非常容易，如下代码中,箭头函数接收了一个名为\x3ccode\x3ename\x3c\/code\x3e的参数，\x3ccode\x3esuper()\x3c\/code\x3e方法把这个参数反馈给其父类\x3ccode\x3ePerson\x3c\/code\x3e.这样就创建了一个基于\x3ccode\x3ePerson\x3c\/code\x3e的新类：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 这里实际用到的是类的第一种声明方式\nconst createPersonClass = name =\x3e class extends Person {\n  constructor() {\n    super(name)\n  }\n}\nconst JakePerson = createPersonClass(\x27Jake\x27)\nconst jake = new JakePerson()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里实际用到的是类的第一种声明方式\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e createPersonClass = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(name)\n  }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e JakePerson = createPersonClass(\x3cspan class=\x22hljs-string\x22\x3e\x27Jake\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e jake = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e JakePerson()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中的\x3ccode\x3eextends\x3c\/code\x3e关键字表明这里使用到了类继承，稍后我们将详细讨论类继承，在此之前我们先仔细如何在类中定义属性和方法。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e类中的属性和方法\x3c\/h3\x3e\n\x3cp\x3e类声明中的\x3ccode\x3econstructor\x3c\/code\x3e方法是可选的。如果省略，JS将为我们自动添加，下面用类声明和用常规构造函数声明的\x3ccode\x3eFruit\x3c\/code\x3e是一样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 用类声明Fruit\nclass Fruit {\n}\n\n\/\/ 使用构造函数声明Fruit\nfunction Fruit() {\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用类声明Fruit\x3c\/span\x3e\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFruit\x3c\/span\x3e \x3c\/span\x3e{\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用构造函数声明Fruit\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFruit\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e所有传入类的参数，都将做为类中\x3ccode\x3econstructor\x3c\/code\x3e的参数，如下所有传入\x3ccode\x3eLog()\x3c\/code\x3e的参数都将作为\x3ccode\x3eLog\x3c\/code\x3e中\x3ccode\x3econstructor\x3c\/code\x3e的参数，这些参数将用以初始化类的实例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Log {\n  constructor(...args) {\n    console.log(args)\n  }\n}\nnew Log(\x27a\x27, \x27b\x27, \x27c\x27)\n\/\/ \x3c- [\x27a\x27 \x27b\x27 \x27c\x27]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLog\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(...args) {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(args)\n  }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Log(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- [\x27a\x27 \x27b\x27 \x27c\x27]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面的代码中，我们定义了类\x3ccode\x3eCounter\x3c\/code\x3e，在\x3ccode\x3econstructor\x3c\/code\x3e中定义的代码会在实例化类时自动执行，这里我们在实例化时为实例添加了一个\x3ccode\x3ecount\x3c\/code\x3e属性，\x3ccode\x3enext\x3c\/code\x3e属性前面添加了\x3ccode\x3eget\x3c\/code\x3e,则表示类\x3ccode\x3eCounter\x3c\/code\x3e的所有实例都有一个\x3ccode\x3enext\x3c\/code\x3e属性，每次某实例访问\x3ccode\x3enext\x3c\/code\x3e属性值时，其值都将\x2b1：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Counter {\n  constructor(start) {\n    this.count = start\n  }\n  get next() {\n    return this.count\x2b\x2b\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCounter\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(start) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count = start\n  }\n  get next() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.count\x2b\x2b\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们新建了\x3ccode\x3eCounter\x3c\/code\x3e类的实例\x3ccode\x3ecounter\x3c\/code\x3e，可以发现每一次\x3ccode\x3ecounter\x3c\/code\x3e的\x3ccode\x3e.next\x3c\/code\x3e被调用的时，\x3ccode\x3ecount\x3c\/code\x3e值增加1。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const counter = new Counter(2)\nconsole.log(counter.next)\n\/\/  2\nconsole.log(counter.next)\n\/\/  3\nconsole.log(counter.next)\n\/\/  4\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e counter = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Counter(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(counter.next)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  2\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(counter.next)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  3\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(counter.next)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/  4\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3ccode\x3egetter\x3c\/code\x3e 绑定一个属性，其后为一个函数，每次该属性被访问，其后的函数将被执行；\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3esetter\x3c\/code\x3e 语法绑定一个属性，其后跟着一个函数，当为该函数设置为某个值时，其后的函数将被调用；\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e当结合使用\x3ccode\x3egetter\x3c\/code\x3e和\x3ccode\x3esetter\x3c\/code\x3e时，我们可以完成一些神奇的事情，下例中，我们定义了类\x3ccode\x3eLocalStorage\x3c\/code\x3e，这个类使用提供的存储\x3ccode\x3ekey\x3c\/code\x3e，在读取\x3ccode\x3edata\x3c\/code\x3e值时，实现了同时在\x3ccode\x3elocalStorage\x3c\/code\x3e中存储和取出相关数据。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class LocalStorage {\n  constructor(key) {\n    this.key = key\n  }\n  get data() {\n    return JSON.parse(localStorage.getItem(this.key))\n  }\n  set data(data) {\n    localStorage.setItem(this.key, JSON.stringify(data))\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLocalStorage\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(key) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.key = key\n  }\n  get data() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(localStorage.getItem(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.key))\n  }\n  set data(data) {\n    localStorage.setItem(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.key, \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(data))\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们看看如何使用类\x3ccode\x3eLocalStorage\x3c\/code\x3e：\x3c\/p\x3e\n\x3cp\x3e新建\x3ccode\x3eLocalStorage\x3c\/code\x3e的实例\x3ccode\x3els\x3c\/code\x3e,传入\x3ccode\x3els\x3c\/code\x3e的\x3ccode\x3ekey\x3c\/code\x3e为\x3ccode\x3egroceries\x3c\/code\x3e,当我们设置\x3ccode\x3els.data\x3c\/code\x3e为某个值时，该值将被转换为JSON对象字符串，并存储在\x3ccode\x3elocalStorage\x3c\/code\x3e中;当使用相应的\x3ccode\x3ekey\x3c\/code\x3e进行读取时，将提取出之前存储在\x3ccode\x3elocalStorage\x3c\/code\x3e中的内容，以JSON的格式进行解析后返回：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ls = new LocalStorage(\x27groceries\x27)\nls.data = [\x27apples\x27, \x27bananas\x27, \x27grapes\x27]\nconsole.log(ls.data)\n\/\/ \x3c- [\x27apples\x27, \x27bananas\x27, \x27grapes\x27]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ls = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e LocalStorage(\x3cspan class=\x22hljs-string\x22\x3e\x27groceries\x27\x3c\/span\x3e)\nls.data = [\x3cspan class=\x22hljs-string\x22\x3e\x27apples\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27bananas\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27grapes\x27\x3c\/span\x3e]\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(ls.data)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- [\x27apples\x27, \x27bananas\x27, \x27grapes\x27]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除了使用\x3ccode\x3egetters\x3c\/code\x3e和\x3ccode\x3esetters\x3c\/code\x3e,我们也可以定义常规的实例方法，继续之前定义过的\x3ccode\x3eFruit\x3c\/code\x3e类，我们再定义了一个可以吃水果的\x3ccode\x3ePerson\x3c\/code\x3e类，我们实例化一个\x3ccode\x3efruit\x3c\/code\x3e和一个\x3ccode\x3eperson\x3c\/code\x3e，然后让 \x3ccode\x3eperson\x3c\/code\x3e 吃 \x3ccode\x3efruit\x3c\/code\x3e 。这里我们让\x3ccode\x3eperson\x3c\/code\x3e吃完了所有的\x3ccode\x3efruit\x3c\/code\x3e，结果是\x3ccode\x3eperson\x3c\/code\x3e的\x3ccode\x3esatiety\x3c\/code\x3e(饱食度)上升到了40。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Person {\n  constructor() {\n    this.satiety = 0\n  }\n  eat(fruit) {\n    while (fruit.pieces \x3e 0) {\n      fruit.bite(this)\n    }\n  }\n}\nconst plum = new Fruit(\x27plum\x27, 40)\nconst person = new Person()\nperson.eat(plum)\nconsole.log(person.satiety)\n\/\/ \x3c- 40\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.satiety = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n  }\n  eat(fruit) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (fruit.pieces \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n      fruit.bite(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    }\n  }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e plum = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Fruit(\x3cspan class=\x22hljs-string\x22\x3e\x27plum\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e40\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e person = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Person()\nperson.eat(plum)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person.satiety)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 40\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有时候我们可能会希望静态方法直接定义在类上，如果使用ES6之前的语法，我们需要将该方法直接添加于构造函数上，如下面的\x3ccode\x3ePerson.isPerson\x3c\/code\x3e:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Person() {\n  this.hunger = 100\n}\nPerson.prototype.eat = function () {\n  this.hunger--\n}\nPerson.isPerson = function (person) {\n  return person instanceof Person\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePerson\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hunger = \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e\n}\nPerson.prototype.eat = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hunger--\n}\nPerson.isPerson = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eperson\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e person \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Person\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e类语法则允许通过添加前缀\x3ccode\x3estatic\x3c\/code\x3e来定义静态方法\x3ccode\x3ePersion.isPerson\x3c\/code\x3e，\x3c\/p\x3e\n\x3cp\x3e下属代码我们给类\x3ccode\x3eMathHelper\x3c\/code\x3e定义了一个静态方法\x3ccode\x3esum\x3c\/code\x3e，这个方法将用以计算实例化时所有传入参数的总和。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class MathHelper {\n  static sum(...numbers) {\n    return numbers.reduce((a, b) =\x3e a \x2b b)\n  }\n}\nconsole.log(MathHelper.sum(1, 2, 3, 4, 5))\n\/\/ \x3c- 15\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eMathHelper\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3estatic\x3c\/span\x3e sum(...numbers) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e numbers.reduce(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ea, b\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e a \x2b b)\n  }\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(MathHelper.sum(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 15\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e类的继承\x3c\/h3\x3e\n\x3cp\x3eES6之前，你可以使用原型链来模拟类的继承，如下代码所示，我们新建了的构造函数\x3ccode\x3eBanana\x3c\/code\x3e，用以拓展上文中定义的\x3ccode\x3eFruit\x3c\/code\x3e类，为了\x3ccode\x3eBanana\x3c\/code\x3e能够正确初始化,我们需要在\x3ccode\x3eBanana\x3c\/code\x3e中调用\x3ccode\x3eFruit.call(this, \x27banana\x27, 105)\x3c\/code\x3e,此外还需要显式的设置\x3ccode\x3eBanana\x3c\/code\x3e的\x3ccode\x3eprototype\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Banana() {\n  Fruit.call(this, \x27banana\x27, 105)\n}\nBanana.prototype = Object.create(Fruit.prototype)\nBanana.prototype.slice = function () {\n  this.pieces = 12\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBanana\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  Fruit.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e105\x3c\/span\x3e)\n}\nBanana.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(Fruit.prototype)\nBanana.prototype.slice = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces = \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上述代码一点也称不上简洁，一般JS开发者会使用库来解决继承问题。比如说Node.js就提供了\x3ccode\x3eutil.inherits\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const util = require(\x27util\x27)\nfunction Banana() {\n  Fruit.call(this, \x27banana\x27, 105)\n}\nutil.inherits(Banana, Fruit)\nBanana.prototype.slice = function () {\n  this.pieces = 12\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e util = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27util\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBanana\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  Fruit.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e105\x3c\/span\x3e)\n}\nutil.inherits(Banana, Fruit)\nBanana.prototype.slice = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces = \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e考虑到，banana除了有确定的\x3ccode\x3ename\x3c\/code\x3e和\x3ccode\x3ecalories\x3c\/code\x3e,以及额外的\x3ccode\x3eslice\x3c\/code\x3e方法（用来把banana切为12块）外，\x3ccode\x3eBanana\x3c\/code\x3e构造函数和\x3ccode\x3eFruit\x3c\/code\x3e构造函数其实没有区别，我们可以在\x3ccode\x3eBanana\x3c\/code\x3e中也执行\x3ccode\x3ebite\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const person = { satiety: 0 }\nconst banana = new Banana()\nbanana.slice()\nbanana.bite(person)\nconsole.log(person.satiety)\n\/\/ \x3c- 8.75\nconsole.log(banana.pieces)\n\/\/ \x3c- 11\nconsole.log(banana.calories)\n\/\/ \x3c- 96.25\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e person = { \x3cspan class=\x22hljs-attr\x22\x3esatiety\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e }\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e banana = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Banana()\nbanana.slice()\nbanana.bite(person)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(person.satiety)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 8.75\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(banana.pieces)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 11\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(banana.calories)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 96.25\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e下面我们看看ES6为继承提供的解决方案，下述代码中，这里我们创建了一个继承自\x3ccode\x3eFruit\x3c\/code\x3e类的名为\x3ccode\x3eBanana\x3c\/code\x3e的类。可以看出，这种语法非常清晰，我们无须彻底弄明白原型的机制就可以获得我们想要的结果，如果想给\x3ccode\x3eFruit\x3c\/code\x3e类传递参数，只需要使用\x3ccode\x3esuper\x3c\/code\x3e关键字即可。\x3ccode\x3esuper\x3c\/code\x3e关键字还可以用以调用存在于父类中的方法，比如说\x3ccode\x3esuper.chop\x3c\/code\x3e,\x3ccode\x3esuper\x3c\/code\x3e`constructor`外面的方法中也可以使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Banana extends Fruit {\n  constructor() {\n    super(\x27banana\x27, 105)\n  }\n  slice() {\n    this.pieces = 12\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBanana\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFruit\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n    \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27banana\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e105\x3c\/span\x3e)\n  }\n  slice() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pieces = \x3cspan class=\x22hljs-number\x22\x3e12\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e基于JS函数的返回值可以是任何表达式，下面我们构建一个构造函数工厂，下面的代码定义了一个名为 \x3ccode\x3ecreateJuicyFruit\x3c\/code\x3e 的函数，通过使用\x3ccode\x3esuper\x3c\/code\x3e我们可以给\x3ccode\x3eFruit\x3c\/code\x3e类传入\x3ccode\x3ename\x3c\/code\x3e和\x3ccode\x3ecalories\x3c\/code\x3e,这样就轻松的实现了对\x3ccode\x3ecreateJuicyFruit\x3c\/code\x3e类的拓展。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const createJuicyFruit = (...params) =\x3e\n  class JuicyFruit extends Fruit {\n    constructor() {\n      this.juice = 0\n      super(...params)\n    }\n    squeeze() {\n      if (this.calories \x3c= 0) {\n        return\n      }\n      this.calories -= 10\n      this.juice \x2b= 3\n    }\n  }\n  \nclass Plum extends createJuicyFruit(\x27plum\x27, 30) {\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e createJuicyFruit = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e...params\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eJuicyFruit\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFruit\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e() {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.juice = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(...params)\n    }\n    squeeze() {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.calories \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.calories -= \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.juice \x2b= \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n    }\n  }\n  \n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePlum\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateJuicyFruit\x3c\/span\x3e(\x27\x3cspan class=\x22hljs-title\x22\x3eplum\x3c\/span\x3e\x27, 30) \x3c\/span\x3e{\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来我们来讲述\x3ccode\x3eSymbol\x3c\/code\x3e,了解\x3ccode\x3eSymbol\x3c\/code\x3e对于之后我们理解迭代至关重要。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eSymbols\x3c\/h2\x3e\n\x3cp\x3eSymbol是ES6提供的一种新的JS基本类型。 它代表唯一值，和字符串，数值等基本类型的一个很大的不同点在于Symbol没有字符表达形式。Symbol的主要目的是用以实现协议，比如说，使用Symbol定义的迭代协议规定了对象将如何被迭代，关于这个，我们将在[Iterator Protocol and Iterable Protocol.]()这一章详细阐述。\x3c\/p\x3e\n\x3cp\x3eES6提供的Symbol有如下三种不同类型：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3elocal Symbol\x3c\/code\x3e；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eglobal Symbol\x3c\/code\x3e；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e语言内置\x3ccode\x3eSymbol\x3c\/code\x3e；\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这三种类型的Symbol存在着一定的不同，我们一种种来讲解，首先看\x3ccode\x3elocal Symbol\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eLocal Symbol\x3c\/h3\x3e\n\x3cp\x3eLocal Symbol 通过 \x3ccode\x3eSymbol\x3c\/code\x3e 包装对象创建，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const first = Symbol()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e first = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里有一点特别值得我们注意，在\x3ccode\x3eNumber\x3c\/code\x3e或\x3ccode\x3eString\x3c\/code\x3e等包装对象前是可以使用\x3ccode\x3enew\x3c\/code\x3e操作符的，在\x3ccode\x3eSymbol\x3c\/code\x3e前则不能使用，使用了会抛出错误，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const oops = new Symbol()\n\/\/ \x3c- TypeError, Symbol is not a constructor\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oops = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- TypeError, Symbol is not a constructor\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了方便调试，我们可以给新建的\x3ccode\x3eSymbol\x3c\/code\x3e添加描述：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const mystery = Symbol(\x27my symbol\x27)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e mystery = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27my symbol\x27\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和数值和字符串一样，Symbol是不可变的，但是和他们不同的是，Symbol是唯一的。描述并不影响唯一性，由具有相同描述的Symbol依旧是不相等的，下面代码说明了这个问题：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(Number(3) === Number(3))\n\/\/ \x3c- true\nconsole.log(Symbol() === Symbol())\n\/\/ \x3c- false\nconsole.log(Symbol(\x27my symbol\x27) === Symbol(\x27my symbol\x27))\n\/\/ \x3c- false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e) === \x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e() === \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e())\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27my symbol\x27\x3c\/span\x3e) === \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27my symbol\x27\x3c\/span\x3e))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eSymbols的类别为\x3ccode\x3esymbol\x3c\/code\x3e，使用 \x3ccode\x3etypeof\x3c\/code\x3e 可返回其类型：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(typeof Symbol())\n\/\/ \x3c- \x27symbol\x27\nconsole.log(typeof Symbol(\x27my symbol\x27))\n\/\/ \x3c- \x27symbol\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e())\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27symbol\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27my symbol\x27\x3c\/span\x3e))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27symbol\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eSymbols 可以用作对象的属性名，这里我们用\x3cstrong\x3e计算属性名\x3c\/strong\x3e来说明该如何使用，如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const weapon = Symbol(\x27weapon\x27)\nconst character = {\n  name: \x27Penguin\x27,\n  [weapon]: \x27umbrella\x27\n}\nconsole.log(character[weapon])\n\/\/ \x3c- \x27umbrella\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e weapon = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27weapon\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e character = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Penguin\x27\x3c\/span\x3e,\n  [weapon]: \x3cspan class=\x22hljs-string\x22\x3e\x27umbrella\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(character[weapon])\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27umbrella\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，许多传统的从对象中提取键的方法中对Symbol无效，也就是说他们获取不到Symbol。如下代码中的\x3ccode\x3efor...in \x3c\/code\x3e,\x3ccode\x3eObject,keys\x3c\/code\x3e,\x3ccode\x3eObject.getOwnPropertyNames\x3c\/code\x3e都不能访问到 Symbol 类型的属性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (let key in character) {\n  console.log(key)\n  \/\/ \x3c- \x27name\x27\n}\nconsole.log(Object.keys(character))\n\/\/ \x3c- [\x27name\x27]\nconsole.log(Object.getOwnPropertyNames(character))\n\/\/ \x3c- [\x27name\x27]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e key \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e character) {\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(key)\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27name\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(character))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- [\x27name\x27]\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertyNames(character))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- [\x27name\x27]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eSymbol的这方面的特性使得ES6之前的没有使用Symbol的代码并不会由于Symbol的出现而受影响。如下代码中，我们将对象解析为JSON，结果中的符号属性被丢弃了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(JSON.stringify(character))\n\/\/ \x3c- \x27{\x26quot;name\x26quot;:\x26quot;Penguin\x26quot;}\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(character))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27{\x22name\x22:\x22Penguin\x22}\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不过，Symbols绝不是一种用来隐藏属性的安全机制。采用特定的方法，它是可见的，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(Object.getOwnPropertySymbols(character))\n\/\/ \x3c- [Symbol(weapon)]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getOwnPropertySymbols(character))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- [Symbol(weapon)]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这意味着，Symbols 并非不可枚举的，只是它对一般方法不可见而已，通过\x3ccode\x3eObject.getOwnPropertySymbols\x3c\/code\x3e我们可以获取任何对象中的所有\x3ccode\x3eSymbol\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e现在我们已经知道了 Symbol 该如何使用，下面我们再讨论下其使用场景。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eSymbols的使用实例\x3c\/h3\x3e\n\x3cp\x3eSymbol最重要的用途就是用以避免命名冲突了，如下代码中，我们给DOM元素添加了自定义的属性，使用Symbol不用担心属性与其它属性甚至之后JS语言会加入的属性相冲突：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const cache = Symbol(\x27calendar\x27)\nfunction createCalendar(el) {\n  if (cache in el) { \/\/ does the symbol exist in the element?\n    return el[cache] \/\/ use the cache to avoid re-instantiation\n  }\n  const api = el[cache] = {\n    \/\/ the calendar API goes here\n  }\n  return api\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cache = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27calendar\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateCalendar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eel\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (cache \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e el) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ does the symbol exist in the element?\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e el[cache] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ use the cache to avoid re-instantiation\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e api = el[cache] = {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ the calendar API goes here\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e api\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eES6 还提供的一种名为\x3ccode\x3eWeakMap\x3c\/code\x3e的新数据类型,它用于唯一地将对象映射到其他对象。和数组查找表比起来，\x3ccode\x3eWeakMap\x3c\/code\x3e查找复杂度始终为O(1),我们将在 [Leveraging ECMAScript Collections]() 一章和其它ES6新增数据类型一起讨论这个。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e使用符号定义协议\x3c\/h3\x3e\n\x3cp\x3e前文中，我们说过 \x3ccode\x3eSymbol\x3c\/code\x3e 可以用以定义协议。协议是定义行为的通信契约或约定。\x3c\/p\x3e\n\x3cp\x3e下述代码中，我们给\x3ccode\x3echaracter\x3c\/code\x3e对象有一个\x3ccode\x3etoJSON\x3c\/code\x3e方法，这个方法，指定了对该对象使用\x3ccode\x3eJSON.stringify\x3c\/code\x3e时被序列化的对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const character = {\n  name: \x27Thor\x27,\n  toJSON: () =\x3e ({\n    key: \x27value\x27\n  })\n}\nconsole.log(JSON.stringify(character))\n\/\/ \x3c- \x27\x26quot;{\x26quot;key\x26quot;:\x26quot;value\x26quot;}\x26quot;\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e character = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Thor\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3etoJSON\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n    \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e\n  })\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(character))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27\x22{\x22key\x22:\x22value\x22}\x22\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果\x3ccode\x3etoJSON\x3c\/code\x3e不是函数，对\x3ccode\x3echaracter\x3c\/code\x3e对象执行\x3ccode\x3eJSON.stringify\x3c\/code\x3e则会有不同的结果，\x3ccode\x3echaracter\x3c\/code\x3e对象整体将被序列化。有时候这不是我们想要的结果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const character = {\n  name: \x27Thor\x27,\n  toJSON: true\n}\nconsole.log(JSON.stringify(character))\n\/\/ \x3c- \x27\x26quot;{\x26quot;name\x26quot;:\x26quot;Thor\x26quot;,\x26quot;toJSON\x26quot;:true}\x26quot;\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e character = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Thor\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3etoJSON\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(character))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27\x22{\x22name\x22:\x22Thor\x22,\x22toJSON\x22:true}\x22\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果\x3ccode\x3etoJSON\x3c\/code\x3e修饰符是Symbol类型，它就不会影响其它的对象属性了，不通过\x3ccode\x3eObject.getOwnPropertySymbols\x3c\/code\x3eSymbol永远不会暴露出来的，以下代码中我们用\x3ccode\x3eSymbol\x3c\/code\x3e自定义序列化函数\x3ccode\x3estringify\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const json = Symbol(\x27alternative to toJSON\x27)\nconst character = {\n  name: \x27Thor\x27,\n  [json]: () =\x3e ({\n    key: \x27value\x27\n  })\n}\nfunction stringify(target) {\n  if (json in target) {\n    return JSON.stringify(target[json]())\n  }\n  return JSON.stringify(target)\n}\nstringify(character)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e json = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27alternative to toJSON\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e character = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Thor\x27\x3c\/span\x3e,\n  [json]: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n    \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27value\x27\x3c\/span\x3e\n  })\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3estringify\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (json \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e target) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(target[json]())\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.stringify(target)\n}\nstringify(character)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用 Symbol 需要我们使用计算属性名在对象字面量中定义 \x3ccode\x3ejson\x3c\/code\x3e，这样做我们定义的变量就不会和其它的用户定义的属性或者以后JS语言可能会加入的属性有冲突。\x3c\/p\x3e\n\x3cp\x3e接下来我们继续讲解下一类符号--\x3ccode\x3eglobal symbol\x3c\/code\x3e，这类符号可以跨代码域访问。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e全局符号\x3c\/h3\x3e\n\x3cp\x3e代码域指的是任何JavaScript表达式的执行上下文，它可以是你的应用当前运行的页面、页面中的\x3ccode\x3e\x26lt;iframe\x26gt;\x3c\/code\x3e、由\x3ccode\x3eeval\x3c\/code\x3e运行的脚本、任意类型的\x3ccode\x3eworker\x3c\/code\x3e（\x3ccode\x3eweb worker\x3c\/code\x3e,\x3ccode\x3eservice workers\x3c\/code\x3e或者\x3ccode\x3eshared workers\x3c\/code\x3e）等等。这些执行上下文每一种都有其全局对象，比如说页面的全局对象\x3ccode\x3ewindow\x3c\/code\x3e，但是这种全局对象不能被其它代码域比如说\x3ccode\x3eServiceWorker\x3c\/code\x3e使用。相比而言，全局符号则更具全局性，它可以被任何代码域访问。\x3c\/p\x3e\n\x3cp\x3eES6提供了两个和全局符号相关的方法，\x3ccode\x3eSymbol.for\x3c\/code\x3e和\x3ccode\x3eSymbol.keyFor\x3c\/code\x3e。我们看看它们分别该如何使用？\x3c\/p\x3e\n\x3ch4\x3e通过\x3ccode\x3eSymbol.for(key)\x3c\/code\x3e获取symbols\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eSymbol.for(key)\x3c\/code\x3e方法将在运行时的符号注册表中查找\x3ccode\x3ekey\x3c\/code\x3e,如果全局注册表中存在\x3ccode\x3ekey\x3c\/code\x3e则返回其对于的\x3ccode\x3eSymbol\x3c\/code\x3e，如果不存在该\x3ccode\x3ekey\x3c\/code\x3e对于的Symbol，该方法会在全局注册表中创建一个新的\x3ccode\x3ekey\x3c\/code\x3e值为该\x3ccode\x3ekey\x3c\/code\x3e值的Symbol。这意味着，\x3ccode\x3eSymbol.for(key)\x3c\/code\x3e是幂等的（多次执行，结果唯一），先进行查找，不存在则新创建，然后返回查找到的或新创建的Symbol。\x3c\/p\x3e\n\x3cp\x3e我们看看使用示例，下面的代码中，\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e第一次调用\x3ccode\x3eSymbol.for\x3c\/code\x3e创建了一个key为\x3ccode\x3eexample\x3c\/code\x3e的Symbol，添加到到注册表，并返回了该Symbol；\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e第二次调用\x3ccode\x3eSymbol.for\x3c\/code\x3e由于该\x3ccode\x3ekey\x3c\/code\x3e已经在注册表中存在，因此返回了之前创建的全局符号。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const example = Symbol.for(\x27example\x27)\nconsole.log(example === Symbol.for(\x27example\x27))\n\/\/ \x3c- true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e example = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.for(\x3cspan class=\x22hljs-string\x22\x3e\x27example\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(example === \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.for(\x3cspan class=\x22hljs-string\x22\x3e\x27example\x27\x3c\/span\x3e))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e全局的符号注册表通过\x3ccode\x3ekey\x3c\/code\x3e标记符号，\x3ccode\x3ekey\x3c\/code\x3e还将作为新创建符号的描述信息。考虑到这些符号在运行时是全局的，在符号的key前添加前缀用以区分你的代码可以有效避免潜在的命名冲突。\x3c\/p\x3e\n\x3ch4\x3e使用\x3ccode\x3eSymbol.keyFor(symbol)\x3c\/code\x3e来提取符号的key\x3c\/h4\x3e\n\x3cp\x3e比如说现存一个名为为\x3ccode\x3esymbol\x3c\/code\x3e的全局符号，使用\x3ccode\x3eSymbol.keyFor(symbol)\x3c\/code\x3e将返回全局注册表中该\x3ccode\x3esymbol\x3c\/code\x3e对应的\x3ccode\x3ekey\x3c\/code\x3e值。我们看以下实例:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const example = Symbol.for(\x27example\x27)\nconsole.log(Symbol.keyFor(example))\n\/\/ \x3c- \x27example\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e example = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.for(\x3cspan class=\x22hljs-string\x22\x3e\x27example\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.keyFor(example))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27example\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e值得注意的是，如果符号非全局符号，该方法将返回\x3ccode\x3eundefined\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(Symbol.keyFor(Symbol()))\n\/\/ \x3c- undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.keyFor(\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e()))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在全局符号注册表中，使用\x3ccode\x3elocal Symbol\x3c\/code\x3e是匹配不到值的，即使它们的描述相同也是如此，local Symbol 不是全局符号注册表的一部分：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const example = Symbol.for(\x27example\x27)\nconsole.log(Symbol.keyFor(Symbol(\x27example\x27)))\n\/\/ \x3c- undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e example = \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.for(\x3cspan class=\x22hljs-string\x22\x3e\x27example\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.keyFor(\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27example\x27\x3c\/span\x3e)))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e全局符号相关的方法主要就是这两个了，下面我们看看该如何实际使用：\x3c\/p\x3e\n\x3ch4\x3e全局符号实践\x3c\/h4\x3e\n\x3cp\x3e某符号为全局符号意味着该符号可以被任何代码域获取，且在任何代码域中调用，它们都将返回相同的值。下面的例子，我们使用\x3ccode\x3eSymbol.for\x3c\/code\x3e分别在页面中和\x3ccode\x3e\x26lt;iframe\x26gt;\x3c\/code\x3e中查找key 为\x3ccode\x3eexample\x3c\/code\x3e 的Symbol，实践表明，它们是相同的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const d = document\nconst frame = d.body.appendChild(d.createElement(\x27iframe\x27))\nconst framed = frame.contentWindow\nconst s1 = window.Symbol.for(\x27example\x27)\nconst s2 = framed.Symbol.for(\x27example\x27)\nconsole.log(s1 === s2)\n\/\/ \x3c- true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e d = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e frame = d.body.appendChild(d.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27iframe\x27\x3c\/span\x3e))\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e framed = frame.contentWindow\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e s1 = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.Symbol.for(\x3cspan class=\x22hljs-string\x22\x3e\x27example\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e s2 = framed.Symbol.for(\x3cspan class=\x22hljs-string\x22\x3e\x27example\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(s1 === s2)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用全局符号就像我们使用全局变量一样，合理使用在某些时候非常便利，但是不合理使用又会造成灾难。全局符号在符号需要跨代码域使用时非常有用，比如说跨\x3ccode\x3eServiceWorker\x3c\/code\x3e和浏览器页面，但是滥用会导致Symbol难易管理，容易冲突。\x3c\/p\x3e\n\x3cp\x3e下面我们来看，最后一种Symbol，内置的常用Symbol。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e内置的常用Symbol\x3c\/h3\x3e\n\x3cp\x3e内置的常用Symbol为JS语言行为添加了钩子，在一定程度上允许你拓展和自定义JS语言。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eSymbol.toPrimitive\x3c\/code\x3e符号，是描述如何通过 Symbols 给语言添加额外的功能的最好的例子，这个Symbol的作用是，依据给定的类型返回默认值。该函数接收一个\x3ccode\x3ehint\x3c\/code\x3e参数，参数可以是\x3ccode\x3estring\x3c\/code\x3e,\x3ccode\x3enumber\x3c\/code\x3e或\x3ccode\x3edefault\x3c\/code\x3e，用以指明默认值的期待类型。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const morphling = {\n  [Symbol.toPrimitive](hint) {\n    if (hint === \x27number\x27) {\n      return Infinity\n    }\n    if (hint === \x27string\x27) {\n      return \x27a lot\x27\n    }\n    return \x27[object Morphling]\x27\n  }\n}\nconsole.log(\x2bmorphling) \/\/ \x2b 号 \n\/\/ \x3c- Infinity\nconsole.log(`That is ${ morphling }!`)\n\/\/ \x3c- \x27That is a lot!\x27\nconsole.log(morphling \x2b \x27 is powerful\x27)\n\/\/ \x3c- \x27[object Morphling] is powerful\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e morphling = {\n  [\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.toPrimitive](hint) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hint === \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3eInfinity\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (hint === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27a lot\x27\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27[object Morphling]\x27\x3c\/span\x3e\n  }\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x2bmorphling) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x2b 号 \x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- Infinity\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e`That is \x3cspan class=\x22hljs-subst\x22\x3e${ morphling }\x3c\/span\x3e!`\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27That is a lot!\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(morphling \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27 is powerful\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- \x27[object Morphling] is powerful\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e另一个常用的内置Symbol是 \x3ccode\x3eSymbol.match\x3c\/code\x3e ,该Symbol指定了匹配的是正则表达式而不是字符串，以\x3ccode\x3e.startWith\x3c\/code\x3e,\x3ccode\x3e.endWith\x3c\/code\x3e或\x3ccode\x3e.includes\x3c\/code\x3e，这三个ES6提供新字符串方法为例。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x26quot;\/bar\/\x26quot;.startsWith(\/bar\/); \n\/\/ Throws TypeError, 因为 \/bar\/ 是一个正则表达式\n\nconst text = \x27\/an example string\/\x27\nconst regex = \/an example string\/\nregex[Symbol.match] = false\nconsole.log(text.startsWith(regex))\n\/\/ \x3c- true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22\/bar\/\x22\x3c\/span\x3e.startsWith(\x3cspan class=\x22hljs-regexp\x22\x3e\/bar\/\x3c\/span\x3e); \n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Throws TypeError, 因为 \/bar\/ 是一个正则表达式\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e text = \x3cspan class=\x22hljs-string\x22\x3e\x27\/an example string\/\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e regex = \x3cspan class=\x22hljs-regexp\x22\x3e\/an example string\/\x3c\/span\x3e\nregex[\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.match] = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(text.startsWith(regex))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果正则表达式没有通过Symbol修改，这里将抛出错误，因为\x3ccode\x3e.startWith\x3c\/code\x3e方法希望其参数是一个字符串而非正则表达式。\x3c\/p\x3e\n\x3ch4\x3e内置Symbol不在全局注册表中但是跨域共享\x3c\/h4\x3e\n\x3cp\x3e这些内置的Symbol是跨代码域共享的，如下所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const frame = document.createElement(\x27iframe\x27)\ndocument.body.appendChild(frame)\nSymbol.iterator === frame.contentWindow.Symbol.iterator\n\/\/ \x3c- true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e frame = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27iframe\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.appendChild(frame)\n\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.iterator === frame.contentWindow.Symbol.iterator\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，虽然语言内置的这些Symbol是跨代码块共享的，但是他们并不在全局符号注册表中，我们在下述代码中想要找到\x3ccode\x3eSymbol.iterator\x3c\/code\x3e的\x3ccode\x3ekey\x3c\/code\x3e值，返回值是\x3ccode\x3eundefined\x3c\/code\x3e就说明了这个问题。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(Symbol.keyFor(Symbol.iterator))\n\/\/ \x3c- undefined\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.keyFor(\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.iterator))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- undefined\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e另外一个常用的符号是\x3ccode\x3eSymbol.iterator\x3c\/code\x3e,它为每一个对象定义了默认的迭代器。我们将在下一章中详细讲述\x3ccode\x3eSymbol.iterator\x3c\/code\x3e的细节内容。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e内置对象的改进\x3c\/h2\x3e\n\x3cp\x3e我们在\x3ca href=\x22https:\/\/github.com\/zhangwang1990\/PracticeModernJavaScript\/blob\/master\/docs\/%E7%AC%AC2%E7%AB%A0.%20ES6%20%E6%A6%82%E8%A6%81.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eES6 概要\x3c\/a\x3e一章，已经讲述过ES6中对象字面量语法的改进，这里我们再补充一下内置对象新增的方法。\x3c\/p\x3e\n\x3cp\x3e除了前面讨论过的\x3ccode\x3eObject.getOwnPropertySymbols\x3c\/code\x3e，新增的对象方法还有\x3ccode\x3eObject.assign\x3c\/code\x3e,\x3ccode\x3eObject.is\x3c\/code\x3e以及\x3ccode\x3eObject.setPrototypeOf\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e使用\x3ccode\x3eObject.assign\x3c\/code\x3e来拓展对象\x3c\/h3\x3e\n\x3cp\x3e我们在实际开发中常常使用各种库，一些库在允许我们自定义某些行为，不过为了使用方便这些库通常也给出了默认值，而我们的自定义常常就是在默认值的基础上进行的。\x3c\/p\x3e\n\x3cp\x3e假如说现在有这么一个Markdown库。其接收一个 \x3ccode\x3einput\x3c\/code\x3e 参数，依据\x3ccode\x3einput\x3c\/code\x3e代表的Markdown内容，转换其为 Html 是其默认的用法，用户不需要提供其它参数就可以简单使用这个库。不过，该库还支持多个高级的配置，只是默认是关闭的，比如说通过配置可以添加\x3ccode\x3e\x26lt;script\x26gt;\x3c\/code\x3e或\x3ccode\x3e\x26lt;iframe\x26gt;\x3c\/code\x3e，可以启用 css 来高亮渲染代码片段。\x3c\/p\x3e\n\x3cp\x3e比如说，该库的默认选项如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const defaults = {\n  scripts: false,\n  iframes: false,\n  highlightSyntax: true\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaults = {\n  \x3cspan class=\x22hljs-attr\x22\x3escripts\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eiframes\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ehighlightSyntax\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以使用解构将\x3ccode\x3edefaults\x3c\/code\x3e对象设置为\x3ccode\x3eoptions\x3c\/code\x3e的默认值，在以前，如果用户想要自定义，用户必须提供每个选项的值。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function md(input, options=defaults) {\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emd\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einput, options=defaults\x3c\/span\x3e) \x3c\/span\x3e{\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eObject.assign\x3c\/code\x3e 就是为这种场景而生，这个方法可以非常方便的合并默认值和用户提供的值，如下代码所示，我们传入\x3ccode\x3e{}\x3c\/code\x3e作为\x3ccode\x3eObject.assign\x3c\/code\x3e的第一个参数，之后这个参数将不断与后面的参数对比合并，后面参数中的重复值将覆盖前面以后的值，待所有的比较合并完成，我们将获得最终的值。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function md(input, options) {\n  const config = Object.assign({}, defaults, options)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emd\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einput, options\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}, defaults, options)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3ch4\x3e理解\x3ccode\x3eObject.assign\x3c\/code\x3e第一个参数的特殊意义\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eObject.assign\x3c\/code\x3e的返回值是依据第一个参数而来的，第一个参数最终会修改为返回值，参数可看做\x3ccode\x3e(target, ...sources)\x3c\/code\x3e,所有的 sources 都会被应用到\x3ccode\x3etarget\x3c\/code\x3e中。\x3c\/p\x3e\n\x3cp\x3e如果这里我们的第一个参数不是一个空对象，而是\x3ccode\x3edefaults\x3c\/code\x3e，那么\x3ccode\x3eObject.assign()\x3c\/code\x3e执行结束之后，\x3ccode\x3edefaults\x3c\/code\x3e对象的值也将被改变，虽然这里我们会得到和前面那个例子中一样的结果，但是由于\x3ccode\x3edefault\x3c\/code\x3e值被改变，在别的地方可能也会导致一些意想不到的问题。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function md(input, options) {\n  const config = Object.assign(defaults, options)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emd\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3einput, options\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e config = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(defaults, options)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e因此，最好把\x3ccode\x3eObject.assign\x3c\/code\x3e的第一个参数始终设置为\x3ccode\x3e{}\x3c\/code\x3e。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e下面的代码加深你对\x3ccode\x3eObject.assign\x3c\/code\x3e的理解：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const defaults = {\n  first: \x27first\x27,\n  second: \x27second\x27\n}\nfunction applyDefaults(options) {\n  return Object.assign({}, defaults, options)\n}\napplyDefaults()\n\/\/ \x3c- { first: \x27first\x27, second: \x27second\x27 }\napplyDefaults({ third: 3 })\n\/\/ \x3c- { first: \x27first\x27, second: \x27second\x27, third: 3 }\napplyDefaults({ second: false })\n\/\/ \x3c- { first: \x27first\x27, second: false }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaults = {\n  \x3cspan class=\x22hljs-attr\x22\x3efirst\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27first\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3esecond\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27second\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eapplyDefaults\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoptions\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}, defaults, options)\n}\napplyDefaults()\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { first: \x27first\x27, second: \x27second\x27 }\x3c\/span\x3e\napplyDefaults({ \x3cspan class=\x22hljs-attr\x22\x3ethird\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e })\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { first: \x27first\x27, second: \x27second\x27, third: 3 }\x3c\/span\x3e\napplyDefaults({ \x3cspan class=\x22hljs-attr\x22\x3esecond\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e })\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { first: \x27first\x27, second: false }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，\x3ccode\x3eObject.assign\x3c\/code\x3e只会考虑可枚举的属性（包括字符串属性和符号属性）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const defaults = {\n  [Symbol(\x27currency\x27)]: \x27USD\x27\n}\nconst options = {\n  price: \x270.99\x27\n}\nObject.defineProperty(options, \x27name\x27, {\n  value: \x27Espresso Shot\x27,\n  enumerable: false\n})\nconsole.log(Object.assign({}, defaults, options))\n\/\/ \x3c- { [Symbol(\x27currency\x27)]: \x27USD\x27, price: \x270.99\x27 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaults = {\n  [\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27currency\x27\x3c\/span\x3e)]: \x3cspan class=\x22hljs-string\x22\x3e\x27USD\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e options = {\n  \x3cspan class=\x22hljs-attr\x22\x3eprice\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x270.99\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(options, \x3cspan class=\x22hljs-string\x22\x3e\x27name\x27\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Espresso Shot\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}, defaults, options))\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { [Symbol(\x27currency\x27)]: \x27USD\x27, price: \x270.99\x27 }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e不过\x3ccode\x3eObject.assign\x3c\/code\x3e也不是万能的，比如说其复制并非深复制，\x3ccode\x3eObject.assign\x3c\/code\x3e不会对对象进行回归处理，值为对象的属性将会被\x3ccode\x3etarget\x3c\/code\x3e直接引用。\x3c\/p\x3e\n\x3cp\x3e下例中，你可能希望\x3ccode\x3ef\x3c\/code\x3e属性可以被添加到\x3ccode\x3etarget.a\x3c\/code\x3e，而保持\x3ccode\x3eb.c\x3c\/code\x3e,\x3ccode\x3eb.d\x3c\/code\x3e不变，但是实际上，当使用\x3ccode\x3eObject.assign\x3c\/code\x3e时，\x3ccode\x3eb.c\x3c\/code\x3e和\x3ccode\x3eb.d\x3c\/code\x3e属性丢失了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.assign({}, { a: { b: \x27c\x27, d: \x27e\x27 } }, { a: { f: \x27g\x27 } })\n\/\/ \x3c- { a: { f: \x27g\x27 } }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}, { \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: { \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ed\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27e\x27\x3c\/span\x3e } }, { \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: { \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27g\x27\x3c\/span\x3e } })\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { a: { f: \x27g\x27 } }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同样的，数据也存在类似的问题，以下代码中，如果你期待\x3ccode\x3eObject.assign\x3c\/code\x3e进行递归处理，你将大失所望。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.assign({}, { a: [\x27b\x27, \x27c\x27, \x27d\x27] }, { a: [\x27e\x27, \x27f\x27] })\n\/\/ \x3c- { a: [\x27e\x27, \x27f\x27] }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign({}, { \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27d\x27\x3c\/span\x3e] }, { \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27e\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27f\x27\x3c\/span\x3e] })\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { a: [\x27e\x27, \x27f\x27] }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在本书写作过程中，存在一个处于\x3ccode\x3estage 3\x3c\/code\x3e的ECMAScript提议，用以在对象中使用拓展符，其使用类似于数组等可迭代对象。对对象使用拓展和使用\x3ccode\x3eObject.assign\x3c\/code\x3e的结果类似。\x3c\/p\x3e\n\x3cp\x3e下述代码展示了对象拓展符的使用方法：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const grocery = { ...details }\n\/\/ Object.assign({}, details)\nconst grocery = { type: \x27fruit\x27, ...details }\n\/\/ Object.assign({ type: \x27fruit\x27 }, details)\nconst grocery = { type: \x27fruit\x27, ...details, ...fruit }\n\/\/ Object.assign({ type: \x27fruit\x27 }, details, fruit)\nconst grocery = { type: \x27fruit\x27, ...details, color: \x27red\x27 }\n\/\/ Object.assign({ type: \x27fruit\x27 }, details, { color: \x27red\x27 })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e grocery = { ...details }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Object.assign({}, details)\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e grocery = { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27fruit\x27\x3c\/span\x3e, ...details }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Object.assign({ type: \x27fruit\x27 }, details)\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e grocery = { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27fruit\x27\x3c\/span\x3e, ...details, ...fruit }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Object.assign({ type: \x27fruit\x27 }, details, fruit)\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e grocery = { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27fruit\x27\x3c\/span\x3e, ...details, \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Object.assign({ type: \x27fruit\x27 }, details, { color: \x27red\x27 })\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e该提案也包含对象剩余值，使用和数组剩余值类似。\x3c\/p\x3e\n\x3cp\x3e下面是对象剩余值的使用实例，就像数组剩余值一样，其需要位于结构的最后面：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const getUnknownProperties = ({ name, type, ...unknown }) =\x3e  unknown\ngetUnknownProperties({\n  name: \x27Carrot\x27,\n  type: \x27vegetable\x27,\n  color: \x27orange\x27\n})\n\/\/ \x3c- { color: \x27orange\x27 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e getUnknownProperties = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e{ name, type, ...unknown }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e  unknown\ngetUnknownProperties({\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Carrot\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27vegetable\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27orange\x27\x3c\/span\x3e\n})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { color: \x27orange\x27 }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以利用类似的方法在变量声明时解构对象，下例中，每一个未明确指明的属性都将位于\x3ccode\x3emeta\x3c\/code\x3e对象中：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const { name, type, ...meta } = {\n  name: \x27Carrot\x27,\n  type: \x27vegetable\x27,\n  color: \x27orange\x27\n}\n\/\/ \x3c- name = \x27Carrot\x27\n\/\/ \x3c- type = \x27vegetable\x27\n\/\/ \x3c- meta = { color: \x27orange\x27 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { name, type, ...meta } = {\n  \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Carrot\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27vegetable\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27orange\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- name = \x27Carrot\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- type = \x27vegetable\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- meta = { color: \x27orange\x27 }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们将在[Practical Considerations.]()一章再详细讨论对象解构和剩余值。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e使用\x3ccode\x3eObject.is\x3c\/code\x3e对比对象\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eObject.is\x3c\/code\x3e方法和严格相等运算符\x3ccode\x3e===\x3c\/code\x3e略有不同。主要表现在两个地方，\x3ccode\x3eNaN\x3c\/code\x3e以及，\x3ccode\x3e-0\x3c\/code\x3e和\x3ccode\x3e0\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e当\x3ccode\x3eNaN\x3c\/code\x3e与\x3ccode\x3eNaN\x3c\/code\x3e相比较时，严格相等运算符\x3ccode\x3e===\x3c\/code\x3e将返回\x3ccode\x3efalse\x3c\/code\x3e,因为\x3ccode\x3eNaN\x3c\/code\x3e和本身也不相等，\x3ccode\x3eObject.is\x3c\/code\x3e则在这种情况下返回\x3ccode\x3etrue\x3c\/code\x3e.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22NaN === NaN\n\/\/ \x3c- false\nObject.is(NaN, NaN)\n\/\/ \x3c- true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e === \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.is(\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e使用严格相等运算符比较\x3ccode\x3e0\x3c\/code\x3e和\x3ccode\x3e-0\x3c\/code\x3e会得到\x3ccode\x3etrue\x3c\/code\x3e,而使用\x3ccode\x3eObject.is\x3c\/code\x3e则会返回\x3ccode\x3efalse\x3c\/code\x3e.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22-0 === \x2b0\n\/\/ \x3c- true\nObject.is(-0, \x2b0)\n\/\/ \x3c- false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-number\x22\x3e-0\x3c\/span\x3e === \x2b\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.is(\x3cspan class=\x22hljs-number\x22\x3e-0\x3c\/span\x3e, \x2b\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3eObject.setPrototpyeOf\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eObject.setPrototypeOf\x3c\/code\x3e，名如其意，它用以设置某个对象的原型指向的对象。与遗留方法\x3ccode\x3e__proto__\x3c\/code\x3e相比，它是被认可的设置对象原型的方法。\x3c\/p\x3e\n\x3cp\x3e还记得吗，我们在ES5中引入了\x3ccode\x3eObject.create\x3c\/code\x3e，这个方法允许我们以任何传递给\x3ccode\x3eObject.create\x3c\/code\x3e的参数作为新建对象的原型链：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const baseCat = { type: \x27cat\x27, legs: 4 }\nconst cat = Object.create(baseCat)\ncat.name = \x27Milanesita\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e baseCat = { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3elegs\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e }\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cat = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(baseCat)\ncat.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Milanesita\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eObject.create\x3c\/code\x3e方法只能在新创建的对象时指定原型，\x3ccode\x3eObject.setPrototypeOf\x3c\/code\x3e则可以用以改变任何已经存在的对象的原型链：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const baseCat = { type: \x27cat\x27, legs: 4 }\nconst cat = Object.setPrototypeOf(\n  { name: \x27Milanesita\x27 },\n  baseCat\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e baseCat = { \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27cat\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3elegs\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e }\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cat = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.setPrototypeOf(\n  { \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Milanesita\x27\x3c\/span\x3e },\n  baseCat\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e与\x3ccode\x3eObject.create\x3c\/code\x3e比起来，\x3ccode\x3eObject.setPrototypeOf\x3c\/code\x3e具有严重的性能问题，因此在如果你很在乎这个，使用前应好好考虑。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3ch4\x3e对性能问题的说明\x3c\/h4\x3e\n\x3cp\x3e使用\x3ccode\x3eObject.setPrototypeOf\x3c\/code\x3e来改变一个对象的原型是一个昂贵的操作，MDN是这样解释的：\x3cbr\x3e由于现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 obj.__proto__ = ... 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何[[Prototype]]已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 [[Prototype]]。相反，你应该使用 Object.create()来创建带有你想要的[[Prototype]]的新对象。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e装饰器(Decorators)\x3c\/h3\x3e\n\x3cp\x3e对于大多数编程语言而言，装饰器不是一个新概念。在现代编程语言中，装饰器模式相当常见，c# 中 有\x3ccode\x3eattributes\x3c\/code\x3e,Java中有\x3ccode\x3eannotations\x3c\/code\x3e，Python中有\x3ccode\x3edecorators\x3c\/code\x3e等等。目前也存在一个处于Stage2 的JavaScript的装饰器提案。\x3c\/p\x3e\n\x3cp\x3eJavaScript中的装饰器语法和Python的非常类似。JavaScript的装饰器可以应用于任何对象或者静态声明的属性前。诸如对象字面量声明或\x3ccode\x3eclass\x3c\/code\x3e声明前，或\x3ccode\x3eget\x3c\/code\x3e,\x3ccode\x3eset\x3c\/code\x3e,\x3ccode\x3estatic\x3c\/code\x3e前。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@inanimate\nclass Car {}\n\n@expensive\n@speed(\x27fast\x27)\nclass Lamborghini extends Car {}\n\nclass View {\n  @throttle(200) \/\/ reconcile once every 200ms at most\n  reconcile() {}\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e@inanimate\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCar\x3c\/span\x3e \x3c\/span\x3e{}\n\n@expensive\n@speed(\x3cspan class=\x22hljs-string\x22\x3e\x27fast\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eLamborghini\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCar\x3c\/span\x3e \x3c\/span\x3e{}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eView\x3c\/span\x3e \x3c\/span\x3e{\n  @throttle(\x3cspan class=\x22hljs-number\x22\x3e200\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ reconcile once every 200ms at most\x3c\/span\x3e\n  reconcile() {}\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e关于装饰器凹凸实验室的一篇文章解释的比较清楚，大家可以参考\x3ca href=\x22https:\/\/aotu.io\/notes\/2016\/10\/24\/decorator\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavascript 中的装饰器\x3c\/a\x3e。\x3c\/p\x3e\n\x3cblockquote\x3e\n\x3cp\x3e当装饰器作用于类本身的时候，我们操作的对象也是这个类本身，而当装饰器作用于类的某个具体的属性的时候，我们操作的对象既不是类本身，也不是类的属性，而是它的描述符（descriptor），而描述符里记录着我们对这个属性的全部信息，所以，我们可以对它自由的进行扩展和封装，最后达到的目的呢，就和之前说过的装饰器的作用是一样的。可以看如下两段代码加深理解\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e作用于类时\x3c\/strong\x3e\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\nfunction isAnimal(target) {\n    target.isAnimal = true;\n      return target;\n}\n@isAnimal\nclass Cat {\n    ...\n}\nconsole.log(Cat.isAnimal);    \/\/ true\n\n\/\/ 相当于\n    \nCat = isAnimal(function Cat() { ... });\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eisAnimal\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget\x3c\/span\x3e) \x3c\/span\x3e{\n    target.isAnimal = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e target;\n}\n@isAnimal\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e \x3c\/span\x3e{\n    ...\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(Cat.isAnimal);    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相当于\x3c\/span\x3e\n    \nCat = isAnimal(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ ... });\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3e作用于类属性时\x3c\/strong\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function readonly(target, name, descriptor) {\n    discriptor.writable = false;\n    return discriptor;\n}\nclass Cat {\n    @readonly\n    say() {\n        console.log(\x26quot;meow ~\x26quot;);\n    }\n}\nvar kitty = new Cat();\nkitty.say = function() {\n    console.log(\x26quot;woof !\x26quot;);\n}\nkitty.say()    \/\/ meow ~\n\n\/\/ 相当于\nlet descriptor = {\n    value: function() {\n        console.log(\x26quot;meow ~\x26quot;);\n    },\n    enumerable: false,\n    configurable: true,\n    writable: true\n};\ndescriptor = readonly(Cat.prototype, \x26quot;say\x26quot;, descriptor) || descriptor;\nObject.defineProperty(Cat.prototype, \x26quot;say\x26quot;, descriptor);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereadonly\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etarget, name, descriptor\x3c\/span\x3e) \x3c\/span\x3e{\n    discriptor.writable = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e discriptor;\n}\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCat\x3c\/span\x3e \x3c\/span\x3e{\n    @readonly\n    say() {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22meow ~\x22\x3c\/span\x3e);\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e kitty = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Cat();\nkitty.say = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22woof !\x22\x3c\/span\x3e);\n}\nkitty.say()    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ meow ~\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 相当于\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e descriptor = {\n    \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22meow ~\x22\x3c\/span\x3e);\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ewritable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n};\ndescriptor = readonly(Cat.prototype, \x3cspan class=\x22hljs-string\x22\x3e\x22say\x22\x3c\/span\x3e, descriptor) || descriptor;\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(Cat.prototype, \x3cspan class=\x22hljs-string\x22\x3e\x22say\x22\x3c\/span\x3e, descriptor);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader15\x22\x3e有用的链接\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/zhangwang1990\/PracticeModernJavaScript\/blob\/master\/docs\/ECMAScript%20%E5%92%8C%20JavaScript%E7%9A%84%E6%9C%AA%E6%9D%A5.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e第一章 ECMAScript简史 和 JavaScript的未来\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/zhangwang1990\/PracticeModernJavaScript\/blob\/master\/docs\/%E7%AC%AC2%E7%AB%A0.%20ES6%20%E6%A6%82%E8%A6%81.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e第二章 ES6 概要\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/zhangwang1990\/PracticeModernJavaScript\/blob\/master\/docs\/%E7%AC%AC3%E7%AB%A0.%20Classes%2CSymbols%2CObjects%20%E5%92%8C%20Decorators.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e第三章 Classs,Symbols,Objects拓展 和 Decorators\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/mjavascript\/practical-modern-javascript\/blob\/master\/ch03.asciidoc\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e本章原文链接\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/zhangwang1990\/PracticeModernJavaScript\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e本书Github地址，期待交流\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>弄清Classs,Symbols,Objects拓展 和 Decorators</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010341292">https://segmentfault.com/a/1190000010341292</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6nnz6mampkt/" target="_blank">https://alili.tech/archive/6nnz6mampkt/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>