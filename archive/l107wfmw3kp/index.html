<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="解析vue2.0的diff算法"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>解析vue2.0的diff算法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/l107wfmw3kp/",
				"appid": "1613049289050283", 
				"title": "解析vue2.0的diff算法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-18T02:30:34"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/0imobok9cq6/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/jvdjd3q1ldm/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f&text=%e8%a7%a3%e6%9e%90vue2.0%e7%9a%84diff%e7%ae%97%e6%b3%95"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f&text=%e8%a7%a3%e6%9e%90vue2.0%e7%9a%84diff%e7%ae%97%e6%b3%95"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f&title=%e8%a7%a3%e6%9e%90vue2.0%e7%9a%84diff%e7%ae%97%e6%b3%95"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f&is_video=false&description=%e8%a7%a3%e6%9e%90vue2.0%e7%9a%84diff%e7%ae%97%e6%b3%95"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e8%a7%a3%e6%9e%90vue2.0%e7%9a%84diff%e7%ae%97%e6%b3%95&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f&title=%e8%a7%a3%e6%9e%90vue2.0%e7%9a%84diff%e7%ae%97%e6%b3%95"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f&title=%e8%a7%a3%e6%9e%90vue2.0%e7%9a%84diff%e7%ae%97%e6%b3%95"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f&title=%e8%a7%a3%e6%9e%90vue2.0%e7%9a%84diff%e7%ae%97%e6%b3%95"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl107wfmw3kp%2f&title=%e8%a7%a3%e6%9e%90vue2.0%e7%9a%84diff%e7%ae%97%e6%b3%95"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">解析vue2.0的diff算法</h1><div class="meta"><div class="postdate"><time datetime="2019-01-18" itemprop="datePublished">2019-01-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e\x3cstrong\x3e转载请注明出处\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e本文转载至我的\x3ca href=\x22https:\/\/github.com\/aooy\/blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eblog\x3c\/a\x3e\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader0\x22\x3e目录\x3c\/h1\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e前言\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3evirtual dom\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e分析diff\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e总结\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e前言\x3c\/h1\x3e\n\x3cp\x3evue2.0加入了virtual dom，有向react靠拢的意思。vue的diff位于\x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/blob\/dev\/src\/core\/vdom\/patch.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epatch.js\x3c\/a\x3e文件中，我的一个小框架\x3ca href=\x22https:\/\/github.com\/aooy\/aoy\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eaoy\x3c\/a\x3e也同样使用此算法，该算法来源于\x3ca href=\x22https:\/\/github.com\/snabbdom\/snabbdom\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3esnabbdom\x3c\/a\x3e，复杂度为O(n)。\x3cbr\x3e了解diff过程可以让我们更高效的使用框架。\x3cbr\x3e本文力求以图文并茂的方式来讲明这个diff的过程。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3evirtual dom\x3c\/h1\x3e\n\x3cp\x3e如果不了解virtual dom，要理解diff的过程是比较困难的。虚拟dom对应的是真实dom， 使用\x3ccode\x3edocument.CreateElement\x3c\/code\x3e 和 \x3ccode\x3edocument.CreateTextNode\x3c\/code\x3e创建的就是真实节点。\x3c\/p\x3e\n\x3cp\x3e我们可以做个试验。打印出一个空元素的第一层属性，可以看到标准让元素实现的东西太多了。如果每次都重新生成新的元素，对性能是巨大的浪费。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var mydiv = document.createElement(\x27div\x27);\nfor(var k in mydiv ){\n  console.log(k)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mydiv = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27div\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e k \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e mydiv ){\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(k)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3evirtual dom就是解决这个问题的一个思路，到底什么是virtual dom呢？通俗易懂的来说就是用一个简单的对象去代替复杂的dom对象。\x3cbr\x3e举个简单的例子，我们在body里插入一个class为a的div。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var mydiv = document.createElement(\x27div\x27);\nmydiv.className = \x27a\x27;\ndocument.body.appendChild(mydiv);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dart\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mydiv = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x27div\x27\x3c\/span\x3e);\nmydiv.className = \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.appendChild(mydiv);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对于这个div我们可以用一个简单的对象\x3ccode\x3emydivVirtual\x3c\/code\x3e代表它，它存储了对应dom的一些重要参数，在改变dom之前，会先比较相应虚拟dom的数据，如果需要改变，才会将改变应用到真实dom上。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/伪代码\nvar mydivVirtual = { \n  tagName: \x27DIV\x27,\n  className: \x27a\x27\n};\nvar newmydivVirtual = {\n   tagName: \x27DIV\x27,\n   className: \x27b\x27\n}\nif(mydivVirtual.tagName !== newmydivVirtual.tagName || mydivVirtual.className  !== newmydivVirtual.className){\n   change(mydiv)\n}\n\n\/\/ 会执行相应的修改 mydiv.className = \x27b\x27;\n\/\/最后  \x3cdiv class=\x27b\x27\x3e\x3c\/div\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/伪代码\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mydivVirtual = { \n  \x3cspan class=\x22hljs-attr\x22\x3etagName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27DIV\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e\n};\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e newmydivVirtual = {\n   \x3cspan class=\x22hljs-attr\x22\x3etagName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27DIV\x27\x3c\/span\x3e,\n   \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(mydivVirtual.tagName !== newmydivVirtual.tagName || mydivVirtual.className  !== newmydivVirtual.className){\n   change(mydiv)\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 会执行相应的修改 mydiv.className = \x27b\x27;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/最后  \x26lt;div class=\x27b\x27\x26gt;\x26lt;\/div\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e读到这里就会产生一个疑问，为什么不直接修改dom而需要加一层virtual dom呢？\x3c\/h4\x3e\n\x3cp\x3e很多时候手工优化dom确实会比virtual dom效率高，对于比较简单的dom结构用手工优化没有问题，但当页面结构很庞大，结构很复杂时，手工优化会花去大量时间，而且可维护性也不高，不能保证每个人都有手工优化的能力。至此，virtual dom的解决方案应运而生，\x3cstrong\x3evirtual dom很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。\x3c\/strong\x3e \x3c\/p\x3e\n\x3cp\x3evirtual dom 另一个重大意义就是提供一个中间层，js去写ui，ios安卓之类的负责渲染，就像reactNative一样。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3e分析diff\x3c\/h1\x3e\n\x3cp\x3e一篇相当经典的文章\x3ca href=\x22https:\/\/calendar.perfplanet.com\/2013\/diff\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eReact’s diff algorithm\x3c\/a\x3e中的图，react的diff其实和vue的diff大同小异。所以这张图能很好的解释过程。\x3cstrong\x3e比较只会在同层级进行, 不会跨层级比较。\x3c\/strong\x3e \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVs5U9\x22 src=\x22https:\/\/static.alili.tech\/img\/bVs5U9\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e举个形象的例子。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c!-- 之前 --\x3e\n\x3cdiv\x3e           \x3c!-- 层级1 --\x3e\n  \x3cp\x3e            \x3c!-- 层级2 --\x3e\n    \x3cb\x3e aoy \x3c\/b\x3e   \x3c!-- 层级3 --\x3e   \n    \x3cspan\x3ediff\x3c\/Span\x3e\n  \x3c\/P\x3e \n\x3c\/div\x3e\n\n\x3c!-- 之后 --\x3e\n\x3cdiv\x3e            \x3c!-- 层级1 --\x3e\n  \x3cp\x3e             \x3c!-- 层级2 --\x3e\n      \x3cb\x3e aoy \x3c\/b\x3e        \x3c!-- 层级3 --\x3e\n  \x3c\/p\x3e\n  \x3cspan\x3ediff\x3c\/Span\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x26lt;!-- 之前 --\x26gt;\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e           \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 层级1 --\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e            \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 层级2 --\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eb\x3c\/span\x3e\x26gt;\x3c\/span\x3e aoy \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eb\x3c\/span\x3e\x26gt;\x3c\/span\x3e   \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 层级3 --\x26gt;\x3c\/span\x3e   \n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3ediff\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSpan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eP\x3c\/span\x3e\x26gt;\x3c\/span\x3e \n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\n\x26lt;!-- 之后 --\x26gt;\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e            \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 层级1 --\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e             \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 层级2 --\x26gt;\x3c\/span\x3e\n      \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eb\x3c\/span\x3e\x26gt;\x3c\/span\x3e aoy \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eb\x3c\/span\x3e\x26gt;\x3c\/span\x3e        \x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- 层级3 --\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3ediff\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eSpan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可能期望将\x3ccode\x3e\x26lt;span\x26gt;\x3c\/code\x3e直接移动到\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e的后边，这是最优的操作。但是实际的diff操作是移除\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e里的\x3ccode\x3e\x26lt;span\x26gt;\x3c\/code\x3e在创建一个新的\x3ccode\x3e\x26lt;span\x26gt;\x3c\/code\x3e插到\x3ccode\x3e\x26lt;p\x26gt;\x3c\/code\x3e的后边。\x3cbr\x3e因为新加的\x3ccode\x3e\x26lt;span\x26gt;\x3c\/code\x3e在层级2，旧的在层级3，属于不同层级的比较。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e源码分析\x3c\/h2\x3e\n\x3cp\x3e文中的代码位于\x3ca href=\x22https:\/\/github.com\/aooy\/aoy\/blob\/master\/src\/vdom\/diff.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eaoy-diff\x3c\/a\x3e中，已经精简了很多代码，留下最核心的部分。\x3c\/p\x3e\n\x3cp\x3ediff的过程就是调用patch函数，就像打补丁一样修改真实dom。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function patch (oldVnode, vnode) {\n    if (sameVnode(oldVnode, vnode)) {\n        patchVnode(oldVnode, vnode)\n    } else {\n        const oEl = oldVnode.el\n        let parentEle = api.parentNode(oEl)\n        createEle(vnode)\n        if (parentEle !== null) {\n            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))\n            api.removeChild(parentEle, oldVnode.el)\n            oldVnode = null\n        }\n    }\n    return vnode\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epatch\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldVnode, vnode)) {\n        patchVnode(oldVnode, vnode)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oEl = oldVnode.el\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e parentEle = api.parentNode(oEl)\n        createEle(vnode)\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parentEle !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))\n            api.removeChild(parentEle, oldVnode.el)\n            oldVnode = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3epatch\x3c\/code\x3e函数有两个参数，\x3ccode\x3evnode\x3c\/code\x3e和\x3ccode\x3eoldVnode\x3c\/code\x3e，也就是新旧两个虚拟节点。在这之前，我们先了解完整的vnode都有什么属性，举个一个简单的例子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ body下的 \x3cdiv id=\x26quot;v\x26quot; class=\x26quot;classA\x26quot;\x3e\x3cdiv\x3e 对应的 oldVnode 就是\n\n{\n  el:  div  \/\/对真实的节点的引用，本例中就是document.querySelector(\x27#id.classA\x27)\n  tagName: \x27DIV\x27,   \/\/节点的标签\n  sel: \x27div#v.classA\x27  \/\/节点的选择器\n  data: null,       \/\/ 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style\n  children: [], \/\/存储子节点的数组，每个子节点也是vnode结构\n  text: null,    \/\/如果是文本节点，对应文本节点的textContent，否则为null\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ body下的 \x26lt;div id=\x22v\x22 class=\x22classA\x22\x26gt;\x26lt;div\x26gt; 对应的 oldVnode 就是\x3c\/span\x3e\n\n{\n  \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e:  div  \x3cspan class=\x22hljs-comment\x22\x3e\/\/对真实的节点的引用，本例中就是document.querySelector(\x27#id.classA\x27)\x3c\/span\x3e\n  tagName: \x3cspan class=\x22hljs-string\x22\x3e\x27DIV\x27\x3c\/span\x3e,   \x3cspan class=\x22hljs-comment\x22\x3e\/\/节点的标签\x3c\/span\x3e\n  sel: \x3cspan class=\x22hljs-string\x22\x3e\x27div#v.classA\x27\x3c\/span\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/节点的选择器\x3c\/span\x3e\n  data: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 一个存储节点属性的对象，对应节点的el[prop]属性，例如onclick , style\x3c\/span\x3e\n  children: [], \x3cspan class=\x22hljs-comment\x22\x3e\/\/存储子节点的数组，每个子节点也是vnode结构\x3c\/span\x3e\n  text: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e,    \x3cspan class=\x22hljs-comment\x22\x3e\/\/如果是文本节点，对应文本节点的textContent，否则为null\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e需要注意的是，el属性引用的是此 virtual dom对应的真实dom，\x3ccode\x3epatch\x3c\/code\x3e的\x3ccode\x3evnode\x3c\/code\x3e参数的\x3ccode\x3eel\x3c\/code\x3e最初是null，因为\x3ccode\x3epatch\x3c\/code\x3e之前它还没有对应的真实dom。\x3c\/p\x3e\n\x3cp\x3e来到\x3ccode\x3epatch\x3c\/code\x3e的第一部分，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (sameVnode(oldVnode, vnode)) {\n    patchVnode(oldVnode, vnode)\n} \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldVnode, vnode)) {\n    patchVnode(oldVnode, vnode)\n} \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3esameVnode\x3c\/code\x3e函数就是看这两个节点是否值得比较，代码相当简单：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function sameVnode(oldVnode, vnode){\n    return vnode.key === oldVnode.key \x26amp;\x26amp; vnode.sel === oldVnode.sel\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esameVnode\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode.key === oldVnode.key \x26amp;\x26amp; vnode.sel === oldVnode.sel\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e两个vnode的key和sel相同才去比较它们，比如\x3ccode\x3ep\x3c\/code\x3e和\x3ccode\x3espan\x3c\/code\x3e，\x3ccode\x3ediv.classA\x3c\/code\x3e和\x3ccode\x3ediv.classB\x3c\/code\x3e都被认为是不同结构而不去比较它们。\x3c\/p\x3e\n\x3cp\x3e如果值得比较会执行\x3ccode\x3epatchVnode(oldVnode, vnode)\x3c\/code\x3e，稍后会详细讲\x3ccode\x3epatchVnode\x3c\/code\x3e函数。\x3c\/p\x3e\n\x3cp\x3e当节点不值得比较，进入else中\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22else {\n        const oEl = oldVnode.el\n        let parentEle = api.parentNode(oEl)\n        createEle(vnode)\n        if (parentEle !== null) {\n            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))\n            api.removeChild(parentEle, oldVnode.el)\n            oldVnode = null\n        }\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oEl = oldVnode.el\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e parentEle = api.parentNode(oEl)\n        createEle(vnode)\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (parentEle !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n            api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl))\n            api.removeChild(parentEle, oldVnode.el)\n            oldVnode = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n        }\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e过程如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e取得\x3ccode\x3eoldvnode.el\x3c\/code\x3e的父节点，\x3ccode\x3eparentEle\x3c\/code\x3e是真实dom\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ecreateEle(vnode)\x3c\/code\x3e会为\x3ccode\x3evnode\x3c\/code\x3e创建它的真实dom，令\x3ccode\x3evnode.el\x3c\/code\x3e =\x3ccode\x3e真实dom\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eparentEle\x3c\/code\x3e将新的dom插入，移除旧的dom\x3cbr\x3e\x3cstrong\x3e当不值得比较时，新节点直接把老节点整个替换了\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e最后\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22return vnode\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e vnode\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3epatch最后会返回vnode，vnode和进入patch之前的不同在哪？\x3cbr\x3e没错，就是vnode.el，\x3cstrong\x3e唯一的改变就是之前vnode.el = null, 而现在它引用的是对应的真实dom。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var oldVnode = patch (oldVnode, vnode)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e oldVnode = patch (oldVnode, vnode)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至此完成一个patch过程。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3epatchVnode\x3c\/h3\x3e\n\x3cp\x3e两个节点值得比较时，会调用\x3ccode\x3epatchVnode\x3c\/code\x3e函数\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22patchVnode (oldVnode, vnode) {\n    const el = vnode.el = oldVnode.el\n    let i, oldCh = oldVnode.children, ch = vnode.children\n    if (oldVnode === vnode) return\n    if (oldVnode.text !== null \x26amp;\x26amp; vnode.text !== null \x26amp;\x26amp; oldVnode.text !== vnode.text) {\n        api.setTextContent(el, vnode.text)\n    }else {\n        updateEle(el, vnode, oldVnode)\n        if (oldCh \x26amp;\x26amp; ch \x26amp;\x26amp; oldCh !== ch) {\n            updateChildren(el, oldCh, ch)\n        }else if (ch){\n            createEle(vnode) \/\/create el\x27s children dom\n        }else if (oldCh){\n            api.removeChildren(el)\n        }\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JS\x22\x3epatchVnode (oldVnode, vnode) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e el = vnode.el = oldVnode.el\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i, oldCh = oldVnode.children, ch = vnode.children\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldVnode === vnode) \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldVnode.text !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; vnode.text !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e \x26amp;\x26amp; oldVnode.text !== vnode.text) {\n        api.setTextContent(el, vnode.text)\n    }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        updateEle(el, vnode, oldVnode)\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldCh \x26amp;\x26amp; ch \x26amp;\x26amp; oldCh !== ch) {\n            updateChildren(el, oldCh, ch)\n        }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (ch){\n            createEle(vnode) \x3cspan class=\x22hljs-comment\x22\x3e\/\/create el\x27s children dom\x3c\/span\x3e\n        }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldCh){\n            api.removeChildren(el)\n        }\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3econst el = vnode.el = oldVnode.el\x3c\/code\x3e 这是很重要的一步，让\x3ccode\x3evnode.el\x3c\/code\x3e引用到现在的真实dom，当\x3ccode\x3eel\x3c\/code\x3e修改时，\x3ccode\x3evnode.el\x3c\/code\x3e会同步变化。\x3c\/p\x3e\n\x3cp\x3e节点的比较有5种情况\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eif (oldVnode === vnode)\x3c\/code\x3e，他们的引用一致，可以认为没有变化。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eif(oldVnode.text !== null \x26amp;\x26amp; vnode.text !== null \x26amp;\x26amp; oldVnode.text !== vnode.text)\x3c\/code\x3e，文本节点的比较，需要修改，则会调用\x3ccode\x3eNode.textContent = vnode.text\x3c\/code\x3e。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eif( oldCh \x26amp;\x26amp; ch \x26amp;\x26amp; oldCh !== ch )\x3c\/code\x3e, 两个节点都有子节点，而且它们不一样，这样我们会调用\x3ccode\x3eupdateChildren\x3c\/code\x3e函数比较子节点，这是diff的核心，后边会讲到。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eelse if (ch)\x3c\/code\x3e，只有新的节点有子节点，调用\x3ccode\x3ecreateEle(vnode)\x3c\/code\x3e，\x3ccode\x3evnode.el\x3c\/code\x3e已经引用了老的dom节点，\x3ccode\x3ecreateEle\x3c\/code\x3e函数会在老dom节点上添加子节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eelse if (oldCh)\x3c\/code\x3e，新节点没有子节点，老节点有子节点，直接删除老节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3eupdateChildren\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22updateChildren (parentElm, oldCh, newCh) {\n    let oldStartIdx = 0, newStartIdx = 0\n    let oldEndIdx = oldCh.length - 1\n    let oldStartVnode = oldCh[0]\n    let oldEndVnode = oldCh[oldEndIdx]\n    let newEndIdx = newCh.length - 1\n    let newStartVnode = newCh[0]\n    let newEndVnode = newCh[newEndIdx]\n    let oldKeyToIdx\n    let idxInOld\n    let elmToMove\n    let before\n    while (oldStartIdx \x3c= oldEndIdx \x26amp;\x26amp; newStartIdx \x3c= newEndIdx) {\n            if (oldStartVnode == null) {   \/\/对于vnode.key的比较，会把oldVnode = null\n                oldStartVnode = oldCh[\x2b\x2boldStartIdx] \n            }else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx]\n            }else if (newStartVnode == null) {\n                newStartVnode = newCh[\x2b\x2bnewStartIdx]\n            }else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx]\n            }else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode)\n                oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n                newStartVnode = newCh[\x2b\x2bnewStartIdx]\n            }else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode)\n                oldEndVnode = oldCh[--oldEndIdx]\n                newEndVnode = newCh[--newEndIdx]\n            }else if (sameVnode(oldStartVnode, newEndVnode)) {\n                patchVnode(oldStartVnode, newEndVnode)\n                api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))\n                oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n                newEndVnode = newCh[--newEndIdx]\n            }else if (sameVnode(oldEndVnode, newStartVnode)) {\n                patchVnode(oldEndVnode, newStartVnode)\n                api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)\n                oldEndVnode = oldCh[--oldEndIdx]\n                newStartVnode = newCh[\x2b\x2bnewStartIdx]\n            }else {\n               \/\/ 使用key时的比较\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) \/\/ 有key生成index表\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key]\n                if (!idxInOld) {\n                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n                    newStartVnode = newCh[\x2b\x2bnewStartIdx]\n                }\n                else {\n                    elmToMove = oldCh[idxInOld]\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n                    }else {\n                        patchVnode(elmToMove, newStartVnode)\n                        oldCh[idxInOld] = null\n                        api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)\n                    }\n                    newStartVnode = newCh[\x2b\x2bnewStartIdx]\n                }\n            }\n        }\n        if (oldStartIdx \x3e oldEndIdx) {\n            before = newCh[newEndIdx \x2b 1] == null ? null : newCh[newEndIdx \x2b 1].el\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)\n        }else if (newStartIdx \x3e newEndIdx) {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n        }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3eupdateChildren (parentElm, oldCh, newCh) {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldStartIdx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, newStartIdx = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldEndIdx = oldCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldStartVnode = oldCh[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldEndVnode = oldCh[oldEndIdx]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newEndIdx = newCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newStartVnode = newCh[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e newEndVnode = newCh[newEndIdx]\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e oldKeyToIdx\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e idxInOld\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e elmToMove\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e before\n    \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (oldStartIdx \x26lt;= oldEndIdx \x26amp;\x26amp; newStartIdx \x26lt;= newEndIdx) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldStartVnode == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {   \x3cspan class=\x22hljs-comment\x22\x3e\/\/对于vnode.key的比较，会把oldVnode = null\x3c\/span\x3e\n                oldStartVnode = oldCh[\x2b\x2boldStartIdx] \n            }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldEndVnode == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n                oldEndVnode = oldCh[--oldEndIdx]\n            }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newStartVnode == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n                newStartVnode = newCh[\x2b\x2bnewStartIdx]\n            }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newEndVnode == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n                newEndVnode = newCh[--newEndIdx]\n            }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode)\n                oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n                newStartVnode = newCh[\x2b\x2bnewStartIdx]\n            }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode)\n                oldEndVnode = oldCh[--oldEndIdx]\n                newEndVnode = newCh[--newEndIdx]\n            }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newEndVnode)) {\n                patchVnode(oldStartVnode, newEndVnode)\n                api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el))\n                oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n                newEndVnode = newCh[--newEndIdx]\n            }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newStartVnode)) {\n                patchVnode(oldEndVnode, newStartVnode)\n                api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el)\n                oldEndVnode = oldCh[--oldEndIdx]\n                newStartVnode = newCh[\x2b\x2bnewStartIdx]\n            }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 使用key时的比较\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldKeyToIdx === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 有key生成index表\x3c\/span\x3e\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key]\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!idxInOld) {\n                    api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n                    newStartVnode = newCh[\x2b\x2bnewStartIdx]\n                }\n                \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                    elmToMove = oldCh[idxInOld]\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el)\n                    }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                        patchVnode(elmToMove, newStartVnode)\n                        oldCh[idxInOld] = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n                        api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el)\n                    }\n                    newStartVnode = newCh[\x2b\x2bnewStartIdx]\n                }\n            }\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldStartIdx \x26gt; oldEndIdx) {\n            before = newCh[newEndIdx \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] == \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e ? \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e : newCh[newEndIdx \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e].el\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)\n        }\x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newStartIdx \x26gt; newEndIdx) {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)\n        }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e代码很密集，为了形象的描述这个过程，可以看看这张图。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK0Zy?w=1215\x26amp;h=920\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK0Zy?w=1215\x26amp;h=920\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e过程可以概括为：\x3ccode\x3eoldCh\x3c\/code\x3e和\x3ccode\x3enewCh\x3c\/code\x3e各有两个头尾的变量\x3ccode\x3eStartIdx\x3c\/code\x3e和\x3ccode\x3eEndIdx\x3c\/code\x3e，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦\x3ccode\x3eStartIdx\x26gt;EndIdx\x3c\/code\x3e表明\x3ccode\x3eoldCh\x3c\/code\x3e和\x3ccode\x3enewCh\x3c\/code\x3e至少有一个已经遍历完了，就会结束比较。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e具体的diff分析\x3c\/h3\x3e\n\x3cp\x3e设置key和不设置key的区别：\x3cbr\x3e\x3cstrong\x3e不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象\x3ccode\x3eoldKeyToIdx\x3c\/code\x3e中查找匹配的节点，所以为节点设置key可以更高效的利用dom。\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3ediff的遍历过程中，只要是对dom进行的操作都调用\x3ccode\x3eapi.insertBefore\x3c\/code\x3e，\x3ccode\x3eapi.insertBefore\x3c\/code\x3e只是原生\x3ccode\x3einsertBefore\x3c\/code\x3e的简单封装。\x3cbr\x3e比较分为两种，一种是有\x3ccode\x3evnode.key\x3c\/code\x3e的，一种是没有的。但这两种比较对真实dom的操作是一致的。\x3c\/p\x3e\n\x3cp\x3e对于与\x3ccode\x3esameVnode(oldStartVnode, newStartVnode)\x3c\/code\x3e和\x3ccode\x3esameVnode(oldEndVnode,newEndVnode)\x3c\/code\x3e为true的情况，不需要对dom进行移动。\x3c\/p\x3e\n\x3cp\x3e总结遍历过程，有3种dom操作：\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e当\x3ccode\x3eoldStartVnode\x3c\/code\x3e，\x3ccode\x3enewEndVnode\x3c\/code\x3e值得比较，说明\x3ccode\x3eoldStartVnode.el\x3c\/code\x3e跑到\x3ccode\x3eoldEndVnode.el\x3c\/code\x3e的后边了。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e图中假设startIdx遍历到1。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK0ZH?w=980\x26amp;h=302\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK0ZH?w=980\x26amp;h=302\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e当\x3ccode\x3eoldEndVnode\x3c\/code\x3e，\x3ccode\x3enewStartVnode\x3c\/code\x3e值得比较，oldEndVnode.el跑到了oldStartVnode.el的前边，准确的说应该是oldEndVnode.el需要移动到oldStartVnode.el的前边”。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK0ZN?w=950\x26amp;h=311\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK0ZN?w=950\x26amp;h=311\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3enewCh中的节点oldCh里没有， 将新节点插入到\x3ccode\x3eoldStartVnode.el\x3c\/code\x3e的前边。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK0ZT?w=950\x26amp;h=581\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK0ZT?w=950\x26amp;h=581\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e在结束时，分为两种情况：\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e\x3ccode\x3e oldStartIdx \x26gt; oldEndIdx\x3c\/code\x3e，可以认为\x3ccode\x3eoldCh\x3c\/code\x3e先遍历完。当然也有可能\x3ccode\x3enewCh\x3c\/code\x3e此时也正好完成了遍历，统一都归为此类。此时\x3ccode\x3enewStartIdx\x3c\/code\x3e和\x3ccode\x3enewEndIdx\x3c\/code\x3e之间的vnode是新增的，调用\x3ccode\x3eaddVnodes\x3c\/code\x3e，把他们全部插进\x3ccode\x3ebefore\x3c\/code\x3e的后边，\x3ccode\x3ebefore\x3c\/code\x3e很多时候是为null的。\x3ccode\x3eaddVnodes\x3c\/code\x3e调用的是\x3ccode\x3einsertBefore\x3c\/code\x3e操作dom节点，我们看看\x3ccode\x3einsertBefore\x3c\/code\x3e的文档：\x3ccode\x3eparentElement.insertBefore(newElement, referenceElement)\x3c\/code\x3e\x3cbr\x3e如果referenceElement为null则newElement将被插入到子节点的末尾。如果newElement已经在DOM树中，newElement首先会从DOM树中移除。\x3cstrong\x3e所以\x3ccode\x3ebefore\x3c\/code\x3e为null，newElement将被插入到子节点的末尾。\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK0ZV?w=1156\x26amp;h=539\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK0ZV?w=1156\x26amp;h=539\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e\x3ccode\x3e newStartIdx \x26gt; newEndIdx\x3c\/code\x3e，可以认为\x3ccode\x3enewCh\x3c\/code\x3e先遍历完。此时\x3ccode\x3eoldStartIdx\x3c\/code\x3e和\x3ccode\x3eoldEndIdx\x3c\/code\x3e之间的vnode在新的子节点里已经不存在了，调用\x3ccode\x3eremoveVnodes\x3c\/code\x3e将它们从dom里删除。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK0ZZ?w=1149\x26amp;h=640\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK0ZZ?w=1149\x26amp;h=640\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e下面举个例子，画出diff完整的过程，每一步dom的变化都用不同颜色的线标出。\x3c\/h4\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3ea,b,c,d,e假设是4个不同的元素，我们没有设置key时，b没有复用，而是直接创建新的，删除旧的。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK0Z2?w=1038\x26amp;h=836\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK0Z2?w=1038\x26amp;h=836\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e当我们给4个元素加上唯一key时，b得到了的复用。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVK0Z6?w=1038\x26amp;h=828\x22 src=\x22https:\/\/static.alili.tech\/img\/bVK0Z6?w=1038\x26amp;h=828\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e这个例子如果我们使用手工优化，只需要3步就可以达到。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader8\x22\x3e总结\x3c\/h1\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e尽量不要跨层级的修改dom\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e设置key可以最大化的利用节点\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e不要盲目相信diff的效率，在必要时可以手工优化\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>解析vue2.0的diff算法</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008782928">https://segmentfault.com/a/1190000008782928</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/l107wfmw3kp/" target="_blank">https://alili.tech/archive/l107wfmw3kp/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>