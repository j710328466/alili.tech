<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="算法小白——基本排序算法入门"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>算法小白——基本排序算法入门 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/jvdjd3q1ldm/",
				"appid": "1613049289050283", 
				"title": "算法小白——基本排序算法入门 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-18T02:30:34"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/l107wfmw3kp/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ltq6f1okq5/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f&text=%e7%ae%97%e6%b3%95%e5%b0%8f%e7%99%bd%e2%80%94%e2%80%94%e5%9f%ba%e6%9c%ac%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f&text=%e7%ae%97%e6%b3%95%e5%b0%8f%e7%99%bd%e2%80%94%e2%80%94%e5%9f%ba%e6%9c%ac%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f&title=%e7%ae%97%e6%b3%95%e5%b0%8f%e7%99%bd%e2%80%94%e2%80%94%e5%9f%ba%e6%9c%ac%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f&is_video=false&description=%e7%ae%97%e6%b3%95%e5%b0%8f%e7%99%bd%e2%80%94%e2%80%94%e5%9f%ba%e6%9c%ac%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%ae%97%e6%b3%95%e5%b0%8f%e7%99%bd%e2%80%94%e2%80%94%e5%9f%ba%e6%9c%ac%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f&title=%e7%ae%97%e6%b3%95%e5%b0%8f%e7%99%bd%e2%80%94%e2%80%94%e5%9f%ba%e6%9c%ac%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f&title=%e7%ae%97%e6%b3%95%e5%b0%8f%e7%99%bd%e2%80%94%e2%80%94%e5%9f%ba%e6%9c%ac%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f&title=%e7%ae%97%e6%b3%95%e5%b0%8f%e7%99%bd%e2%80%94%e2%80%94%e5%9f%ba%e6%9c%ac%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fjvdjd3q1ldm%2f&title=%e7%ae%97%e6%b3%95%e5%b0%8f%e7%99%bd%e2%80%94%e2%80%94%e5%9f%ba%e6%9c%ac%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%85%a5%e9%97%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">算法小白——基本排序算法入门</h1><div class="meta"><div class="postdate"><time datetime="2019-01-18" itemprop="datePublished">2019-01-18</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e计算的 时间复杂度（最差、平均、和最好性能），依据列表（list）的大小(n)。一般而言，好的性能是O(n log n)，且坏的性能是O(n^2)。对于一个排序理想的性能是O(n)。仅使用一个抽象关键比较运算的排序算法总平均上总是至少需要O(n log n)。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e插入排序(insertion sort)\x3c\/h2\x3e\n\x3cp\x3e插入排序应该算是最简单和容易理解的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。具有n个元素时它需要经过n-1趟排序。对于p = 1到p = n-1趟，插入排序保证从位置0到位置p上的元素为已排序状态。它就是基于这个事实来排序的。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/0\/0f\/Insertion-sort-example-300px.gif\/220px-Insertion-sort-example-300px.gif\x22 src=\x22https:\/\/static.alili.techhttps:\/\/upload.wikimedia.org\/wikipedia\/commons\/thumb\/0\/0f\/Insertion-sort-example-300px.gif\/220px-Insertion-sort-example-300px.gif\x22 alt=\x22insert sort gif\x22 title=\x22insert sort gif\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function sort(arr) {\n  if(arr.length \x3c= 1) {\n    return arr\n  }\n\n  for(var i=0; i\x3carr.length; i\x2b\x2b) {\n    for(var j=i-1; j\x3e=0; j--) {\n      if(arr[j\x2b1] \x3c arr[j]) {\n        var temp = arr[j\x2b1];\n        arr[j\x2b1] = arr[j];\n        arr[j] = temp\n      }\n    }\n  }\n\n  return arr\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esort\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(arr)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(arr.length \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;arr.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j=i\x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e; j\x26gt;=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j--) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] \x26lt; arr[j]) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e temp = arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];\n        arr[j\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = arr[j];\n        arr[j] = temp\n      }\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果目标是把n个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需(n-1)次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有n(n-1)\/2次。插入排序的赋值操作是比较操作的次数减去(n-1)次。平均来说插入排序算法复杂度为O(n^2)。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e冒泡排序(bubble sort)\x3c\/h2\x3e\n\x3cp\x3e冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最好的情况，冒泡排序需要O(n^2)次交换，而插入排序只要最多O(n)交换。冒泡排序的实现（类似下面）通常会对已经排序好的数列拙劣地运行O(n^2)，而插入排序在这个例子只需要O(n)个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序替换之。冒泡排序如果能在内部循环第一次运行时，使用一个旗标来表示有无需要交换的可能，也可以把最好的复杂度降低到O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为鸡尾酒排序，因为算法会从数列的一端到另一端之间穿梭往返。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/upload.wikimedia.org\/wikipedia\/commons\/0\/06\/Bubble-sort.gif\x22 src=\x22https:\/\/static.alili.techhttps:\/\/upload.wikimedia.org\/wikipedia\/commons\/0\/06\/Bubble-sort.gif\x22 alt=\x22bubble sort gif\x22 title=\x22bubble sort gif\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3cbr\x3e冒泡排序算法的运作如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e比较相邻的元素。如果第一个比第二个大，就交换他们两个。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e针对所有的元素重复以上的步骤，除了最后一个。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function bubbleSort(arr) {\n  if(arr.length \x3c= 1) {\n    return arr;\n  }\n  for(var j=0; j\x3carr.length; j\x2b\x2b) {\n    for(var i=0; i\x3carr.length-j; i\x2b\x2b) {\n      if(arr[i] \x3e arr[i\x2b1]) {\n        var tmp = arr[i];\n        arr[i] = arr[i\x2b1];\n        arr[i\x2b1] = tmp;\n      }\n    }\n  }\n\n  return arr;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebubbleSort\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(arr)\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(arr.length \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j\x26lt;arr.length; j\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i\x26lt;arr.length-j; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(arr[i] \x26gt; arr[i\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tmp = arr[i];\n        arr[i] = arr[i\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];\n        arr[i\x2b\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] = tmp;\n      }\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e选择排序(selection sort)\x3c\/h2\x3e\n\x3cp\x3e选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\x3cbr\x3e选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/www.codingconnect.net\/wp-content\/uploads\/2016\/09\/Selection-Sort.gif\x22 src=\x22https:\/\/static.alili.techhttp:\/\/www.codingconnect.net\/wp-content\/uploads\/2016\/09\/Selection-Sort.gif\x22 alt=\x22selection sort gif\x22 title=\x22selection sort gif\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch4\x3e复杂度分析\x3c\/h4\x3e\n\x3cp\x3e选择排序的交换操作介于 0 和(n-1)次之间。选择排序的比较操作为n(n-1)\/2次之间。选择排序的赋值操作介于0和3(n-1)次之间。比较次数O(n^2)，比较次数与关键字的初始状态无关，总的比较次数 N=(n-1)\x2b(n-2)\x2b...\x2b1=n(n-1)\/2。交换次数O(n),最好情况是，已经有序，交换0次；最坏情况是，逆序，交换n-1次。交换次数比冒泡排序较少，由于交换所需CPU时间比比较所需的CPU时间多, n值较小时，选择排序比冒泡排序快。\x3cbr\x3e原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；实际适用的场合非常罕见。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function selectionSort(arr) {\n    if(arr.length \x3c= 1) {\n        return arr\n    }\n    var i, j, min;\n    var temp;\n    for (i = 0; i \x3c arr.length - 1; i\x2b\x2b) {\n        min = i;\n        for (j = i \x2b 1; j \x3c arr.length; j\x2b\x2b) {\n            if (arr[min] \x3e arr[j])\n                min = j;\n                temp = arr[min];\n                arr[min] = arr[i];\n                arr[i] = temp;\n        }\n    }\n    return arr\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs maxima\x22\x3e\x3ccode\x3efunction selectionSort(arr) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(arr.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e arr\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e i, j, \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e temp;\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; arr.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e = i;\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (j = i \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; j \x26lt; arr.\x3cspan class=\x22hljs-built_in\x22\x3elength\x3c\/span\x3e; j\x2b\x2b) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (arr[\x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e] \x26gt; arr[j])\n                \x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e = j;\n                temp = arr[\x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e];\n                arr[\x3cspan class=\x22hljs-built_in\x22\x3emin\x3c\/span\x3e] = arr[i];\n                arr[i] = temp;\n        }\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3ereturn\x3c\/span\x3e arr\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e快速排序(quick sort)\x3c\/h2\x3e\n\x3cp\x3e快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22https:\/\/upload.wikimedia.org\/wikipedia\/commons\/9\/9c\/Quicksort-example.gif\x22 src=\x22https:\/\/static.alili.techhttps:\/\/upload.wikimedia.org\/wikipedia\/commons\/9\/9c\/Quicksort-example.gif\x22 alt=\x22quick sort gif\x22 title=\x22quick sort gif\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e步骤为：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e从数列中挑出一个元素，称为\x22基准\x22（pivot），\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。\x3cbr\x3e递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e正如它的名字，快速排序是在时间中最快的已知排序算法，它的平均运行时间是O(NlogN)。快速排序也是一种分治的递归算法。将数组S排序的基本算法由下列简单的四步组成：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e如果S中元素个数是0或1，则返回\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e取S中任一元素v，称之为枢纽元\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e将S - {v}分成两个不相交的集合：S1 = {x∈S - {v} | x ≤ v}和S2 = {x∈S - {v} | x ≥ v}\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e返回{quicksort(S1)}，继续v，继而quicksort(S2)\x3cbr\x3e由于对枢纽元的处理会导致第三步中的分割不唯一，因此，我们希望把等于枢纽元的大约一半的关键字分到S1中，而另外一半分到S2中，那怎么去选择一个好的枢纽元呢？\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e选取枢纽元\x3cbr\x3e一种错误的方法\x3cbr\x3e通常的，没有经过充分考虑的选择是将第一个元素用作枢纽元。如果输入是随机的，那么这是可以接受的，但是如果输入是预排序或是反序的，那么这样的枢纽元就会产生一个劣质的分割，因为所有的元素不是都被划入S1就是被划入S2。\x3cbr\x3e一种安全的作法\x3cbr\x3e一种安全的方针是随机选取枢纽元。但是另一方面，随机数的生成一般是昂贵的，根本减少不了算法奇遇部分的平均运行时间。\x3cbr\x3e三数中值分割法\x3cbr\x3e一组N个数的中值是第Math.ceil(N\/2)个最大的数。枢纽元的最好的选择是数组的中值。不幸的是，这很难算出，且会减慢快速排序的速度。因此一般的做法是使用左端、右端和中心位置上的三个元素的中值作为枢纽元。例如，输入为8, 1, 4, 9, 6, 3, 5, 2, 7, 0，它的左边元素是8，右边元素是0，中心位置为Math.floor((left \x2b right) \/ 2)上的元素是6，于是枢纽元v=6。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function quickSort(arr) {\n  if (arr.length \x3c= 1) {\n    return arr.slice(0);\n  }\n\n  var left = [];\n  var right = [];\n  var mid = [arr[0]]; \/\/first number as a pivot\n\n  for (var i = 1; i \x3c arr.length; i\x2b\x2b) {\n    if (arr[i] \x3c mid[0]) {\n      left.push(arr[i]);\n    } else {\n      right.push(arr[i]);\n    }\n  }\n\n  return quickSort(left).concat(mid.concat(quickSort(right)));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs swift\x22\x3e\x3ccode\x3efunction \x3cspan class=\x22hljs-built_in\x22\x3equickSort\x3c\/span\x3e(arr) {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (arr.length \x26lt;= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e arr.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e = [];\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e mid = [arr[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]]; \x3cspan class=\x22hljs-comment\x22\x3e\/\/first number as a pivot\x3c\/span\x3e\n\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; i \x26lt; arr.length; i\x2b\x2b) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (arr[i] \x26lt; mid[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e.push(arr[i]);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e.push(arr[i]);\n    }\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3equickSort\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eleft\x3c\/span\x3e).concat(mid.concat(\x3cspan class=\x22hljs-built_in\x22\x3equickSort\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3eright\x3c\/span\x3e)));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>算法小白——基本排序算法入门</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008778205">https://segmentfault.com/a/1190000008778205</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/jvdjd3q1ldm/" target="_blank">https://alili.tech/archive/jvdjd3q1ldm/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5328xogjarn/">IndexedDB--HTML5本地存储<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/xpccu0hsqbr/">JS学习系列 01 - 编译原理和作用域<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/shv09bbtbfd/">Vue2 SSR 的优化之旅<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5vj1ojfo6h6/">[2016年末巨献] — HTML5可交互地铁线路图（第二季：帝都进阶版）<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/m02hlm4bzh/">vue2.0开发聊天程序（三）组件的通信<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/mz5o7n90plg/">《很高兴我没有猝死》- 前端新人的 2016 年总结和感悟<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/3vhoe2mo09k/">一道颇有难度的JavaScript题<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/uj12mb7thp/">使用CANVAS实现交互性圆形马赛克效果<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/ja636h8hcxa/">写于 2016 年末<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5uomnoq1kmi/">前端学习资源整理<aside class="dates">2019-01-28</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>