<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="WebGL 初探"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>WebGL 初探 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/0ux7b50f8tw/",
				"appid": "1613049289050283", 
				"title": "WebGL 初探 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-02T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/pkedmi91nzr/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/d962ve6qizb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f&text=WebGL%20%e5%88%9d%e6%8e%a2"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f&text=WebGL%20%e5%88%9d%e6%8e%a2"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f&title=WebGL%20%e5%88%9d%e6%8e%a2"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f&is_video=false&description=WebGL%20%e5%88%9d%e6%8e%a2"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=WebGL%20%e5%88%9d%e6%8e%a2&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f&title=WebGL%20%e5%88%9d%e6%8e%a2"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f&title=WebGL%20%e5%88%9d%e6%8e%a2"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f&title=WebGL%20%e5%88%9d%e6%8e%a2"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f0ux7b50f8tw%2f&title=WebGL%20%e5%88%9d%e6%8e%a2"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">WebGL 初探</h1><div class="meta"><div class="postdate"><time datetime="2019-02-02" itemprop="datePublished">2019-02-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e该文章于一天前发表在 github，若有问题可提至 \x3ca href=\x22https:\/\/github.com\/sundway\/blog\/issues\/3\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub\x3c\/a\x3e。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e目前，我们有很多方案可以快速的接触到 WebGL 并绘制复杂的图形，但最后发现我们忽视了很多细节性的东西。当然，这对初学 WebGL 是有必要的，它能迅速提起我们对 WebGL 的学习兴趣。当学习到更加深入的阶段时，我们更想了解 WebGL 的工作机制，这也将对我们编程有极大的帮助。以上也是我想写这样一个系列的原因。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e简介\x3c\/h2\x3e\n\x3cp\x3e用更专业的描述讲，WebGL (Web Graphics Library) 是一个用以渲染交互式 3D 和 2D 图形的无需插件且兼容下一代浏览器的 JavaScript API，通过 HTML5 中 \x26lt;canvas\x26gt; 元素实现功能。WebGL 是由 Khronos Group 集团制定，而非 W3C 组织。目前，我们可以使用的是 WebGL 第一个版本，它继承自 OpenGL ES 2.0 。而 OpenGL ES (OpenGL for Embedded Systems) 是 OpenGL 三维图形 API 的子集，针对手机、PDA 和游戏主机等嵌入式设备而设计。以下是各版本之间的关系图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007106472?w=916\x26amp;h=417\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007106472?w=916\x26amp;h=417\x22 alt=\x22版本关系\x22 title=\x22版本关系\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eHello World\x3c\/h2\x3e\n\x3cp\x3e首先，我们将通过实现一个简单的 WebGL 程序（清空绘图区）叩开 WebGL 的大门。下面将实现一个最简单的 WebGL 功能：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007106473?w=809\x26amp;h=82\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007106473?w=809\x26amp;h=82\x22 alt=\x22处理流程\x22 title=\x22处理流程\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e创建 canvas 元素\x3c\/h3\x3e\n\x3cp\x3eWebGL 采用 HTML5 中的 \x26lt;canvas\x26gt; 元素。为了使用 WebGL 进行 3D 渲染，你首先需要一个 canvas 元素。这里创建了一个 canvas 元素，并使用 onload 事件创建来初始化 WebGL 上下文。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cbody onload=\x26quot;start()\x26quot;\x3e\n  \x3ccanvas id=\x26quot;glcanvas\x26quot; width=\x26quot;640\x26quot; height=\x26quot;480\x26quot;\x3e\n    Your browser doesn\x27t appear to support the HTML5 \x3ccode\x3e\x26amp;lt;canvas\x26amp;gt;\x3c\/code\x3e element.\n  \x3c\/canvas\x3e\n\x3c\/body\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs xml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonload\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22start()\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ecanvas\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22glcanvas\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ewidth\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22640\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eheight\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22480\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    Your browser doesn\x27t appear to support the HTML5 \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ecode\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x26amp;lt;canvas\x26amp;gt;\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ecode\x3c\/span\x3e\x26gt;\x3c\/span\x3e element.\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ecanvas\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e获取 WebGL 上下文\x3c\/h3\x3e\n\x3cp\x3e目前，各浏览器基本都实现了对 WebGL 的支持，但 IE11 及 Edge 浏览器稍微有些不同。以下是对初始化 WebGL 的基本封装：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initWebGL(canvas) {\n  \/\/ 创建全局变量\n  window.gl = null;\n  \n  try {\n    \/\/ 尝试获取标准上下文，如果失败，回退到试验性上下文\n    gl = canvas.getContext(\x26quot;webgl\x26quot;) || canvas.getContext(\x26quot;experimental-webgl\x26quot;);\n  }\n  catch(e) {\n    throw \x27创建失败。\x27;\n  }\n  \n  \/\/ 如果没有GL上下文，马上放弃\n  if (!gl) {\n    alert(\x26quot;WebGL初始化失败，可能是因为您的浏览器不支持。\x26quot;);\n    gl = null;\n  }\n  return gl;\n}       \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitWebGL\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecanvas\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建全局变量\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.gl = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 尝试获取标准上下文，如果失败，回退到试验性上下文\x3c\/span\x3e\n    gl = canvas.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x22webgl\x22\x3c\/span\x3e) || canvas.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x22experimental-webgl\x22\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ecatch\x3c\/span\x3e(e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27创建失败。\x27\x3c\/span\x3e;\n  }\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果没有GL上下文，马上放弃\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!gl) {\n    alert(\x3cspan class=\x22hljs-string\x22\x3e\x22WebGL初始化失败，可能是因为您的浏览器不支持。\x22\x3c\/span\x3e);\n    gl = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e gl;\n}       \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里通过采用 canvas 的 \x3ccode\x3egetContext(contextType, contextAttributes)\x3c\/code\x3e 方法判断浏览器是否支持 WebGL，并创建其上下文。当返回值是 canvas 的上下文时，浏览器可支持 WebGL，为 null 时，则创建失败。注意，在 IE11 及 Edge 浏览器下，需要使用 \x22experimental-webgl\x22 创建 WebGL，此处做了兼容处理。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e清空绘图区\x3c\/h3\x3e\n\x3cp\x3e下面将背景颜色设置为黑色，并清空缓存区。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var gl; \/\/ WebGL的全局变量\n\nfunction start() {\n  var canvas = document.getElementById(\x26quot;glcanvas\x26quot;);\n\n  \/\/ 初始化 WebGL 上下文\n  gl = initWebGL(canvas);   \n  \n  \/\/ 只有在 WebGL 可用的时候才继续\n  \n  if (gl) {\n    \/\/ 设置清除颜色为黑色，不透明\n    gl.clearColor(0.0, 0.0, 0.0, 1.0);     \n    \/\/ 清除颜色和深度缓存\n    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);     \n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ WebGL的全局变量\x3c\/span\x3e\n\nfunction start() {\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e canvas = document.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22glcanvas\x22\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化 WebGL 上下文\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e = initWebGL(canvas);   \n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有在 WebGL 可用的时候才继续\x3c\/span\x3e\n  \n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置清除颜色为黑色，不透明\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.clearColor(0.0, 0.0, 0.0, 1.0);     \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 清除颜色和深度缓存\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eclear\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.COLOR_BUFFER_BIT|\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.DEPTH_BUFFER_BIT);     \n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样，我们可以在浏览器中看到一块黑色区域。你可能已经注意到，WebGL 遵循的是传统 OpenGL 颜色分量的取值范围，从 0.0 到 1.0。RGB 的值越高，颜色越亮。注意，\x3ccode\x3eclear()\x3c\/code\x3e 方法在这里清除颜色和深度缓存，而不是绘制区域的 \x26lt;canvas\x26gt;，该方法继承自 OpenGL（基于多缓存模型）。实际还有模版缓存，但实际很少会被用到。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e更进一步\x3c\/h2\x3e\n\x3cp\x3e上面我们完成了第一个 WebGL 程序，但是我们还未接触到 WebGL 的核心：可编程着色器。接下来，我们将使用可编程着色器在屏幕上绘制点。可编程着色器是一个较为复杂的概念，也有自己的编程语言 \x3ca href=\x22https:\/\/www.opengl.org\/documentation\/glsl\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGLSL\x3c\/a\x3e，后面将会又专门的文章具体讲解可编程着色器。这里我们只需要简单了解绘制的流程：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007106474?w=888\x26amp;h=152\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007106474?w=888\x26amp;h=152\x22 alt=\x22处理流程\x22 title=\x22处理流程\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e编写着色器程序\x3c\/h3\x3e\n\x3cp\x3eWebGL 是无法像 OpenGL 利用固定渲染管线，代替它的是可编辑渲染管线中的 GLSL 着色语言。下面是顶点及片元着色器 GLSL 程序，用字符串表示，它将直接运行在浏览器之上。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 顶点着色器程序\nvar VSHADER_SOURCE = \n  \x27void main() {\\n\x27 \x2b\n  \x27  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n\x27 \x2b \/\/ 设置顶点位置\n  \x27  gl_PointSize = 10.0;\\n\x27 \x2b                    \/\/ 设置点的大小\n  \x27}\\n\x27;\n\n\/\/ 片元着色器程序\nvar FSHADER_SOURCE =\n  \x27void main() {\\n\x27 \x2b\n  \x27  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\\n\x27 \x2b \/\/ 设置点的颜色，此处为白色\n  \x27}\\n\x27;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 顶点着色器程序\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e VSHADER_SOURCE = \n  \x3cspan class=\x22hljs-string\x22\x3e\x27void main() {\\n\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27  gl_Position = vec4(0.0, 0.0, 0.0, 1.0);\\n\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置顶点位置\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e\x27  gl_PointSize = 10.0;\\n\x27\x3c\/span\x3e \x2b                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置点的大小\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e\x27}\\n\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 片元着色器程序\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e FSHADER_SOURCE =\n  \x3cspan class=\x22hljs-string\x22\x3e\x27void main() {\\n\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\\n\x27\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置点的颜色，此处为白色\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e\x27}\\n\x27\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面程序是不是有中似曾相识的感觉？没错，GLSL 语言和 C 语言很类似。着色器程序中包含一个主函数，且返回值为空。其中 \x3ccode\x3evec4()\x3c\/code\x3e 构造函数用于生成一个四维向量（x,y,z,w）。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e编译着色器\x3c\/h3\x3e\n\x3cp\x3e首先，需要用 \x3ccode\x3ecreateShader( type )\x3c\/code\x3e 方法生成相应类型的 WebGLShader。接着，使用 \x3ccode\x3eshaderSource( shader, sourceCode )\x3c\/code\x3e 作为 GLSL 源码的钩子函数。最后使用 \x3ccode\x3ecompileShader( shader )\x3c\/code\x3e 完成对着色器的编译。程序中我们做了编译后的校验，当着色器编译失败时，会报出失败并删除着色器。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createShader (gl, type, sourceCode) {\n  \/\/ 编译着色器类型：顶点着色器及片元着色器。\n  var shader = gl.createShader( type );\n  gl.shaderSource( shader, sourceCode );\n  gl.compileShader( shader );\n\n  if ( !gl.getShaderParameter(shader, gl.COMPILE_STATUS) ) {\n    var info = gl.getShaderInfoLog( shader );\n    console.log( \x26quot;无法编译 WebGL 程序。 \\n\\n\x26quot; \x2b info);\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3efunction createShader (\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e, sourceCode) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 编译着色器类型：顶点着色器及片元着色器。\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e shader = \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.createShader( \x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e );\n  \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.shaderSource( shader, sourceCode );\n  \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.compileShader( shader );\n\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e ( !\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.getShaderParameter(shader, \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.COMPILE_STATUS) ) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e info = \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.getShaderInfoLog( shader );\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e( \x3cspan class=\x22hljs-string\x22\x3e\x22无法编译 WebGL 程序。 \\n\\n\x22\x3c\/span\x3e \x2b info);\n    \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.deleteShader(shader);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e null;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e shader;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e连接到可用程序\x3c\/h3\x3e\n\x3cp\x3e此时，着色器仍是不可用的，需要将其赋值到 WebGLProgram 上。这里主要进行了三步操作，首先，需要使用 \x3ccode\x3ecreateProgram()\x3c\/code\x3e 方法创建和初始化一个 WebGLProgram 对象。接着，使用 \x3ccode\x3e gl.attachShader(program, shader)\x3c\/code\x3e 将该对象结合两个已经编译的着色器。最后，使用 \x3ccode\x3elinkProgram(program)\x3c\/code\x3e 将 WebGLProgram 和着色器连接。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createProgram(gl, vshader, fshader) {\n  \/\/ 创建着色器对象\n  var vertexShader = createShader(gl, gl.VERTEX_SHADER, vshader);\n  var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fshader);\n  if (!vertexShader || !fragmentShader) {\n    return null;\n  }\n\n  \/\/ 创建编程对象\n  var program = gl.createProgram();\n  if (!program) {\n    return null;\n  }\n\n  \/\/ 赋值已创建的着色器对象\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n\n  \/\/ 连接编程对象\n  gl.linkProgram(program);\n\n  \/\/ 检查链接结果\n  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!linked) {\n    var error = gl.getProgramInfoLog(program);\n    console.log(\x27链接程序失败：\x27 \x2b error);\n    gl.deleteProgram(program);\n    gl.deleteShader(fragmentShader);\n    gl.deleteShader(vertexShader);\n    return null;\n  }\n  return program;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3efunction createProgram(\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e, vshader, fshader) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建着色器对象\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vertexShader = createShader(\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.VERTEX_SHADER, vshader);\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fragmentShader = createShader(\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.FRAGMENT_SHADER, fshader);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!vertexShader || !fragmentShader) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e null;\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建编程对象\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.createProgram();\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e null;\n  }\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 赋值已创建的着色器对象\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.attachShader(\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e, vertexShader);\n  \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.attachShader(\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e, fragmentShader);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 连接编程对象\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.linkProgram(\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e);\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 检查链接结果\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e linked = \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.getProgramParameter(\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.LINK_STATUS);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!linked) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eerror\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.getProgramInfoLog(\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e);\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x27链接程序失败：\x27 \x2b \x3cspan class=\x22hljs-keyword\x22\x3eerror\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.deleteProgram(\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.deleteShader(fragmentShader);\n    \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.deleteShader(vertexShader);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e null;\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e使用可用着色器程序\x3c\/h3\x3e\n\x3cp\x3e这一步主要使用 \x3ccode\x3euseProgram(program)\x3c\/code\x3e 方法告诉 GPU 使用程序。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initShaders(gl, vshader, fshader) {\n  var program = createProgram(gl, vshader, fshader);\n  if (!program) {\n    console.log(\x27创建程序失败。\x27);\n    return false;\n  }\n\n  gl.useProgram(program);\n  gl.program = program;\n\n  return true;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3efunction initShaders(\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e, vshader, fshader) {\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e = createProgram(\x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e, vshader, fshader);\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e) {\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x27创建程序失败。\x27);\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e false;\n  }\n\n  \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.useProgram(\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-keyword\x22\x3egl\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3eprogram\x3c\/span\x3e;\n\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e true;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e绘制一个点\x3c\/h3\x3e\n\x3cp\x3e最后，使用 \x3ccode\x3edrawArrays(mode, first, count)\x3c\/code\x3e 绘制一个点，该函数是一个非常强大的渲染函数，后续文章会有详细介绍。此处只需要知道传入 \x22POINTS\x22 绘制了一个点。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 绘制一个点\ngl.drawArrays(gl.POINTS, 0, 1);   \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绘制一个点\x3c\/span\x3e\ngl.drawArrays(gl.POINTS, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);   \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至此，我们已经完成了绘制一个点的全部程序。当运行以上程序时，我们会在浏览器中看到一个白色的点。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e结束语\x3c\/h2\x3e\n\x3cp\x3e到现在，我们虽然还没有使用 WebGL 绘制三维图形，但我们已经进入了 WebGL 世界。我们已经使用 WebGL 绘制了简单的图形。但是这只是 WebGL 的绘制的冰山一角，我们使用 WebGL 当然不是为了绘制这样一个简单的图形。为了绘制更复杂的图形，我们还有很多的细节需要去了解。但是无论如何，我们都已经开启了 WebGL 的第一步，其实问题也并没有我们想象的那么难。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>WebGL 初探</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007106469">https://segmentfault.com/a/1190000007106469</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/0ux7b50f8tw/" target="_blank">https://alili.tech/archive/0ux7b50f8tw/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/dc9tmbt89lc/">CSS3 巧妙实现聊天气泡<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/awfhylei7vr/">Element 一套优雅的 Vue 2 组件库是如何开发的<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/5n6e7oj31zb/">Ionic2入坑基础教程和安装指南<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/k9uktrr2ck/">JavaScript arguments 对象全面介绍<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/d31ygsiurr7/">JavaScript 版俄罗斯方块——重构<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/f1goxj498pc/">JavaScript中this绑定详解<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/fpk9tyls8sb/">Markcook2.0，使用Vue2.0和Vuex2.0进行完全重构升级<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/rnj4z8l02t/">N3-components - 强劲的 Vue UI组件库<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/7njdijhy2um/">Node.js &#43; React Native 毕设：农业物联网监测系统的开发手记<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/f8zzbybr4tl/">Redux、Flux、Vuex<aside class="dates">2019-02-02</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>