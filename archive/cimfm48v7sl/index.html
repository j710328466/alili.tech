<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="《JavaScript 闯关记》之作用域和闭包"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>《JavaScript 闯关记》之作用域和闭包 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/cimfm48v7sl/",
				"appid": "1613049289050283", 
				"title": "《JavaScript 闯关记》之作用域和闭包 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-30T02:30:22"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/uo00jfm9kqo/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/9efvzxyz00h/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f&text=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f&text=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f&is_video=false&description=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fcimfm48v7sl%2f&title=%e3%80%8aJavaScript%20%e9%97%af%e5%85%b3%e8%ae%b0%e3%80%8b%e4%b9%8b%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">《JavaScript 闯关记》之作用域和闭包</h1><div class="meta"><div class="postdate"><time datetime="2019-01-30" itemprop="datePublished">2019-01-30</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e作用域和闭包是 JavaScript 最重要的概念之一，想要进一步学习 JavaScript，就必须理解 JavaScript 作用域和闭包的工作原理。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e作用域\x3c\/h2\x3e\n\x3cp\x3e任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在 JavaScript 中，变量的作用域有全局作用域和局部作用域两种。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e全局作用域（Global Scope）\x3c\/h3\x3e\n\x3cp\x3e在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下三种情形拥有全局作用域：\x3c\/p\x3e\n\x3cp\x3e1.最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var global = \x26quot;global\x26quot;;     \/\/ 显式声明一个全局变量\nfunction checkscope() {\n    var local = \x26quot;local\x26quot;;   \/\/ 显式声明一个局部变量\n    return global;         \/\/ 返回全局变量的值\n}\nconsole.log(global);       \/\/ \x26quot;global\x26quot;\nconsole.log(checkscope()); \/\/ \x26quot;global\x26quot;\nconsole.log(local);        \/\/ error: local is not defined.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e global = \x3cspan class=\x22hljs-string\x22\x3e\x22global\x22\x3c\/span\x3e;     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 显式声明一个全局变量\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckscope\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e local = \x3cspan class=\x22hljs-string\x22\x3e\x22local\x22\x3c\/span\x3e;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 显式声明一个局部变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e global;         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回全局变量的值\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(global);       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22global\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(checkscope()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22global\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(local);        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ error: local is not defined.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中，\x3ccode\x3eglobal\x3c\/code\x3e 是全局变量，不管是在 \x3ccode\x3echeckscope()\x3c\/code\x3e 函数内部还是外部，都能访问到全局变量 \x3ccode\x3eglobal\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e2.所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function checkscope() {\n    var local = \x26quot;local\x26quot;; \/\/ 显式声明一个局部变量\n    global = \x26quot;global\x26quot;;   \/\/ 隐式声明一个全局变量(不好的写法)\n}\nconsole.log(global);     \/\/ \x26quot;global\x26quot;\nconsole.log(local);      \/\/ error: local is not defined.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckscope\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e local = \x3cspan class=\x22hljs-string\x22\x3e\x22local\x22\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 显式声明一个局部变量\x3c\/span\x3e\n    global = \x3cspan class=\x22hljs-string\x22\x3e\x22global\x22\x3c\/span\x3e;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 隐式声明一个全局变量(不好的写法)\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(global);     \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22global\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(local);      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ error: local is not defined.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中，变量 \x3ccode\x3eglobal\x3c\/code\x3e 未用 \x3ccode\x3evar\x3c\/code\x3e 关键字定义就直接赋值，所以隐式的创建了全局变量 \x3ccode\x3eglobal\x3c\/code\x3e，但这种写法容易造成误解，应尽量避免这种写法。\x3c\/p\x3e\n\x3cp\x3e3.所有 \x3ccode\x3ewindow\x3c\/code\x3e 对象的属性拥有全局作用域\x3c\/p\x3e\n\x3cp\x3e一般情况下，\x3ccode\x3ewindow\x3c\/code\x3e 对象的内置属性都拥有全局作用域，例如 \x3ccode\x3ewindow.name\x3c\/code\x3e、\x3ccode\x3ewindow.location\x3c\/code\x3e、\x3ccode\x3ewindow.top\x3c\/code\x3e 等等。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e局部作用域（Local Scope）\x3c\/h3\x3e\n\x3cp\x3e和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到。最常见的是在函数体内定义的变量，只能在函数体内使用。例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function checkscope() {\n    var local = \x26quot;local\x26quot;;   \/\/ 显式声明一个局部变量\n    return local;         \/\/ 返回全局变量的值\n}\nconsole.log(checkscope()); \/\/ \x26quot;local\x26quot;\nconsole.log(local);        \/\/ error: local is not defined.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckscope\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e local = \x3cspan class=\x22hljs-string\x22\x3e\x22local\x22\x3c\/span\x3e;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 显式声明一个局部变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e local;         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回全局变量的值\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(checkscope()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22local\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(local);        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ error: local is not defined.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面代码中，在函数体内定义了变量 \x3ccode\x3elocal\x3c\/code\x3e，在函数体内是可以访问了，在函数外访问就报错了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e全局和局部作用域的关系\x3c\/h3\x3e\n\x3cp\x3e在函数体内，局部变量的优先级高于同名的全局变量。如果在函数内声明的一个局部变量或者函数参数中带有的变量和全局变量重名，那么全局变量就被局部变量所遮盖。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var scope = \x26quot;global\x26quot;;      \/\/ 声明一个全局变量\nfunction checkscope() {\n    var scope = \x26quot;local\x26quot;;   \/\/ 声明一个同名的局部变量\n    return scope;          \/\/ 返回局部变量的值，而不是全局变量的值\n}\nconsole.log(checkscope()); \/\/ \x26quot;local\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22global\x22\x3c\/span\x3e;      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明一个全局变量\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckscope\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22local\x22\x3c\/span\x3e;   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明一个同名的局部变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e scope;          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回局部变量的值，而不是全局变量的值\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(checkscope()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22local\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e尽管在全局作用域编写代码时可以不写 \x3ccode\x3evar\x3c\/code\x3e 语句，但声明局部变量时则必须使用 \x3ccode\x3evar\x3c\/code\x3e 语句。思考一下如果不这样做会怎样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22scope = \x26quot;global\x26quot;;           \/\/ 声明一个全局变量，甚至不用 var 来声明\nfunction checkscope2() {\n    scope = \x26quot;local\x26quot;;        \/\/ 糟糕！我们刚修改了全局变量\n    myscope = \x26quot;local\x26quot;;      \/\/ 这里显式地声明了一个新的全局变量\n    return [scope, myscope];\/\/ 返回两个值\n}\nconsole.log(checkscope2()); \/\/ [\x26quot;local\x26quot;, \x26quot;local\x26quot;]，产生了副作用\nconsole.log(scope);         \/\/ \x26quot;local\x26quot;，全局变量修改了\nconsole.log(myscope);       \/\/ \x26quot;local\x26quot;，全局命名空间搞乱了\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3escope = \x3cspan class=\x22hljs-string\x22\x3e\x22global\x22\x3c\/span\x3e;           \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明一个全局变量，甚至不用 var 来声明\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckscope2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    scope = \x3cspan class=\x22hljs-string\x22\x3e\x22local\x22\x3c\/span\x3e;        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 糟糕！我们刚修改了全局变量\x3c\/span\x3e\n    myscope = \x3cspan class=\x22hljs-string\x22\x3e\x22local\x22\x3c\/span\x3e;      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里显式地声明了一个新的全局变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e [scope, myscope];\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回两个值\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(checkscope2()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ [\x22local\x22, \x22local\x22]，产生了副作用\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(scope);         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22local\x22，全局变量修改了\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(myscope);       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22local\x22，全局命名空间搞乱了\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数定义是可以嵌套的。由于每个函数都有它自己的作用域，因此会出现几个局部作用域嵌套的情况，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var scope = \x26quot;global scope\x26quot;;         \/\/ 全局变量\nfunction checkscope() {\n    var scope = \x26quot;local scope\x26quot;;      \/\/局部变量 \n    function nested() {\n        var scope = \x26quot;nested scope\x26quot;; \/\/ 嵌套作用域内的局部变量\n        return scope;               \/\/ 返回当前作用域内的值\n    }\n    return nested();\n}\nconsole.log(checkscope());          \/\/ \x26quot;nested scope\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22global scope\x22\x3c\/span\x3e;         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 全局变量\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckscope\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22local scope\x22\x3c\/span\x3e;      \x3cspan class=\x22hljs-comment\x22\x3e\/\/局部变量 \x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enested\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22nested scope\x22\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 嵌套作用域内的局部变量\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e scope;               \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回当前作用域内的值\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e nested();\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(checkscope());          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22nested scope\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e函数作用域和声明提前\x3c\/h3\x3e\n\x3cp\x3e在一些类似 C 语言的编程语言中，花括号内的每一段代码都具有各自的作用域，而且变量在声明它们的代码段之外是不可见的，我们称为块级作用域（block scope），而 JavaScript 中没有块级作用域。JavaScript 取而代之地使用了函数作用域（function scope），变量在声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。\x3c\/p\x3e\n\x3cp\x3e在如下所示的代码中，在不同位置定义了变量 \x3ccode\x3ei\x3c\/code\x3e、\x3ccode\x3ej\x3c\/code\x3e 和 \x3ccode\x3ek\x3c\/code\x3e，它们都在同一个作用域内，这三个变量在函数体内均是有定义的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function test(o) {\n    var i = 0; \/\/ i在整个函数体内均是有定义的\n    if (typeof o == \x26quot;object\x26quot;) {\n        var j = 0; \/\/ j在函数体内是有定义的，不仅仅是在这个代码段内\n        for (var k = 0; k \x3c 10; k\x2b\x2b) { \/\/ k在函数体内是有定义的，不仅仅是在循环内\n            console.log(k); \/\/ 输出数字0~9\n        }\n        console.log(k); \/\/ k已经定义了，输出10\n    }\n    console.log(j); \/\/ j已经定义了，但可能没有初始化\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etest\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eo\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ i在整个函数体内均是有定义的\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e o == \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ j在函数体内是有定义的，不仅仅是在这个代码段内\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e k = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; k \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; k\x2b\x2b) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ k在函数体内是有定义的，不仅仅是在循环内\x3c\/span\x3e\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(k); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出数字0~9\x3c\/span\x3e\n        }\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(k); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ k已经定义了，输出10\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(j); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ j已经定义了，但可能没有初始化\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eJavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。JavaScript 的这个特性被非正式地称为声明提前（hoisting），即 JavaScript 函数里声明的所有变量（但不涉及赋值）都被「提前」至函数体的顶部，看一下如下代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var scope = \x26quot;global\x26quot;;\nfunction f() {\n    console.log(scope);  \/\/ 输出\x26quot;undefined\x26quot;，而不是\x26quot;global\x26quot;\n    var scope = \x26quot;local\x26quot;; \/\/ 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的\n    console.log(scope);  \/\/ 输出\x26quot;local\x26quot;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22global\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(scope);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出\x22undefined\x22，而不是\x22global\x22\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22local\x22\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(scope);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出\x22local\x22\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你可能会误以为函数中的第一行会输出 \x3ccode\x3e\x22global\x22\x3c\/code\x3e，因为代码还没有执行到 \x3ccode\x3evar\x3c\/code\x3e 语句声明局部变量的地方。其实不然，由于函数作用域的特性，局部变量在整个函数体始终是有定义的，也就是说，在函数体内局部变量遮盖了同名全局变量。尽管如此，只有在程序执行到 \x3ccode\x3evar\x3c\/code\x3e 语句的时候，局部变量才会被真正赋值。因此，上述过程等价于：将函数内的变量声明“提前”至函数体顶部，同时变量初始化留在原来的位置：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function f() {\n    var scope;          \/\/ 在函数顶部声明了局部变量\n    console.log(scope); \/\/ 变量存在，但其值是\x26quot;undefined\x26quot;\n    scope = \x26quot;local\x26quot;;    \/\/ 这里将其初始化并赋值\n    console.log(scope); \/\/ 这里它具有了我们所期望的值\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope;          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在函数顶部声明了局部变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(scope); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 变量存在，但其值是\x22undefined\x22\x3c\/span\x3e\n    scope = \x3cspan class=\x22hljs-string\x22\x3e\x22local\x22\x3c\/span\x3e;    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里将其初始化并赋值\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(scope); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里它具有了我们所期望的值\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在具有块级作用域的编程语言中，在狭小的作用域里让变量声明和使用变量的代码尽可能靠近彼此，通常来讲，这是一个非常不错的编程习惯。由于 JavaScript 没有块级作用域，因此一些程序员特意将变量声明放在函数体顶部，而不是将声明靠近放在使用变量之处。这种做法使得他们的源代码非常清晰地反映了真实的变量作用域。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e作用域链\x3c\/h3\x3e\n\x3cp\x3e当代码在一个环境中执行时，会创建变量对象的一个\x3cstrong\x3e作用域链\x3c\/strong\x3e（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其\x3cstrong\x3e活动对象\x3c\/strong\x3e（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 \x3ccode\x3earguments\x3c\/code\x3e 对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。\x3c\/p\x3e\n\x3cp\x3e标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。\x3c\/p\x3e\n\x3cp\x3e请看下面的示例代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var color = \x26quot;blue\x26quot;;\n\nfunction changeColor(){\n    if (color === \x26quot;blue\x26quot;){\n        color = \x26quot;red\x26quot;;\n    } else {\n        color = \x26quot;blue\x26quot;;\n    }\n}\n\nconsole.log(changeColor());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e color = \x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echangeColor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (color === \x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e){\n        color = \x3cspan class=\x22hljs-string\x22\x3e\x22red\x22\x3c\/span\x3e;\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        color = \x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e;\n    }\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(changeColor());\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这个简单的例子中，函数 \x3ccode\x3echangeColor()\x3c\/code\x3e 的作用域链包含两个对象：它自己的变量对象（其中定义着 \x3ccode\x3earguments\x3c\/code\x3e 对象）和全局环境的变量对象。可以在函数内部访问变量 \x3ccode\x3ecolor\x3c\/code\x3e，就是因为可以在这个作用域链中找到它。\x3c\/p\x3e\n\x3cp\x3e此外，在局部作用域中定义的变量可以在局部环境中与全局变量互换使用，如下面这个例子所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var color = \x26quot;blue\x26quot;;\n\nfunction changeColor(){\n    var anotherColor = \x26quot;red\x26quot;;\n\n    function swapColors(){\n        var tempColor = anotherColor;\n        anotherColor = color;\n        color = tempColor;\n\n        \/\/ 这里可以访问color、anotherColor和tempColor\n    }\n\n    \/\/ 这里可以访问color和anotherColor，但不能访问tempColor\n    swapColors();\n}\n\n\/\/ 这里只能访问color\nchangeColor();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e color = \x3cspan class=\x22hljs-string\x22\x3e\x22blue\x22\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echangeColor\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e anotherColor = \x3cspan class=\x22hljs-string\x22\x3e\x22red\x22\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eswapColors\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e tempColor = anotherColor;\n        anotherColor = color;\n        color = tempColor;\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里可以访问color、anotherColor和tempColor\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里可以访问color和anotherColor，但不能访问tempColor\x3c\/span\x3e\n    swapColors();\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里只能访问color\x3c\/span\x3e\nchangeColor();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e以上代码共涉及3个执行环境：全局环境、\x3ccode\x3echangeColor()\x3c\/code\x3e 的局部环境和 \x3ccode\x3eswapColors()\x3c\/code\x3e 的局部环境。全局环境中有一个变量 \x3ccode\x3ecolor\x3c\/code\x3e 和一个函数 \x3ccode\x3echangeColor()\x3c\/code\x3e。\x3ccode\x3echangeColor()\x3c\/code\x3e 的局部环境中有一个名为 \x3ccode\x3eanotherColor\x3c\/code\x3e 的变量和一个名为 \x3ccode\x3eswapColors()\x3c\/code\x3e 的函数，但它也可以访问全局环境中的变量 \x3ccode\x3ecolor\x3c\/code\x3e。\x3ccode\x3eswapColors()\x3c\/code\x3e 的局部环境中有一个变量 \x3ccode\x3etempColor\x3c\/code\x3e，该变量只能在这个环境中访问到。无论全局环境还是 \x3ccode\x3echangeColor()\x3c\/code\x3e 的局部环境都无权访问 \x3ccode\x3etempColor\x3c\/code\x3e。然而，在 \x3ccode\x3eswapColors()\x3c\/code\x3e 内部则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。下图形象地展示了前面这个例子的作用域链。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/qiniu.shijiajie.com\/blog\/javascript-lesson\/2.41.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/qiniu.shijiajie.com\/blog\/javascript-lesson\/2.41.jpg\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上图中的矩形表示特定的执行环境。其中，内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。对于这个例子中的 \x3ccode\x3eswapColors()\x3c\/code\x3e 而言，其作用域链中包含3个对象：\x3ccode\x3eswapColors()\x3c\/code\x3e 的变量对象、\x3ccode\x3echangeColor()\x3c\/code\x3e 的变量对象和全局变量对象。\x3ccode\x3eswapColors()\x3c\/code\x3e 的局部环境开始时会先在自己的变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。\x3ccode\x3echangeColor()\x3c\/code\x3e 的作用域链中只包含两个对象：它自己的变量对象和全局变量对象。这也就是说，它不能访问 \x3ccode\x3eswapColors()\x3c\/code\x3e 的环境。函数参数也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e闭包\x3c\/h2\x3e\n\x3cp\x3eMDN 对闭包的定义：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e闭包是指那些能够访问独立（自由）变量的函数（变量在本地使用，但定义在一个封闭的作用域中）。换句话说，这些函数可以「记忆」它被创建时候的环境。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e《JavaScript 权威指南(第6版)》对闭包的定义：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称为闭包。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e《JavaScript 高级程序设计(第3版)》对闭包的定义：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e闭包是指有权访问另一个函数作用域中的变量的函数。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e上面这些定义都比较晦涩难懂，\x3ca href=\x22http:\/\/www.ruanyifeng.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阮一峰\x3c\/a\x3e的解释稍微好理解一些：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成定义在一个函数内部的函数。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e闭包的用途\x3c\/h3\x3e\n\x3cp\x3e闭包可以用在许多地方。它的最大用处有两个，一个是可以读取函数内部的变量（作用域链），另一个就是让这些变量的值始终保持在内存中。怎么来理解这句话呢？请看下面的代码。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fun() {　　　\n    var n = 1;\n\n    add = function() {\n        n \x2b= 1\n    }\n\n    function fun2(){\n        console.log(n);\n    }\n\n    return fun2;\n}\n\nvar result = fun();　　\nresult(); \/\/ 1\nadd();\nresult(); \/\/ 2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{　　　\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e n = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\n    add = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        n \x2b= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n    }\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efun2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(n);\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e fun2;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = fun();　　\nresult(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\nadd();\nresult(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这段代码中，\x3ccode\x3eresult\x3c\/code\x3e 实际上就是函数 \x3ccode\x3efun2\x3c\/code\x3e。它一共运行了两次，第一次的值是 \x3ccode\x3e1\x3c\/code\x3e，第二次的值是 \x3ccode\x3e2\x3c\/code\x3e。这证明了，函数 \x3ccode\x3efun\x3c\/code\x3e 中的局部变量 \x3ccode\x3en\x3c\/code\x3e 一直保存在内存中，并没有在 \x3ccode\x3efun\x3c\/code\x3e 调用后被自动清除。\x3c\/p\x3e\n\x3cp\x3e为什么会这样呢？原因就在于 \x3ccode\x3efun\x3c\/code\x3e 是 \x3ccode\x3efun2\x3c\/code\x3e 的父函数，而 \x3ccode\x3efun2\x3c\/code\x3e 被赋给了一个全局变量，这导致 \x3ccode\x3efun2\x3c\/code\x3e 始终在内存中，而 \x3ccode\x3efun2\x3c\/code\x3e 的存在依赖于 \x3ccode\x3efun\x3c\/code\x3e，因此 \x3ccode\x3efun\x3c\/code\x3e 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。\x3c\/p\x3e\n\x3cp\x3e这段代码中另一个值得注意的地方，就是 \x3ccode\x3eadd = function() { n \x2b= 1 }\x3c\/code\x3e 这一行。首先，变量 \x3ccode\x3eadd\x3c\/code\x3e 前面没有使用 \x3ccode\x3evar\x3c\/code\x3e 关键字，因此 \x3ccode\x3eadd\x3c\/code\x3e 是一个全局变量，而不是局部变量。其次，\x3ccode\x3eadd\x3c\/code\x3e 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，和 \x3ccode\x3efun2\x3c\/code\x3e 处于同一作用域，所以 \x3ccode\x3eadd\x3c\/code\x3e 相当于是一个 \x3ccode\x3esetter\x3c\/code\x3e，可以在函数外部对函数内部的局部变量进行操作。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e计数器的困境\x3c\/h3\x3e\n\x3cp\x3e我们再来看一个经典例子「计数器的困境」，假设你想统计一些数值，且该计数器在所有函数中都是可用的。你可以定义一个全局变量 \x3ccode\x3ecounter\x3c\/code\x3e 当做计数器，再定义一个 \x3ccode\x3eadd()\x3c\/code\x3e 函数来设置计数器递增。代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var counter = 0;\nfunction add() {\n    return counter \x2b= 1;\n}\n\nconsole.log(add());\nconsole.log(add());\nconsole.log(add());\n\/\/ 计数器现在为 3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e counter \x2b= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(add());\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(add());\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(add());\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计数器现在为 3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e计数器数值在执行 \x3ccode\x3eadd()\x3c\/code\x3e 函数时发生变化。但问题来了，页面上的任何脚本都能改变计数器 \x3ccode\x3ecounter\x3c\/code\x3e，即便没有调用 \x3ccode\x3eadd()\x3c\/code\x3e 函数。如果我们将计数器 \x3ccode\x3ecounter \x3c\/code\x3e 定义在 \x3ccode\x3eadd()\x3c\/code\x3e 函数内部，就不会被外部脚本随意修改到计数器的值了。代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add() {\n    var counter = 0;\n    return counter \x2b= 1;\n}\n\nconsole.log(add());\nconsole.log(add());\nconsole.log(add());\n\/\/ 本意是想输出 3, 但事与愿违，输出的都是 1 \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e counter \x2b= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(add());\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(add());\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(add());\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 本意是想输出 3, 但事与愿违，输出的都是 1 \x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为每次调用 \x3ccode\x3eadd()\x3c\/code\x3e 函数，计数器都会被重置为 0，输出的都是 1，这并不是我们想要的结果。闭包正好可以解决这个问题，我们在 \x3ccode\x3eadd()\x3c\/code\x3e 函数内部，再定义一个 \x3ccode\x3eplus()\x3c\/code\x3e 内嵌函数（闭包），内嵌函数 \x3ccode\x3eplus()\x3c\/code\x3e 可以访问父函数的 \x3ccode\x3ecounter\x3c\/code\x3e 变量。代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function add() {\n    var counter = 0;\n    var plus = function() {counter \x2b= 1;}\n    plus();\n    return counter; \n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eadd\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e plus = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{counter \x2b= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;}\n    plus();\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e counter; \n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e接下来，只要我们能在外部访问 \x3ccode\x3eplus()\x3c\/code\x3e 函数，并且确保 \x3ccode\x3ecounter = 0\x3c\/code\x3e 只执行一次，就能解决计数器的困境。代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var add = function() {\n    var counter = 0;\n    var plus = function() {return counter \x2b= 1;}\n    return plus;\n}\n\nvar puls2 = add();\nconsole.log(puls2());\nconsole.log(puls2());\nconsole.log(puls2());\n\/\/ 计数器为 3\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e add = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e plus = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e counter \x2b= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;}\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e plus;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e puls2 = add();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(puls2());\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(puls2());\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(puls2());\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 计数器为 3\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e计数器 \x3ccode\x3ecounter\x3c\/code\x3e 受 \x3ccode\x3eadd()\x3c\/code\x3e 函数的作用域保护，只能通过 \x3ccode\x3epuls2\x3c\/code\x3e 方法修改。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e使用闭包的注意点\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除或设置为 \x3ccode\x3enull\x3c\/code\x3e，断开变量和内存的联系。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（public method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eJavaScript 闭包是一种强大的语言特性。通过使用这个语言特性来隐藏变量，可以避免覆盖其他地方使用的同名变量，理解闭包有助于编写出更有效也更简洁的代码。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e\n\x3ccode\x3ethis\x3c\/code\x3e 关键字\x3c\/h2\x3e\n\x3cp\x3e谈到作用域和闭包就不得不说 \x3ccode\x3ethis\x3c\/code\x3e 关键字，虽然它们之间关联不大，但是它们一起使用却容易让人产生疑惑。下面列出了使用 \x3ccode\x3ethis\x3c\/code\x3e 的大部分场景，带大家一探究竟。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3ethis\x3c\/code\x3e 是 JavaScript 的关键字，指函数执行时的上下文，跟函数定义时的上下文无关。随着函数使用场合的不同，\x3ccode\x3ethis\x3c\/code\x3e 的值会发生变化。但是有一个总的原则，那就是 \x3ccode\x3ethis\x3c\/code\x3e 指代的是调用函数的那个对象。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e全局上下文\x3c\/h3\x3e\n\x3cp\x3e在全局上下文中，也就是在任何函数体外部，\x3ccode\x3ethis\x3c\/code\x3e 指代全局对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 在浏览器中，this 指代全局对象 window\nconsole.log(this === window);  \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 在浏览器中，this 指代全局对象 window\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e函数上下文\x3c\/h3\x3e\n\x3cp\x3e在函数上下文中，也就是在任何函数体内部，\x3ccode\x3ethis\x3c\/code\x3e 指代调用函数的那个对象。\x3c\/p\x3e\n\x3ch4\x3e函数调用中的 \x3ccode\x3ethis\x3c\/code\x3e\n\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function f1(){\n    return this;\n}\n\nconsole.log(f1() === window); \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(f1() === \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上代码所示，直接定义一个函数 \x3ccode\x3ef1()\x3c\/code\x3e，相当于为 \x3ccode\x3ewindow\x3c\/code\x3e 对象定义了一个属性。直接执行函数 \x3ccode\x3ef1()\x3c\/code\x3e，相当于执行 \x3ccode\x3ewindow.f1()\x3c\/code\x3e。所以函数 \x3ccode\x3ef1()\x3c\/code\x3e 中的 \x3ccode\x3ethis\x3c\/code\x3e 指代调用函数的那个对象，也就是 \x3ccode\x3ewindow\x3c\/code\x3e 对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function f2(){\n    \x26quot;use strict\x26quot;; \/\/ 这里是严格模式\n    return this;\n}\n\nconsole.log(f2() === undefined); \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n\x3cspan class=\x22hljs-meta\x22\x3e    \x22use strict\x22\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里是严格模式\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;\n}\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(f2() === \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上代码所示，在「严格模式」下，禁止 \x3ccode\x3ethis\x3c\/code\x3e 关键字指向全局对象（在浏览器环境中也就是 \x3ccode\x3ewindow\x3c\/code\x3e 对象），\x3ccode\x3ethis\x3c\/code\x3e 的值将维持 \x3ccode\x3eundefined\x3c\/code\x3e 状态。\x3c\/p\x3e\n\x3ch4\x3e对象方法中的 \x3ccode\x3ethis\x3c\/code\x3e\n\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var o = {\n    name: \x26quot;stone\x26quot;,\n    f: function() {\n        return this.name;\n    }\n};\n\nconsole.log(o.f()); \/\/ \x26quot;stone\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22stone\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n    }\n};\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(o.f()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22stone\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如上代码所示，对象 \x3ccode\x3eo\x3c\/code\x3e 中包含一个属性 \x3ccode\x3ename\x3c\/code\x3e 和一个方法 \x3ccode\x3ef()\x3c\/code\x3e。当我们执行 \x3ccode\x3eo.f()\x3c\/code\x3e 时，方法 \x3ccode\x3ef()\x3c\/code\x3e 中的 \x3ccode\x3ethis\x3c\/code\x3e 指代调用函数的那个对象，也就是对象 \x3ccode\x3eo\x3c\/code\x3e，所以 \x3ccode\x3ethis.name\x3c\/code\x3e 也就是 \x3ccode\x3eo.name\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e注意，在何处定义函数完全不会影响到 \x3ccode\x3ethis\x3c\/code\x3e 的行为，我们也可以首先定义函数，然后再将其附属到 \x3ccode\x3eo.f\x3c\/code\x3e。这样做 \x3ccode\x3ethis\x3c\/code\x3e 的行为也一致。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var fun = function() {\n    return this.name;\n};\n\nvar o = { name: \x26quot;stone\x26quot; };\no.f = fun;\n\nconsole.log(o.f()); \/\/ \x26quot;stone\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fun = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o = { \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22stone\x22\x3c\/span\x3e };\no.f = fun;\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(o.f()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22stone\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e类似的，\x3ccode\x3ethis\x3c\/code\x3e 的绑定只受最靠近的成员引用的影响。在下面的这个例子中，我们把一个方法 \x3ccode\x3eg()\x3c\/code\x3e 当作对象 \x3ccode\x3eo.b\x3c\/code\x3e 的函数调用。在这次执行期间，函数中的 \x3ccode\x3ethis\x3c\/code\x3e 将指向 \x3ccode\x3eo.b\x3c\/code\x3e。事实上，这与对象本身的成员没有多大关系，最靠近的引用才是最重要的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22o.b = {\n    name: \x26quot;sophie\x26quot;\n    g: fun,\n};\n\nconsole.log(o.b.g()); \/\/ \x26quot;sophie\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eo.b = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22sophie\x22\x3c\/span\x3e\n    g: fun,\n};\n\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(o.b.g()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22sophie\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\n\x3ccode\x3eeval()\x3c\/code\x3e 方法中的 \x3ccode\x3ethis\x3c\/code\x3e\n\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3eeval()\x3c\/code\x3e 方法可以将字符串转换为 JavaScript 代码，使用 \x3ccode\x3eeval()\x3c\/code\x3e 方法时，\x3ccode\x3ethis\x3c\/code\x3e 指向哪里呢？答案很简单，看谁在调用 \x3ccode\x3eeval()\x3c\/code\x3e 方法，调用者的执行环境中的 \x3ccode\x3ethis\x3c\/code\x3e 就被 \x3ccode\x3eeval()\x3c\/code\x3e 方法继承下来了。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 全局上下文\nfunction f1(){\n    return eval(\x26quot;this\x26quot;);\n}\nconsole.log(f1() === window); \/\/ true\n\n\/\/ 函数上下文\nvar o = {\n    name: \x26quot;stone\x26quot;,\n    f: function() {\n        return eval(\x26quot;this.name\x26quot;);\n    }\n};\nconsole.log(o.f()); \/\/ \x26quot;stone\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 全局上下文\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eeval\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22this\x22\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(f1() === \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 函数上下文\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o = {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22stone\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eeval\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22this.name\x22\x3c\/span\x3e);\n    }\n};\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(o.f()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x22stone\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e\n\x3ccode\x3ecall()\x3c\/code\x3e 和 \x3ccode\x3eapply()\x3c\/code\x3e 方法中的 \x3ccode\x3ethis\x3c\/code\x3e\n\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3ecall()\x3c\/code\x3e 和 \x3ccode\x3eapply()\x3c\/code\x3e 是函数对象的方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，\x3ccode\x3ethis\x3c\/code\x3e 指代的就是这两个方法的第一个参数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var x = 0;　　\nfunction f() {　　　　\n    console.log(this.x);　　\n}　　\nvar o = {};　　\no.x = 1;\no.m = f;　　\no.m.apply(); \/\/ 0\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e x = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;　　\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{　　　　\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x);　　\n}　　\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o = {};　　\no.x = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\no.m = f;　　\no.m.apply(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 0\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3ecall()\x3c\/code\x3e 和 \x3ccode\x3eapply()\x3c\/code\x3e 的参数为空时，默认调用全局对象。因此，这时的运行结果为 \x3ccode\x3e0\x3c\/code\x3e，证明 \x3ccode\x3ethis\x3c\/code\x3e 指的是全局对象。如果把最后一行代码修改为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22o.m.apply(o); \/\/ 1\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eo.m.apply(o); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e运行结果就变成了 \x3ccode\x3e1\x3c\/code\x3e，证明了这时 \x3ccode\x3ethis\x3c\/code\x3e 指代的是对象 \x3ccode\x3eo\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch4\x3e\n\x3ccode\x3ebind()\x3c\/code\x3e 方法中的 \x3ccode\x3ethis\x3c\/code\x3e\n\x3c\/h4\x3e\n\x3cp\x3eECMAScript 5 引入了 \x3ccode\x3eFunction.prototype.bind\x3c\/code\x3e。调用 \x3ccode\x3ef.bind(someObject)\x3c\/code\x3e 会创建一个与 \x3ccode\x3ef\x3c\/code\x3e 具有相同函数体和作用域的函数，但是在这个新函数中，\x3ccode\x3ethis\x3c\/code\x3e 将永久地被绑定到了 \x3ccode\x3ebind\x3c\/code\x3e 的第一个参数，无论这个函数是如何被调用的。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function f() {\n    return this.a;\n}\n\nvar g = f.bind({\n    a: \x26quot;stone\x26quot;\n});\nconsole.log(g()); \/\/ stone\n\nvar o = {\n    a: 28,\n    f: f,\n    g: g\n};\nconsole.log(o.f(), o.g()); \/\/ 28, stone\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ef\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e g = f.bind({\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22stone\x22\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(g()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ stone\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e o = {\n    \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e28\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3ef\x3c\/span\x3e: f,\n    \x3cspan class=\x22hljs-attr\x22\x3eg\x3c\/span\x3e: g\n};\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(o.f(), o.g()); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 28, stone\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eDOM 事件处理函数中的 \x3ccode\x3ethis\x3c\/code\x3e\n\x3c\/h4\x3e\n\x3cp\x3e一般来讲，当函数使用 \x3ccode\x3eaddEventListener\x3c\/code\x3e，被用作事件处理函数时，它的 \x3ccode\x3ethis\x3c\/code\x3e 指向触发事件的元素。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c!DOCTYPE HTML\x3e\n\x3chtml\x3e\n\x3chead\x3e\n    \x3cmeta charset=\x26quot;UTF-8\x26quot;\x3e\n    \x3ctitle\x3etest\x3c\/title\x3e\n\x3c\/head\x3e\n\x3cbody\x3e\n    \x3cbutton id=\x26quot;btn\x26quot; type=\x26quot;button\x26quot;\x3eclick\x3c\/button\x3e\n    \x3cscript\x3e\n        var btn = document.getElementById(\x26quot;btn\x26quot;);\n        btn.addEventListener(\x26quot;click\x26quot;, function(){\n            this.style.backgroundColor = \x26quot;#A5D9F3\x26quot;;\n        }, false);\n    \x3c\/script\x3e\n\x3c\/body\x3e\n\x3c\/html\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x26lt;!DOCTYPE HTML\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emeta\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3echarset\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22UTF-8\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3etest\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22button\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eclick\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e btn = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e);\n        btn.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22click\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.style.backgroundColor = \x3cspan class=\x22hljs-string\x22\x3e\x22#A5D9F3\x22\x3c\/span\x3e;\n        }, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n    \x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但在 IE 浏览器中，当函数使用 \x3ccode\x3eattachEvent\x3c\/code\x3e ，被用作事件处理函数时，它的 \x3ccode\x3ethis\x3c\/code\x3e 却指向 \x3ccode\x3ewindow\x3c\/code\x3e。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3c!DOCTYPE HTML\x3e\n\x3chtml\x3e\n\x3chead\x3e\n    \x3cmeta charset=\x26quot;UTF-8\x26quot;\x3e\n    \x3ctitle\x3etest\x3c\/title\x3e\n\x3c\/head\x3e\n\x3cbody\x3e\n    \x3cbutton id=\x26quot;btn\x26quot; type=\x26quot;button\x26quot;\x3eclick\x3c\/button\x3e\n    \x3cscript\x3e\n        var btn = document.getElementById(\x26quot;btn\x26quot;);\n        btn.attachEvent(\x26quot;onclick\x26quot;, function(){\n            console.log(this === window);  \/\/ true\n        });\n    \x3c\/script\x3e\n\x3c\/body\x3e\n\x3c\/html\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-meta\x22\x3e\x26lt;!DOCTYPE HTML\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3emeta\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3echarset\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22UTF-8\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3etest\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etitle\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22button\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eclick\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n    \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e btn = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22btn\x22\x3c\/span\x3e);\n        btn.attachEvent(\x3cspan class=\x22hljs-string\x22\x3e\x22onclick\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e === \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e);  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n        });\n    \x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3e内联事件处理函数中的 \x3ccode\x3ethis\x3c\/code\x3e\n\x3c\/h4\x3e\n\x3cp\x3e当代码被内联处理函数调用时，它的 \x3ccode\x3ethis\x3c\/code\x3e 指向监听器所在的 DOM 元素。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cbutton onclick=\x26quot;alert(this.tagName.toLowerCase());\x26quot;\x3e\n  Show this\n\x3c\/button\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonclick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22alert(this.tagName.toLowerCase());\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  Show this\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的 \x3ccode\x3ealert\x3c\/code\x3e 会显示 \x3ccode\x3ebutton\x3c\/code\x3e，注意只有外层代码中的 \x3ccode\x3ethis\x3c\/code\x3e 是这样设置的。如果 \x3ccode\x3ethis\x3c\/code\x3e 被包含在匿名函数中，则又是另外一种情况了。如下代码所示：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cbutton onclick=\x26quot;alert((function(){return this})());\x26quot;\x3e\n  Show inner this\n\x3c\/button\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonclick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22alert((function(){return this})());\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  Show inner this\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在这种情况下，\x3ccode\x3ethis\x3c\/code\x3e 被包含在匿名函数中，相当于处于全局上下文中，所以它指向 \x3ccode\x3ewindow\x3c\/code\x3e 对象。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e关卡\x3c\/h2\x3e\n\x3cp\x3e仔细想想，下面代码块会输出什么结果呢？\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 挑战一\nfunction func1() {\n    function func2() {\n        console.log(this)\n    }\n    return func2;\n}\nfunc1()();  \/\/ ???\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挑战一\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunc1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efunc2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e func2;\n}\nfunc1()();  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ???\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 挑战二\nscope = \x26quot;stone\x26quot;;\n\nfunction Func() {\n    var scope = \x26quot;sophie\x26quot;;\n\n    function inner() {\n        console.log(scope);\n    }\n    return inner;\n}\n\nvar ret = Func();\nret();    \/\/ ???\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挑战二\x3c\/span\x3e\nscope = \x3cspan class=\x22hljs-string\x22\x3e\x22stone\x22\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22sophie\x22\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einner\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(scope);\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e inner;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = Func();\nret();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ???\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 挑战三\nscope = \x26quot;stone\x26quot;;\n\nfunction Func() {\n    var scope = \x26quot;sophie\x26quot;;\n\n    function inner() {\n        console.log(scope);\n    }\n    scope = \x26quot;tommy\x26quot;;\n    return inner;\n}\n\nvar ret = Func();\nret();    \/\/ ???\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挑战三\x3c\/span\x3e\nscope = \x3cspan class=\x22hljs-string\x22\x3e\x22stone\x22\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22sophie\x22\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einner\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(scope);\n    }\n    scope = \x3cspan class=\x22hljs-string\x22\x3e\x22tommy\x22\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e inner;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = Func();\nret();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ???\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 挑战四\nscope = \x26quot;stone\x26quot;;\n\nfunction Bar() {\n    console.log(scope);\n}\n\nfunction Func() {\n    var scope = \x26quot;sophie\x26quot;;\n    return Bar;\n}\n\nvar ret = Func();\nret();    \/\/ ???\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挑战四\x3c\/span\x3e\nscope = \x3cspan class=\x22hljs-string\x22\x3e\x22stone\x22\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(scope);\n}\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFunc\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e scope = \x3cspan class=\x22hljs-string\x22\x3e\x22sophie\x22\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Bar;\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ret = Func();\nret();    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ???\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 挑战五\nvar name = \x26quot;The Window\x26quot;;　　\nvar object = {　　　　\n    name: \x26quot;My Object\x26quot;,\n    getNameFunc: function() {　　　　　　\n        return function() {　　　　　　　　\n            return this.name;　　　　　　\n        };　　　　\n    }　　\n};　　\nconsole.log(object.getNameFunc()());    \/\/ ???\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挑战五\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = \x3cspan class=\x22hljs-string\x22\x3e\x22The Window\x22\x3c\/span\x3e;　　\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e object = {　　　　\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22My Object\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3egetNameFunc\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{　　　　　　\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{　　　　　　　　\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;　　　　　　\n        };　　　　\n    }　　\n};　　\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(object.getNameFunc()());    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ???\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 挑战六\nvar name = \x26quot;The Window\x26quot;;　　\nvar object = {　　　　\n    name: \x26quot;My Object\x26quot;,\n    getNameFunc: function() {　　　　　　\n        var that = this;　　　　　　\n        return function() {　　　　　　　　\n            return that.name;　　　　　　\n        };　　　　\n    }　　\n};　　\nconsole.log(object.getNameFunc()());    \/\/ ???\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 挑战六\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e name = \x3cspan class=\x22hljs-string\x22\x3e\x22The Window\x22\x3c\/span\x3e;　　\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e object = {　　　　\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22My Object\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3egetNameFunc\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{　　　　　　\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e that = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e;　　　　　　\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{　　　　　　　　\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e that.name;　　　　　　\n        };　　　　\n    }　　\n};　　\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(object.getNameFunc()());    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ???\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e更多\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e关注微信公众号「劼哥舍」回复「答案」，获取关卡详解。  \x3cbr\x3e关注 \x3ca href=\x22https:\/\/github.com\/stone0090\/javascript-lessons\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/stone0090\/javascript-lessons\x3c\/a\x3e，获取最新动态。\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>《JavaScript 闯关记》之作用域和闭包</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007791657">https://segmentfault.com/a/1190000007791657</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/cimfm48v7sl/" target="_blank">https://alili.tech/archive/cimfm48v7sl/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>