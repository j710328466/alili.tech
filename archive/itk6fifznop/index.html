<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="javascript典型内存泄漏及chrome的排查方法"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>javascript典型内存泄漏及chrome的排查方法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/itk6fifznop/",
				"appid": "1613049289050283", 
				"title": "javascript典型内存泄漏及chrome的排查方法 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-17T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/i45oewhck6/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/oi6abiw4f3b/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f&text=javascript%e5%85%b8%e5%9e%8b%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%8f%8achrome%e7%9a%84%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f&text=javascript%e5%85%b8%e5%9e%8b%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%8f%8achrome%e7%9a%84%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f&title=javascript%e5%85%b8%e5%9e%8b%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%8f%8achrome%e7%9a%84%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f&is_video=false&description=javascript%e5%85%b8%e5%9e%8b%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%8f%8achrome%e7%9a%84%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=javascript%e5%85%b8%e5%9e%8b%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%8f%8achrome%e7%9a%84%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f&title=javascript%e5%85%b8%e5%9e%8b%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%8f%8achrome%e7%9a%84%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f&title=javascript%e5%85%b8%e5%9e%8b%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%8f%8achrome%e7%9a%84%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f&title=javascript%e5%85%b8%e5%9e%8b%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%8f%8achrome%e7%9a%84%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fitk6fifznop%2f&title=javascript%e5%85%b8%e5%9e%8b%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%8f%8achrome%e7%9a%84%e6%8e%92%e6%9f%a5%e6%96%b9%e6%b3%95"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">javascript典型内存泄漏及chrome的排查方法</h1><div class="meta"><div class="postdate"><time datetime="2019-01-17" itemprop="datePublished">2019-01-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3ejavascript的内存泄漏\x3c\/h1\x3e\n\x3cp\x3e对于JavaScript这门语言的使用者来说，大多数的使用者的内存管理意识都不强。因为JavaScript一直以来都只作为在网页上使用的脚本语言，而网页往往都不会长时间的运行，所以使用者对JavaScript的运行时长和内存控制都比较漠视。但随着Spa（单页应用）、node.js服务端程序和各种js工具的诞生，我们需要重新重视JavaScript的内存管理。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e内存泄漏的定义\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eJavaScript的内存管理\x3c\/h2\x3e\n\x3cp\x3e首先JavaScript是一个有Garbage Collection 的语言，也就是我们不需要手动的回收内存。不同的JavaScript引擎有不同的垃圾回收机制，这里我们主要以V8这个被广泛使用的JavaScript引擎为主。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3eJavaScript内存分配和回收的关键词：GC根、作用域\x3c\/h3\x3e\n\x3cp\x3eGC根：一般指全局且不会被垃圾回收的对象，比如：window、document或者是页面上存在的dom元素。JavaScript的垃圾回收算法会判断某块对象内存是否是GC根可达（存在一条由GC根对象到该对象的引用），如果不是那这块内存将会被标记回收。\x3c\/p\x3e\n\x3cp\x3e作用域：在JavaScript的作用域里，我们能够新建对象来分配内存。比如说调用函数，函数执行的过程中就会创建一块作用域，如果是创建的是作用域内的局部对象，当作用域运行结束后，所有的局部对象（GC根无法触及）都会被标记回收，在JavaScript中能引起作用域分配的有函数调用、with和全局作用域。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e作用域的分类：局部作用域、全局作用域、闭包作用域\x3c\/h3\x3e\n\x3ch4\x3e局部作用域\x3c\/h4\x3e\n\x3cp\x3e函数调用会创建局部作用域，在局部作用域中的新建的对象，如果函数运行结束后，该对象没有作用域外部的引用，那该对象将会标记回收\x3c\/p\x3e\n\x3ch4\x3e全局作用域\x3c\/h4\x3e\n\x3cp\x3e每个JavaScript进程都会有一个全局作用域，全局作用域上的引用的对象都是常驻内存的，直到进程退出内存才会自动释放。\x3cbr\x3e手动释放全局作用域上的引用的对象有两种方式：\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3eglobal.foo = undefined\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e重新赋值改变引用\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3edelete global.foo\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e删除对象属性\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch4\x3e闭包作用域\x3c\/h4\x3e\n\x3cp\x3e在JavaScript语言中有闭包的概念,闭包指的是包含自由变量的代码块、自由变量不是在这个代码块内或者任何全局上下文中定义的，而是在定义代码块的环境中定义（局部变量）。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var closure = (function(){\n    \/\/这里是闭包的作用域\n    var i = 0 \/\/ i就是自由变量\n    return function（）{\n        console.log(i\x2b\x2b)\n    }\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e closure = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里是闭包的作用域\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ i就是自由变量\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e（）\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(i\x2b\x2b)\n    }\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e闭包作用域会保持对自由变量的引用。上面代码的引用链就是:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window -\x3e closure -\x3e i\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e -\x26gt; closure -\x26gt; i\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e闭包作用域还有一个重要的概念，闭包对象是当前作用域中的所有内部函数作用域共享的，并且这个当前作用域的闭包对象中除了包含一条指向上一层作用域闭包对象的引用外，其余的存储的变量引用一定是当前作用域中的所有内部函数作用域中使用到的变量\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e常见的几种内存泄漏的方式及使用chrome dev tools的排查方法\x3c\/h2\x3e\n\x3ch4\x3e用全局变量缓存数据\x3c\/h4\x3e\n\x3cp\x3e将全局变量作为缓存数据的一种方式，将之后要用到的数据都挂载到全局变量上，用完之后也不手动释放内存（因为全局变量引用的对象，垃圾回收机制不会自动回收），全局变量逐渐就积累了一些不用的对象，导致内存泄漏\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22   var x = [];\n    function createSomeNodes() {\n        var div;\n        var i = 10000;\n        var frag = document.createDocumentFragment();\n        for (; i \x3e 0; i--) {\n            div = document.createElement(\x26quot;div\x26quot;);\n            div.appendChild(document.createTextNode(i \x2b \x26quot; - \x26quot; \x2b new Date().toTimeString()));\n            frag.appendChild(div);\n        }\n        document.getElementById(\x26quot;nodes\x26quot;).appendChild(frag);\n    }\n    function grow() {\n        x.push(new Array(1000000).join(\x27x\x27));\n        createSomeNodes();\n        setTimeout(grow, 1000);\n    }\n    grow()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e   \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e x = [];\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateSomeNodes\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e div;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e10000\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e frag = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createDocumentFragment();\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (; i \x26gt; \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i--) {\n            div = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createElement(\x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e);\n            div.appendChild(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createTextNode(i \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 - \x22\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e().toTimeString()));\n            frag.appendChild(div);\n        }\n        \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22nodes\x22\x3c\/span\x3e).appendChild(frag);\n    }\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3egrow\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        x.push(\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1000000\x3c\/span\x3e).join(\x3cspan class=\x22hljs-string\x22\x3e\x27x\x27\x3c\/span\x3e));\n        createSomeNodes();\n        setTimeout(grow, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n    }\n    grow()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e上面的代码贴一张 timeline的截图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVLvWb?w=1374\x26amp;h=433\x22 src=\x22https:\/\/static.alili.tech\/img\/bVLvWb?w=1374\x26amp;h=433\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3cbr\x3e主要看memory区域，通过分析代码我们可以知道页面上的dom节点是不断增加的，所以memory里绿色的线（代表dom nodes）也是不断升高的；而代表js heap的蓝色的线是有升有降，当整体趋势是逐渐升高，这是因为js 有内存回收机制，每当内存回收的时候蓝色的线就会下降，但是存在部分内存一直得不到释放，所以蓝色的线逐渐升高\x3c\/p\x3e\n\x3ch4\x3ejs错误引用DOM元素\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    var nodes = \x27\x27;\n    (function () {\n        var item = {\n            name:new Array(1000000).join(\x27x\x27)\n        }\n        nodes = document.getElementById(\x26quot;nodes\x26quot;)\n        nodes.item = item\n        nodes.parentElement.removeChild(nodes)\n    })()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e nodes = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e;\n    (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e item = {\n            \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e:\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1000000\x3c\/span\x3e).join(\x3cspan class=\x22hljs-string\x22\x3e\x27x\x27\x3c\/span\x3e)\n        }\n        nodes = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x22nodes\x22\x3c\/span\x3e)\n        nodes.item = item\n        nodes.parentElement.removeChild(nodes)\n    })()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的dom元素虽然已经从页面上移除了，但是js中仍然保存这对该dom元素的引用。\x3cbr\x3e因为这段代码是只执行一次的，所以用timeline视图会很难分析出来是否存在内存泄漏，所以我们可以用 chrome dev tool 的 profile tab里的heap snapshot 工具来分析。\x3cbr\x3e上面的代码贴一张 heap snapshot 的summary模式的截图\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVLvVx?w=1431\x26amp;h=266\x22 src=\x22https:\/\/static.alili.tech\/img\/bVLvVx?w=1431\x26amp;h=266\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e通过constructor的filter功能，我们把上面代码中创建的长字符串找出来，可以看到代码运行结束后，内存中的长字符串依然没有被垃圾回收掉。\x3cbr\x3e顺带提一下的是右边红框里的shadow size和 retainer size的含义\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eshadow size 指的是对象本地的大小\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eretainer size 指的是对象所引用内存的大小，回收该对象是会将他引用的内存也一并回收，所以retainer size 指代的是回收内存后会释放出来的内存大小\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e上面我们可以看到 长字符串本身的shadow size和retainer size是一样大的，这是引用长字符串没有引用其他的对象，如果有引用其他对象，那shadow size 和retainer size将不一致。\x3c\/p\x3e\n\x3ch4\x3e闭包循环引用\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22(function(){\n    var theThing = null\n    var replaceThing = function () {\n        var originalThing = theThing\n        var unused = function () {\n            if (originalThing)\n                console.log(\x26quot;hi\x26quot;)\n        }\n        theThing = {\n            longStr: new Array(1000000).join(\x27*\x27),\n            someMethod: function someMethod() {\n                console.log(\x27someMessage\x27)\n            }\n        };\n    };\n    setInterval(replaceThing,100)\n})()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e theThing = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e replaceThing = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e originalThing = theThing\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e unused = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (originalThing)\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22hi\x22\x3c\/span\x3e)\n        }\n        theThing = {\n            \x3cspan class=\x22hljs-attr\x22\x3elongStr\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1000000\x3c\/span\x3e).join(\x3cspan class=\x22hljs-string\x22\x3e\x27*\x27\x3c\/span\x3e),\n            \x3cspan class=\x22hljs-attr\x22\x3esomeMethod\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3esomeMethod\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27someMessage\x27\x3c\/span\x3e)\n            }\n        };\n    };\n    setInterval(replaceThing,\x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e)\n})()\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先我们明确一下，unused是一个闭包，因为它引用了自由变量 originalThing，虽然它被没有使用，但v8引擎并不会把它优化掉，因为 JavaScript里存在eval函数，所以v8引擎并不会随便优化掉暂时没有使用的函数。\x3c\/p\x3e\n\x3cp\x3etheThing 引用了someMethod，someMethod这个函数作用域隐式的和unused这个闭包共享一个闭包上下文。所以someMethod也引用了originalThing这个自由变量。\x3c\/p\x3e\n\x3cp\x3e这里面的引用链是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22GCHandler -\x3e replaceThing -\x3e theThing -\x3e someMethod -\x3e originalThing -\x3e someMethod(old) -\x3e originalThing(older)-\x3e someMethod(older)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eGCHandler -\x26gt; replaceThing -\x26gt; theThing -\x26gt; someMethod -\x26gt; originalThing -\x26gt; someMethod(old) -\x26gt; originalThing(older)-\x26gt; someMethod(older)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e随着setInterval的不断执行，这条引用链是不会断的，所以内存会不断泄漏，直致程序崩溃。\x3cbr\x3e因为是闭包作用域引起的内存泄漏，这时候最好的选择是使用 chrome的heap snapshot的container视图，我们通过container视图能清楚的看到这条不断泄漏内存的引用链\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVLvU6?w=1435\x26amp;h=624\x22 src=\x22https:\/\/static.alili.tech\/img\/bVLvU6?w=1435\x26amp;h=624\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e由于作者水平有限，文中如有错误还望指出，谢谢！\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e参考文档：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22http:\/\/baike.baidu.com\/link?url=e_bPFscy3DwYYP1P_nvZMmFY5nBLDDqhQuw1B0FRmIiQcBCcQNOv5nXxbCWxWwbzgtgLJqPfTQtZblrff2v-34aU6ZZjkVkmIS4pS1eC3weL7yvGM_h3aiyajHo0PCtg\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e百科内存泄漏介绍\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/developers.google.com\/web\/tools\/chrome-devtools\/memory-problems\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3echrome devtolls\x3c\/a\x3e\x3cbr\x3e深入浅出nodejs\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/ElemeFE\/node-interview\/issues\/7\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3enode-interview\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>javascript典型内存泄漏及chrome的排查方法</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008901861">https://segmentfault.com/a/1190000008901861</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/itk6fifznop/" target="_blank">https://alili.tech/archive/itk6fifznop/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>