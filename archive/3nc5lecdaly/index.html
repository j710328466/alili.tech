<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="[译] TC39，ECMAScript 和 JavaScript 的未来（Part 1）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>[译] TC39，ECMAScript 和 JavaScript 的未来（Part 1） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/3nc5lecdaly/",
				"appid": "1613049289050283", 
				"title": "[译] TC39，ECMAScript 和 JavaScript 的未来（Part 1） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-10T02:30:08"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/a8gzczukyqo/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hl1fwwzz34a/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f&text=%5b%e8%af%91%5d%20TC39%ef%bc%8cECMAScript%20%e5%92%8c%20JavaScript%20%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%88Part%201%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f&text=%5b%e8%af%91%5d%20TC39%ef%bc%8cECMAScript%20%e5%92%8c%20JavaScript%20%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%88Part%201%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f&title=%5b%e8%af%91%5d%20TC39%ef%bc%8cECMAScript%20%e5%92%8c%20JavaScript%20%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%88Part%201%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f&is_video=false&description=%5b%e8%af%91%5d%20TC39%ef%bc%8cECMAScript%20%e5%92%8c%20JavaScript%20%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%88Part%201%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%5b%e8%af%91%5d%20TC39%ef%bc%8cECMAScript%20%e5%92%8c%20JavaScript%20%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%88Part%201%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f&title=%5b%e8%af%91%5d%20TC39%ef%bc%8cECMAScript%20%e5%92%8c%20JavaScript%20%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%88Part%201%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f&title=%5b%e8%af%91%5d%20TC39%ef%bc%8cECMAScript%20%e5%92%8c%20JavaScript%20%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%88Part%201%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f&title=%5b%e8%af%91%5d%20TC39%ef%bc%8cECMAScript%20%e5%92%8c%20JavaScript%20%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%88Part%201%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3nc5lecdaly%2f&title=%5b%e8%af%91%5d%20TC39%ef%bc%8cECMAScript%20%e5%92%8c%20JavaScript%20%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%88Part%201%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">[译] TC39，ECMAScript 和 JavaScript 的未来（Part 1）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-10" itemprop="datePublished">2019-01-10</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e原文：\x3ca href=\x22https:\/\/ponyfoo.com\/articles\/tc39-ecmascript-proposals-future-of-javascript#stage-0\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eTC39, ECMAScript, and the Future of JavaScript\x3c\/a\x3e\x3cbr\x3e作者：\x3ca href=\x22https:\/\/ponyfoo.com\/contributors\/ponyfoo\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNicolás Bevacqua\x3c\/a\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e译者序\x3c\/h2\x3e\n\x3cp\x3e很荣幸能够和 Nicolás Bevacqua 同台分享。Nicolás Bevacqua 分享了《the Future of Writing JavaScript 》，我在其后分享了《面向前端开发者的V8性能优化》。如果想了解更多 V8 知识可以关注我的专栏：\x3ca href=\x22https:\/\/zhuanlan.zhihu.com\/v8core\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eV8 引擎\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e由于 Nicolás Bevacqua 是英文分享，现场由很多听众都没有太明白，会后我联系了 Nicolás Bevacqua 争得大神同意后将其文章翻译为中文。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVP9I5?w=1080\x26amp;h=1920\x22 src=\x22https:\/\/static.alili.tech\/img\/bVP9I5?w=1080\x26amp;h=1920\x22 alt=\x22Nicolás Bevacqua justjavac\x22 title=\x22Nicolás Bevacqua justjavac\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e大神微信玩的很溜，很快就学会了抢红包。\x3c\/p\x3e\n\x3cp\x3e再次感谢 Nicolás Bevacqua 的精彩分享。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e译文：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e上周，我在中国深圳的\x3ca href=\x22http:\/\/tfc.alloyteam.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e腾讯前端大会\x3c\/a\x3e上发表了与本文同名的\x3ca href=\x22https:\/\/ponyfoo.com\/presentations\/tc39-ecmascript-and-the-future-of-javascript\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e演讲\x3c\/a\x3e。在这篇文章中，我根据 PonyFoo 网站的格式重新编辑了一遍。我希望你喜欢它！\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3eTC39 是什么？\x3c\/h2\x3e\n\x3cp\x3eTC39 指的是技术委员会（Technical Committee）第 39 号。它是 ECMA 的一部分，ECMA 是 “ECMAScript” 规范下的 JavaScript 语言标准化的机构。\x3c\/p\x3e\n\x3cp\x3eECMAScript 规范定义了 JavaScript 如何一步一步的进化、发展。其中规定了：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e字符串 \x3ccode\x3e\x27A\x27\x3c\/code\x3e 为什么是 \x3ccode\x3eNaN\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e字符串 \x3ccode\x3e\x27A\x27\x3c\/code\x3e 为什么\x3cstrong\x3e不等于\x3c\/strong\x3e \x3ccode\x3eNaN\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eNaN\x3c\/code\x3e 为什么是 \x3ccode\x3eNaN\x3c\/code\x3e，但却\x3cstrong\x3e不等于\x3c\/strong\x3e \x3ccode\x3eNaN\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e并介绍了为什么 \x3ccode\x3eNumber.isNaN\x3c\/code\x3e 是一个很好的 idea ...\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22isNaN(NaN) \/\/ true\nisNaN(\x27A\x27) \/\/ true\n\x27A\x27 == NaN \/\/ false\n\x27A\x27 === NaN \/\/ false\nNaN === NaN \/\/ false\n\n\/\/ … 解决方案!\n\nNumber.isNaN(\x27A\x27) \/\/ false\nNumber.isNaN(NaN) \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eisNaN\x3c\/span\x3e(\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eisNaN\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e == \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e === \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e === \x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ … 解决方案!\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e.isNaN(\x3cspan class=\x22hljs-string\x22\x3e\x27A\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eNumber\x3c\/span\x3e.isNaN(\x3cspan class=\x22hljs-literal\x22\x3eNaN\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e它还解释了正零与负零什么情况下相等，什么情况下不相等。。。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x2b0 == -0 \/\/ true\n\x2b0 === -0 \/\/ true\n1\/\x2b0 === 1 \/ -0 \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x2b\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e == \x3cspan class=\x22hljs-number\x22\x3e-0\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x2b\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e-0\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\/\x2b\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e === \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e \/ \x3cspan class=\x22hljs-number\x22\x3e-0\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而且 js 中还有很多奇技淫巧，例如只使用感叹号、小括号、方括号和加号来编码任何有效的 JavaScript 表达式。可以在 \x3ca href=\x22http:\/\/jsfuck.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJSFuck\x3c\/a\x3e 网站了解更多关于如何只使用 \x3ccode\x3e\x2b!()[]\x3c\/code\x3e 编写 JavaScript 代码的技巧。\x3c\/p\x3e\n\x3cp\x3e不论如何，TC39 所做的不懈努力是\x3cstrong\x3e难能可贵\x3c\/strong\x3e的。\x3c\/p\x3e\n\x3cp\x3eTC39 遵循的原则是：分阶段加入不同的语言特性。一旦提案成熟，TC39 会根据提案中的变动来更新规范。直到最近，TC39 依然依赖基于 Microsoft Word 的比较传统的工作流程。但 ES3 出来之后，他们花了\x3cstrong\x3e十年时间，几乎没有任何改变\x3c\/strong\x3e，使其达到规范。之后，ES6 又花了四年才能实现。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e显然，他们的流程必须改善。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e自 ES6 出来之后，他们精简了提案的修订过程，以满足现代化开发的需求。新流程使用 HTML 的超集来格式化提案。他们使用 \x3ca href=\x22https:\/\/github.com\/tc39\/proposals\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eGitHub pull requests\x3c\/a\x3e，这有助于增加社区的参与，并且提出的提案数量也增加了。这个规范现在是一个 \x3ca href=\x22https:\/\/tc39.github.io\/ecma262\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eliving standard\x3c\/a\x3e，这意味着提案会更快，而且我们也不用等待新版本的规范出来。\x3c\/p\x3e\n\x3cp\x3e新流程涉及四个不同的 Stage。一个提案越成熟，越有可能最终将其纳入规范。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eStage 0\x3c\/h2\x3e\n\x3cp\x3e任何尚未提交作为正式提案的讨论、想法变更或者补充都被认为是第 0 阶段的“稻草人”提案。只有 TC39 的成员可以创建这些提案，而且今天就有若干活跃的“稻草人”提案。\x3c\/p\x3e\n\x3cp\x3e目前在 Stage 0 的提案包括异步操作的 \x3ca href=\x22https:\/\/github.com\/tc39\/proposal-cancellation\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecancellation tokens \x3c\/a\x3e， \x3ca href=\x22https:\/\/github.com\/domenic\/zones\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eZones\x3c\/a\x3e 作为 Angular 团队的一员，提供了很多建议。Stage 0 包括了很多一直没有进入 Stage 1 的提案。\x3c\/p\x3e\n\x3cp\x3e在这篇文章的后面，我们将仔细分析一部分提案。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eStage 1\x3c\/h2\x3e\n\x3cp\x3e在 Stage 1，提案已经被正式化，并期望解决此问题，还需要观察与其他提案的相互影响。在这个阶段的提案确定了一个分散的问题，并为这个问题提供了具体的解决方案。\x3c\/p\x3e\n\x3cp\x3eStage 1 提议通常包括高阶 API 描述（high level AP），使用示例以及内部语义和算法的讨论。这些建议在通过这一过程时可能会发生重大变化。\x3c\/p\x3e\n\x3cp\x3eStage 1 目前提案的例子包括：\x3ca href=\x22https:\/\/ponyfoo.com\/articles\/observables-coming-to-ecmascript\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eObservable\x3c\/a\x3e、\x3ca href=\x22https:\/\/ponyfoo.com\/articles\/proposal-statements-as-expressions-using-do\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edo\x3c\/a\x3e 表达式、生成器箭头函数、\x3ca href=\x22https:\/\/github.com\/tc39\/proposal-promise-try\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise.try\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3eStage 2\x3c\/h2\x3e\n\x3cp\x3eStage 2 的提案应提供规范初稿。\x3c\/p\x3e\n\x3cp\x3e此时，语言的实现者开始观察 runtime 的具体实现是否合理。该实现可以使用 polyfill 的方式，以便使代码可在 runtime 中的行为负责规范的定义; javascript 引擎的实现为提案提供了原生支持; 或者可以 Babel 这样的编译时编译器来支持。\x3c\/p\x3e\n\x3cp\x3e目前 Stage 2 阶段的提案有 \x3ca href=\x22https:\/\/github.com\/tc39\/proposal-class-fields\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3epublic class fields\x3c\/a\x3e、\x3ca href=\x22https:\/\/medium.com\/the-thinkmill\/javascripts-new-private-class-fields-93106e37647a\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eprivate class fields\x3c\/a\x3e、\x3ca href=\x22https:\/\/ponyfoo.com\/articles\/javascript-decorators-proposal\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3edecorators\x3c\/a\x3e、\x3ca href=\x22https:\/\/github.com\/tc39\/proposal-promise-finally\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePromise#finally\x3c\/a\x3e、等等。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eStage 3\x3c\/h2\x3e\n\x3cp\x3eStage 3 提案是建议的候选提案。在这个高级阶段，规范的编辑人员和评审人员必须在最终规范上签字。Stage 3 的提案不会有太大的改变，在对外发布之前只是修正一些问题。\x3c\/p\x3e\n\x3cp\x3e语言的实现者也应该对此提案感兴趣 - 如果只是提案却没有具体实现去支持这个提案，那么这个提案早就胎死腹中了。事实上，提案至少具有一个浏览器实现、友好的 polyfill或者由像 Babel 这样的构建时编译器支持。\x3c\/p\x3e\n\x3cp\x3eStage 3 由很多令人兴奋的功能，如\x3ca href=\x22https:\/\/github.com\/tc39\/proposal-object-rest-spread\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e对象的解析与剩余\x3c\/a\x3e，\x3ca href=\x22https:\/\/ponyfoo.com\/articles\/javascript-asynchronous-iteration-proposal\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e异步迭代器\x3c\/a\x3e，\x3ca href=\x22https:\/\/github.com\/tc39\/proposal-dynamic-import\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eimport()\x3c\/a\x3e 方法和\x3ca href=\x22https:\/\/ponyfoo.com\/articles\/regular-expressions-post-es6\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e更好的 Unicode 正则表达式支持\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3eStage 4\x3c\/h2\x3e\n\x3cp\x3e最后，当规范的实现至少通过两个验收测试时，提案进入 Stage 4。\x3c\/p\x3e\n\x3cp\x3e进入 Stage 4 的提案将包含在 ECMAScript 的下一个修订版中。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/ponyfoo.com\/articles\/understanding-javascript-async-await\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e异步函数\x3c\/a\x3e，\x3ca href=\x22https:\/\/github.com\/tc39\/Array.prototype.includes\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eArray#includes\x3c\/a\x3e 和 \x3ca href=\x22https:\/\/github.com\/rwaldron\/exponentiation-operator\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e幂运算符\x3c\/a\x3e 是 Stage 4 的一些特性。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e保持最新 Staying Up To Date\x3c\/h2\x3e\n\x3cp\x3e我(原文作者)创建了一个网站，用来展示当前提案的列表。它描述了他们在什么阶段，并链接到每个提案，以便您可以更多地了解它们。\x3c\/p\x3e\n\x3cp\x3e网址为 \x3ca href=\x22https:\/\/prop-tc39.now.sh\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eproptt39.now.sh\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e目前，每年都有新的正式规范版本，但精简的流程也意味着正式版本变得越来越不相关。现在重点放在提案阶段，我们可以预测，在 ES6 之后，对该标准的具体修订的引用将变得不常见。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e提案 Proposals\x3c\/h2\x3e\n\x3cp\x3e我们来看一些目前正在开发的最有趣的提案。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3eArray#includes （Stage 4）\x3c\/h2\x3e\n\x3cp\x3e在介绍 \x3ccode\x3eArray#includes\x3c\/code\x3e 之前，我们不得不依赖 \x3ccode\x3eArray#indexOf\x3c\/code\x3e 函数，并检查索引是否超出范围，以确定元素是否属于数组。\x3c\/p\x3e\n\x3cp\x3e随着 \x3ccode\x3eArray#includes\x3c\/code\x3e 进入 Stage 4，我们可以使用 \x3ccode\x3eArray#includes\x3c\/code\x3e 来代替。它补充了 ES6 的 \x3ccode\x3eArray#find\x3c\/code\x3e 和 \x3ccode\x3eArray#findIndex\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[1, 2].indexOf(2) !== -1 \/\/ true\n[1, 2].indexOf(3) !== -1 \/\/ false\n[1, 2].includes(2) \/\/ true\n[1, 2].includes(3) \/\/ false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e].indexOf(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e].indexOf(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e) !== \x3cspan class=\x22hljs-number\x22\x3e-1\x3c\/span\x3e \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e].includes(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e].includes(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e异步函数（Stage 4）\x3c\/h2\x3e\n\x3cp\x3e当我们使用 Promise 时，我们经常考虑执行线程。我们有一个异步任务 \x3ccode\x3efetch\x3c\/code\x3e，其他任务依赖于 \x3ccode\x3efetch\x3c\/code\x3e 的响应，但在收到该数据之前程序时阻塞的。\x3c\/p\x3e\n\x3cp\x3e在下面的例子中，我们从 API 中获取产品列表，该列表返回一个 \x3ccode\x3ePromise\x3c\/code\x3e。当 fetch 相应之后，Promise 被 resolve。然后，我们将响应流作为 JSON 读取，并使用响应中的数据更新视图。如果在此过程中发生任何错误，我们可以将其记录到控制台，以了解发生了什么。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fetch(\x27\/api\/products\x27)\n  .then(response =\x3e response.json())\n  .then(data =\x3e {\n    updateView(data)\n  })\n  .catch(err =\x3e {\n    console.log(\x27Update failed\x27, err)\n  })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3efetch(\x3cspan class=\x22hljs-string\x22\x3e\x27\/api\/products\x27\x3c\/span\x3e)\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresponse\x3c\/span\x3e =\x26gt;\x3c\/span\x3e response.json())\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edata\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    updateView(data)\n  })\n  .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eerr\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Update failed\x27\x3c\/span\x3e, err)\n  })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e异步函数提供了语法糖，可以用来改进我们基于 \x3ccode\x3ePromise\x3c\/code\x3e 的代码。我们开始逐行改变以上基于 Promise 的代码。我们可以使用 \x3ccode\x3eawait\x3c\/code\x3e 关键字。当我们 \x3ccode\x3eawait\x3c\/code\x3e 一个 Promise 时，我们得到 Promise 的 fulled 状态的值。\x3c\/p\x3e\n\x3cp\x3ePromise 代码的意思是：“我想执行这个操作，然后(then)在其他操作中使用它的结果”。\x3c\/p\x3e\n\x3cp\x3e同时，\x3ccode\x3eawait\x3c\/code\x3e 有效地反转了这个意思，使得它更像：“我想要取得这个操作的结果”。我喜欢，因为它听起来更简单。\x3c\/p\x3e\n\x3cp\x3e在我们的示例中，响应对象是我们之后获取的，所以我们将等待(\x3ccode\x3eawait\x3c\/code\x3e)获取(\x3ccode\x3efetch\x3c\/code\x3e)操作的结果，并赋值给 \x3ccode\x3eresponse\x3c\/code\x3e 变量，而不是使用 \x3ccode\x3epromise\x3c\/code\x3e 的 \x3ccode\x3ethen\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e原文：we’ll flip things over and assigned the result of \x3ccode\x3eawait\x3c\/code\x3e \x3ccode\x3efetch\x3c\/code\x3e to the \x3ccode\x3eresponse\x3c\/code\x3e variable\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x2b const response = await fetch(\x27\/api\/products\x27)\n- fetch(\x27\/api\/products\x27)\n    .then(response =\x3e response.json())\n    .then(data =\x3e {\n      updateView(data)\n    })\n    .catch(err =\x3e {\n      console.log(\x27Update failed\x27, err)\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22diff hljs\x22\x3e\x3ccode class=\x22diff\x22\x3e\x3cspan class=\x22hljs-addition\x22\x3e\x2b const response = await fetch(\x27\/api\/products\x27)\x3c\/span\x3e\n\x3cspan class=\x22hljs-deletion\x22\x3e- fetch(\x27\/api\/products\x27)\x3c\/span\x3e\n    .then(response =\x26gt; response.json())\n    .then(data =\x26gt; {\n      updateView(data)\n    })\n    .catch(err =\x26gt; {\n      console.log(\x27Update failed\x27, err)\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们给 \x3ccode\x3eresponse.json()\x3c\/code\x3e 同样的待遇。我们 \x3ccode\x3eawait\x3c\/code\x3e 上一次的操作并将其赋值给 \x3ccode\x3edata\x3c\/code\x3e 变量。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  const response = await fetch(\x27\/api\/products\x27)\n\x2b const data = await response.json()\n-   .then(response =\x3e response.json())\n    .then(data =\x3e {\n      updateView(data)\n    })\n    .catch(err =\x3e {\n      console.log(\x27Update failed\x27, err)\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22diff hljs\x22\x3e\x3ccode class=\x22diff\x22\x3e  const response = await fetch(\x27\/api\/products\x27)\n\x3cspan class=\x22hljs-addition\x22\x3e\x2b const data = await response.json()\x3c\/span\x3e\n\x3cspan class=\x22hljs-deletion\x22\x3e-   .then(response =\x26gt; response.json())\x3c\/span\x3e\n    .then(data =\x26gt; {\n      updateView(data)\n    })\n    .catch(err =\x26gt; {\n      console.log(\x27Update failed\x27, err)\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e既然 \x3ccode\x3ethen\x3c\/code\x3e 链已经消失了，我们就可以直接调用 \x3ccode\x3eupdateView\x3c\/code\x3e 语句了，因为我们已经到了之前代码中的 Promise then 链的尽头，我们不需要等待任何其他的 Promise。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  const response = await fetch(\x27\/api\/products\x27)\n  const data = await response.json()\n\x2b updateView(data)\n-   .then(data =\x3e {\n-     updateView(data)\n-   })\n    .catch(err =\x3e {\n      console.log(\x27Update failed\x27, err)\n    })\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22diff hljs\x22\x3e\x3ccode class=\x22diff\x22\x3e  const response = await fetch(\x27\/api\/products\x27)\n  const data = await response.json()\n\x3cspan class=\x22hljs-addition\x22\x3e\x2b updateView(data)\x3c\/span\x3e\n\x3cspan class=\x22hljs-deletion\x22\x3e-   .then(data =\x26gt; {\x3c\/span\x3e\n\x3cspan class=\x22hljs-deletion\x22\x3e-     updateView(data)\x3c\/span\x3e\n\x3cspan class=\x22hljs-deletion\x22\x3e-   })\x3c\/span\x3e\n    .catch(err =\x26gt; {\n      console.log(\x27Update failed\x27, err)\n    })\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在我们可以使用 \x3ccode\x3etry\/catch\x3c\/code\x3e 块，而不是 \x3ccode\x3e.catch\x3c\/code\x3e，这使得我们的代码更加语义化。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x2b try {\n    const response = await fetch(\x27\/api\/products\x27)\n    const data = await response.json()\n    updateView(data)\n\x2b } catch(err) {\n- .catch(err =\x3e {\n    console.log(\x27Update failed\x27, err)\n\x2b }\n- )}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22diff hljs\x22\x3e\x3ccode class=\x22diff\x22\x3e\x3cspan class=\x22hljs-addition\x22\x3e\x2b try {\x3c\/span\x3e\n    const response = await fetch(\x27\/api\/products\x27)\n    const data = await response.json()\n    updateView(data)\n\x3cspan class=\x22hljs-addition\x22\x3e\x2b } catch(err) {\x3c\/span\x3e\n\x3cspan class=\x22hljs-deletion\x22\x3e- .catch(err =\x26gt; {\x3c\/span\x3e\n    console.log(\x27Update failed\x27, err)\n\x3cspan class=\x22hljs-addition\x22\x3e\x2b }\x3c\/span\x3e\n\x3cspan class=\x22hljs-deletion\x22\x3e- )}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e一个限制是 \x3ccode\x3eawait\x3c\/code\x3e 只能在异步函数内使用。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x2b async function run() {\n    try {\n      const response = await fetch(\x27\/api\/products\x27)\n      const data = await response.json()\n      updateView(data)\n    } catch(err) {\n      console.log(\x27Update failed\x27, err)\n    }\n\x2b }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22diff hljs\x22\x3e\x3ccode class=\x22diff\x22\x3e\x3cspan class=\x22hljs-addition\x22\x3e\x2b async function run() {\x3c\/span\x3e\n    try {\n      const response = await fetch(\x27\/api\/products\x27)\n      const data = await response.json()\n      updateView(data)\n    } catch(err) {\n      console.log(\x27Update failed\x27, err)\n    }\n\x3cspan class=\x22hljs-addition\x22\x3e\x2b }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是，我们可以将异步函数转换为自调用函数表达式。如果我们将顶级代码包在这样的表达式中，我们可以在代码中的任何地方使用 \x3ccode\x3eawait\x3c\/code\x3e 表达式。\x3c\/p\x3e\n\x3cp\x3e一些社区希望原生支持顶级块作用于的 \x3ccode\x3eawait\x3c\/code\x3e，而另外一些人则认为这会对用户造成负面影响，因为一些库可能会阻塞异步加载，从而大大减缓了我们应用程序的加载时间。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x2b (async () =\x3e {\n- async function run() {\n    try {\n      const response = await fetch(\x27\/api\/products\x27)\n      const data = await response.json()\n      updateView(data)\n    } catch(err) {\n      console.log(\x27Update failed\x27, err)\n    }\n\x2b })()\n- }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22diff hljs\x22\x3e\x3ccode class=\x22diff\x22\x3e\x3cspan class=\x22hljs-addition\x22\x3e\x2b (async () =\x26gt; {\x3c\/span\x3e\n\x3cspan class=\x22hljs-deletion\x22\x3e- async function run() {\x3c\/span\x3e\n    try {\n      const response = await fetch(\x27\/api\/products\x27)\n      const data = await response.json()\n      updateView(data)\n    } catch(err) {\n      console.log(\x27Update failed\x27, err)\n    }\n\x3cspan class=\x22hljs-addition\x22\x3e\x2b })()\x3c\/span\x3e\n\x3cspan class=\x22hljs-deletion\x22\x3e- }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就个人而言，我认为在 JavaScript 性能中已经有足够的空间来应对这种愚蠢的事情，来优化初始化的库使用 \x3ccode\x3eawait\x3c\/code\x3e 的行为。\x3c\/p\x3e\n\x3cp\x3e请注意，您也可以在 non-promise 的值前面使用 \x3ccode\x3eawait\x3c\/code\x3e，甚至编写代码 \x3ccode\x3eawait (2 \x2b 3)\x3c\/code\x3e。在这种情况下，\x3ccode\x3e(2 \x2b 3)\x3c\/code\x3e 表达的结果会被包在 Promise 中，作为 Promise 的最终值。\x3ccode\x3e5\x3c\/code\x3e 成为这个 \x3ccode\x3eawait\x3c\/code\x3e 表达式的结果。\x3c\/p\x3e\n\x3cp\x3e请注意，\x3ccode\x3eawait\x3c\/code\x3e 加上任何 JavaScript 表达式也是一个表达式。这意味着我们不限制 \x3ccode\x3eawait\x3c\/code\x3e 语句的赋值操作，而且我们也可以把 \x3ccode\x3eawait\x3c\/code\x3e 函数调用作为模板文字插值的一部分。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22`Price: ${ await getPrice() }`\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e`Price: \x3cspan class=\x22hljs-subst\x22\x3e${ \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getPrice() }\x3c\/span\x3e`\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e或作为另一个函数调用的一部分...\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22renderView(await getPrice())\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3erenderView(\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getPrice())\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e甚至作为数学表达式的一部分。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x222 * (await getPrice())\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * (\x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e getPrice())\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后，不管它们的内容如何，​​异步函数\x3cstrong\x3e总是返回一个 Promise\x3c\/strong\x3e。这意味着我们可以添加 \x3ccode\x3e.then\x3c\/code\x3e 或 \x3ccode\x3e.catch\x3c\/code\x3e 等异步功能，也可以使用 \x3ccode\x3eawait\x3c\/code\x3e 获取最终的结果。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const sleep = delay =\x3e new Promise(resolve =\x3e\n  setTimeout(resolve, delay)\n)\n\nconst slowLog = async (...terms) =\x3e {\n  await sleep(2000)\n  console.log(...terms)\n}\n\nslowLog(\x27Well that was underwhelming\x27)\n  .then(() =\x3e console.log(\x27Nailed it!\x27))\n  .catch(reason =\x3e console.error(\x27Failed\x27, reason))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e sleep = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3edelay\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3eresolve\x3c\/span\x3e =\x26gt;\x3c\/span\x3e\n  setTimeout(resolve, delay)\n)\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e slowLog = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e (...terms) =\x26gt; {\n  \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e sleep(\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e)\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(...terms)\n}\n\nslowLog(\x3cspan class=\x22hljs-string\x22\x3e\x27Well that was underwhelming\x27\x3c\/span\x3e)\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27Nailed it!\x27\x3c\/span\x3e))\n  .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ereason\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(\x3cspan class=\x22hljs-string\x22\x3e\x27Failed\x27\x3c\/span\x3e, reason))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e正如您所期望的那样，返回的 Promise 与 \x3ccode\x3easync\x3c\/code\x3e 函数返回的值进行运算，或者被 catch 函数来处理任何未捕获的异常。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e异步迭代器（Stage 3）\x3c\/h2\x3e\n\x3cp\x3e异步迭代器已经进入了 Stage 3。在了解异步迭代器之前，让我们简单介绍一下 ES6 中引入的迭代。迭代可以是任何遵循迭代器协议的对象。\x3c\/p\x3e\n\x3cp\x3e为了使对象可以迭代，我们定义一个 \x3ccode\x3eSymbol.iterator\x3c\/code\x3e 方法。迭代器方法应该返回一个具有 \x3ccode\x3enext\x3c\/code\x3e 方法的对象。这个对象描述了我们的 \x3ccode\x3eiterable\x3c\/code\x3e 的顺序。当对象被迭代时，每当我们需要读取序列中的下一个元素时，将调用 \x3ccode\x3enext\x3c\/code\x3e 方法。\x3ccode\x3evalue\x3c\/code\x3e 用来获取序列中每一个对象的值。当返回的对象被标记为 \x3ccode\x3edone\x3c\/code\x3e，序列结束。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const list = {\n  [Symbol.iterator]() {\n    let i = 0\n    return {\n      next: () =\x3e ({\n        value: i\x2b\x2b,\n        done: i \x3e 5\n      })\n    }\n  }\n}\n[...list]\n\/\/ \x3c- [0, 1, 2, 3, 4]\nArray.from(list)\n\/\/ \x3c- [0, 1, 2, 3, 4]\nfor (const i of list) {\n  \/\/ \x3c- 0, 1, 2, 3, 4\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e list = {\n  [\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.iterator]() {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-attr\x22\x3enext\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n        \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: i\x2b\x2b,\n        \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: i \x26gt; \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n      })\n    }\n  }\n}\n[...list]\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- [0, 1, 2, 3, 4]\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.from(list)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- [0, 1, 2, 3, 4]\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e i \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e list) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 0, 1, 2, 3, 4\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以使用 \x3ccode\x3eArray.from\x3c\/code\x3e 或使用扩展操作符使用 \x3ccode\x3eIterables\x3c\/code\x3e 。它们也可以通过使用 \x3ccode\x3efor..of\x3c\/code\x3e 循环来遍历元素序列。\x3c\/p\x3e\n\x3cp\x3e异步迭代器只有一点点不同。在这个提议下，一个对象通过 \x3ccode\x3eSymbol.asyncIterator\x3c\/code\x3e 来表示它们是异步迭代的。异步迭代器的方法签名与常规迭代器的约定略有不同：该 \x3ccode\x3enext\x3c\/code\x3e 方法需要返回 包装了 \x3ccode\x3e{ value, done }\x3c\/code\x3e 的 \x3ccode\x3ePromise\x3c\/code\x3e，而不是 \x3ccode\x3e{ value, done }\x3c\/code\x3e 直接返回。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const list = {\n  [Symbol.asyncIterator]() {\n    let i = 0\n    return {\n      next: () =\x3e Promise.resolve({\n        value: i\x2b\x2b,\n        done: i \x3e 5\n      })\n    }\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e list = {\n  [\x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e.asyncIterator]() {\n    \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-attr\x22\x3enext\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3ePromise\x3c\/span\x3e.resolve({\n        \x3cspan class=\x22hljs-attr\x22\x3evalue\x3c\/span\x3e: i\x2b\x2b,\n        \x3cspan class=\x22hljs-attr\x22\x3edone\x3c\/span\x3e: i \x26gt; \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n      })\n    }\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种简单的变化非常优雅，因为 Promise 可以很容易地代表序列的最终元素。\x3c\/p\x3e\n\x3cp\x3e异步迭代不能与数组扩展运算符、\x3ccode\x3eArray.from\x3c\/code\x3e、\x3ccode\x3efor..of\x3c\/code\x3e 一起使用，因为这三个都专门用于同步迭代。\x3c\/p\x3e\n\x3cp\x3e这个提案也引入了一个新的 \x3ccode\x3efor await..of\x3c\/code\x3e 结构。它可以用于在异步迭代序列上语义地迭代。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for await (const i of items) {\n  \/\/ \x3c- 0, 1, 2, 3, 4\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e i \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e items) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 0, 1, 2, 3, 4\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e请注意，该 \x3ccode\x3efor await..of\x3c\/code\x3e 结构只能在异步函数中使用。否则我们会得到语法错误。就像任何其他异步函数一样，我们也可以在我们的循环周围或内部使用 \x3ccode\x3etry\/catch\x3c\/code\x3e 块 \x3ccode\x3efor await..of\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function readItems() {\n  for await (const i of items) {\n    \/\/ \x3c- 0, 1, 2, 3, 4\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereadItems\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e i \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e items) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- 0, 1, 2, 3, 4\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e更进一步。还有异步生成器函数。与普通生成器函数有些相似，异步生成器函数不仅支持 \x3ccode\x3easync\x3c\/code\x3e \x3ccode\x3eawait\x3c\/code\x3e 语义，还允许 \x3ccode\x3eawait\x3c\/code\x3e 语句以及 \x3ccode\x3efor await..of\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e（原文第一段：The rabbit hole goes deeper of course. 这是爱丽丝梦游仙境的梗吗？）\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function* getProducts(categoryUrl) {\n  const listReq = await fetch(categoryUrl)\n  const list = await listReq.json()\n  for (const product of list) {\n    const productReq = await product.url\n    const product = await productReq.json()\n    yield product\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e* \x3cspan class=\x22hljs-title\x22\x3egetProducts\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecategoryUrl\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e listReq = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetch(categoryUrl)\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e list = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e listReq.json()\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e product \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e list) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e productReq = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e product.url\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e product = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e productReq.json()\n    \x3cspan class=\x22hljs-keyword\x22\x3eyield\x3c\/span\x3e product\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在异步生成器函数中，我们可以使用 \x3ccode\x3eyield*\x3c\/code\x3e 与其他异步发生器和普通的发生器一起使用。当调用时，异步生成器函数返回异步生成器对象，其方法返回包裹了 \x3ccode\x3e{ value, done }\x3c\/code\x3e 的 Promise，而不是 \x3ccode\x3e{ value, done }\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e最后，异步生成器对象可以被使用在 \x3ccode\x3efor await..of\x3c\/code\x3e，就像异步迭代一样。这是因为异步生成器对象是异步迭代，就像普通生成器对象是普通的迭代。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22async function readProducts() {\n  const g = getProducts(category)\n  for await (const product of g) {\n    \/\/ use product details\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereadProducts\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e g = getProducts(category)\n  \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e product \x3cspan class=\x22hljs-keyword\x22\x3eof\x3c\/span\x3e g) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ use product details\x3c\/span\x3e\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader12\x22\x3e对象解构与剩余（Stage 3）\x3c\/h2\x3e\n\x3cp\x3e从 ES6 开始，我们使用 \x3ccode\x3eObject.assign\x3c\/code\x3e 将属性从一个或多个源对象复制到一个目标对象上。在下一个例子中，我们将一些属性复制到一个空的对象上。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.assign(\n {},\n { a: \x27a\x27 },\n { b: \x27b\x27 },\n { a: \x27c\x27 }\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.assign(\n {},\n { \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e },\n { \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e },\n { \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e }\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e对象解构（spread）提议允许我们使用纯语法编写等效的代码。我们从一个空对象开始，\x3ccode\x3eObject.assign\x3c\/code\x3e 隐含在语法中。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n ...{ a: \x27a\x27 },\n ...{ b: \x27b\x27 },\n ...{ a: \x27c\x27 }\n}\n\/\/ \x3c- { a: \x27c\x27, b: \x27b\x27 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e{\n ...{ \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e },\n ...{ \x3cspan class=\x22hljs-attr\x22\x3eb\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27b\x27\x3c\/span\x3e },\n ...{ \x3cspan class=\x22hljs-attr\x22\x3ea\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27c\x27\x3c\/span\x3e }\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { a: \x27c\x27, b: \x27b\x27 }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和对象解构相反的还有对象剩余，类似数组的剩余参数。当对对象进行解构时，我们可以使用对象扩展运算符将模式中未明确命名的属性重建为另一个对象。\x3c\/p\x3e\n\x3cp\x3e在以下示例中，id 显式命名，不会包含在剩余对象中。对象剩余（rest）可以从字面上读取为“所有其他属性都转到一个名为 rest 的对象”，当然，变量名称供您选择。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const item = {\n id: \x274fe09c27\x27,\n name: \x27Banana\x27,\n amount: 3\n}\nconst { id, ...rest } = item\n\/\/ \x3c- { name: \x27Banana\x27, amount: 3 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e item = {\n \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x274fe09c27\x27\x3c\/span\x3e,\n \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Banana\x27\x3c\/span\x3e,\n \x3cspan class=\x22hljs-attr\x22\x3eamount\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { id, ...rest } = item\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { name: \x27Banana\x27, amount: 3 }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在函数参数列表中解析对象时，我们也可以使用对象剩余属性。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function print({ id, ...rest }) {\n  console.log(rest)\n}\nprint({ id: \x274fe09c27\x27, name: \x27Banana\x27 })\n\/\/ \x3c- { name: \x27Banana\x27 }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eprint\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e{ id, ...rest }\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(rest)\n}\nprint({ \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x274fe09c27\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Banana\x27\x3c\/span\x3e })\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x26lt;- { name: \x27Banana\x27 }\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e动态 import()（Stage 3）\x3c\/h2\x3e\n\x3cp\x3eES6 引入了原生 JavaScript 模块。与 CommonJS 类似，JavaScript 模块选择了静态语法。这样开发工具有更简单的方式从静态源码中分析和构建依赖树，这使它成为一个很好的默认选项。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import markdown from \x27.\/markdown\x27\n\/\/ …\nexport default compile\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e markdown \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/markdown\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ …\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e compile\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e然而，作为开发人员，我们并不总是知道我们需要提前导入的模块。对于这些情况，例如，当我们依赖本地化来加载具有用户语言的字符串的模块时，Stage 3 的动态 \x3ccode\x3eimport()\x3c\/code\x3e 提案就很有用了。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eimport()\x3c\/code\x3e 运行时动态加载模块。它为模块的命名空间对象返回 Promise，当获取该对象时，系统将解析和执行所请求的模块及其所有依赖项。如果模块加载失败，Promise 将被拒绝。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import(`.\/i18n.${ navigator.language }.js`)\n  .then(module =\x3e console.log(module.messages))\n  .catch(reason =\x3e console.error(reason))\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22js\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e`.\/i18n.\x3cspan class=\x22hljs-subst\x22\x3e${ navigator.language }\x3c\/span\x3e.js`\x3c\/span\x3e)\n  .then(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3emodule\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.messages))\n  .catch(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3ereason\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(reason))\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e未完。。。。\x3c\/strong\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>[译] TC39，ECMAScript 和 JavaScript 的未来（Part 1）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010008098">https://segmentfault.com/a/1190000010008098</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/3nc5lecdaly/" target="_blank">https://alili.tech/archive/3nc5lecdaly/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>