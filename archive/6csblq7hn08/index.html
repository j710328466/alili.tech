<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="MobX"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>MobX | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6csblq7hn08/",
				"appid": "1613049289050283", 
				"title": "MobX | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-27T02:30:59"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/6wn1jn2yrcv/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/jtod8y10sf/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f&text=MobX"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f&text=MobX"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f&title=MobX"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f&is_video=false&description=MobX"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=MobX&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f&title=MobX"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f&title=MobX"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f&title=MobX"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6csblq7hn08%2f&title=MobX"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">MobX</h1><div class="meta"><div class="postdate"><time datetime="2019-01-27" itemprop="datePublished">2019-01-27</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e1. 介绍\x3c\/h2\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3e1.1. 原理\x3c\/h3\x3e\n\x3cp\x3eReact的render是 \x3cem\x3e状态\x3c\/em\x3e 转化为树状结构的渲染组件的方法  \x3cbr\x3e而MobX提供了一种存储，更新 \x3cem\x3e状态\x3c\/em\x3e 的方法  \x3cbr\x3eReact 和 MobX都在优化着软件开发中相同的问题。  \x3cbr\x3eReact 使用的方法是让\x3cstrong\x3e虚拟DOM\x3c\/strong\x3e来减少繁琐而沉重的DOM变化。  \x3cbr\x3e而MobX则通过一个虚拟的\x3cstrong\x3e状态依赖图表\x3c\/strong\x3e来让react组件和应用状态同步化来减少不必要的状态导致组件更新\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e1.2. 安装\x3c\/h3\x3e\n\x3cp\x3eMobX：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm install mobx --save\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sql\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-keyword\x22\x3einstall\x3c\/span\x3e mobx \x3cspan class=\x22hljs-comment\x22\x3e--save\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact bindings：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22npm install mobx-react --save\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs sql\x22\x3e\x3ccode\x3enpm \x3cspan class=\x22hljs-keyword\x22\x3einstall\x3c\/span\x3e mobx-react \x3cspan class=\x22hljs-comment\x22\x3e--save\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1.3. 要点\x3c\/h3\x3e\n\x3cp\x3eMobX看起来很复杂的样子，其实是用它只需要三步\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e定义你的状态，让它们成为观察者(observable)\x3cbr\x3e存储状态(Store state)可以是任何的数据结构，随你定义为：对象，数组，类，循环结构，引用都没所谓。但需要记住一点，就是：随着时间的变化，用MobX 去把它们定义成观察者(observable)\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {observable} from \x27mobx\x27\nlet appState = observable({\n    timer: 0\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observable} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e appState = observable({\n    \x3cspan class=\x22hljs-attr\x22\x3etimer\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e我们不需要让appState去观察什么。你现在就能创建视图(view)，每当appState的相关数据发生变化的时候，就会自动更新。MobX会采用最优的方式去更新你的视图。以下有一个例子来说明如何使用，其中使用了ES6／ES7的语法（当然MobX也是支持ES5），\x3cstrong\x3e\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/decorator\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e代码中@的意义\x3c\/a\x3e\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {observer} from \x27mobx-react\x27;\n@observer\nclass TimerView extends React.Component {\n    render() {\n        return (\x3cbutton onClick={this.onReset.bind(this)}\x3e\n                Seconds passed: {this.props.appState.timer}\n            \x3c\/button\x3e);\n    }\n    onReset () {\n        \/\/appState.resetTimer会在下一节完成\n        this.props.appState.resetTimer();\n    }\n};\nReact.render(\x3cTimerView appState={appState} \/\x3e, document.body);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observer} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27mobx-react\x27\x3c\/span\x3e;\n@observer\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTimerView\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eonClick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{this.onReset.bind(this)}\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                Seconds passed: {this.props.appState.timer}\n            \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebutton\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e);\n    }\n    onReset () {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/appState.resetTimer会在下一节完成\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.appState.resetTimer();\n    }\n};\nReact.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTimerView\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eappState\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{appState}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, document.body);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e修改状态\x3cbr\x3e第三节要说的是修改状态。MobX和其他框架不同，它不会要求你去做什么事情，它只是帮助你去做简单的事情\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22appState.resetTimer = action(function reset() {\n    appState.timer = 0;\n});\nsetInterval(action(function tick() {\n    appState.timer \x2b= 1;\n}), 1000);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eappState.resetTimer = action(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereset\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    appState.timer = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n});\nsetInterval(action(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3etick\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    appState.timer \x2b= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}), \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中action包装用法只能在strict模式下使用，请记得在你的javascript文件头写上：\x27use strict\x27。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e2. API\x3c\/h2\x3e\n\x3cp\x3e从上面的例子可以看到，MobX的API其实不多：observable, computed, reactions, actions\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e2.1. observable(value)\x3c\/h3\x3e\n\x3cp\x3e其中的value可以是JS原定的数据结构，引用，对象，数组，ES6的\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/set-map\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3emap\x3c\/a\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e如果value是一个map的话，则需要使用一个调节器（modifier）\x3cstrong\x3easMap\x3c\/strong\x3e来使用。这时候会返回一个\x3cstrong\x3eObservable Map\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果是一个数组，返回\x3cstrong\x3eObservable Array\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果是一个没有属性的对象，则返回一个\x3cstrong\x3eObservable Object\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果是一个有属性的对象，JS原有的数据结构，函数等，返回一个\x3cstrong\x3e Boxed Observable\x3c\/strong\x3e。MobX不会自动让一个有属性的对象成为观察者。这是这个有属性的对象的构造函数应该做的事情，你可以使用extendObservable在它的构造函数里面，或者在它的类使用@observable去定义。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e以下是一些例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const map = observable(asMap({ key: \x26quot;value\x26quot;}));\nmap.set(\x26quot;key\x26quot;, \x26quot;new value\x26quot;);\n\nconst list = observable([1, 2, 4]);\nlist[2] = 3;\n\nconst person = observable({\n    firstName: \x26quot;Clive Staples\x26quot;,\n    lastName: \x26quot;Lewis\x26quot;\n});\nperson.firstName = \x26quot;C.S.\x26quot;;\n\nconst temperature = observable(20);\ntemperature.set(25);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e map = observable(asMap({ \x3cspan class=\x22hljs-attr\x22\x3ekey\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22value\x22\x3c\/span\x3e}));\nmap.set(\x3cspan class=\x22hljs-string\x22\x3e\x22key\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x22new value\x22\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e list = observable([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e]);\nlist[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e] = \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e person = observable({\n    \x3cspan class=\x22hljs-attr\x22\x3efirstName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Clive Staples\x22\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3elastName\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x22Lewis\x22\x3c\/span\x3e\n});\nperson.firstName = \x3cspan class=\x22hljs-string\x22\x3e\x22C.S.\x22\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e temperature = observable(\x3cspan class=\x22hljs-number\x22\x3e20\x3c\/span\x3e);\ntemperature.set(\x3cspan class=\x22hljs-number\x22\x3e25\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e2.2. @observable\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {observable} from \x26quot;mobx\x26quot;;\nclass OrderLine {\n    @observable price:number = 0;\n    @observable amount:number = 1;\n    constructor(price) {\n        this.price = price;\n    }\n    \/\/这里在下一节会说到\n    @computed get total() {\n        return this.price * this.amount;\n    }\n}\nconst line = new OrderLine();\nconsole.log(\x26quot;price\x26quot; in line); \/\/ true\n\/\/hasOwnProperty：判断一个对象是否有你给出名称的属性或对象。需要注意，此方法无法检查该对象的原型链中是否具有该属性\nconsole.log(line.hasOwnProperty(\x26quot;price\x26quot;)); \/\/false\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observable} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eOrderLine\x3c\/span\x3e \x3c\/span\x3e{\n    @observable price:number = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    @observable amount:number = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(price) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.price = price;\n    }\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里在下一节会说到\x3c\/span\x3e\n    @computed get total() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.price * \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.amount;\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e line = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e OrderLine();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22price\x22\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e line); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/hasOwnProperty：判断一个对象是否有你给出名称的属性或对象。需要注意，此方法无法检查该对象的原型链中是否具有该属性\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(line.hasOwnProperty(\x3cspan class=\x22hljs-string\x22\x3e\x22price\x22\x3c\/span\x3e)); \x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如果你的环境不支持ES6\/7的语法的话，其实@observable key = value;  只是extendObservable(this, { key: value })的语法糖。因此在ES5环境下你也能使用\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e2.3. (@)computed\x3c\/h3\x3e\n\x3cp\x3eComputed values 就像一个算术公式一样去从现有的状态或其他值去计算出需要的值。计算的耗费是不可低估的。Computed尽可能帮你减少其中的耗费。它们是高度优化的，请把它用在可能用到的地方。\x3c\/p\x3e\n\x3cp\x3e不要混淆下一节说到的autorun。虽然他们都是被动调用的表达式。但是……  \x3cbr\x3eComputed使用情况：如果你需要产生一个有观察者(observers)参数计算的新的值的时候  \x3cbr\x3eautorun使用情况：你不想产生一个新的值就想达到一个新的效果\/功能。就像是打log或者进行网络请求  \x3cbr\x3eComputed values是自动帮你从你的状态(state)值和其他计算辅助值来计算的。MobX做了很多的优化。当参与计算的值没有发生改变，Computed是不会重新运行。如果参与计算的值没有被使用，Computed values是暂停的。\x3c\/p\x3e\n\x3cp\x3e如果Computed values不再是观察者(observed)，那么在UI上也会把它除掉，MobX能自动做垃圾回收。autorun则需要你自己手动去处理。如果参与计算的值不再被使用，是不会缓存Computed的，所以重新计算是需要的。这个是最理想的默认情况。如果你想保留，可以了解一下keepalive和observe。\x3c\/p\x3e\n\x3cp\x3e例子1:    在2.2的例子。@computed get\x3c\/p\x3e\n\x3cp\x3e例子2: @computed set\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Foo {\n    @observable length: 2,\n    @computed get squared() {\n        return this.length * this.length;\n    }\n    set squared(value) { \/\/this is automatically an action, no annotation necessary\n        this.length = Math.sqrt(value);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eFoo\x3c\/span\x3e \x3c\/span\x3e{\n    @observable length: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\n    @computed get squared() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length * \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length;\n    }\n    set squared(value) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/this is automatically an action, no annotation necessary\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.length = \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.sqrt(value);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e需要注意的是：setter并非用于直接改变参数计算的值,如例子中的length。而是作为一个逆推导。\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3e2.4. Autorun\x3c\/h3\x3e\n\x3cp\x3eAutorun是用在一些你想要产生一个不用观察者参与的被动调用函数里面。当autorun被使用的时候，一旦依赖项发生变化，autorun提供的函数就会被执行。与之相反的是，computed提供的函数只会在他有自己的观察员(observers)的时候才会评估是否重新执行，否则它的值被认为是无用的。  \x3c\/p\x3e\n\x3cp\x3e根据这些经验：如果你需要一个自动运行但却不会产生任何新的值的结果的函数，那么请使用Autorun。其他情况请使用computed。Autorun只是作用于如果达到某个效果或者功能，而不是计算某些值。如果有一个字符串作为第一个参数存入Autorun，那么它将成为一个调试名称。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var numbers = observable([1,2,3]);\nvar sum = computed(() =\x3e numbers.reduce((a, b) =\x3e a \x2b b, 0));\n\nvar disposer = autorun(() =\x3e console.log(sum.get()));\n\/\/ prints \x276\x27\nnumbers.push(4);\n\/\/ prints \x2710\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e numbers = observable([\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e,\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e]);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sum = computed(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e numbers.reduce(\x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3ea, b\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e a \x2b b, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e));\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e disposer = autorun(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sum.get()));\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ prints \x276\x27\x3c\/span\x3e\nnumbers.push(\x3cspan class=\x22hljs-number\x22\x3e4\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ prints \x2710\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e2.5. @observer\x3c\/h3\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3eobserver 函数\/修饰器用于react组件。通过\x3cem\x3emobx-react\x3c\/em\x3e依赖包来提供。它通过mobx.autorun来包装了组件的render函数，以确保组件的render函数在任何数据的更改是强制重新渲染\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {observer} from \x26quot;mobx-react\x26quot;;\nvar timerData = observable({\n    secondsPassed: 0\n});\nsetInterval(() =\x3e {\n    timerData.secondsPassed\x2b\x2b;\n}, 1000);\n@observer class Timer extends React.Component {\n    render() {\n        return (\x3cspan\x3eSeconds passed: { this.props.timerData.secondsPassed } \x3c\/span\x3e )\n    }\n});\nReact.render(\x3cTimer timerData={timerData} \/\x3e, document.body);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observer} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22mobx-react\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e timerData = observable({\n    \x3cspan class=\x22hljs-attr\x22\x3esecondsPassed\x3c\/span\x3e: \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n});\nsetInterval(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n    timerData.secondsPassed\x2b\x2b;\n}, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e);\n@observer \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTimer\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eSeconds passed: { this.props.timerData.secondsPassed } \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e )\n    }\n});\nReact.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTimer\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etimerData\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{timerData}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, document.body);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3etips: 如果还有其他的decorators一起或者高阶组件的存在，请确保observer为最内层（优先应用）的修饰器。否则它可能无法工作。如果你只在ES5的环境下工作：其实observer不过是\x3cstrong\x3eobserver(class Timer ... { })\x3c\/strong\x3e 的语法糖。\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e难点—组件中相关值的引用：\x3cbr\x3eMobX能做的事情很多，但是它却不能把原始的值变成观察者（尽管可以通过包裹这个值来返回一个boxed observables的对象）。所以观察者不是这个原始的值，而是返回后的对象的属性值。修改一个刚才的例子：\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React.render(\x3cTimer timerData={timerData.secondsPassed} \/\x3e, document.body)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eReact.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTimer\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etimerData\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{timerData.secondsPassed}\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, document.body)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这时候程序并不会工作了。传入组件的只是timerData里面secondsPassed的当前值。在组件里面，它是不可变的。\x3c\/p\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e把你的组件内部状态变成可观察的\x3cbr\x3e和普通的类一样，你可以在你的组件使用@observable修饰器。这意味着你的组件拥有了一个内部state，而且它不需要使用react内部提供的繁琐的setState机制。这个内部state能调起render函数，但是却不能准确调起React的生命周期函数，例如：componentShouldUpdate \/ componentWillUpdate。如果你想要这些，最好使用react提供的API来创建state。当然也可以这样写\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {observer} from \x26quot;mobx-react\x26quot;\nimport {observable} from \x26quot;mobx\x26quot;\n@observer class Timer extends React.Component {\n    @observable secondsPassed = 0\n    componentWillMount() {\n        setInterval(() =\x3e {\n            this.secondsPassed\x2b\x2b\n        }, 1000)\n    }\n    render() {\n        return (\x3cspan\x3eSeconds passed: { this.secondsPassed } \x3c\/span\x3e )\n    }\n})\nReact.render(\x3cTimer \/\x3e, document.body)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observer} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22mobx-react\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observable} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22mobx\x22\x3c\/span\x3e\n@observer \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTimer\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    @observable secondsPassed = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n    componentWillMount() {\n        setInterval(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.secondsPassed\x2b\x2b\n        }, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\n    }\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3eSeconds passed: { this.secondsPassed } \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3espan\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e )\n    }\n})\nReact.render(\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eTimer\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e, document.body)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e连接observer和stores\x3cbr\x3emobx-react提供了\x3cstrong\x3eProvider\x3c\/strong\x3e组件让你可以把传递下来的stores作用在react提供的上下文机制。通过连接这些stores和observer，这些observer会成为组件的属性来使用。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const colors = observable({\n   foreground: \x27#000\x27,\n   background: \x27#fff\x27\n});\nconst App = () =\x3e\n  \x3cProvider colors={colors}\x3e\n     \x3capp stuff... \/\x3e\n  \x3c\/Provider\x3e;\nconst Button = observer([\x26quot;colors\x26quot;], ({ colors, label, onClick }) =\x3e\n  \x3cbutton style=\x22{{\x22\n      color: colors.foreground,\n      backgroundColor: colors.background\n    \x22}}\x22\n    onClick={onClick}\n  \x3e{label}\x3cbutton\x3e\n);\n\/\/ later..\ncolors.foreground = \x27blue\x27;\n\/\/ all buttons updated\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e colors = observable({\n   \x3cspan class=\x22hljs-attr\x22\x3eforeground\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#000\x27\x3c\/span\x3e,\n   \x3cspan class=\x22hljs-attr\x22\x3ebackground\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#fff\x27\x3c\/span\x3e\n});\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e App = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e\n  \x26lt;Provider colors={colors}\x26gt;\n     \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eapp\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3estuff...\x3c\/span\x3e \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eProvider\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e Button = observer([\x3cspan class=\x22hljs-string\x22\x3e\x22colors\x22\x3c\/span\x3e], ({ colors, label, onClick }) =\x26gt;\n  \x26lt;button style=\x22{{\x22\n      color: colors.foreground,\n      backgroundColor: colors.background\n    \x22}}\x22\n    onClick={onClick}\n  \x26gt;{label}\x26lt;button\x26gt;\n);\n\/\/ later..\ncolors.foreground = \x27blue\x27;\n\/\/ all buttons updated\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3ecomponentWillReact\x3cbr\x3eReact 的组件总是从新的堆栈去渲染。因此让它它很难判断一个组件是否需要重新渲染。在mobx-react里面，你可以使用重新定义的生命周期componentWillReact。它只会在观察者发生变化的时候才重新渲染。\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import {observer} from \x26quot;mobx-react\x26quot;;\n@observer class TodoView extends React.Component {\n    componentWillReact() {\n        console.log(\x26quot;I will re-render, since the todo has changed!\x26quot;);\n    }\n    render() {\n        return \x3cdiv\x3ethis.props.todo.title\x3c\/div\x3e;\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observer} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22mobx-react\x22\x3c\/span\x3e;\n@observer \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTodoView\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n    componentWillReact() {\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22I will re-render, since the todo has changed!\x22\x3c\/span\x3e);\n    }\n    render() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3ethis.props.todo.title\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ecomponentWillReact没有任何参数，而且不会在render初始化之前执行（componentWillMount的区别)。而当接收新的属性或者setState之后，它会被调用。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3e2.6. action\x3c\/h3\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3e任何应用程序都有操作（action）。action是任何改变状态的事物。使用MobX，您可以通过标记它们在您的代码中显式地显示您的操作（action）。它会更好的帮助你组织你的代码。建议将它们用于修改可观察量或具有副作用的任何函数中。  \x3cbr\x3e需要注意的是：action是用在\x3cem\x3estrict mode\x3c\/em\x3e 中的\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22action(fn)\naction(name, fn)\n@action classMethod() {}\n@action(name) classMethod () {}\n@action boundClassMethod = (args) =\x3e { body }\n@action(name) boundClassMethod = (args) =\x3e { body }\n@action.bound classMethod() {}\n@action.bound(function() {})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eaction(fn)\naction(name, fn)\n@action classMethod() {}\n@action(name) classMethod () {}\n@action boundClassMethod = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eargs\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e { body }\n@action(name) boundClassMethod = \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3eargs\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e { body }\n@action.bound classMethod() {}\n@action.bound(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@action createRandomContact() {\n    this.pendingRequestCount\x2b\x2b;\n    superagent\n         .get(\x27https:\/\/randomuser.me\/api\/\x27)\n         .set(\x27Accept\x27, \x27application\/json\x27)\n         .end(action(\x26quot;createRandomContact-callback\x26quot;, (error, results) =\x3e {\n                 if (error) console.error(error)\n                 else {\n                     const data = JSON.parse(results.text).results[0];\n                     const contact = new Contact(this, data.dob, data.name, data.login.username, data.picture)\n                     contact.addTag(\x27random-user\x27);\n                     this.contacts.push(contact);\n                     this.pendingRequestCount--;\n                 }\n        }\n))}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e@action createRandomContact() {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pendingRequestCount\x2b\x2b;\n    superagent\n         .get(\x3cspan class=\x22hljs-string\x22\x3e\x27https:\/\/randomuser.me\/api\/\x27\x3c\/span\x3e)\n         .set(\x3cspan class=\x22hljs-string\x22\x3e\x27Accept\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27application\/json\x27\x3c\/span\x3e)\n         .end(action(\x3cspan class=\x22hljs-string\x22\x3e\x22createRandomContact-callback\x22\x3c\/span\x3e, (error, results) =\x26gt; {\n                 \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (error) \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.error(error)\n                 \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                     \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = \x3cspan class=\x22hljs-built_in\x22\x3eJSON\x3c\/span\x3e.parse(results.text).results[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e];\n                     \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e contact = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Contact(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, data.dob, data.name, data.login.username, data.picture)\n                     contact.addTag(\x3cspan class=\x22hljs-string\x22\x3e\x27random-user\x27\x3c\/span\x3e);\n                     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.contacts.push(contact);\n                     \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.pendingRequestCount--;\n                 }\n        }\n))}\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3eaction 仅仅作用于当前运行的函数，而不能作用于当前函数调用的函数。这意味着在一些定时器或者网络请求，异步处理的情况下，它们的回调函数无法对状态做成改变。这些回调函数都应该有action包裹，如果例子里面的 \x3cem\x3ecreateRandomContact-callback\x3c\/em\x3e 一样。但是，如果你使用了async \/ await的话，最好的方式应该是使用 \x3cstrong\x3erunInAction\x3c\/strong\x3e 来让它变得更加简单\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22@action \/*optional*\/ updateDocument = async () =\x3e {\n    const data = await fetchDataFromUrl();\n    \/* required in strict mode to be allowed to update state: *\/\n    runInAction(\x26quot;update state after fetching data\x26quot;, () =\x3e {\n        this.data.replace(data);\n        this.isSaving = true;\n    })\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e@action \x3cspan class=\x22hljs-comment\x22\x3e\/*optional*\/\x3c\/span\x3e updateDocument = \x3cspan class=\x22hljs-keyword\x22\x3easync\x3c\/span\x3e () =\x26gt; {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = \x3cspan class=\x22hljs-keyword\x22\x3eawait\x3c\/span\x3e fetchDataFromUrl();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/* required in strict mode to be allowed to update state: *\/\x3c\/span\x3e\n    runInAction(\x3cspan class=\x22hljs-string\x22\x3e\x22update state after fetching data\x22\x3c\/span\x3e, () =\x26gt; {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.data.replace(data);\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.isSaving = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e;\n    })\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3col\x3e\x3cli\x3e\x3cp\x3eBound actions  \x3cbr\x3e目前看到的actions都是遵循在javascript中绑定的正常规则，但是在MobX 3引入了action.bound来自动绑定actions到目标对象上。和action的使用不一样，不需要一个名字参数。它的名称始终基于绑定到属性的操作上。需要注意的是，在箭头函数上不要这样使用，因为箭头函数已经绑定了上下文，不能在重新更改上下文\x3c\/p\x3e\x3c\/li\x3e\x3c\/ol\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Ticker {\n    @observable this.tick = 0\n\n    @action.bound\n    increment() {\n        this.tick\x2b\x2b \/\/ \x27this\x27 will always be correct\n    }\n}\nconst ticker = new Ticker()\nsetInterval(ticker.increment, 1000)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eTicker\x3c\/span\x3e \x3c\/span\x3e{\n    @observable \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tick = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e\n\n    @action.bound\n    increment() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.tick\x2b\x2b \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27this\x27 will always be correct\x3c\/span\x3e\n    }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ticker = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Ticker()\nsetInterval(ticker.increment, \x3cspan class=\x22hljs-number\x22\x3e1000\x3c\/span\x3e)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3e后记\x3c\/h2\x3e\n\x3cp\x3e启动例子项目：\x3ca href=\x22https:\/\/github.com\/sanyuelanv\/learn_mobx\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e进入\x3c\/a\x3e\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e前端项目：npm install 或者 yarn install 打开本地的8080端口\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e后端部分：进入 back文件夹，执行npm start 打开本地的3000端口\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e作为对比：使用redux的例子：\x3ca href=\x22https:\/\/github.com\/sanyuelanv\/project\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e进入\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>MobX</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008267003">https://segmentfault.com/a/1190000008267003</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6csblq7hn08/" target="_blank">https://alili.tech/archive/6csblq7hn08/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>