<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React 渲染机制解析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React 渲染机制解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/qjy55u75wel/",
				"appid": "1613049289050283", 
				"title": "React 渲染机制解析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-05T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/iuyok7gtoag/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/zc5xuuk9j7/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f&text=React%20%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f&text=React%20%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f&title=React%20%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f&is_video=false&description=React%20%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%20%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f&title=React%20%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f&title=React%20%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f&title=React%20%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fqjy55u75wel%2f&title=React%20%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6%e8%a7%a3%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React 渲染机制解析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-05" itemprop="datePublished">2019-01-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3eReact渲染过程\x3c\/h3\x3e\n\x3cp\x3e我们都知道使用React可以使得网页的性能有很大的提高，本文具体探究它是通过什么样的渲染机制做到的。\x3c\/p\x3e\n\x3cp\x3e在页面一开始打开的时候，React会调用render函数构建一棵Dom树，在state\/props发生改变的时候，render函数会被再次调用渲染出另外一棵树，接着，React会用对两棵树进行对比，找到需要更新的地方批量改动。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eDiff 算法\x3c\/h3\x3e\n\x3cp\x3e这个过程中，比较两棵Dom tree高效找出需要更新的地方是很重要的。React基于两个假设：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e两个相同的组件产生类似的DOM结构，不同组件产生不同DOM结构\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对于同一层次的一组子节点，它们可以通过唯一的id区分\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e发明了一种叫Diff的算法，它极大的优化了这个比较的过程，将算法复杂度从O(n^3)降低到O(n)。\x3c\/p\x3e\n\x3cp\x3e同时，基于第一点假设，我们可以推论出，Diff算法只会对同层的节点进行比较。如图，它只会对颜色相同的节点进行比较。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000010522785\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000010522785\x22 alt=\x22\x22 title=\x22\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e也就是说如果父节点不同，React将不会在去对比子节点。因为不同的组件DOM结构会不相同，所以就没有必要在去对比子节点了。这也提高了对比的效率。\x3c\/p\x3e\n\x3cp\x3e下面，我们具体看下Diff算法是怎么做的，这里分为两种情况考虑\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e节点类型不同\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e节点类型相同，但是属性不同\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e不同节点类型\x3c\/h3\x3e\n\x3cp\x3e对于不同的节点类型，react会基于第一条假设，直接删去旧的节点，新建一个新的节点。\x3c\/p\x3e\n\x3cp\x3e比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cA\x3e\n  \x3cC\/\x3e\n\x3c\/A\x3e\n\/\/ 由shape1到shape2\n\x3cB\x3e\n  \x3cC\/\x3e\n\x3c\/B\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-params\x22\x3e\x26lt;A\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-params\x22\x3e\x26lt;C\/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-params\x22\x3e\x26lt;\/A\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 由shape1到shape2\x3c\/span\x3e\n\x3cspan class=\x22hljs-params\x22\x3e\x26lt;B\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-params\x22\x3e\x26lt;C\/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-params\x22\x3e\x26lt;\/B\x26gt;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact会直接删掉A节点（包括它所有的子节点）,然后新建一个B节点插入。\x3c\/p\x3e\n\x3cp\x3e为了验证这一点，我打印出了从shape1到shape2节点的生命周期，gitbub链接：\x3cbr\x3e\x3ca href=\x22https:\/\/github.com\/hhhuangqiong\/reconciliation\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/hhhuangqio...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e感兴趣的可以自己跑一跑代码~\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Shape1 :\nA is created \nA render\nC is created\nC render\nC componentDidMount\nA componentDidMount\n\nShape2 :\nA componentWillUnmount\nC componentWillUnmount\nB is created\nB render\nC is created\nC render\nC componentDidMount\nB componentDidMount\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mathematica\x22\x3e\x3ccode\x3eShape1 :\nA is created \nA render\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e is created\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e render\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e componentDidMount\nA componentDidMount\n\nShape2 :\nA componentWillUnmount\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e componentWillUnmount\nB is created\nB render\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e is created\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e render\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e componentDidMount\nB componentDidMount\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由此可以看出，A与其子节点C会被直接删除，然后重新建一个B，C插入。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e相同节点类型\x3c\/h3\x3e\n\x3cp\x3e当对比相同的节点类型比较简单，react会对比它们的属性，只改变需要改变的属性\x3c\/p\x3e\n\x3cp\x3e比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv className=\x26quot;before\x26quot; title=\x26quot;stuff\x26quot; \/\x3e\n\n\x3cdiv className=\x26quot;after\x26quot; title=\x26quot;stuff\x26quot; \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e className=\x3cspan class=\x22hljs-string\x22\x3e\x22before\x22\x3c\/span\x3e title=\x3cspan class=\x22hljs-string\x22\x3e\x22stuff\x22\x3c\/span\x3e \/\x26gt;\n\n\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e className=\x3cspan class=\x22hljs-string\x22\x3e\x22after\x22\x3c\/span\x3e title=\x3cspan class=\x22hljs-string\x22\x3e\x22stuff\x22\x3c\/span\x3e \/\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这两个div中，react会只更新className的值\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv style=\x22{{\x22color: \x27red\x27, fontWeight: \x27bold\x27\x22}}\x22 \/\x3e\n\n\x3cdiv style=\x22{{\x22color: \x27green\x27, fontWeight: \x27bold\x27\x22}}\x22 \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e style=\x22{{\x22\x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27red\x27\x3c\/span\x3e, fontWeight: \x3cspan class=\x22hljs-string\x22\x3e\x27bold\x27\x3c\/span\x3e\x22}}\x22 \/\x26gt;\n\n\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e style=\x22{{\x22\x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27green\x27\x3c\/span\x3e, fontWeight: \x3cspan class=\x22hljs-string\x22\x3e\x27bold\x27\x3c\/span\x3e\x22}}\x22 \/\x26gt;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这两个div中，react只会去更新color的值\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e列表比较\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv\x3e\n  \x3cA \/\x3e\n  \x3cB \/\x3e\n\x3c\/div\x3e\n\/\/ 列表一到列表二\n\x3cdiv\x3e\n  \x3cA \/\x3e\n  \x3cC \/\x3e\n  \x3cB \/\x3e\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dts\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-params\x22\x3e\x26lt;div\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-params\x22\x3e\x26lt;A \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-params\x22\x3e\x26lt;B \/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-params\x22\x3e\x26lt;\/div\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 列表一到列表二\x3c\/span\x3e\n\x3cspan class=\x22hljs-params\x22\x3e\x26lt;div\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-params\x22\x3e\x26lt;A \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-params\x22\x3e\x26lt;C \/\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-params\x22\x3e\x26lt;B \/\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-params\x22\x3e\x26lt;\/div\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从列表一到列表二，只是在中间插入了一个C，但是如果没有key的时候，react会把B删去，新建一个C放在B的位置，然后重新建一个节点B放在尾部。\x3c\/p\x3e\n\x3cp\x3e你说什么就是什么咯？！不信的话，我们还是跑一边代码，看看生命周期验证一下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22列表一：\nA is created\nA render\nB is created\nB render\nA componentDidMount\nB componentDidMount\n\n列表二：\nA render\nB componentWillUnmount\nC is created\nC render\nB is created\nB render\nA componentDidUpdate\nC componentDidMount\nB componentDidMount\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs armasm\x22\x3e\x3ccode\x3e列表一：\nA is created\nA render\n\x3cspan class=\x22hljs-keyword\x22\x3eB \x3c\/span\x3eis created\n\x3cspan class=\x22hljs-keyword\x22\x3eB \x3c\/span\x3erender\nA componentDidMount\n\x3cspan class=\x22hljs-keyword\x22\x3eB \x3c\/span\x3ecomponentDidMount\n\n列表二：\nA render\n\x3cspan class=\x22hljs-keyword\x22\x3eB \x3c\/span\x3ecomponentWillUnmount\nC is created\nC render\n\x3cspan class=\x22hljs-keyword\x22\x3eB \x3c\/span\x3eis created\n\x3cspan class=\x22hljs-keyword\x22\x3eB \x3c\/span\x3erender\nA componentDidUpdate\nC componentDidMount\n\x3cspan class=\x22hljs-keyword\x22\x3eB \x3c\/span\x3ecomponentDidMount\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当节点很多的时候，这样做是非常低效的，所以我们需要给每个节点配一个key，让react可以识别出来哪些节点是一样的，不需要重新创建。\x3cbr\x3e配上key之后，在跑一遍代码看看，\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22A render\nC is created\nC render\nB render\nA componentDidUpdate\nC componentDidMount\nB componentDidUpdate\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mathematica\x22\x3e\x3ccode\x3eA render\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e is created\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e render\nB render\nA componentDidUpdate\n\x3cspan class=\x22hljs-keyword\x22\x3eC\x3c\/span\x3e componentDidMount\nB componentDidUpdate\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e果然，配上key之后，列表二的生命周期就如我所愿，只在指定的位置创建C节点插入。\x3cbr\x3e这里要注意的一点是，key值必须是稳定（所以我们不能用Math.random()去创建key），可预测，并且唯一的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3eReact整个的渲染机制就是在state\/props发生改变的时候，重新渲染所有的节点，构造出新的虚拟Dom tree跟原来的Dom tree用Diff算法进行比较，得到需要更新的地方在批量造作在真实的Dom上，由于这样做就减少了对Dom的频繁操作，从而提升的性能。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e探索性能优化\x3c\/h2\x3e\n\x3cp\x3e但是，是不是真的需要对所有的节点都重新渲染一遍呢？\x3cbr\x3e下一篇文章，我们将继续探讨这个问题~ \x3c\/p\x3e\n\x3cp\x3e参考文档：\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/www.infoq.com\/cn\/articles\/react-dom-diff\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/www.infoq.com\/cn\/artic...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/facebook.github.io\/react\/docs\/reconciliation.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/facebook.github.io\/re...\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React 渲染机制解析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010522782">https://segmentfault.com/a/1190000010522782</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/qjy55u75wel/" target="_blank">https://alili.tech/archive/qjy55u75wel/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>