<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 版俄罗斯方块——重构"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 版俄罗斯方块——重构 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/d31ygsiurr7/",
				"appid": "1613049289050283", 
				"title": "JavaScript 版俄罗斯方块——重构 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-02T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/f1goxj498pc/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/k9uktrr2ck/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f&text=JavaScript%20%e7%89%88%e4%bf%84%e7%bd%97%e6%96%af%e6%96%b9%e5%9d%97%e2%80%94%e2%80%94%e9%87%8d%e6%9e%84"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f&text=JavaScript%20%e7%89%88%e4%bf%84%e7%bd%97%e6%96%af%e6%96%b9%e5%9d%97%e2%80%94%e2%80%94%e9%87%8d%e6%9e%84"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f&title=JavaScript%20%e7%89%88%e4%bf%84%e7%bd%97%e6%96%af%e6%96%b9%e5%9d%97%e2%80%94%e2%80%94%e9%87%8d%e6%9e%84"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f&is_video=false&description=JavaScript%20%e7%89%88%e4%bf%84%e7%bd%97%e6%96%af%e6%96%b9%e5%9d%97%e2%80%94%e2%80%94%e9%87%8d%e6%9e%84"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e7%89%88%e4%bf%84%e7%bd%97%e6%96%af%e6%96%b9%e5%9d%97%e2%80%94%e2%80%94%e9%87%8d%e6%9e%84&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f&title=JavaScript%20%e7%89%88%e4%bf%84%e7%bd%97%e6%96%af%e6%96%b9%e5%9d%97%e2%80%94%e2%80%94%e9%87%8d%e6%9e%84"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f&title=JavaScript%20%e7%89%88%e4%bf%84%e7%bd%97%e6%96%af%e6%96%b9%e5%9d%97%e2%80%94%e2%80%94%e9%87%8d%e6%9e%84"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f&title=JavaScript%20%e7%89%88%e4%bf%84%e7%bd%97%e6%96%af%e6%96%b9%e5%9d%97%e2%80%94%e2%80%94%e9%87%8d%e6%9e%84"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fd31ygsiurr7%2f&title=JavaScript%20%e7%89%88%e4%bf%84%e7%bd%97%e6%96%af%e6%96%b9%e5%9d%97%e2%80%94%e2%80%94%e9%87%8d%e6%9e%84"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 版俄罗斯方块——重构</h1><div class="meta"><div class="postdate"><time datetime="2019-02-02" itemprop="datePublished">2019-02-02</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e在 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006919702\x22\x3eJavaScript 版俄罗斯方块\x3c\/a\x3e 中曾提到，因为临时起意，所以项目结构和很多命名都比较混乱。另外，计分等功能也未实现。这次抽空实现计分和速度设置，并在此之前进行了简单的重构。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader0\x22\x3e传送门\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/git.oschina.net\/jamesfancy\/tetris\/tree\/js_version\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e本文源码地址\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/jamesfancy.oschina.io\/tetris\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e演示地址（最新发布，不一定与本文源码对应）\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006919702\x22\x3e如何构建 - 参考前一篇博文\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e重构项目结构\x3c\/h2\x3e\n\x3cp\x3e项目结构上主要是将原来的 \x3ccode\x3eapp\x3c\/code\x3e 更名为 \x3ccode\x3esrc\x3c\/code\x3e，表示脚本和 less 源码都在这里。当然原来存放脚本源码的 \x3ccode\x3eapp\/src\x3c\/code\x3e 也相更名为 \x3ccode\x3esrc\/scripts\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22[root\x3e\n  |-- index.html    : 入口\n  |-- js\/           : 构建生成的脚本\n  |-- css\/          : 构建生成的样式表\n  |-- lib\/          : bower 引入的库\n  `-- src\/          : 前端源文件\n        |-- less    : 样式表源文件\n        `-- scripts : 脚本(es6)源文件\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22markdown hljs\x22\x3e\x3ccode class=\x22markdown\x22\x3e[root\x26gt;\n  |-- index.html    : 入口\n  |-- js\/           : 构建生成的脚本\n  |-- css\/          : 构建生成的样式表\n  |-- lib\/          : bower 引入的库\n  `-- src\/          : 前端源文件\n\x3cspan class=\x22hljs-code\x22\x3e        |-- less    : 样式表源文件\x3c\/span\x3e\n\x3cspan class=\x22hljs-code\x22\x3e        `-- scripts : 脚本(es6)源文件\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e除此这外，基 \x3ccode\x3escripts\x3c\/code\x3e 中细分了模块，在重构的过程中创建了 \x3ccode\x3emodel\x3c\/code\x3e 和 \x3ccode\x3etetris\x3c\/code\x3e 两个子目录。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e结构分析\x3c\/h2\x3e\n\x3cp\x3e重构之前先进行了简单的结构分析，主要是将几个模块划分出来，放在 \x3ccode\x3emodel\x3c\/code\x3e 目录下。重构和写新功能的过程中创建了 \x3ccode\x3etetris\x3c\/code\x3e 目录，这里放的是功能类和辅助类。然而最主要的功能还是在 \x3ccode\x3escrits\/tetris.js\x3c\/code\x3e 中。\x3c\/p\x3e\n\x3cp\x3e下面是一开始分析模型时画的图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVDMXD?w=1281\x26amp;h=523\x22 src=\x22https:\/\/static.alili.tech\/img\/bVDMXD?w=1281\x26amp;h=523\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e重构\x3c\/h2\x3e\n\x3cp\x3e写程序，重构总是非常需要但也非常容易出错的部分。俄罗斯方块的整个重构的过程从 \x3ca href=\x22https:\/\/git.oschina.net\/jamesfancy\/tetris\/tree\/working\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码中 working 分支\x3c\/a\x3e 的提交日志中可以看到。\x3c\/p\x3e\n\x3cp\x3e关于重构，最重要的一点是：\x3cstrong\x3e改变代码结构，但不改变逻辑\x3c\/strong\x3e。也就是说，每一步重构都要在保证原有业务逻辑的基础上对代码进行修改——虽然并不是 100% 能达到，但要尽最大努力遵循这个原则，才不会在重构的过程中产生莫名其妙的 BUG。关于这一点，应该是在《重构 改善既有代码的设计》一书中提到的。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e虽然不确定改代码不改逻辑的原则是在 《重构 改善既有代码的设计》 这本书中提到的，但是这本书还是推荐大家去看一看。重构对于开发有着很重要的作用，不过重构过程中涉及到很多设计模式，所以设计模式也是需要读一读的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e私有成员\x3c\/h3\x3e\n\x3cp\x3e在重构的过程中，我为所有类都加入了私有成员定义。这样做的目的是避免在使用它们的时候，不小心访问了不该访问的成员（一般指不小心改写，但有时候不小心取值也可能造成错误）。\x3c\/p\x3e\n\x3cp\x3e关于私有成员这个话题，我曾在 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000003488631\x22\x3eES5 中模拟 ES6 的 Symbol 实现私有成员\x3c\/a\x3e 中讨论过。在这里我没有用那篇博客中提到的方法，而是直接使用了 Symbol。Babel 对 \x3ccode\x3eSymbol()\x3c\/code\x3e 做了兼容处理，如果是在支持 \x3ccode\x3eSymbol\x3c\/code\x3e 的浏览器上，会直接使用 ES6 的 Symbol；不支持的，则用 Babel 实现的一个模拟的 Symbol 代替。\x3c\/p\x3e\n\x3cp\x3e加入了私有化成员的代码看起来有些奇怪，比如下面这个简单的 \x3ccode\x3ePoint\x3c\/code\x3e 类的代码。以下的实现主要是为了（尽可能）保证 \x3ccode\x3ePoint\x3c\/code\x3e 对象一但生成，其坐标就不能随意改动——也就是 Immutable。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const __ = {\n    x: Symbol(\x26quot;x\x26quot;),\n    y: Symbol(\x26quot;y\x26quot;)\n};\n\nexport default class Point {\n    constructor(x, y) {\n        this[__.x] = x;\n        this[__.y] = y;\n    }\n\n    get x() {\n        return this[__.x];\n    }\n\n    get y() {\n        return this[__.y];\n    }\n\n    move(offsetX = 0, offsetY = 0) {\n        return new Point(this.x \x2b offsetX, this.y \x2b offsetY);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e __ = {\n    \x3cspan class=\x22hljs-attr\x22\x3ex\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22x\x22\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-attr\x22\x3ey\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eSymbol\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22y\x22\x3c\/span\x3e)\n};\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePoint\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(x, y) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[__.x] = x;\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[__.y] = y;\n    }\n\n    get x() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[__.x];\n    }\n\n    get y() {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[__.y];\n    }\n\n    move(offsetX = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, offsetY = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Point(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.x \x2b offsetX, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.y \x2b offsetY);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\n\x3cp\x3e这段代码还好，在写了很多 \x3ccode\x3econst __ = { ... }\x3c\/code\x3e 之后，我突然觉得非常思念 TypeScript。在 TypeScript 中只需要简单的 \x3ccode\x3eprivate _x;\x3c\/code\x3e 就可以申明私有成员。\x3c\/p\x3e\n\x3cp\x3eTypeScript 中申明的私有成员仅限于静态检查，最终生成的 JavaScript 脚本中，这些成员都可以在外部访问。不过没关系，因为静态检查可以更好的帮我们规避错误。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3eModels\x3c\/h2\x3e\n\x3cp\x3e只有 \x3ccode\x3escripts\/model\x3c\/code\x3e 下面实现的几个类是比较纯粹的模型，除了用于存储数据的字段（Field）和存取数据的属性（Property）之外，方法也都是用于存取数据的。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3ePoint 和 BlockPoint，继承\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3emodel\/point.js\x3c\/code\x3e 和 \x3ccode\x3emodel\/blockpoint.js\x3c\/code\x3e 里分别实现了用于描述点（小方块）的两个类，区别仅仅在于 \x3ccode\x3eBlockPoint\x3c\/code\x3e 多一个颜色属性。实际上 \x3ccode\x3eBlockPoint\x3c\/code\x3e 是 \x3ccode\x3ePoint\x3c\/code\x3e 的子类。在 ES6 里实现继承太容易了，下面是这两个类的结构示意\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Point {\n    constructor(x, y) {\n        \/\/ ....\n    }\n}\n\nclass BlockPoint extends Point {\n    constructor(x = 0, y = 0, c = \x26quot;c0\x26quot;) {\n        super(x, y);\n        \/\/ ....\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePoint\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(x, y) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ....\x3c\/span\x3e\n    }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eBlockPoint\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ePoint\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(x = 0, y = 0, c = \x22c0\x22) {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(x, y);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ....\x3c\/span\x3e\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e继氶的实现关键就两点需要注意：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e通过 \x3ccode\x3eextends\x3c\/code\x3e 关键字实现继承\x3c\/li\x3e\n\x3cli\x3e如果子类中定义了构造函数 \x3ccode\x3econstructor\x3c\/code\x3e，记得第一句话一定要调用父类的构造函数 \x3ccode\x3esuper(...)\x3c\/code\x3e。Javaer 应该很熟悉这个要求的。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3eForm\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eForm\x3c\/code\x3e 在这里不是“表单”的意思，而是“形状、外形”的意思，表示一个方块图形（Shape）通过旋转形成的最多4 种形态，每个 \x3ccode\x3eForm\x3c\/code\x3e 对象是其中一种。所以 \x3ccode\x3eForm\x3c\/code\x3e 其实是一组 \x3ccode\x3ePoint\x3c\/code\x3e 组成的。\x3c\/p\x3e\n\x3cp\x3e上一个版本中没有定义 \x3ccode\x3eForm\x3c\/code\x3e 这个数据结构，是在生成 Shape 的时候生成的匿名对象。那段代码看起来特别绕，虽然也可以提取个函数出来，不过现在通过 \x3ccode\x3eForm\x3c\/code\x3e 类的构造函数来生成，不仅达到了同样的目的，也把 \x3ccode\x3ewidth\x3c\/code\x3e 的 \x3ccode\x3eheight\x3c\/code\x3e 封装起来了。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3eShape 和 SHAPES\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eShape\x3c\/code\x3e 和 \x3ccode\x3eSHAPES\x3c\/code\x3e 跟原来区别不大。\x3ccode\x3eSHAPES\x3c\/code\x3e 的生成代码通过定义 \x3ccode\x3eForm\x3c\/code\x3e 类，简化了不少。而 \x3ccode\x3eShape\x3c\/code\x3e 类在构建后，也由于成员私有化的原因，\x3ccode\x3ecolor\x3c\/code\x3e 和 \x3ccode\x3eforms\x3c\/code\x3e 不能被改变了，只能获取。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3eTetris 中的游戏相关类\x3c\/h2\x3e\n\x3cp\x3e除了几个比较纯粹的模型类放在 \x3ccode\x3emodel\x3c\/code\x3e 中，主要入口 \x3ccode\x3eindex.js\x3c\/code\x3e 和 \x3ccode\x3etetris.js\x3c\/code\x3e 放在脚本源码根目录下，其它的游戏相关类都是放在 \x3ccode\x3etetris\x3c\/code\x3e 目录下的。这只是用包（Java概念）或命名空间（C\x2b\x2b\/C#概念）的概念对源码进行了一个基本的划分。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eBlock 和 BlockFactory\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eBlock\x3c\/code\x3e 表示一个大方块，是由四个小方块组成的大方块，它的原型（此原型非 JS 的 Prototype）就是 \x3ccode\x3eShape\x3c\/code\x3e。所以一个 \x3ccode\x3eBlock\x3c\/code\x3e 会有一个 \x3ccode\x3eShape\x3c\/code\x3e 原型的引用，同时保存着当前它的位置 \x3ccode\x3eposition\x3c\/code\x3e 和形态 \x3ccode\x3eformIndex\x3c\/code\x3e，这两个属性在游戏过程中是可以改变的，直接影响着 \x3ccode\x3eBlock\x3c\/code\x3e 最终绘制出来的位置和样子。\x3c\/p\x3e\n\x3cp\x3e整有游戏中其实只有两个 \x3ccode\x3eBlock\x3c\/code\x3e，一个在预览区中，另一个在游戏区定时下落并被玩家操作。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eBlock\x3c\/code\x3e 对象下落到底之后就不再是 \x3ccode\x3eBlock\x3c\/code\x3e 了，它会被固化在游戏区。为什么要这样设计呢？因为 \x3ccode\x3eBlock\x3c\/code\x3e 表示的是一个完整的大方块，而游戏区下方的方块一旦填满一行就会被消除，大方块将再也不完整。这种情况有两个方案可以描述：\x3c\/p\x3e\n\x3col\x3e\n\x3cli\x3e仍然以大方块对象放在那里，但是标记已被消除的块，这样在绘制的时候就可以不绘制已消除的块。\x3c\/li\x3e\n\x3cli\x3e大方块下落完成之后就将其打散成一个个的 \x3ccode\x3eBlockPoint\x3c\/code\x3e，通过矩阵管理。\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cp\x3e很明显，第二种方法通过二维数组实现，会更直观，程序写起来也会更简单。所以我选用了第二种方法。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eBlock\x3c\/code\x3e 除了描述大方块的位置和形态之外，也会配合游戏控制进行一些数据运算和变化，比如位置的变化：\x3ccode\x3emoveLeft()\x3c\/code\x3e、\x3ccode\x3emoveRight()\x3c\/code\x3e、\x3ccode\x3emoveDown()\x3c\/code\x3e 等，以及形态的变化 \x3ccode\x3erotate()\x3c\/code\x3e；还有几个 \x3ccode\x3efastenXxxx\x3c\/code\x3e 方法，生成 \x3ccode\x3eBlockPoint[]\x3c\/code\x3e 用于绘制或判断下一个位置是否可以放置。关于这一点，在 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006919702\x22 target=\x22_blank\x22\x3eJavaScript 版俄罗斯方块\x3c\/a\x3e 中已经谈过。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eBlockFactory\x3c\/code\x3e 功能未变，仍然是产生一个随机方块。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3ePuzzle 和 Matrix\x3c\/h3\x3e\n\x3cp\x3e之前对 Puzzle 和 Matrix 的定义有点混淆，这里把它们区分开了。\x3c\/p\x3e\n\x3cp\x3ePuzzle 用于绘制浏览区和预览区，它除了描述一个指定长宽的绘制区域之外，还有存储着两个重要的对象，\x3ccode\x3eblock: Block\x3c\/code\x3e 和 \x3ccode\x3efastened: BlockPoint[]\x3c\/code\x3e，也就是上面提到的运动中的方块，和固定下来的若干小方块。\x3c\/p\x3e\n\x3cp\x3ePuzzle 本向不维护 \x3ccode\x3eblock\x3c\/code\x3e 和 \x3ccode\x3efastened\x3c\/code\x3e，但它要绘制这两个重要数据对象中的所有 \x3ccode\x3eBlockPoint\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3eMatrix 不再是一个类，它是两个数据。一个是 \x3ccode\x3ePuzzle\x3c\/code\x3e 中的 \x3ccode\x3ematrix\x3c\/code\x3e 属性，维护着由 \x3ccode\x3e\x26lt;div\x26gt;\x3c\/code\x3e（行） 和 \x3ccode\x3e\x26lt;span\x26gt;\x3c\/code\x3e（单元） 组成的绘制区；另一个是 \x3ccode\x3eTetris\x3c\/code\x3e 中的 \x3ccode\x3ematrix\x3c\/code\x3e 属性，维护着一个 \x3ccode\x3eBlockPoint\x3c\/code\x3e 的矩阵，也就是 \x3ccode\x3ePuzzle::fastened\x3c\/code\x3e 的矩阵形态，它更容易通过固化或删除等操作来改变。\x3c\/p\x3e\n\x3cp\x3e由于 \x3ccode\x3eTetris::matrix\x3c\/code\x3e 在大部分时间是不变的，则 \x3ccode\x3ePuzzle\x3c\/code\x3e 绘制的时候需要的只是其中其中非空部分的列表，所以这里有一个比较好的业务逻辑是：在 \x3ccode\x3eTetris::matrix\x3c\/code\x3e 变化的时候，从它重新生成 \x3ccode\x3ePuzzle::fastened\x3c\/code\x3e，由 \x3ccode\x3ePuzzle\x3c\/code\x3e 绘制时使用。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e有点遗憾，写此博文的时候发现重构之后忘了实现这一优化处理，仍然是在每次 \x3ccode\x3eTetris::render\x3c\/code\x3e 的时候都会去重新生成 \x3ccode\x3ePuzzle::fastened\x3c\/code\x3e。不过没关系，下个版本一定记得处理这个事情。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3eEventable\x3c\/h3\x3e\n\x3cp\x3e在重构和写新功能的过程中，发现了事件的重要性，好些处理都会用到事件。\x3c\/p\x3e\n\x3cp\x3e比如在点击\x3ckbd\x3e暂停\/恢复\x3c\/kbd\x3e 和 \x3ckbd\x3e重新开始\x3c\/kbd\x3e 的时候，需要去判断当前游戏的状态，并根据状态的情况来触发到底是不是真的暂停或重新开始。\x3c\/p\x3e\n\x3cp\x3e又比如，在计分和速度选择功能中，如果计分达到一定程度，就需要触发提速。\x3c\/p\x3e\n\x3cp\x3e上面提到的这些都可以使用观察者模式来设计，则事件就是观察者模式的一个典型实现。要实现自己的事件处理机制其实不难，但是这里可以偷偷懒，直接借用 jQuery 的事件处理，所以定义了 \x3ccode\x3eEventable\x3c\/code\x3e 类用于封装 jQuery 的事件处理，所有支持事件的业务类都可以从它继承。\x3c\/p\x3e\n\x3cp\x3e封装很简单，这里采用的是封装事件代理对象的方式，具体可以看源代码，一共只有 20 多行，很容易懂。也可以在构造函数中把 \x3ccode\x3ethis\x3c\/code\x3e 封装一个 jQuery 对象出来代理事件处理，这种方式可以将事件处理函数中的 \x3ccode\x3ethis\x3c\/code\x3e 指向自己（自己指 Eventable 对象）。不过还好，这个项目中不需要关心事件处理函数中的 \x3ccode\x3ethis\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3eStateManager\x3c\/h3\x3e\n\x3cp\x3e在实现 Tetris 中的主要游戏逻辑的时候，发现状态管理并不简单，尤其是加了 \x3ckbd\x3e暂停\/恢复\x3c\/kbd\x3e 按钮之后，暂停状态就分为代码暂停和人工暂停两种情况，对于两种情况的恢复操作也是有区别的。除此之外还有游戏结束的状态……所以干脆就定义个 \x3ccode\x3eStateManager\x3c\/code\x3e 来管理状态了。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3eStateManager\x3c\/code\x3e 维护着游戏的状态，提供改变状态的方法，也提供判断状态的属性。如果 JavaScript 有接口语法的话，这个接口大概是这样的\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22interface IStateManager {\n    get isPaused(): boolean;\n    get isPausedByManual(): boolean;\n    get isRestartable(): boolean;\n    get isOver(): boolean;\n\n    pause(byWhat);\n    resume(byWhat);\n    start();\n    over();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22typescript hljs\x22\x3e\x3ccode class=\x22typescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3einterface\x3c\/span\x3e IStateManager {\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e isPaused(): \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e isPausedByManual(): \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e isRestartable(): \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e isOver(): \x3cspan class=\x22hljs-built_in\x22\x3eboolean\x3c\/span\x3e;\n\n    pause(byWhat);\n    resume(byWhat);\n    start();\n    over();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e我又开始想念 TypeScript 了\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3eInfoPanel 和 CommandPanel\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eInfoPanel\x3c\/code\x3e 主要用于积分和速度的管理，包括与用户的交互（UI）。\x3ccode\x3eCommandPanel\x3c\/code\x3e 则是负责两个按钮事件的处理。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3eTetris\x3c\/h3\x3e\n\x3cp\x3e说实在的，我仍然认为 \x3ccode\x3eTetris\x3c\/code\x3e 的代码有点复杂，还需要重构简化。不过尝试了一下之后发现这并不是一件很容易的事情，所以就留待后面的版本来处理了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader16\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3e这次对俄罗斯方块游戏的重构只是一个初步的重构，最初的目的只是想把模型定义清楚，不过也对业务处理进行了一些拆分。模型定义的目的是达到了，但是业务拆分仍然不尽满意。\x3c\/p\x3e\n\x3cp\x3e工作上之前的两个项目都是用的 TypeScript 1.8，虽然是 TypeScript 1.8 有一些坑在那里，但是 TypeScript 的静态语言特性，尤其是静态检查对大型 JavaScript 项目还是有很大帮助的。之前一直认为 TypeScript 增加了代码量，也降低了 JavaScript 的灵活度，但这次用 ES6 重构俄罗斯方块游戏让我深深的感受到，这根本不是 TypeScript 的缺点，它至少可以解决 JavaScript 中的这几个问题：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e静态检查在开发阶段就能发现很多潜在的问题，而不是在运行的时候才能发现问题。要知道，问题发现得越早改起来越容易。\x3c\/li\x3e\n\x3cli\x3e编辑器（我用的 VSCode）的智能提示和自动完成功能在 TypeScript 的严格语法下非常好用，一个点出来就知道哪些方法可以调用，哪些不能。而对于 JavaScript 这方面就要弱一些了，编辑器不是按语义来分析，而是看代码中出现了哪些，这样难免会出现写代码不小心对象和方法不匹配的情况。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e所以，下个版本我准备尝试用 \x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006992529\x22\x3eTypeScript 2.0\x3c\/a\x3e 来改写。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e新篇来啦：\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000007074816\x22 target=\x22_blank\x22\x3eJavaScript 版俄罗斯方块——转换为 TypeScript\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader17\x22\x3e传送门\x3c\/h3\x3e\n\x3cul\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/git.oschina.net\/jamesfancy\/tetris\/tree\/js_version\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e本文源码地址\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22http:\/\/jamesfancy.oschina.io\/tetris\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e演示地址（最新发布，不一定与本文源码对应）\x3c\/a\x3e\x3c\/li\x3e\n\x3cli\x3e\x3ca href=\x22https:\/\/segmentfault.com\/a\/1190000006919702\x22\x3e如何构建 - 参考前一篇博文\x3c\/a\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 版俄罗斯方块——重构</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007063852">https://segmentfault.com/a/1190000007063852</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/d31ygsiurr7/" target="_blank">https://alili.tech/archive/d31ygsiurr7/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/sj57jxyoook/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（上）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/qsw902j95k/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（下）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/nnpmjlot58j/">IndexedDB使用与出坑指南<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/alvlbas9oai/">JS事件模型<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/u0pzym8k36o/">JS练习实例--编写经典小游戏俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/khwpyk5yz8q/">JavaScript 事件代理和委托<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/kuocl6lc3n/">JavaScript 版俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/n8bk54lyrf/">Promise学习:基础入门<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/7bk7u30qncb/">Redux 入坑进阶 - 源码解析<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/853kqfmqmf7/">Snap.svg 基本知识入门<aside class="dates">2019-02-03</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>