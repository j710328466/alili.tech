<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="vue-router 实现分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>vue-router 实现分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/v435voaplgi/",
				"appid": "1613049289050283", 
				"title": "vue-router 实现分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-17T02:30:25"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/tb15k5jdl4n/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/i45oewhck6/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f&text=vue-router%20%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f&text=vue-router%20%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f&title=vue-router%20%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f&is_video=false&description=vue-router%20%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=vue-router%20%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f&title=vue-router%20%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f&title=vue-router%20%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f&title=vue-router%20%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fv435voaplgi%2f&title=vue-router%20%e5%ae%9e%e7%8e%b0%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">vue-router 实现分析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-17" itemprop="datePublished">2019-01-17</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3evue-router 是 Vue.js 官方的路由库，本着学习的目的，我对 vue-router 的源码进行了阅读和分析，分享出来给其他感兴趣的同学做个参考吧。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e参考\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e源码：\x3ca href=\x22https:\/\/github.com\/vuejs\/vue-router\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evuejs\/vue-router v2.2.1 - github\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e文档：\x3ca href=\x22http:\/\/router.vuejs.org\/zh-cn\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evue-router 官方中文教程\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e初步\x3c\/h2\x3e\n\x3cp\x3e我们分别从不同的视角来看 vue-router。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e从开发者角度来看，是这样的：\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var router = new VueRouter({\n  routes: [\n   {path: \x27\/foo\x27, component: {template: \x27\x3cdiv\x3eFOO\x3c\/div\x3e\x27\x22}}\x22,\n   {path: \x27\/bar\x27, component: {template: \x27\x3cdiv\x3eBAR\x3c\/div\x3e\x27\x22}}\x22\n  ]\n})\n\nvar vm = new Vue({\n  el: \x27#app\x27,\n  router: router\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e router = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e VueRouter({\n  \x3cspan class=\x22hljs-attr\x22\x3eroutes\x3c\/span\x3e: [\n   {\x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/foo\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e: {\x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;FOO\x26lt;\/div\x26gt;\x27\x3c\/span\x3e\x22}}\x22,\n   {\x3cspan class=\x22hljs-attr\x22\x3epath\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\/bar\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-attr\x22\x3ecomponent\x3c\/span\x3e: {\x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;BAR\x26lt;\/div\x26gt;\x27\x3c\/span\x3e\x22}}\x22\n  ]\n})\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  \x3cspan class=\x22hljs-attr\x22\x3eel\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3erouter\x3c\/span\x3e: router\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们创建一个 \x3ccode\x3erouter\x3c\/code\x3e，传入的 \x3ccode\x3eroutes\x3c\/code\x3e 中的每一项即为一条路由（route）配置，表示在匹配给定的地址时，应该使用什么组件渲染视图。\x3c\/p\x3e\n\x3cp\x3e将 \x3ccode\x3erouter\x3c\/code\x3e 传入 \x3ccode\x3enew Vue()\x3c\/code\x3e 用于创建根组件，这样根组件中对应的视图区域，可以基于 \x3ccode\x3erouter\x3c\/code\x3e 中的配置，根据页面地址显示不同的内容。当然，这还需要在组件模板中使用 \x3ccode\x3e\x26lt;router-view\x26gt;\x3c\/code\x3e 来定义区域。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e从视图角度来看，是这样的：\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cdiv id=\x26quot;app\x26quot;\x3e\n  ...\n  \x3crouter-view\x3e\x3c\/router-view\x3e\n  ...\n\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22xml hljs\x22\x3e\x3ccode class=\x22html\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22app\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  ...\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3erouter-view\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3erouter-view\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  ...\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e页面地址变更后，\x3ccode\x3e\x26lt;router-view\x26gt;\x3c\/code\x3e 对应的区域会更新为地址匹配的组件。例如，路径是 \x3ccode\x3e\/foo\x3c\/code\x3e 则对应区域显示 FOO，路径是 \x3ccode\x3e\/bar\x3c\/code\x3e 则显示 BAR，路径没有匹配的组件时，则不显示内容。\x3c\/p\x3e\n\x3cul\x3e\x3cli\x3e\x3cp\x3e从数据角度来看，是这样的：\x3c\/p\x3e\x3c\/li\x3e\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22vm\n\x2b _router | $router\n  - history\n  - matcher\n\x2b _route | $route\n  - matched\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3evm\n\x2b _router | $router\n  -\x3cspan class=\x22ruby\x22\x3e history\n\x3c\/span\x3e  -\x3cspan class=\x22ruby\x22\x3e matcher\n\x3c\/span\x3e\x2b _route | $route\n  -\x3cspan class=\x22ruby\x22\x3e matched\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3evm.$router\x3c\/code\x3e 引用当前组件对应的 \x3ccode\x3erouter\x3c\/code\x3e 对象，该对象在初始化时（在 \x3ccode\x3evm\x3c\/code\x3e 创建过程中执行初始化），会启动对页面地址变更的监听，从而在变更时更新 \x3ccode\x3evm\x3c\/code\x3e 的数据（\x3ccode\x3e$route\x3c\/code\x3e），进而触发视图的更新。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e深入\x3c\/h2\x3e\n\x3cp\x3e\x3cstrong\x3e如何实现对地址变更的监听？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e对于缺省的 \x3ccode\x3eHashHistory\x3c\/code\x3e 模式（也就是基于页面地址的 hash 部分来实现路由功能，如 \x3ccode\x3ehttp:\/\/example.com\/path#\/foo\x3c\/code\x3e、\x3ccode\x3ehttp:\/\/example.com\/path#\/bar\x3c\/code\x3e），是通过监听 \x3ccode\x3ehashChange\x3c\/code\x3e 事件来实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window.addEventListener(\x27hashchange\x27, () =\x3e {\n  \/\/ this.transitionTo(...)\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27hashchange\x27\x3c\/span\x3e, () =\x26gt; {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this.transitionTo(...)\x3c\/span\x3e\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/vuejs\/vue-router\/blob\/v2.2.1\/src\/history\/hash.js#L21\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e这个动作是什么时候执行的呢？\x3c\/p\x3e\n\x3cp\x3e是在 \x3ccode\x3erouter.init()\x3c\/code\x3e（\x3ca href=\x22https:\/\/github.com\/vuejs\/vue-router\/blob\/v2.2.1\/src\/index.js#L103\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e）中调用的，而 \x3ccode\x3erouter.init()\x3c\/code\x3e 则是在根组件创建时（\x3ca href=\x22https:\/\/github.com\/vuejs\/vue-router\/blob\/v2.2.1\/src\/install.js#L24\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e）调用的。\x3c\/p\x3e\n\x3cp\x3e而 Vue 组件在创建时，又怎么会去调用 \x3ccode\x3erouter.init()\x3c\/code\x3e 呢？\x3c\/p\x3e\n\x3cp\x3e这是由于 vue-router 将自身作为一个插件安装到了 Vue，通过 \x3ccode\x3eVue.mixin()\x3c\/code\x3e 注册了一个 \x3ccode\x3ebeforeCreate()\x3c\/code\x3e 钩子函数，从而在之后所有的 Vue 组件创建时都会调用该钩子函数，给了检查是否有 \x3ccode\x3erouter\x3c\/code\x3e 参数，从而进行初始化的机会。进而通过层层调用执行了监听 \x3ccode\x3ehashchange\x3c\/code\x3e 事件的动作。\x3c\/p\x3e\n\x3cp\x3e整理一下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3enew Vue()\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行 vue-router 注入的 \x3ccode\x3ebeforeCreate\x3c\/code\x3e 钩子函数\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行 \x3ccode\x3erouter.init(vm)\x3c\/code\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e执行 \x3ccode\x3ehistory.setupListeners()\x3c\/code\x3e，注册事件监听\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e地址变更如何通知到 \x3ccode\x3evm\x3c\/code\x3e？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e这个过程比较简单，\x3ccode\x3ehashchange\x3c\/code\x3e 时，执行 \x3ccode\x3ehistory.transitionTo(...)\x3c\/code\x3e，在这个过程中，会进行地址匹配，得到一个对应当前地址的 \x3ccode\x3eroute\x3c\/code\x3e，然后将其设置到对应的 \x3ccode\x3evm._route\x3c\/code\x3e 上。\x3c\/p\x3e\n\x3cp\x3e只是进行了赋值，为什么 \x3ccode\x3evm\x3c\/code\x3e 就可以感知到路由的改变了呢？\x3c\/p\x3e\n\x3cp\x3e答案在 vue-router 注入 Vue 的 \x3ccode\x3ebeforeCreate\x3c\/code\x3e 钩子函数中（\x3ca href=\x22https:\/\/github.com\/vuejs\/vue-router\/blob\/v2.2.1\/src\/install.js#L25\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e）：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue.util.defineReactive(this, \x27_route\x27, this._router.history.current)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3eVue.util.defineReactive(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27_route\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._router.history.current)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e采用与 Vue 本身数据相同的“数据劫持”方式，这样对 \x3ccode\x3evm._route\x3c\/code\x3e 的赋值会被 Vue 拦截到，并且触发 Vue 组件的更新渲染流程。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e地址变更如果同步视图更新？\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e接上一步，\x3ccode\x3evm._route\x3c\/code\x3e 已经接收到路由的变更，从而触发视图更新。而当视图更新进一步调用到 \x3ccode\x3e\x26lt;router-view\x26gt;\x3c\/code\x3e 的 \x3ccode\x3erender()\x3c\/code\x3e 时，即进入了 \x3ccode\x3e\x26lt;router-view\x26gt;\x3c\/code\x3e 的处理（\x3ca href=\x22https:\/\/github.com\/vuejs\/vue-router\/blob\/v2.2.1\/src\/components\/view.js#L12\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e）。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;router-view\x26gt;\x3c\/code\x3e 的 \x3ccode\x3erender()\x3c\/code\x3e 采用函数调用（\x3ccode\x3eh()\x3c\/code\x3e）模式，而非通过模板生成。这也是 Vue2 支持的定义组件渲染逻辑的方式，类似 React 的 \x3ccode\x3erender()\x3c\/code\x3e。采用这种模式的好处是可以完全利用 JavaScript 的能力来编写逻辑，不必受制于 Vue 的类 HTML 模板语法。\x3c\/p\x3e\n\x3cp\x3e这里的主要处理逻辑是从根组件中取出当前的路由对象（\x3ccode\x3eparent.$route\x3c\/code\x3e），然后取得该路由下对应的组件，然后交由该组件进行渲染：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22return h(component, data, children)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e h(component, data, children)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这其中还涉及 \x3ccode\x3e\x26lt;router-view\x26gt;\x3c\/code\x3e 嵌套的处理，不过主要逻辑就是这样了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3e其实 vue-router 从 \x3ccode\x3e\x26lt;router-view\x26gt;\x3c\/code\x3e 的实现来看，就是一个具有特定功能的 Vue 组件而已，不过要配合根组件的 router 发挥作用。但整体还是很“响应式”的，也是蛮“Vue风格”的。\x3c\/p\x3e\n\x3cp\x3evue-router 以插件方式“侵入”Vue，从而支持一个额外的 \x3ccode\x3erouter\x3c\/code\x3e 属性，以提供监听并改变组件路由数据的能力。这样每次路由发生改变后，可以同步到数据，进而“响应式”地触发组件的更新。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;router-view\x26gt;\x3c\/code\x3e 作为根组件下的子组件，从根组件那里可以获取到当前的路由对象，进而根据路由对象的组件配置，取出组件并用其替换当前位置的内容。这样，也就完成整个路由变更到视图变更的过程。\x3c\/p\x3e\n\x3cp\x3e路由变更到视图变更的过程整理为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22hashchange\n--\x3e\nmatch route\n--\x3e\nset vm._route\n--\x3e\n\x3crouter-view\x3e render()\n--\x3e\nrender matched component\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haml\x22\x3e\x3ccode\x3ehashchange\n-\x3cspan class=\x22ruby\x22\x3e-\x26gt;\n\x3c\/span\x3ematch route\n-\x3cspan class=\x22ruby\x22\x3e-\x26gt;\n\x3c\/span\x3eset vm._route\n-\x3cspan class=\x22ruby\x22\x3e-\x26gt;\n\x3c\/span\x3e\x26lt;router-view\x26gt; render()\n-\x3cspan class=\x22ruby\x22\x3e-\x26gt;\n\x3c\/span\x3erender matched component\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实现过程中的技术点包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eVue 插件机制\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e响应式数据机制\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eVue 渲染机制\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e地址变更监听\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e最后\x3c\/h2\x3e\n\x3cp\x3e我写了一个应用 Vue.js、vue-router 以及其他 Vue 相关工具（Vuex、vue-loader）的示例，感兴趣可以看下：\x3ca href=\x22https:\/\/github.com\/luobotang\/vue-demo\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eluobotang\/vue-demo - github\x3c\/a\x3e。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>vue-router 实现分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008831927">https://segmentfault.com/a/1190000008831927</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/v435voaplgi/" target="_blank">https://alili.tech/archive/v435voaplgi/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>