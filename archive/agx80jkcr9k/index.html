<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="React中元素与组件的区别"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>React中元素与组件的区别 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/agx80jkcr9k/",
				"appid": "1613049289050283", 
				"title": "React中元素与组件的区别 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-19T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/4q3ewqvqbsy/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/mw9p5lb9qfb/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f&text=React%e4%b8%ad%e5%85%83%e7%b4%a0%e4%b8%8e%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f&text=React%e4%b8%ad%e5%85%83%e7%b4%a0%e4%b8%8e%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f&title=React%e4%b8%ad%e5%85%83%e7%b4%a0%e4%b8%8e%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f&is_video=false&description=React%e4%b8%ad%e5%85%83%e7%b4%a0%e4%b8%8e%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=React%e4%b8%ad%e5%85%83%e7%b4%a0%e4%b8%8e%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8c%ba%e5%88%ab&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f&title=React%e4%b8%ad%e5%85%83%e7%b4%a0%e4%b8%8e%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f&title=React%e4%b8%ad%e5%85%83%e7%b4%a0%e4%b8%8e%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f&title=React%e4%b8%ad%e5%85%83%e7%b4%a0%e4%b8%8e%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fagx80jkcr9k%2f&title=React%e4%b8%ad%e5%85%83%e7%b4%a0%e4%b8%8e%e7%bb%84%e4%bb%b6%e7%9a%84%e5%8c%ba%e5%88%ab"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">React中元素与组件的区别</h1><div class="meta"><div class="postdate"><time datetime="2019-01-19" itemprop="datePublished">2019-01-19</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e在初学 React 的时候，分不清 React 组件和 React 元素，着实踩了一些坑。搞清楚 React 中什么是组件，什么是元素，既可以理清楚概念，也可以让你避免一些不必要的错误。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eReact 元素\x3c\/h2\x3e\n\x3cp\x3eReact 元素（React element），它是 React 中最小基本单位，我们可以使用 JSX 语法轻松地创建一个 React 元素:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const element = \x3cdiv className=\x26quot;element\x26quot;\x3eI\x27m element\x3c\/div\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e element = \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclassName\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22element\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3eI\x27m element\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact 元素不是真实的 DOM 元素，它仅仅是 js 的普通对象（plain objects），所以也没办法直接调用 DOM 原生的 API。上面的 JSX 转译后的对象大概是这样的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22{\n    _context: Object,\n    _owner: null,\n    key: null,\n    props: {\n    className: \x27element\x27，\n    children: \x27I\x27m element\x27\n  },\n    ref: null,\n    type: \x26quot;div\x26quot;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs yaml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    _context:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eObject,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    _owner:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    key:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    props:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    className:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27element\x27\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e，\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    children:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27I\x27\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3em\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3eelement\x27\x3c\/span\x3e\n  \x3cspan class=\x22hljs-string\x22\x3e},\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    ref:\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e,\x3c\/span\x3e\n\x3cspan class=\x22hljs-attr\x22\x3e    type:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22div\x22\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e}\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e只有在这个元素渲染被完成后，才能通过选择器的方式获取它对应的 DOM 元素。不过，按照 React 有限状态机的设计思想，应该使用状态和属性来表述组件，要尽量避免 DOM 操作，即便要进行 DOM 操作，也应该使用 React 提供的接口\x3ccode\x3eref\x3c\/code\x3e和\x3ccode\x3egetDOMNode()\x3c\/code\x3e。一般使用 React 提供的接口就足以应付需要 DOM 操作的场景了，因此像 jQuery 强大的选择器在 React 中几乎没有用武之地了。 \x3c\/p\x3e\n\x3cp\x3e除了使用 JSX 语法，我们还可以使用 \x3ccode\x3eReact.createElement()\x3c\/code\x3e 和 \x3ccode\x3eReact.cloneElement()\x3c\/code\x3e 来构建 React 元素。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eReact.createElement()\x3c\/h3\x3e\n\x3cp\x3eJSX 语法就是用\x3ccode\x3eReact.createElement()\x3c\/code\x3e来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如\x3ccode\x3ediv\x3c\/code\x3e、\x3ccode\x3espan\x3c\/code\x3e，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React.createElement(\n    type,\n    [props],\n    [...children]\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eReact\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.createElement\x3c\/span\x3e(\n    \x3cspan class=\x22hljs-selector-tag\x22\x3etype\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-selector-attr\x22\x3e[props]\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-selector-attr\x22\x3e[...children]\x3c\/span\x3e\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3eReact.cloneElement()\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eReact.cloneElement()\x3c\/code\x3e与\x3ccode\x3eReact.createElement()\x3c\/code\x3e相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22React.cloneElement(\n  element,\n  [props],\n  [...children]\n)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs css\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-selector-tag\x22\x3eReact\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.cloneElement\x3c\/span\x3e(\n  \x3cspan class=\x22hljs-selector-tag\x22\x3eelement\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-selector-attr\x22\x3e[props]\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-selector-attr\x22\x3e[...children]\x3c\/span\x3e\n)\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3eReact 组件\x3c\/h2\x3e\n\x3cp\x3eReact 中有三种构建组件的方式。\x3ccode\x3eReact.createClass()\x3c\/code\x3e、\x3ccode\x3eES6 class\x3c\/code\x3e和无状态函数。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3eReact.createClass()\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eReact.createClass()\x3c\/code\x3e是三种方式中最早，兼容性最好的方法。在0.14版本前官方指定的组件写法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Greeting = React.createClass({\n  render: function() {\n    return \x3ch1\x3eHello, {this.props.name}\x3c\/h1\x3e;\n  }\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Greeting = React.createClass({\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello, {this.props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eES6 class\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eES6 class\x3c\/code\x3e是目前官方推荐的使用方式，它使用了ES6标准语法来构建，但它的实现仍是调用\x3ccode\x3eReact.createClass()\x3c\/code\x3e来实现了，\x3ccode\x3eES6 class\x3c\/code\x3e的生命周期和自动绑定方式与\x3ccode\x3eReact.createClass()\x3c\/code\x3e略有不同。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Greeting extemds React.Component{\n  render: function() {\n    return \x3ch1\x3eHello, {this.props.name}\x3c\/h1\x3e;\n  }\n};\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGreeting\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eextemds\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n  render: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello, {this.props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n  }\n};\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e无状态函数\x3c\/h3\x3e\n\x3cp\x3e无状态函数是使用函数构建的无状态组件，无状态组件传入\x3ccode\x3eprops\x3c\/code\x3e和\x3ccode\x3econtext\x3c\/code\x3e两个参数，它没有\x3ccode\x3estate\x3c\/code\x3e，除了\x3ccode\x3erender()\x3c\/code\x3e，没有其它生命周期方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function Greeting (props) {\n  return \x3ch1\x3eHello, {props.name}\x3c\/h1\x3e;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eGreeting\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eprops\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3eHello, {props.name}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eh1\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eReact.createClass()\x3c\/code\x3e和\x3ccode\x3eES6 class\x3c\/code\x3e构建的组件的数据结构是类，无状态组件数据结构是函数，它们在 React 被视为是一样的。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e元素与组件的区别\x3c\/h2\x3e\n\x3cp\x3e组件是由元素构成的。元素数据结构是普通对象，而组件数据结构是类或纯函数。除此之外，还有几点区别要注意：\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3ethis.props.children\x3c\/h3\x3e\n\x3cp\x3e在 JSX 中，被元素嵌套的元素会以属性 children 的方式传入该元素的组件。当仅嵌套一个元素时，children 是一个 React 元素，当嵌套多个元素时，children 是一个 React 元素的数组。可以直接把 children 写入 JSX 的中，但如果要给它们传入新属性，就要用到\x3ccode\x3eReact.cloneElement()\x3c\/code\x3e来构建新的元素。我曾放过以下错误:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22render () {\n  var Child = this.props.children\n  return \x3cdiv\x3e\x3cChild tip={\x27error!\x27}\/\x3e\x3cdiv\x3e\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3erender () {\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Child = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;\x26lt;Child tip={\x3cspan class=\x22hljs-string\x22\x3e\x27error!\x27\x3c\/span\x3e}\/\x26gt;\x26lt;div\x26gt;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因为 Child 是一个 React 元素，而不是组件，这样的写法是完全错误的，正确的方式应该是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22render () {\n  var child = this.props.children\n  return \x3cdiv\x3e{ React.cloneElement(child, {tip: \x27right way!\x27}) }\x3cdiv\x3e\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3erender () {\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e child = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x26lt;div\x26gt;{ React.cloneElement(child, {tip: \x3cspan class=\x22hljs-string\x22\x3e\x27right way!\x27\x3c\/span\x3e}) }\x26lt;div\x26gt;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e就这样，原有属性和新添加的属性被一并传入了子元素。使用\x3ccode\x3eReact.cloneElement()\x3c\/code\x3e才是操作元素的正确姿势。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3e用户组件\x3c\/h3\x3e\n\x3cp\x3e有的时候，组件可以让用户以属性的方式传入自定义的组件，来提升组件的灵活性。这个属性传入的就应该是 React 元素，而非 React 组件。使用 React 元素可以让用户传入自定义组件的同时，为组件添加属性。同样，可以使用\x3ccode\x3eReact.cloneElement()\x3c\/code\x3e为自定义组件添加更多属性，或替换子元素。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 推荐\n\x3cMyComponent tick={\n  \x3cUserComponent tip=\x26quot;Yes\x26quot;\/\x3e\n} \/\x3e\n\n\/\/ 不推荐\n\x3cMyComponent tick={ UserComponent } \/\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs django\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3e\/\/ 推荐\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMyComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e\n  \x26lt;\x3cspan class=\x22hljs-attr\x22\x3eUserComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etip\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22Yes\x22\x3c\/span\x3e\/\x26gt;\x3c\/span\x3e\n} \/\x26gt;\n\n\/\/ 不推荐\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eMyComponent\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etick\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e{\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eUserComponent\x3c\/span\x3e } \/\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader10\x22\x3e最后\x3c\/h2\x3e\n\x3cp\x3e最后，打个不恰当的比喻，React 组件是\x3ccode\x3eMyComponent\x3c\/code\x3e，React 元素就是\x3ccode\x3e\x26lt;MyComponent \/\x26gt;\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3eAD\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/4bin.cn\/blog\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e新开博客，更多文章，陆续更新中...\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>React中元素与组件的区别</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008587988">https://segmentfault.com/a/1190000008587988</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/agx80jkcr9k/" target="_blank">https://alili.tech/archive/agx80jkcr9k/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5328xogjarn/">IndexedDB--HTML5本地存储<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/xpccu0hsqbr/">JS学习系列 01 - 编译原理和作用域<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/shv09bbtbfd/">Vue2 SSR 的优化之旅<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5vj1ojfo6h6/">[2016年末巨献] — HTML5可交互地铁线路图（第二季：帝都进阶版）<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/m02hlm4bzh/">vue2.0开发聊天程序（三）组件的通信<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/mz5o7n90plg/">《很高兴我没有猝死》- 前端新人的 2016 年总结和感悟<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/3vhoe2mo09k/">一道颇有难度的JavaScript题<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/uj12mb7thp/">使用CANVAS实现交互性圆形马赛克效果<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/ja636h8hcxa/">写于 2016 年末<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5uomnoq1kmi/">前端学习资源整理<aside class="dates">2019-01-28</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>