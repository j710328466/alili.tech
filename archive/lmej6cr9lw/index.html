<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="状态管理的未来：Apollo的GraphQL语言服务器"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>状态管理的未来：Apollo的GraphQL语言服务器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/lmej6cr9lw/",
				"appid": "1613049289050283", 
				"title": "状态管理的未来：Apollo的GraphQL语言服务器 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-25T02:30:23"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/z3urntmbxe/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/wa8a3i7gv6/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f&text=%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%9aApollo%e7%9a%84GraphQL%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f&text=%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%9aApollo%e7%9a%84GraphQL%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f&title=%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%9aApollo%e7%9a%84GraphQL%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f&is_video=false&description=%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%9aApollo%e7%9a%84GraphQL%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%9aApollo%e7%9a%84GraphQL%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f&title=%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%9aApollo%e7%9a%84GraphQL%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f&title=%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%9aApollo%e7%9a%84GraphQL%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f&title=%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%9aApollo%e7%9a%84GraphQL%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2flmej6cr9lw%2f&title=%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86%e7%9a%84%e6%9c%aa%e6%9d%a5%ef%bc%9aApollo%e7%9a%84GraphQL%e8%af%ad%e8%a8%80%e6%9c%8d%e5%8a%a1%e5%99%a8"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">状态管理的未来：Apollo的GraphQL语言服务器</h1><div class="meta"><div class="postdate"><time datetime="2019-01-25" itemprop="datePublished">2019-01-25</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n            \x3chr\x3e\n\x3cp\x3e\x3cimg src=\x22http:\/\/p0.qhimg.com\/t01526cb0a8a9b36f56.png\x22 alt=\x22\x22\x3e\n在Apollo的开发工具(DevTools)中查询程序当前状态\x3c\/p\x3e\n\x3ch1\x3e状态管理的未来\x3c\/h1\x3e\n\x3ch2\x3e在Apollo客户端程序(Apollo Client)里使用链路状态(apollo-link-state)软件包管理本地数据\x3c\/h2\x3e\n\x3cp\x3e一个程序随着大小的增加，状态常常会变得更复杂。作为开发人员，我们的任务不仅是要同时兼顾来自多个远程服务器的数据，还要处理由用户界面互动得来的本地数据。总而言之，我们要把数据的每个部分都以某种方式存储起来，使得程序无论从的哪个组件那里都能轻松地获取数据。\x3c\/p\x3e\n\x3cp\x3e许许多多开发人员告诉过我们Apollo客户端程序(Apollo Client)非常擅于管理远程数据，这差不多占了他们\x3cstrong\x3e80%\x3c\/strong\x3e的数据需求，但\x3cstrong\x3e剩下的20%\x3c\/strong\x3e，如全局开关和设备接口结果之类的本地数据怎么办呢？\x3c\/p\x3e\n\x3cp\x3e在过去，Apollo用户靠Redux库或MobX库的独立store对象来管理那20%。这种方法在Apollo客户端程序(Apollo Client)1.0版里也是行得通的，但Apollo客户端程序(Apollo Client)2.0版里没有Redux部分了，要同步两个store对象间的本地和远程数据就变得更困难了。常常听到用户反映，他们想把程序的所有状态都封装进Apollo客户端程序(Apollo Client)里去，保证\x3cstrong\x3e信息来源的单一性\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch3\x3e方案建立在坚实基础上\x3c\/h3\x3e\n\x3cp\x3e我们知道这个问题必须解决，所以自问：要在Apollo客户端程序(Apollo Client)里管理状态的话看上去会是怎么样的？首先，我们考虑了Redux库一些讨人喜欢的特色，比如其开发工具，以及通过connect将状态和组件绑定等功能。我们还考虑了Redux带来的痛点，比如异步行为生成器、缓存和优化界面之类的核心功能要用到样板和DIY方法来实现才行。\x3c\/p\x3e\n\x3cp\x3e为了能理想地管理状态，我们想过要以Redux的优点作为基础建立方案，同时解决一些受到批评的问题。我们也想过利用GraphQL语言的优势，只用一个查询(query)语句就能向多个来源请求数据。\x3c\/p\x3e\n\x3cp\x3e\x3cimg src=\x22http:\/\/p0.qhimg.com\/t01c46c0bb84ee464ca.png\x22 alt=\x22\x22\x3e\x3c\/p\x3e\n\x3cp\x3eApollo客户端程序(Apollo Client)数据流向架构图\x3c\/p\x3e\n\x3ch3\x3e学习一次就能在任何地方使用GraphQL语言\x3c\/h3\x3e\n\x3cp\x3e关于GraphQL语言有一种常见的误解，那就是这种模式要与某种特定的服务器实现方法结合在一起。实际上，这种模式要灵活得多。无论是从\x3ca href=\x22https:\/\/github.com\/iheanyi\/go-grpc-graphql-simple-example\x22\x3egRPC服务器\x3c\/a\x3e上，或是\x3ca href=\x22https:\/\/github.com\/apollographql\/apollo-link-rest\x22\x3eREST端点\x3c\/a\x3e上，或是\x3ca href=\x22https:\/\/github.com\/apollographql\/apollo-link-state\x22\x3e客户端缓存\x3c\/a\x3e里请求获取数据， GraphQL语言都可以用作一种\x3cstrong\x3e通用数据语言\x3c\/strong\x3e，完全不管数据来源。\x3c\/p\x3e\n\x3cp\x3e这就是为什么用GraphQL语言查询(query)与修改(mutation)来描述程序形成的状态是完美的。我们可以用GraphQL修改(mutation)操作来表示状态的变化，可以用GraphQL查询(query)操作来声明表达组件所需要的数据，以此访问状态数据。\x3c\/p\x3e\n\x3cp\x3eGraphQL的一大优点是能把从多个来源得到的数据汇总，可以是本地的也可以是远程的。在一个查询(query)操作里指定数据域指令即可。?让我们看看怎么做吧！\x3c\/p\x3e\n\x3ch3\x3e用Apollo客户端程序(Apollo Client)实现状态管理\x3c\/h3\x3e\n\x3cp\x3e在Apollo客户端程序(Apollo Client)里管理本地数据可以通过\x3ca href=\x22https:\/\/www.apollographql.com\/docs\/link\/\x22\x3eApollo Link\x3c\/a\x3e这个模块化网络栈来实现，它能在任意一点上与GraphQL请求操作的循环挂钩。要从GraphQL服务器上访问数据，我们可以用\x3ccode\x3eHttpLink\x3c\/code\x3e链路，但要从缓存中请求本地数据，我们需要安装一个新的链路：\x3ccode\x3e链路状态(apollo-link-state)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs livescript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { ApolloClient } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27apollo-client\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { InMemoryCache } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27apollo-cache-inmemory\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { ApolloLink } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27apollo-link\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { withClientState } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27apollo-link-state\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { HttpLink } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27apollo-link-http\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { defaults, resolvers } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27.\/resolvers\/todos\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e cache = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e InMemoryCache();\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e stateLink = withClientState({ resolvers, cache, defaults });\n\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e client = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e ApolloClient({\n  cache,\n  link: ApolloLink.\x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e([stateLink, \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e HttpLink()]),\n});\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3eApollo客户端程序(Apollo Client)带链路状态(apollo-link-state)模块的初始化\x3c\/p\x3e\n\x3cp\x3e要创建状态链路，用\x3ccode\x3ewithClientState\x3c\/code\x3e函数，把\x3ccode\x3e解析器(resolvers)\x3c\/code\x3e对象\x3ccode\x3e默认(defaults)\x3c\/code\x3e对象和Apollo的\x3ccode\x3e缓存(cache)\x3c\/code\x3e对象组成一个参数对象传入，然后把状态链路与整个链路拼接起来，作为其中一环。状态链路应该放在\x3ccode\x3eHttpLink\x3c\/code\x3e链路前面，这样程序就能先拦截执行本地的查询(query)与修改(mutation)，然后再进入网络。\x3c\/p\x3e\n\x3ch4\x3e默认对象(Defaults)\x3c\/h4\x3e\n\x3cp\x3e\x3ccode\x3e默认(defaults)\x3c\/code\x3e这个对象表示了创建状态链路时要写入缓存的初始状态。虽然不是必需的，但传入\x3ccode\x3e默认(defaults)\x3c\/code\x3e对象给缓存预热一下是很重要的，因为这样不管什么组件查询(query)数据都不会出现错误。\x3ccode\x3e默认(defaults)\x3c\/code\x3e对象的形态应该反映程序里缓存的计划查询方式。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs arduino\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaults = {\n  visibilityFilter: \x3cspan class=\x22hljs-string\x22\x3e\x27SHOW_ALL\x27\x3c\/span\x3e,\n  todos: [],\n};\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e默认(Defaults)代表了想写入缓存的初始状态\x3c\/p\x3e\n\x3ch4\x3e解析器(Resolvers)\x3c\/h4\x3e\n\x3cp\x3e用Apollo客户端程序(Apollo Client)管理状态时，Apollo缓存就成了程序里所有本地和远程数据的唯一来源。如何更新并访问缓存里的数据呢？这时就要用到解析器了。如果大家在服务器端用过\x3ccode\x3egraphql-tools\x3c\/code\x3e工具，那客户端解析器的类型签名和它是一样的：\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3efieldName: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e(obj, args, context, info)\x3c\/span\x3e =\x26gt;\x3c\/span\x3e result;\n\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e不熟悉这个也不用担心。这里要注意的有两点最重要，一是查询(query)或修改(mutation)部分中的变量是作为第二个参数传入的，二是缓存会自动添加到语句环境里去。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e defaults = { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 和之前一样 }\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e resolvers = {\n  \x3cspan class=\x22hljs-attr\x22\x3eMutation\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3evisibilityFilter\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e_, { filter }, { cache }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      cache.writeData({ \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: { \x3cspan class=\x22hljs-attr\x22\x3evisibilityFilter\x3c\/span\x3e: filter } });\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eaddTodo\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e(\x3cspan class=\x22hljs-params\x22\x3e_, { text }, { cache }\x3c\/span\x3e) =\x26gt;\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e query = gql\x3cspan class=\x22hljs-string\x22\x3e`\n        query GetTodos {\n          todos @client {\n            id\n            text\n            completed\n          }\n        }\n      `\x3c\/span\x3e;\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e previous = cache.readQuery({ query });\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e newTodo = {\n        \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: nextTodoId\x2b\x2b,\n        text,\n        \x3cspan class=\x22hljs-attr\x22\x3ecompleted\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-attr\x22\x3e__typename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27TodoItem\x27\x3c\/span\x3e,\n      };\n      \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e data = {\n        \x3cspan class=\x22hljs-attr\x22\x3etodos\x3c\/span\x3e: previous.todos.concat([newTodo]),\n      };\n      cache.writeData({ data });\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e newTodo;\n    },\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e解析器函数可以用来更新和访问缓存里的数据\x3c\/p\x3e\n\x3cp\x3e要把数据写入缓存的根路径，我们调用\x3ccode\x3ecache.writeData\x3c\/code\x3e函数并传入数据。有时我们写入缓存的数据取决于之前缓存里已有的数据，比如上面\x3ccode\x3eaddTodo\x3c\/code\x3e的修改(mutation)部分。在那种情况下，可以用\x3ccode\x3ecache.readQuery\x3c\/code\x3e函数先从缓存里读取，再进行写入。如果要把缓存内已有对象的一部分写进去，也可以选择传入一个\x3ccode\x3eid\x3c\/code\x3e号，它与对象在缓存里的键相对应。因为我们用的是\x3ccode\x3eInMemoryCache\x3c\/code\x3e，键值就是\x3ccode\x3e__typename:id\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e链路状态(apollo-link-state)\x3c\/code\x3e模块支持异步解析函数，这对于实施异步操作的附加效果很有用，比如访问设备API接口。然而，建议大家不要在解析函数中调用REST端点，而是用\x3ccode\x3e[apollo-link-rest](https:\/\/github.com\/apollographql\/apollo-link-rest)\x3c\/code\x3e库，有自己的\x3ccode\x3e@rest\x3c\/code\x3e指令可用。\x3c\/p\x3e\n\x3ch4\x3e\x3ccode\x3e@client\x3c\/code\x3e客户指令\x3c\/h4\x3e\n\x3cp\x3e从用户界面发起修改(mutation)操作时，Apollo的网络栈需要知道更新的数据是在客户端还是在服务器上。\x3ccode\x3e链路状态(apollo-link-state)\x3c\/code\x3e模块用的是\x3ccode\x3e@client\x3c\/code\x3e客户指令来设定只用于客户端的数据域。然后，\x3ccode\x3e链路状态(apollo-link-state)\x3c\/code\x3e再为这些域调用解析函数。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs coffeescript\x22\x3econst SET_VISIBILITY = gql`\x3cspan class=\x22javascript\x22\x3e\n  mutation SetFilter($filter: \x3cspan class=\x22hljs-built_in\x22\x3eString\x3c\/span\x3e!) {\n    visibilityFilter(filter: $filter) @client\n  }\n\x3c\/span\x3e`;\n\nconst setVisibilityFilter = graphql(SET_VISIBILITY, {\n  props: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e({ mutate, ownProps })\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n    onClick: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e =\x26gt;\x3c\/span\x3e mutate({ variables: { filter: ownProps.filter } }),\n  }),\n});\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e用@client客户指令对本地数据进行修改(mutation)\x3c\/p\x3e\n\x3cp\x3e查询(query)操作看起来和修改(mutation)很像。在查询(query)中有什么异步操作要执行的话，Apollo客户端程序(Apollo Client)会帮忙追踪加载与错误状态。对React框架来说，这些状态可以在\x3ccode\x3ethis.props.data\x3c\/code\x3e属性里找到，同时那里还可以找到无数的辅助函数，可以用来重新获取数据、分页和轮询。\x3c\/p\x3e\n\x3cp\x3e有一个让人兴奋的特色是可以在一个查询(query)里请求多个数据源的数据！? 在这个例子里，我们要用Apollo缓存里的\x3ccode\x3e可视化过滤器(visibilityFilter)\x3c\/code\x3e从GraphQL服务器那里请求一个\x3ccode\x3e用户(user)\x3c\/code\x3e数据。\x3c\/p\x3e\n\x3cpre\x3e\x3ccode class=\x22hljs routeros\x22\x3econst GET_USERS_ACTIVE_TODOS = gql`\n  {\n    visibilityFilter @client\n    user(id: 1) {\n      name\n     \x3cspan class=\x22hljs-built_in\x22\x3e address\n\x3c\/span\x3e    }\n  }\n`;\n\nconst withActiveState = graphql(GET_USERS_ACTIVE_TODOS, {\n  props: ({ ownProps, data }) =\x26gt; ({\n    active: ownProps.filter === data.visibilityFilter,\n    data,\n  }),\n});\n\x3c\/code\x3e\x3c\/pre\x3e\x3cp\x3e用@client客户指令查询Apollo缓存\x3c\/p\x3e\n\x3cp\x3e如果想要看更多的例子和窍门，想将\x3ccode\x3e链路状态(apollo-link-state)\x3c\/code\x3e整合到程序里去，请到我们\x3ca href=\x22https:\/\/www.apollographql.com\/docs\/link\/links\/state.html\x22\x3e更新后的文档页\x3c\/a\x3e。\x3c\/p\x3e\n\x3ch3\x3e1.0版路线图\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3e链路状态(apollo-link-state)\x3c\/code\x3e模块已经很稳定了，在现在的程序里已经够用了，不过我们还是想尽快弄好一些新的特色：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e客户端模式：\x3c\/strong\x3e 目前，我们还不支持根据客户端模式进行类型验证。这是因为如果在运行阶段要把\x3ccode\x3egraphql-js\x3c\/code\x3e用于构建验证模式的模块都包括进去，那会极大地增加软件包的大小。与之相反，我们希望能把模式构建转移到生成阶段去，并支持模式自我查询(introspection)，这样大家就仍然可以利用到GraphQL的绝妙特色。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e辅助组件：\x3c\/strong\x3e 我们的目标是要在Apollo程序中尽量实现无缝状态管理。我们想编写一些React组件，使常规操作不那么冗长，比如在后台实现修改(mutation)本身，同时把变量传进去。\x3c\/p\x3e\n\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e如果对这些问题有兴趣，请加入我们的\x3ca href=\x22https:\/\/github.com\/apollographql\/apollo-link-state\x22\x3eGitHub\x3c\/a\x3e小组或Apollo Slack的\x3ccode\x3e#local-state\x3c\/code\x3e频道。我们希望有你的参与和帮助，一起塑造下一代状态管理！?\x3c\/p\x3e\n\n          \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>状态管理的未来：Apollo的GraphQL语言服务器</p><h2 id="原文链接">原文链接</h2><p><a href="https://www.zcfy.cc/article/the-future-of-state-management-apollo-graphql">https://www.zcfy.cc/article/the-future-of-state-management-apollo-graphql</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/lmej6cr9lw/" target="_blank">https://alili.tech/archive/lmej6cr9lw/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5328xogjarn/">IndexedDB--HTML5本地存储<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/xpccu0hsqbr/">JS学习系列 01 - 编译原理和作用域<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/shv09bbtbfd/">Vue2 SSR 的优化之旅<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5vj1ojfo6h6/">[2016年末巨献] — HTML5可交互地铁线路图（第二季：帝都进阶版）<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/m02hlm4bzh/">vue2.0开发聊天程序（三）组件的通信<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/mz5o7n90plg/">《很高兴我没有猝死》- 前端新人的 2016 年总结和感悟<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/3vhoe2mo09k/">一道颇有难度的JavaScript题<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/uj12mb7thp/">使用CANVAS实现交互性圆形马赛克效果<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/ja636h8hcxa/">写于 2016 年末<aside class="dates">2019-01-28</aside></a></li><li><a href="/archive/5uomnoq1kmi/">前端学习资源整理<aside class="dates">2019-01-28</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>