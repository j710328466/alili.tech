<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="深入解析Vue源码"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>深入解析Vue源码 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/7lwstc7t1u9/",
				"appid": "1613049289050283", 
				"title": "深入解析Vue源码 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-05T02:30:11"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/7uhwcfdfx1j/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/ux1b3sjrd3l/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f&text=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90Vue%e6%ba%90%e7%a0%81"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f&text=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90Vue%e6%ba%90%e7%a0%81"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90Vue%e6%ba%90%e7%a0%81"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f&is_video=false&description=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90Vue%e6%ba%90%e7%a0%81"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90Vue%e6%ba%90%e7%a0%81&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90Vue%e6%ba%90%e7%a0%81"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90Vue%e6%ba%90%e7%a0%81"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90Vue%e6%ba%90%e7%a0%81"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7lwstc7t1u9%2f&title=%e6%b7%b1%e5%85%a5%e8%a7%a3%e6%9e%90Vue%e6%ba%90%e7%a0%81"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">深入解析Vue源码</h1><div class="meta"><div class="postdate"><time datetime="2019-01-05" itemprop="datePublished">2019-01-05</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch3 id=\x22articleHeader0\x22\x3eVue简介\x3c\/h3\x3e\n\x3cp\x3e数据绑定\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/**\n*假设有这么两个钟东西\n**\/\n\/\/数据\nvar object = {\n  message: \x27Hello World!\x27\n}\n\/\/DOM\n\x3cdiv id=\x26quot;example\x26quot;\x3e\n  \x22{{\x22 message \x22}}\x22\n\x3c\/div\x3e\n\n\/**\n*我们可以这么写\n**\/\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/**\n*假设有这么两个钟东西\n**\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/数据\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-selector-tag\x22\x3eobject\x3c\/span\x3e = {\n  message: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/DOM\x3c\/span\x3e\n\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e id=\x3cspan class=\x22hljs-string\x22\x3e\x22example\x22\x3c\/span\x3e\x26gt;\n  \x22{{\x22 message \x22}}\x22\n\x26lt;\/div\x26gt;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n*我们可以这么写\n**\/\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22new Vue({\n  el: \x27#example\x27,\n  data: object\n})\n\n\/**\n* 如果有个数据\n**\/\n\nvar object1 = {\n  message: \x27Hello World!\x27\n}\n\nvar object2 = {\n  message: \x27Hello World!\x27\n}\n\n\/\/DOM\n\x3cdiv id=\x26quot;example1\x26quot;\x3e\n  \x22{{\x22 message \x22}}\x22\n\x3c\/div\x3e\n\n\x3cdiv id=\x26quot;example2\x26quot;\x3e\n  \x22{{\x22 message \x22}}\x22\n\x3c\/div\x3e\n\n\/**\n*我们还可以这么写\n**\/\n\nvar vm1 = new Vue({el: \x27#example1\x27,data: object})\n\/\/改变vm1的数据DOM随之改变\nvm2.message = \x27oliver\x27\n\nvar vm2 = new Vue({el: \x27#example2\x27,data: object})\n\nvm2.message = \x27lisa\x27\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3enew Vue({\n  el: \x3cspan class=\x22hljs-string\x22\x3e\x27#example\x27\x3c\/span\x3e,\n  data: \x3cspan class=\x22hljs-selector-tag\x22\x3eobject\x3c\/span\x3e\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n* 如果有个数据\n**\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e object1 = {\n  message: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e object2 = {\n  message: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello World!\x27\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/DOM\x3c\/span\x3e\n\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e id=\x3cspan class=\x22hljs-string\x22\x3e\x22example1\x22\x3c\/span\x3e\x26gt;\n  \x22{{\x22 message \x22}}\x22\n\x26lt;\/div\x26gt;\n\n\x26lt;\x3cspan class=\x22hljs-selector-tag\x22\x3ediv\x3c\/span\x3e id=\x3cspan class=\x22hljs-string\x22\x3e\x22example2\x22\x3c\/span\x3e\x26gt;\n  \x22{{\x22 message \x22}}\x22\n\x26lt;\/div\x26gt;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n*我们还可以这么写\n**\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e vm1 = new Vue({el: \x3cspan class=\x22hljs-string\x22\x3e\x27#example1\x27\x3c\/span\x3e,data: object})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/改变vm1的数据DOM随之改变\x3c\/span\x3e\nvm2\x3cspan class=\x22hljs-selector-class\x22\x3e.message\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27oliver\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e vm2 = new Vue({el: \x3cspan class=\x22hljs-string\x22\x3e\x27#example2\x27\x3c\/span\x3e,data: object})\n\nvm2\x3cspan class=\x22hljs-selector-class\x22\x3e.message\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27lisa\x27\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e组件化\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Example = Vue.extend({\ntemplate: \x27\x3cdiv\x3e\x22{{\x22 message \x22}}\x22\x3c\/div\x3e\x27,\ndata: function () {\nreturn {\n  message: \x27Hello Vue.js!\x27\n}\n}\n})\n\n\/\/ 将该组件注册为 \x3cexample\x3e 标签\nVue.component(\x27example\x27, Example)\n\nVue 在组件化上和 React 类似：一切都是组件。\n组件使用上也和React一致:\n\n\x3cexample\x3e\x3c\/example\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Example = Vue.extend({\n\x3cspan class=\x22hljs-attr\x22\x3etemplate\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;div\x26gt;\x22{{\x22 message \x22}}\x22\x26lt;\/div\x26gt;\x27\x3c\/span\x3e,\n\x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attr\x22\x3emessage\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27Hello Vue.js!\x27\x3c\/span\x3e\n}\n}\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将该组件注册为 \x26lt;example\x26gt; 标签\x3c\/span\x3e\nVue.component(\x3cspan class=\x22hljs-string\x22\x3e\x27example\x27\x3c\/span\x3e, Example)\n\nVue 在组件化上和 React 类似：一切都是组件。\n组件使用上也和React一致:\n\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eexample\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eexample\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e组件之间数据传递:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221.用 props 来定义如何接收外部数据;\nVue.component(\x27child\x27, {\n  \/\/ 声明 props\n  props: [\x27msg\x27],\n  \/\/ prop 可以用在模板内\n  \/\/ 可以用 `this.msg` 设置\n  template: \x27\x3cspan\x3e\x22{{\x22 msg \x22}}\x22\x3c\/span\x3e\x27\n})\n\x3cchild msg=\x26quot;hello!\x26quot;\x3e\x3c\/child\x3e\n\n2.用自定义事件来向外传递消息;\n使用 $on() 监听事件；\n使用 $emit() 在它上面触发事件；\n使用 $dispatch() 派发事件，事件沿着父链冒泡；\n使用 $broadcast() 广播事件，事件向下传导给所有的后代。\n\n3.用 \x3cslot\x3e API 来将外部动态传入的内容（其他组件或是 HTML）和自身模板进行组合;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e用 props 来定义如何接收外部数据;\nVue.component(\x3cspan class=\x22hljs-string\x22\x3e\x27child\x27\x3c\/span\x3e, {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 声明 props\x3c\/span\x3e\n  props: [\x3cspan class=\x22hljs-string\x22\x3e\x27msg\x27\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ prop 可以用在模板内\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 可以用 `this.msg` 设置\x3c\/span\x3e\n  template: \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;span\x26gt;\x22{{\x22 msg \x22}}\x22\x26lt;\/span\x26gt;\x27\x3c\/span\x3e\n})\n\x26lt;child msg=\x3cspan class=\x22hljs-string\x22\x3e\x22hello!\x22\x3c\/span\x3e\x26gt;\x26lt;\/child\x26gt;\n\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e用自定义事件来向外传递消息;\n使用 $on() 监听事件；\n使用 $emit() 在它上面触发事件；\n使用 $dispatch() 派发事件，事件沿着父链冒泡；\n使用 $broadcast() 广播事件，事件向下传导给所有的后代。\n\n\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3e用 \x26lt;slot\x26gt; API 来将外部动态传入的内容（其他组件或是 HTML）和自身模板进行组合;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e模块化\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Webpack 或者 Browserify，然后再加上 ES2015配合 vue-loader 或是 vueify，就可以把Vue的每一个组件变成\nWeb Components\n\n\x3c!-- MyComponent.vue --\x3e\n\n\x3c!-- css --\x3e\n\x3cstyle\x3e\n.message {\n  color: red;\n}\n\x3c\/style\x3e\n\n\x3c!-- template --\x3e\n\x3ctemplate\x3e\n  \x3cdiv class=\x26quot;message\x26quot;\x3e\x22{{\x22 message \x22}}\x22\x3c\/div\x3e\n\x3c\/template\x3e\n\n\x3c!-- js --\x3e\n\x3cscript\x3e\nexport default {\n  props: [\x27message\x27],\n  created() {\n    console.log(\x27MyComponent created!\x27)\n  }\n}\n\x3c\/script\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs django\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3eWebpack 或者 Browserify，然后再加上 ES2015配合 vue-loader 或是 vueify，就可以把Vue的每一个组件变成\nWeb Components\n\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- MyComponent.vue --\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- css --\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3estyle\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22css\x22\x3e\n\x3cspan class=\x22hljs-selector-class\x22\x3e.message\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attribute\x22\x3ecolor\x3c\/span\x3e: red;\n}\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3estyle\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- template --\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3etemplate\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22message\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22 message \x22}}\x22\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3etemplate\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\x26lt;!-- js --\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22javascript\x22\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-attr\x22\x3eprops\x3c\/span\x3e: [\x3cspan class=\x22hljs-string\x22\x3e\x27message\x27\x3c\/span\x3e],\n  created() {\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27MyComponent created!\x27\x3c\/span\x3e)\n  }\n}\n\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e路由\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22使用Vue重构的Angular项目\n\nwww.songxuemeng.com\/diary\n\n个人感觉vue-router烦的问题是组件之间的数据交互,rootRouter的数据很难向其他组件传递.\n\n\/**\n*解决方法\n**\/\nvar app = Vue.extend({\n  data:function(){\n      return {\n          data:\x27\x27,\n      };\n  },\n});\nrouter.map({\n      \x27\/\x27: {\n          component:  Vue.extend({\n                            mixins: [calendar.mixin],\n                            data:function(){\n                                return {\n                                    data:data\n                                }\n                            }\n                      })\n      },\n  })\nrouter.start(app, \x27#app\x27);\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e使用Vue重构的Angular项目\n\nwww.songxuemeng.com\/diary\n\n个人感觉vue-router烦的问题是组件之间的数据交互,rootRouter的数据很难向其他组件传递.\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/**\n*解决方法\n**\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e app = Vue.extend({\n  data:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n          data:\x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e,\n      };\n  },\n});\nrouter.map({\n      \x3cspan class=\x22hljs-string\x22\x3e\x27\/\x27\x3c\/span\x3e: {\n          component:  Vue.extend({\n                            mixins: [calendar.mixin],\n                            data:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n                                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n                                    data:data\n                                }\n                            }\n                      })\n      },\n  })\nrouter.start(app, \x3cspan class=\x22hljs-string\x22\x3e\x27#app\x27\x3c\/span\x3e);\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader1\x22\x3eVue源码分析\x3c\/h3\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/img2.tbcdn.cn\/L1\/461\/1\/8142ef3fc2055839f1a93a933d80e17694b4f76b\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/img2.tbcdn.cn\/L1\/461\/1...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eVue.js是一个典型的MVVM的程序结构，程序大体可以分为：\x3cbr\x3e全局设计：包括全局接口、默认选项等；\x3cbr\x3evm实例设计：包括接口(vm原形)、实例初始化过程(vm构造函数)\x3c\/p\x3e\n\x3cp\x3e下面是构造函数最核心的工作内容。\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/img3.tbcdn.cn\/L1\/461\/1\/00049a09def4aff8d80f3bb7229e3f6d395426fb\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/img3.tbcdn.cn\/L1\/461\/1...\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e整个实例初始化的过程中，重中之重就是把数据 (Model) 和视图 (View) 建立起关联关系。Vue.js 和诸多 MVVM 的思路是类似的，主要做了三件事：\x3c\/p\x3e\n\x3cp\x3e通过 observer 对 data 进行了监听，并且提供订阅某个数据项的变化的能力\x3cbr\x3e把 template 解析成一段 document fragment，然后解析其中的 directive，得到每一个 directive 所依赖的数据项及其更新方法。比如 v-text=\x22message\x22 被解析之后；\x3cbr\x3e所依赖的数据项 this.$data.message，以及\x3cbr\x3e相应的视图更新方法 node.textContent = this.$data.message\x3cbr\x3e通过 watcher 把上述两部分结合起来，即把 directive 中的数据依赖订阅在对应数据的 observer 上，这样当数据变化的时候，就会触发 observer，进而触发相关依赖对应的视图更新方法，最后达到模板原本的关联效果。\x3cbr\x3e所以整个 vm 的核心，就是如何实现 observer, directive (parser), watcher 这三样东西\x3c\/p\x3e\n\x3ch4\x3evue文件结构\x3c\/h4\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/img4.tbcdn.cn\/L1\/461\/1\/cb73a147451157e52500734c0d31665a9540adae\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/img4.tbcdn.cn\/L1\/461\/1...\x3c\/a\x3e\x3c\/p\x3e\n\x3ch4\x3e数据列表的更新\x3c\/h4\x3e\n\x3cp\x3e视图更新效率的焦点问题主要在于大列表的更新和深层数据更新这两方面.\x3c\/p\x3e\n\x3cp\x3e但是工作中经常用的主要是前者\x3c\/p\x3e\n\x3cp\x3e首先 diff(data, oldVms) 这个函数的注释对整个比对更新机制做了个简要的阐述，大概意思是先比较新旧两个列表的 vm 的数据的状态，然后差量更新 DOM。\x3c\/p\x3e\n\x3cp\x3e第一步：便利新列表里的每一项，如果该项的 vm 之前就存在，则打一个 _reused 的标，如果不存在对应的 vm，则创建一个新的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (i = 0, l = data.length; i \x3c l; i\x2b\x2b) {\n        item = data[i];\n        key = convertedFromObject ? item.$key : null;\n        value = convertedFromObject ? item.$value : item;\n        primitive = !isObject(value);\n        frag = !init \x26amp;\x26amp; this.getCachedFrag(value, i, key);\n        if (frag) {\n          \/\/ reusable fragment如果存在打上usered\n          frag.reused = true;\n          \/\/ update $index\n          frag.scope.$index = i;\n          \/\/ update $key\n          if (key) {\n            frag.scope.$key = key;\n          }\n          \/\/ update iterator\n          if (iterator) {\n            frag.scope[iterator] = key !== null ? key : i;\n          }\n          \/\/ update data for track-by, object repeat \x26amp;\n          \/\/ primitive values.\n          if (trackByKey || convertedFromObject || primitive) {\n            frag.scope[alias] = value;\n          }\n        } else {\n          \/\/ new isntance如果不存在就新建一个\n          frag = this.create(value, alias, i, key);\n          frag.fresh = !init;\n        }\n        frags[i] = frag;\n        if (init) {\n          frag.before(end);\n        }\n      }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs processing\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = data.length; i \x26lt; l; i\x2b\x2b) {\n        item = data[i];\n        \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e = convertedFromObject ? item.$\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e : \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e;\n        value = convertedFromObject ? item.$value : item;\n        primitive = !isObject(value);\n        frag = !init \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getCachedFrag(value, i, \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (frag) {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ reusable fragment如果存在打上usered\x3c\/span\x3e\n          frag.reused = \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e;\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update $index\x3c\/span\x3e\n          frag.scope.$index = i;\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update $key\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e) {\n            frag.scope.$\x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e = \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e;\n          }\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update iterator\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (iterator) {\n            frag.scope[iterator] = \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e !== \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e ? \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e : i;\n          }\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ update data for track-by, object repeat \x26amp;\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ primitive values.\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (trackByKey || convertedFromObject || primitive) {\n            frag.scope[alias] = value;\n          }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ new isntance如果不存在就新建一个\x3c\/span\x3e\n          frag = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.create(value, alias, i, \x3cspan class=\x22hljs-built_in\x22\x3ekey\x3c\/span\x3e);\n          frag.fresh = !init;\n        }\n        frags[i] = frag;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (init) {\n          frag.before(end);\n        }\n      }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第二步：便利旧列表里的每一项，如果 _reused 的标没有被打上，则说明新列表里已经没有它了，就地销毁该 vm。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (i = 0, l = oldFrags.length; i \x3c l; i\x2b\x2b) {\n    frag = oldFrags[i];\n    if (!frag.reused) {\n\/\/如果没有used说明不存在,就地销毁\n      this.deleteCachedFrag(frag);\n      this.remove(frag, removalIndex\x2b\x2b, totalRemoved, inDocument);\n    }\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = oldFrags.length; i \x26lt; l; i\x2b\x2b) {\n    frag = oldFrags[i];\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!frag.reused) {\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/如果没有used说明不存在,就地销毁\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deleteCachedFrag(frag);\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.remove(frag, removalIndex\x2b\x2b, totalRemoved, inDocument);\n    }\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e第三步：整理新的 vm 在视图里的顺序，同时还原之前打上的 _reused 标。就此列表更新完成\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22for (i = 0, l = frags.length; i \x3c l; i\x2b\x2b) {\n        frag = frags[i];\n        \/\/ this is the frag that we should be after\n        targetPrev = frags[i - 1];\n        prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n        if (frag.reused \x26amp;\x26amp; !frag.staggerCb) {\n          currentPrev = findPrevFrag(frag, start, this.id);\n          if (currentPrev !== targetPrev \x26amp;\x26amp; (!currentPrev ||\n          \/\/ optimization for moving a single item.\n          \/\/ thanks to suggestions by @livoras in #1807\n          findPrevFrag(currentPrev, start, this.id) !== targetPrev)) {\n            this.move(frag, prevEl);\n          }\n        } else {\n          \/\/ new instance, or still in stagger.\n          \/\/ insert with updated stagger index.\n          this.insert(frag, insertionIndex\x2b\x2b, prevEl, inDocument);\n        }\n\/\/还原打上的used\n        frag.reused = frag.fresh = false;\n      }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = frags.length; i \x26lt; l; i\x2b\x2b) {\n        frag = frags[i];\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ this is the frag that we should be after\x3c\/span\x3e\n        targetPrev = frags[i - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e];\n        prevEl = targetPrev ? targetPrev.staggerCb ? targetPrev.staggerAnchor : targetPrev.end || targetPrev.node : start;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (frag.reused \x26amp;\x26amp; !frag.staggerCb) {\n          currentPrev = findPrevFrag(frag, start, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id);\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (currentPrev !== targetPrev \x26amp;\x26amp; (!currentPrev ||\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ optimization for moving a single item.\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ thanks to suggestions by @livoras in #1807\x3c\/span\x3e\n          findPrevFrag(currentPrev, start, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id) !== targetPrev)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.move(frag, prevEl);\n          }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ new instance, or still in stagger.\x3c\/span\x3e\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/ insert with updated stagger index.\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.insert(frag, insertionIndex\x2b\x2b, prevEl, inDocument);\n        }\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/还原打上的used\x3c\/span\x3e\n        frag.reused = frag.fresh = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n      }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ekeep-alive\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      Vue.js 为其组件设计了一个 [keep-alive] 的特性，如果这个特性存在，那么在组件被重复创建的时候，会通过缓存机制快速创建组件，以提升视图更新的性能。\n\n          bind: function bind() {\n      if (!this.el.__vue__) {\n        \/\/ keep-alive cache\n        this.keepAlive = this.params.keepAlive;\n        if (this.keepAlive) {\n          this.cache = {};\n        }\n.....\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e      Vue.js 为其组件设计了一个 [keep-alive] 的特性，如果这个特性存在，那么在组件被重复创建的时候，会通过缓存机制快速创建组件，以提升视图更新的性能。\n\n          bind: function bind() {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.el.__vue__) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ keep-alive cache\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.keepAlive = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.params.keepAlive;\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.keepAlive) {\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cache = {};\n        }\n.....\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader2\x22\x3e数据监听机制\x3c\/h3\x3e\n\x3ch4\x3e对象数据监听\x3c\/h4\x3e\n\x3cp\x3e\x27Vue\x27使用\x27Object.defineProperty\x27这个\x27API\x27为想要监听的属性增加了对应的\x27getter\x27和\x27setter\x27,每次数据改变的时候在setter中触发函数\x27dep.notify()\x27,来达到数据监听的效果\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/对要监听的属性使用Object.defineProperty重写get和set函数,增加setter和getter方法\n  Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter() {\n          \/\/增加getter\n          var value = getter ? getter.call(obj) : val;\n          if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n          }\n          if (isArray(value)) {\n            for (var e, i = 0, l = value.length; i \x3c l; i\x2b\x2b) {\n              e = value[i];\n              e \x26amp;\x26amp; e.__ob__ \x26amp;\x26amp; e.__ob__.dep.depend();\n            }\n          }\n        }\n          return value;\n        },\n        set: function reactiveSetter(newVal) {\n          var value = getter ? getter.call(obj) : val;\n          \/\/在属性set value的时候调用!!!\n          if (newVal === value) {\n            return;\n          }\n          \/\/增加setter\n          if (setter) {\n            setter.call(obj, newVal);\n          } else {\n            val = newVal;\n          }\n          childOb = observe(newVal);\n          \/\/最后调用一个自己的函数\n          dep.notify();\n        }\n      });\n\n      然后dep.notify()都做了什么呢?\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/对要监听的属性使用Object.defineProperty重写get和set函数,增加setter和getter方法\x3c\/span\x3e\n  Object.defineProperty(obj, key, {\n        enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3ereactiveGetter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/增加getter\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e = getter ? getter.call(obj) : val;\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n          dep.depend();\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (childOb) {\n            childOb.dep.depend();\n          }\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isArray(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e)) {\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e e, i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e.length; i \x26lt; l; i\x2b\x2b) {\n              e = \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e[i];\n              e \x26amp;\x26amp; e.__ob__ \x26amp;\x26amp; e.__ob__.dep.depend();\n            }\n          }\n        }\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e;\n        },\n        \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3efunction \x3cspan class=\x22hljs-title\x22\x3ereactiveSetter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e) \x3c\/span\x3e{\n          \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e = getter ? getter.call(obj) : val;\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/在属性set value的时候调用!!!\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newVal === \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n          }\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/增加setter\x3c\/span\x3e\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (setter) {\n            setter.call(obj, newVal);\n          } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            val = newVal;\n          }\n          childOb = observe(newVal);\n          \x3cspan class=\x22hljs-comment\x22\x3e\/\/最后调用一个自己的函数\x3c\/span\x3e\n          dep.notify();\n        }\n      });\n\n      然后dep.notify()都做了什么呢?\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  Dep.prototype.notify = function () {\n    \/\/ stablize the subscriber list first\n    var subs = toArray(this.subs)\n    for (var i = 0, l = subs.length; i \x3c l; i\x2b\x2b) {\n      \/\/对相应的数据进行更新\n      subs[i].update()\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e  Dep.prototype.notify = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ stablize the subscriber list first\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e subs = toArray(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs)\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, l = subs.length; i \x26lt; l; i\x2b\x2b) {\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/对相应的数据进行更新\x3c\/span\x3e\n      subs[i].update()\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      dep在文档里面定义是:\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e      dep在文档里面定义是:\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/A dep is an observable that can have multiple\n  \/\/directives subscribing to it.\n  export default function Dep () {\n    this.id = uid\x2b\x2b\n    this.subs = []\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/A dep is an observable that can have multiple\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/directives subscribing to it.\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eDep\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.id = uid\x2b\x2b\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subs = []\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x27dep\x27是维护数据的一个数组,对应着一个\x27watcher\x27对象\x3c\/p\x3e\n\x3cp\x3e所以整个数据监听的完成是靠set给属性提供一个setter然后当数据更新时,dep会触发watcher对象,返回新值.\x3c\/p\x3e\n\x3cp\x3e之后会有更详细解释\x3c\/p\x3e\n\x3cp\x3e数组可能会有点麻烦，Vue.js 采取的是对几乎每一个可能改变数据的方法进行 prototype 更改：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22;[\x27push\x27, \x27pop\x27, \x27shift\x27, \x27unshift\x27, \x27splice\x27, \x27sort\x27, \x27reverse\x27].forEach(function (method) {\n    \/\/ cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n      \/\/ avoid leaking arguments:\n      \/\/ http:\/\/jsperf.com\/closure-with-arguments\n      var i = arguments.length;\n      var args = new Array(i);\n      while (i--) {\n        args[i] = arguments[i];\n      }\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case \x27push\x27:\n          inserted = args;\n          break;\n        case \x27unshift\x27:\n          inserted = args;\n          break;\n        case \x27splice\x27:\n          inserted = args.slice(2);\n          break;\n      }\n      if (inserted) ob.observeArray(inserted);\n      \/\/ notify change\n      ob.dep.notify();\n      return result;\n    });\n  });\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e;[\x3cspan class=\x22hljs-string\x22\x3e\x27push\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27pop\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27shift\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27unshift\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27splice\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27sort\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27reverse\x27\x3c\/span\x3e].forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3emethod\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ cache original method\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e original = arrayProto[method];\n    def(arrayMethods, method, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emutator\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ avoid leaking arguments:\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ http:\/\/jsperf.com\/closure-with-arguments\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e.length;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e args = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e(i);\n      \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n        args[i] = \x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e[i];\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = original.apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, args);\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e ob = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.__ob__;\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e inserted;\n      \x3cspan class=\x22hljs-keyword\x22\x3eswitch\x3c\/span\x3e (method) {\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27push\x27\x3c\/span\x3e:\n          inserted = args;\n          \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27unshift\x27\x3c\/span\x3e:\n          inserted = args;\n          \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-keyword\x22\x3ecase\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27splice\x27\x3c\/span\x3e:\n          inserted = args.slice(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n          \x3cspan class=\x22hljs-keyword\x22\x3ebreak\x3c\/span\x3e;\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (inserted) ob.observeArray(inserted);\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ notify change\x3c\/span\x3e\n      ob.dep.notify();\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n    });\n  });\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e同时 Vue.js 提供了两个额外的“糖方法” $set 和 $remove 来弥补这方面限制带来的不便。\x3c\/p\x3e\n\x3cp\x3e但这个策略主要面临两个问题：\x3c\/p\x3e\n\x3cp\x3e无法监听数据的 length，导致 arr.length 这样的数据改变无法被监听\x3cbr\x3e通过角标更改数据，即类似 arr[2] = 1 这样的赋值操作，也无法被监听\x3c\/p\x3e\n\x3cp\x3e为此 Vue.js 在文档中明确提示不建议直接角标修改数据\x3c\/p\x3e\n\x3cp\x3e\x22实例计算属性。getter 和 setter 的 this 自动地绑定到实例。\x22\x3c\/p\x3e\n\x3cp\x3e举个栗子:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var vm = new Vue({\n  data: { a: 1 },\n  computed: {\n    \/\/ 仅读取，值只须为函数\n    b: function () {\n      return this.a * 2\n    },\n    \/\/ 读取和设置\n    c: {\n      get: function () {\n        return this.a \x2b 1\n      },\n      set: function (v) {\n        this.a = v - 1\n      }\n    }\n  }\n  })\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vm = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Vue({\n  data: { a: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e },\n  computed: {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 仅读取，值只须为函数\x3c\/span\x3e\n    b: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a * \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n    },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 读取和设置\x3c\/span\x3e\n    c: {\n      \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n      },\n      \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(v)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.a = v - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e\n      }\n    }\n  }\n  })\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看出来computed可以提供自定义一个属性c的getter和setter\/b的getter,问题是c和b怎么维护和a的关系\x3c\/p\x3e\n\x3cp\x3e下面是computed怎么提供属性setter和getter的代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/初始化computed\n  ...\n  var userDef = computed[key];\n  \/\/userDef指的是computed属性,this -\x3e computed\n  def.get = makeComputedGetter(userDef, this);\n  \/\/或者makeComputedGetter(userDef.get, this)\n  ...\n  function makeComputedGetter(getter, owner) {\n      var watcher = new Watcher(owner, getter, null, {\n        lazy: true\n      });\n      return function computedGetter() {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value;\n      };\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e  \x3cspan class=\x22hljs-comment\x22\x3e\/\/初始化computed\x3c\/span\x3e\n  ...\n  \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e userDef = computed[key];\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/userDef指的是computed属性,this -\x26gt; computed\x3c\/span\x3e\n  def.get = makeComputedGetter(userDef, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/或者makeComputedGetter(userDef.get, this)\x3c\/span\x3e\n  ...\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emakeComputedGetter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3egetter, owner\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(owner, getter, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, {\n        \x3cspan class=\x22hljs-attribute\x22\x3elazy\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n      });\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecomputedGetter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (watcher.dirty) {\n          watcher.evaluate();\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n          watcher.depend();\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e watcher.value;\n      };\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ecomputed在建立的时候绑定一个对应的 watcher 对象，在计算过程中它把属性记录为依赖。之后当依赖的 setter 被调用时，会触发 watcher 重新计算 ，也就会导致它的关联指令更新 DOM。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e视图解析过程\x3c\/h3\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e解析器\x3c\/h3\x3e\n\x3cp\x3eparsers\/path.js 主要的职责是可以把一个 JSON 数据里的某一个“路径”下的数据取出来，比如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var path = \x27a.b[1].v\x27\nvar obj = {\n  a: {\n    b: [\n      {v: 1},\n      {v: 2},\n      {v: 3}\n    ]\n  }\n}\nparse(obj, path) \/\/ 2\n\nvar pathStateMachine = []\n\npathStateMachine[BEFORE_PATH] = {\n  \x27ws\x27: [BEFORE_PATH],\n  \x27ident\x27: [IN_IDENT, APPEND],\n  \x27[\x27: [IN_SUB_PATH],\n  \x27eof\x27: [AFTER_PATH]\n}\n\npathStateMachine[IN_PATH] = {\n  \x27ws\x27: [IN_PATH],\n  \x27.\x27: [BEFORE_IDENT],\n  \x27[\x27: [IN_SUB_PATH],\n  \x27eof\x27: [AFTER_PATH]\n}\n\npathStateMachine[BEFORE_IDENT] = {\n  \x27ws\x27: [BEFORE_IDENT],\n  \x27ident\x27: [IN_IDENT, APPEND]\n}\n\npathStateMachine[IN_IDENT] = {\n  \x27ident\x27: [IN_IDENT, APPEND],\n  \x270\x27: [IN_IDENT, APPEND],\n  \x27number\x27: [IN_IDENT, APPEND],\n  \x27ws\x27: [IN_PATH, PUSH],\n  \x27.\x27: [BEFORE_IDENT, PUSH],\n  \x27[\x27: [IN_SUB_PATH, PUSH],\n  \x27eof\x27: [AFTER_PATH, PUSH]\n}\n\npathStateMachine[IN_SUB_PATH] = {\n  \x26quot;\x27\x26quot;: [IN_SINGLE_QUOTE, APPEND],\n  \x27\x26quot;\x27: [IN_DOUBLE_QUOTE, APPEND],\n  \x27[\x27: [IN_SUB_PATH, INC_SUB_PATH_DEPTH],\n  \x27]\x27: [IN_PATH, PUSH_SUB_PATH],\n  \x27eof\x27: ERROR,\n  \x27else\x27: [IN_SUB_PATH, APPEND]\n}\n\npathStateMachine[IN_SINGLE_QUOTE] = {\n  \x26quot;\x27\x26quot;: [IN_SUB_PATH, APPEND],\n  \x27eof\x27: ERROR,\n  \x27else\x27: [IN_SINGLE_QUOTE, APPEND]\n}\n\npathStateMachine[IN_DOUBLE_QUOTE] = {\n  \x27\x26quot;\x27: [IN_SUB_PATH, APPEND],\n  \x27eof\x27: ERROR,\n  \x27else\x27: [IN_DOUBLE_QUOTE, APPEND]\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs prolog\x22\x3e\x3ccode\x3evar path = \x3cspan class=\x22hljs-string\x22\x3e\x27a.b[1].v\x27\x3c\/span\x3e\nvar obj = {\n  a: {\n    b: [\n      {v: \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e},\n      {v: \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e},\n      {v: \x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e}\n    ]\n  }\n}\nparse(obj, path) \/\/ \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n\nvar pathStateMachine = []\n\npathStateMachine[\x3cspan class=\x22hljs-symbol\x22\x3eBEFORE_PATH\x3c\/span\x3e] = {\n  \x3cspan class=\x22hljs-string\x22\x3e\x27ws\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eBEFORE_PATH\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27ident\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_IDENT\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27[\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_SUB_PATH\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27eof\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eAFTER_PATH\x3c\/span\x3e]\n}\n\npathStateMachine[\x3cspan class=\x22hljs-symbol\x22\x3eIN_PATH\x3c\/span\x3e] = {\n  \x3cspan class=\x22hljs-string\x22\x3e\x27ws\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_PATH\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eBEFORE_IDENT\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27[\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_SUB_PATH\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27eof\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eAFTER_PATH\x3c\/span\x3e]\n}\n\npathStateMachine[\x3cspan class=\x22hljs-symbol\x22\x3eBEFORE_IDENT\x3c\/span\x3e] = {\n  \x3cspan class=\x22hljs-string\x22\x3e\x27ws\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eBEFORE_IDENT\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27ident\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_IDENT\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e]\n}\n\npathStateMachine[\x3cspan class=\x22hljs-symbol\x22\x3eIN_IDENT\x3c\/span\x3e] = {\n  \x3cspan class=\x22hljs-string\x22\x3e\x27ident\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_IDENT\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x270\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_IDENT\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27number\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_IDENT\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27ws\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_PATH\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3ePUSH\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27.\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eBEFORE_IDENT\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3ePUSH\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27[\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_SUB_PATH\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3ePUSH\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27eof\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eAFTER_PATH\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3ePUSH\x3c\/span\x3e]\n}\n\npathStateMachine[\x3cspan class=\x22hljs-symbol\x22\x3eIN_SUB_PATH\x3c\/span\x3e] = {\n  \x3cspan class=\x22hljs-string\x22\x3e\x22\x27\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_SINGLE_QUOTE\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27\x22\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_DOUBLE_QUOTE\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27[\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_SUB_PATH\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eINC_SUB_PATH_DEPTH\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27]\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_PATH\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3ePUSH_SUB_PATH\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27eof\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-symbol\x22\x3eERROR\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27else\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_SUB_PATH\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e]\n}\n\npathStateMachine[\x3cspan class=\x22hljs-symbol\x22\x3eIN_SINGLE_QUOTE\x3c\/span\x3e] = {\n  \x3cspan class=\x22hljs-string\x22\x3e\x22\x27\x22\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_SUB_PATH\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27eof\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-symbol\x22\x3eERROR\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27else\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_SINGLE_QUOTE\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e]\n}\n\npathStateMachine[\x3cspan class=\x22hljs-symbol\x22\x3eIN_DOUBLE_QUOTE\x3c\/span\x3e] = {\n  \x3cspan class=\x22hljs-string\x22\x3e\x27\x22\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_SUB_PATH\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e],\n  \x3cspan class=\x22hljs-string\x22\x3e\x27eof\x27\x3c\/span\x3e: \x3cspan class=\x22hljs-symbol\x22\x3eERROR\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-string\x22\x3e\x27else\x27\x3c\/span\x3e: [\x3cspan class=\x22hljs-symbol\x22\x3eIN_DOUBLE_QUOTE\x3c\/span\x3e, \x3cspan class=\x22hljs-symbol\x22\x3eAPPEND\x3c\/span\x3e]\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e状态机可以完成\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221.dom结构中\x22{{\x22data.someObj\x22}}\x22的解析;\n2.对字符型json的取值;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs abnf\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e.dom结构中\x22{{\x22data.someObj\x22}}\x22的解析\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e.对字符型json的取值\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可惜大学里面的编译原理我给忘记了,否则可以给大家解析一下.\x3c\/p\x3e\n\x3ch4\x3e视图解析过程\x3c\/h4\x3e\n\x3cp\x3e视图的解析过程，Vue.js 的策略是把 element 或 template string 先统一转换成 document fragment，然后再分解和解析其中的子组件和 directives。\x3c\/p\x3e\n\x3cp\x3e相比React的visual DOM有一定的性能优化空间，毕竟 DOM 操作相比纯 JavaScript 运算还是会慢一些。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3eVue扩展\x3c\/h3\x3e\n\x3ch4\x3eMixin\x3c\/h4\x3e\n\x3cp\x3eMixin (混入) 是一种可以在多个 Vue 组件之间灵活复用特性的机制。你可以像写一个普通 Vue 组件的选项对象一样编写一个 mixin：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log(\x27hello from mixin!\x27)\n    }\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3ecreated\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hello()\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3ehello\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27hello from mixin!\x27\x3c\/span\x3e)\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ test.js\nvar myMixin = require(\x27.\/mixin\x27)\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\nvar component = new Component() \/\/ -\x3e \x26quot;hello from mixin!\x26quot;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ test.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e myMixin = require(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/mixin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e Component = Vue.extend({\n  mixins: [myMixin]\n})\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e component = new Component() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -\x26gt; \x22hello from mixin!\x22\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eVue插件\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue插件类型分为以下几种:\n\n1.添加一个或几个全局方法。比如 vue-element\n2.添加一个或几个全局资源：指令、过滤器、动画效果等。比如\nvue-touch\n3.通过绑定到 Vue.prototype 的方式添加一些 Vue 实例方法。这里有个约定，就是 Vue 的实例方法应该带有 $ 前缀，这样就不会和用户的数据和方法产生冲突了。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e插件类型分为以下几种:\n\n\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e添加一个或几个全局方法。比如 vue-element\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e添加一个或几个全局资源：指令、过滤器、动画效果等。比如\n\x3cspan class=\x22hljs-title\x22\x3evue\x3c\/span\x3e-touch\n\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3e通过绑定到 \x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e.proto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e 的方式添加一些 \x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e 实例方法。这里有个约定，就是 \x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e 的实例方法应该带有 $ 前缀，这样就不会和用户的数据和方法产生冲突了。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e开发Vue插件\x3c\/h5\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22MyPlugin.install = function (Vue, options) {\n\/\/ 1. 添加全局方法或属性\nVue.myGlobalMethod = ...\n\/\/ 2. 添加全局资源\nVue.directive(\x27my-directive\x27, {})\n\/\/ 3. 添加实例方法\nVue.prototype.$myMethod = ...\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3eMyPlugin\x3cspan class=\x22hljs-selector-class\x22\x3e.install\x3c\/span\x3e = function (Vue, options) {\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1. 添加全局方法或属性\x3c\/span\x3e\nVue\x3cspan class=\x22hljs-selector-class\x22\x3e.myGlobalMethod\x3c\/span\x3e = ...\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2. 添加全局资源\x3c\/span\x3e\nVue.directive(\x3cspan class=\x22hljs-string\x22\x3e\x27my-directive\x27\x3c\/span\x3e, {})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3. 添加实例方法\x3c\/span\x3e\nVue\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e.\x3cspan class=\x22hljs-variable\x22\x3e$myMethod\x3c\/span\x3e = ...\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e使用Vue插件\x3c\/h5\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var vueTouch = require(\x27vue-touch\x27)\n\/\/ use the plugin globally\nVue.use(vueTouch)\n你也可以向插件里传递额外的选项：\n\nVue.use(require(\x27my-plugin\x27), {\n\/* pass in additional options *\/\n})\n\n全局方法:\nVue.fun()\n局部方法:\nvm.$fun()\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vueTouch = require(\x3cspan class=\x22hljs-string\x22\x3e\x27vue-touch\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ use the plugin globally\x3c\/span\x3e\nVue.use(vueTouch)\n你也可以向插件里传递额外的选项：\n\nVue.use(require(\x3cspan class=\x22hljs-string\x22\x3e\x27my-plugin\x27\x3c\/span\x3e), {\n\x3cspan class=\x22hljs-comment\x22\x3e\/* pass in additional options *\/\x3c\/span\x3e\n})\n\n全局方法:\nVue.\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e()\n局部方法:\nvm.$\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eVue指令\x3c\/h4\x3e\n\x3cp\x3eVue.js 允许注册自定义指令，实质上是开放 Vue 一些技巧：怎样将数据的变化映射到 DOM 的行为。你可以使用 Vue.directive(id, definition) 的方法传入指令 id 和定义对象来注册一个全局自定义指令。定义对象需要提供一些钩子函数：\x3cbr\x3ebind： 仅调用一次，当指令第一次绑定元素的时候。\x3cbr\x3eupdate： 第一次是紧跟在 bind 之后调用，获得的参数是绑定的初始值；以后每当绑定的值发生变化就会被调用，获得新值与旧值两个参数。\x3cbr\x3eunbind：仅调用一次，当指令解绑元素的时候。\x3c\/p\x3e\n\x3cp\x3e一旦注册好自定义指令，你就可以在 Vue.js 模板中像这样来使用它（需要添加 Vue.js 的指令前缀，默认为 \x3ccode\x3ev-\x3c\/code\x3e）：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;div v-my-directive=\x22someValue\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e如果你只需要 \x3ccode\x3eupdate\x3c\/code\x3e 函数，你可以只传入一个函数，而不用传定义对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/ 这个函数会被作为 update() 函数使用\n})```\n\n所有的钩子函数会被复制到实际的**指令对象**中，而这个指令对象将会是所有钩子函数的 `this` 上下文环境。指令对象上暴露了一些有用的公开属性：\n\n- **el**： 指令绑定的元素\n- **vm**： 拥有该指令的上下文 ViewModel\n- **expression**： 指令的表达式，不包括参数和过滤器\n- **arg**： 指令的参数\n- **raw**： 未被解析的原始表达式\n- **name**： 不带前缀的指令名\n\n\x3e这些属性是只读的，不要修改它们。你也可以给指令对象附加自定义的属性，但是注意不要覆盖已有的内部属性。\n\n使用指令对象属性的示例：\n\n`\x3cdiv id=\x26quot;demo\x26quot; v-demo=\x26quot;LightSlateGray : msg\x26quot;\x3e\x3c\/div\x3e`\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs asciidoc\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-code\x22\x3e  \/\/ 这个函数会被作为 update() 函数使用\x3c\/span\x3e\n})\x3cspan class=\x22hljs-code\x22\x3e```\x3c\/span\x3e\n\n所有的钩子函数会被复制到实际的*\x3cspan class=\x22hljs-strong\x22\x3e*指令对象*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*中，而这个指令对象将会是所有钩子函数的 `this` 上下文环境。指令对象上暴露了一些有用的公开属性：\n\n\x3c\/span\x3e\x3cspan class=\x22hljs-bullet\x22\x3e- \x3c\/span\x3e*\x3cspan class=\x22hljs-strong\x22\x3e*el*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 指令绑定的元素\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*vm*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 拥有该指令的上下文 ViewModel\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*expression*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 指令的表达式，不包括参数和过滤器\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*arg*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 指令的参数\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*raw*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 未被解析的原始表达式\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*name*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 不带前缀的指令名\n\n\x3c\/span\x3e\x26gt;这些属性是只读的，不要修改它们。你也可以给指令对象附加自定义的属性，但是注意不要覆盖已有的内部属性。\n\n使用指令对象属性的示例：\n\n\x3cspan class=\x22hljs-code\x22\x3e`\x26lt;div id=\x22demo\x22 v-demo=\x22LightSlateGray : msg\x22\x26gt;\x26lt;\/div\x26gt;`\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ebind: function () {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.el.style.color = \x27#fff\x27\nthis.el.style.backgroundColor = this.arg\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3ethis\x3cspan class=\x22hljs-selector-class\x22\x3e.el\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.style\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.color\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27#fff\x27\x3c\/span\x3e\nthis\x3cspan class=\x22hljs-selector-class\x22\x3e.el\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.style\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.backgroundColor\x3c\/span\x3e = this.arg\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e},\x3cbr\x3e  update: function (value) {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.el.innerHTML =\n  \x27name - \x27       \x2b this.name \x2b \x27\x3cbr\x3e\x27 \x2b\n  \x27raw - \x27        \x2b this.raw \x2b \x27\x3cbr\x3e\x27 \x2b\n  \x27expression - \x27 \x2b this.expression \x2b \x27\x3cbr\x3e\x27 \x2b\n  \x27argument - \x27   \x2b this.arg \x2b \x27\x3cbr\x3e\x27 \x2b\n  \x27value - \x27      \x2b value\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3ethis\x3cspan class=\x22hljs-selector-class\x22\x3e.el\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.innerHTML\x3c\/span\x3e =\n  \x3cspan class=\x22hljs-string\x22\x3e\x27name - \x27\x3c\/span\x3e       \x2b this\x3cspan class=\x22hljs-selector-class\x22\x3e.name\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;br\x26gt;\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27raw - \x27\x3c\/span\x3e        \x2b this\x3cspan class=\x22hljs-selector-class\x22\x3e.raw\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;br\x26gt;\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27expression - \x27\x3c\/span\x3e \x2b this\x3cspan class=\x22hljs-selector-class\x22\x3e.expression\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;br\x26gt;\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27argument - \x27\x3c\/span\x3e   \x2b this\x3cspan class=\x22hljs-selector-class\x22\x3e.arg\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;br\x26gt;\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27value - \x27\x3c\/span\x3e      \x2b value\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3cbr\x3evar demo = new Vue({\x3cbr\x3e  el: \x27#demo\x27,\x3cbr\x3e  data: {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22msg: \x27hello!\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3emsg:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27hello!\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3ccode\x3e`\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eResult\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ename - demo\x3c\/li\x3e\n\x3cli\x3eraw - LightSlateGray：msg\x3c\/li\x3e\n\x3cli\x3eexpression - msg\x3c\/li\x3e\n\x3cli\x3eargument - LightSlateGray\x3c\/li\x3e\n\x3cli\x3evalue - hello!\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader6\x22\x3e多重从句\x3c\/h3\x3e\n\x3cp\x3e同一个特性内部，逗号分隔的多个从句将被绑定为多个指令实例。在下面的例子中，指令会被创建和调用两次：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;div v-demo=\x22color: \x27white\x27, text: \x27hello!\x27\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e如果想要用单个指令实例处理多个参数，可以利用字面量对象作为表达式：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;div v-demo=\x22{color: \x27white\x27, text: \x27hello!\x27}\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  console.log(value) \/\/ Object {color: \x27white\x27, text: \x27hello!\x27}\n})```\n\n## 字面指令\n\n如果在创建自定义指令的时候传入 `isLiteral: true`，那么特性值就会被看成直接字符串，并被赋值给该指令的 `expression`。字面指令不会试图建立数据监视。\n\n**Example**：\n\n`\x3cdiv v-literal-dir=\x26quot;foo\x26quot;\x3e\x3c\/div\x3e`\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e  console.log(value) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Object {color: \x27white\x27, text: \x27hello!\x27}\x3c\/span\x3e\n})```\n\n## 字面指令\n\n如果在创建自定义指令的时候传入 `isLiteral: true`，那么特性值就会被看成直接字符串，并被赋值给该指令的 `expression`。字面指令不会试图建立数据监视。\n\n**Example**：\n\n`\x26lt;div v-literal-dir=\x3cspan class=\x22hljs-string\x22\x3e\x22foo\x22\x3c\/span\x3e\x26gt;\x26lt;\/div\x26gt;`\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eisLiteral: true,\x3cbr\x3e  bind: function () {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(this.expression) \/\/ \x27foo\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expression) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27foo\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3ccode\x3e`\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3e动态字面指令\x3c\/h3\x3e\n\x3cp\x3e然而，在字面指令含有 \x3ccode\x3eMustache\x3c\/code\x3e 标签的情形下，指令的行为如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e指令实例会有一个属性，\x3ccode\x3ethis._isDynamicLiteral\x3c\/code\x3e 被设为 \x3ccode\x3etrue\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3e如果没有提供 \x3ccode\x3eupdate\x3c\/code\x3e 函数，\x3ccode\x3eMustache\x3c\/code\x3e 表达式只会被求值一次，并将该值赋给 \x3ccode\x3ethis.expression\x3c\/code\x3e 。不会对表达式进行数据监视。\x3c\/li\x3e\n\x3cli\x3e如果提供了 \x3ccode\x3eupdate\x3c\/code\x3e 函数，指令将会为表达式建立一个数据监视，并且在计算结果变化的时候调用 \x3ccode\x3eupdate\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e双向指令\x3c\/h2\x3e\n\x3cp\x3e如果你的指令想向 Vue 实例写回数据，你需要传入 \x3ccode\x3etwoWay: true\x3c\/code\x3e 。该选项允许在指令中使用 \x3ccode\x3ethis.set(value)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  twoWay: true,\n  bind: function () {\n    this.handler = function () {\n      \/\/ 把数据写回 vm\n      \/\/ 如果指令这样绑定 v-example=\x26quot;a.b.c\x26quot;,\n      \/\/ 这里将会给 `vm.a.b.c` 赋值\n      this.set(this.el.value)\n    }.bind(this)\n    this.el.addEventListener(\x27input\x27, this.handler)\n  },\n  unbind: function () {\n    this.el.removeEventListener(\x27input\x27, this.handler)\n  }\n})```\n\n## 内联语句\n\n传入 `acceptStatement: true` 可以让自定义指令像 `v-on` 一样接受内联语句：\n\n`\x3cdiv v-my-directive=\x26quot;a\x2b\x2b\x26quot;\x3e\x3c\/div\x3e`\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  twoWay: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ebind\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handler = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把数据写回 vm\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果指令这样绑定 v-example=\x22a.b.c\x22,\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里将会给 `vm.a.b.c` 赋值\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.set(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.el.value)\n    }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.el.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handler)\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eunbind\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.el.removeEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handler)\n  }\n})\x3cspan class=\x22hljs-string\x22\x3e``\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e`\n\n## 内联语句\n\n传入 `\x3c\/span\x3eacceptStatement: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e` 可以让自定义指令像 `\x3c\/span\x3ev-on\x3cspan class=\x22hljs-string\x22\x3e` 一样接受内联语句：\n\n`\x3c\/span\x3e\x26lt;div v-my-directive=\x3cspan class=\x22hljs-string\x22\x3e\x22a\x2b\x2b\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e`\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eacceptStatement: true,\x3cbr\x3e  update: function (fn) {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ the passed in value is a function which when called,\n\/\/ will execute the \x26quot;a\x2b\x2b\x26quot; statement in the owner vm\x27s\n\/\/ scope.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode\x3e\/\/ \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e passed \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evalue\x3c\/span\x3e is \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewhich\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewhen\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecalled\x3c\/span\x3e,\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\n\/\/ will execute the \x22a\x2b\x2b\x22 statement in the owner vm\x27s\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\n\/\/ scope.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3ccode\x3e`\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e但是请明智地使用此功能，因为通常我们希望避免在模板中产生副作用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e深度数据观察\x3c\/h2\x3e\n\x3cp\x3e如果你希望在一个对象上使用自定义指令，并且当对象内部嵌套的属性发生变化时也能够触发指令的 \x3ccode\x3eupdate\x3c\/code\x3e 函数，那么你就要在指令的定义中传入 \x3ccode\x3edeep: true\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;div v-my-directive=\x22obj\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  deep: true,\n  update: function (obj) {\n    \/\/ 当 obj 内部嵌套的属性变化时也会调用此函数\n  }\n})```\n\n## 指令优先级\n\n你可以选择给指令提供一个优先级数（默认是 0）。同一个元素上优先级越高的指令会比其他的指令处理得早一些。优先级一样的指令会按照其在元素特性列表中出现的顺序依次处理，但是不能保证这个顺序在不同的浏览器中是一致的。\n\n通常来说作为用户，你并不需要关心内置指令的优先级，如果你感兴趣的话，可以参阅源码。逻辑控制指令 `v-repeat`， `v-if` 被视为 “终结性指令”，它们在编译过程中始终拥有最高的优先级。\n\n## 元素指令\n\n有时候，我们可能想要我们的指令可以以自定义元素的形式被使用，而不是作为一个特性。这与 `Angular` 的 `E` 类指令的概念非常相似。元素指令可以看做是一个轻量的自定义组件（后面会讲到）。你可以像下面这样注册一个自定义的元素指令：\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e  deep: true,\n  update: function (obj) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当 obj 内部嵌套的属性变化时也会调用此函数\x3c\/span\x3e\n  }\n})```\n\n## 指令优先级\n\n你可以选择给指令提供一个优先级数（默认是 \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e）。同一个元素上优先级越高的指令会比其他的指令处理得早一些。优先级一样的指令会按照其在元素特性列表中出现的顺序依次处理，但是不能保证这个顺序在不同的浏览器中是一致的。\n\n通常来说作为用户，你并不需要关心内置指令的优先级，如果你感兴趣的话，可以参阅源码。逻辑控制指令 `v-repeat`， `v-\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e` 被视为 “终结性指令”，它们在编译过程中始终拥有最高的优先级。\n\n## 元素指令\n\n有时候，我们可能想要我们的指令可以以自定义元素的形式被使用，而不是作为一个特性。这与 `Angular` 的 `E` 类指令的概念非常相似。元素指令可以看做是一个轻量的自定义组件（后面会讲到）。你可以像下面这样注册一个自定义的元素指令：\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\/\/ 和普通指令的 API 一致\x3cbr\x3e  bind: function () {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 对 this.el 进行操作...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对 this.el 进行操作...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eVue扩展\x3c\/h3\x3e\n\x3ch4\x3eMixin\x3c\/h4\x3e\n\x3cp\x3eMixin (混入) 是一种可以在多个 Vue 组件之间灵活复用特性的机制。你可以像写一个普通 Vue 组件的选项对象一样编写一个 mixin：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22module.exports = {\n  created: function () {\n    this.hello()\n  },\n  methods: {\n    hello: function () {\n      console.log(\x27hello from mixin!\x27)\n    }\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n  \x3cspan class=\x22hljs-attr\x22\x3ecreated\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.hello()\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3emethods\x3c\/span\x3e: {\n    \x3cspan class=\x22hljs-attr\x22\x3ehello\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27hello from mixin!\x27\x3c\/span\x3e)\n    }\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ test.js\nvar myMixin = require(\x27.\/mixin\x27)\nvar Component = Vue.extend({\n  mixins: [myMixin]\n})\nvar component = new Component() \/\/ -\x3e \x26quot;hello from mixin!\x26quot;\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ test.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e myMixin = require(\x3cspan class=\x22hljs-string\x22\x3e\x27.\/mixin\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e Component = Vue.extend({\n  mixins: [myMixin]\n})\n\x3cspan class=\x22hljs-selector-tag\x22\x3evar\x3c\/span\x3e component = new Component() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ -\x26gt; \x22hello from mixin!\x22\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eVue插件\x3c\/h4\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Vue插件类型分为以下几种:\n\n1.添加一个或几个全局方法。比如 vue-element\n2.添加一个或几个全局资源：指令、过滤器、动画效果等。比如\nvue-touch\n3.通过绑定到 Vue.prototype 的方式添加一些 Vue 实例方法。这里有个约定，就是 Vue 的实例方法应该带有 $ 前缀，这样就不会和用户的数据和方法产生冲突了。\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs elm\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e插件类型分为以下几种:\n\n\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e添加一个或几个全局方法。比如 vue-element\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3e添加一个或几个全局资源：指令、过滤器、动画效果等。比如\n\x3cspan class=\x22hljs-title\x22\x3evue\x3c\/span\x3e-touch\n\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3e通过绑定到 \x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e.proto\x3cspan class=\x22hljs-keyword\x22\x3etype\x3c\/span\x3e 的方式添加一些 \x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e 实例方法。这里有个约定，就是 \x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e 的实例方法应该带有 $ 前缀，这样就不会和用户的数据和方法产生冲突了。\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e开发Vue插件\x3c\/h5\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22MyPlugin.install = function (Vue, options) {\n\/\/ 1. 添加全局方法或属性\nVue.myGlobalMethod = ...\n\/\/ 2. 添加全局资源\nVue.directive(\x27my-directive\x27, {})\n\/\/ 3. 添加实例方法\nVue.prototype.$myMethod = ...\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3eMyPlugin\x3cspan class=\x22hljs-selector-class\x22\x3e.install\x3c\/span\x3e = function (Vue, options) {\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1. 添加全局方法或属性\x3c\/span\x3e\nVue\x3cspan class=\x22hljs-selector-class\x22\x3e.myGlobalMethod\x3c\/span\x3e = ...\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 2. 添加全局资源\x3c\/span\x3e\nVue.directive(\x3cspan class=\x22hljs-string\x22\x3e\x27my-directive\x27\x3c\/span\x3e, {})\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 3. 添加实例方法\x3c\/span\x3e\nVue\x3cspan class=\x22hljs-selector-class\x22\x3e.prototype\x3c\/span\x3e.\x3cspan class=\x22hljs-variable\x22\x3e$myMethod\x3c\/span\x3e = ...\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e使用Vue插件\x3c\/h5\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var vueTouch = require(\x27vue-touch\x27)\n\/\/ use the plugin globally\nVue.use(vueTouch)\n你也可以向插件里传递额外的选项：\n\nVue.use(require(\x27my-plugin\x27), {\n\/* pass in additional options *\/\n})\n\n全局方法:\nVue.fun()\n局部方法:\nvm.$fun()\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vueTouch = require(\x3cspan class=\x22hljs-string\x22\x3e\x27vue-touch\x27\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ use the plugin globally\x3c\/span\x3e\nVue.use(vueTouch)\n你也可以向插件里传递额外的选项：\n\nVue.use(require(\x3cspan class=\x22hljs-string\x22\x3e\x27my-plugin\x27\x3c\/span\x3e), {\n\x3cspan class=\x22hljs-comment\x22\x3e\/* pass in additional options *\/\x3c\/span\x3e\n})\n\n全局方法:\nVue.\x3cspan class=\x22hljs-keyword\x22\x3efun\x3c\/span\x3e()\n局部方法:\nvm.$\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3efun\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch4\x3eVue指令\x3c\/h4\x3e\n\x3cp\x3eVue.js 允许注册自定义指令，实质上是开放 Vue 一些技巧：怎样将数据的变化映射到 DOM 的行为。你可以使用 Vue.directive(id, definition) 的方法传入指令 id 和定义对象来注册一个全局自定义指令。定义对象需要提供一些钩子函数：\x3cbr\x3ebind： 仅调用一次，当指令第一次绑定元素的时候。\x3cbr\x3eupdate： 第一次是紧跟在 bind 之后调用，获得的参数是绑定的初始值；以后每当绑定的值发生变化就会被调用，获得新值与旧值两个参数。\x3cbr\x3eunbind：仅调用一次，当指令解绑元素的时候。\x3c\/p\x3e\n\x3cp\x3e一旦注册好自定义指令，你就可以在 Vue.js 模板中像这样来使用它（需要添加 Vue.js 的指令前缀，默认为 \x3ccode\x3ev-\x3c\/code\x3e）：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;div v-my-directive=\x22someValue\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e如果你只需要 \x3ccode\x3eupdate\x3c\/code\x3e 函数，你可以只传入一个函数，而不用传定义对象：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  \/\/ 这个函数会被作为 update() 函数使用\n})```\n\n所有的钩子函数会被复制到实际的**指令对象**中，而这个指令对象将会是所有钩子函数的 `this` 上下文环境。指令对象上暴露了一些有用的公开属性：\n\n- **el**： 指令绑定的元素\n- **vm**： 拥有该指令的上下文 ViewModel\n- **expression**： 指令的表达式，不包括参数和过滤器\n- **arg**： 指令的参数\n- **raw**： 未被解析的原始表达式\n- **name**： 不带前缀的指令名\n\n\x3e这些属性是只读的，不要修改它们。你也可以给指令对象附加自定义的属性，但是注意不要覆盖已有的内部属性。\n\n使用指令对象属性的示例：\n\n`\x3cdiv id=\x26quot;demo\x26quot; v-demo=\x26quot;LightSlateGray : msg\x26quot;\x3e\x3c\/div\x3e`\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs asciidoc\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-code\x22\x3e  \/\/ 这个函数会被作为 update() 函数使用\x3c\/span\x3e\n})\x3cspan class=\x22hljs-code\x22\x3e```\x3c\/span\x3e\n\n所有的钩子函数会被复制到实际的*\x3cspan class=\x22hljs-strong\x22\x3e*指令对象*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*中，而这个指令对象将会是所有钩子函数的 `this` 上下文环境。指令对象上暴露了一些有用的公开属性：\n\n\x3c\/span\x3e\x3cspan class=\x22hljs-bullet\x22\x3e- \x3c\/span\x3e*\x3cspan class=\x22hljs-strong\x22\x3e*el*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 指令绑定的元素\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*vm*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 拥有该指令的上下文 ViewModel\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*expression*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 指令的表达式，不包括参数和过滤器\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*arg*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 指令的参数\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*raw*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 未被解析的原始表达式\n- *\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*name*\x3c\/span\x3e\x3cspan class=\x22hljs-strong\x22\x3e*： 不带前缀的指令名\n\n\x3c\/span\x3e\x26gt;这些属性是只读的，不要修改它们。你也可以给指令对象附加自定义的属性，但是注意不要覆盖已有的内部属性。\n\n使用指令对象属性的示例：\n\n\x3cspan class=\x22hljs-code\x22\x3e`\x26lt;div id=\x22demo\x22 v-demo=\x22LightSlateGray : msg\x22\x26gt;\x26lt;\/div\x26gt;`\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ebind: function () {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.el.style.color = \x27#fff\x27\nthis.el.style.backgroundColor = this.arg\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3ethis\x3cspan class=\x22hljs-selector-class\x22\x3e.el\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.style\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.color\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27#fff\x27\x3c\/span\x3e\nthis\x3cspan class=\x22hljs-selector-class\x22\x3e.el\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.style\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.backgroundColor\x3c\/span\x3e = this.arg\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e},\x3cbr\x3e  update: function (value) {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22this.el.innerHTML =\n  \x27name - \x27       \x2b this.name \x2b \x27\x3cbr\x3e\x27 \x2b\n  \x27raw - \x27        \x2b this.raw \x2b \x27\x3cbr\x3e\x27 \x2b\n  \x27expression - \x27 \x2b this.expression \x2b \x27\x3cbr\x3e\x27 \x2b\n  \x27argument - \x27   \x2b this.arg \x2b \x27\x3cbr\x3e\x27 \x2b\n  \x27value - \x27      \x2b value\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3ethis\x3cspan class=\x22hljs-selector-class\x22\x3e.el\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.innerHTML\x3c\/span\x3e =\n  \x3cspan class=\x22hljs-string\x22\x3e\x27name - \x27\x3c\/span\x3e       \x2b this\x3cspan class=\x22hljs-selector-class\x22\x3e.name\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;br\x26gt;\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27raw - \x27\x3c\/span\x3e        \x2b this\x3cspan class=\x22hljs-selector-class\x22\x3e.raw\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;br\x26gt;\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27expression - \x27\x3c\/span\x3e \x2b this\x3cspan class=\x22hljs-selector-class\x22\x3e.expression\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;br\x26gt;\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27argument - \x27\x3c\/span\x3e   \x2b this\x3cspan class=\x22hljs-selector-class\x22\x3e.arg\x3c\/span\x3e \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27\x26lt;br\x26gt;\x27\x3c\/span\x3e \x2b\n  \x3cspan class=\x22hljs-string\x22\x3e\x27value - \x27\x3c\/span\x3e      \x2b value\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3cbr\x3evar demo = new Vue({\x3cbr\x3e  el: \x27#demo\x27,\x3cbr\x3e  data: {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22msg: \x27hello!\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs groovy\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-string\x22\x3emsg:\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27hello!\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3ccode\x3e`\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eResult\x3c\/strong\x3e\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ename - demo\x3c\/li\x3e\n\x3cli\x3eraw - LightSlateGray：msg\x3c\/li\x3e\n\x3cli\x3eexpression - msg\x3c\/li\x3e\n\x3cli\x3eargument - LightSlateGray\x3c\/li\x3e\n\x3cli\x3evalue - hello!\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader11\x22\x3e多重从句\x3c\/h3\x3e\n\x3cp\x3e同一个特性内部，逗号分隔的多个从句将被绑定为多个指令实例。在下面的例子中，指令会被创建和调用两次：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;div v-demo=\x22color: \x27white\x27, text: \x27hello!\x27\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e如果想要用单个指令实例处理多个参数，可以利用字面量对象作为表达式：\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;div v-demo=\x22{color: \x27white\x27, text: \x27hello!\x27}\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  console.log(value) \/\/ Object {color: \x27white\x27, text: \x27hello!\x27}\n})```\n\n## 字面指令\n\n如果在创建自定义指令的时候传入 `isLiteral: true`，那么特性值就会被看成直接字符串，并被赋值给该指令的 `expression`。字面指令不会试图建立数据监视。\n\n**Example**：\n\n`\x3cdiv v-literal-dir=\x26quot;foo\x26quot;\x3e\x3c\/div\x3e`\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e  console.log(value) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Object {color: \x27white\x27, text: \x27hello!\x27}\x3c\/span\x3e\n})```\n\n## 字面指令\n\n如果在创建自定义指令的时候传入 `isLiteral: true`，那么特性值就会被看成直接字符串，并被赋值给该指令的 `expression`。字面指令不会试图建立数据监视。\n\n**Example**：\n\n`\x26lt;div v-literal-dir=\x3cspan class=\x22hljs-string\x22\x3e\x22foo\x22\x3c\/span\x3e\x26gt;\x26lt;\/div\x26gt;`\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eisLiteral: true,\x3cbr\x3e  bind: function () {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(this.expression) \/\/ \x27foo\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cpp\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expression) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \x27foo\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3ccode\x3e`\x3c\/code\x3e\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e动态字面指令\x3c\/h3\x3e\n\x3cp\x3e然而，在字面指令含有 \x3ccode\x3eMustache\x3c\/code\x3e 标签的情形下，指令的行为如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e指令实例会有一个属性，\x3ccode\x3ethis._isDynamicLiteral\x3c\/code\x3e 被设为 \x3ccode\x3etrue\x3c\/code\x3e；\x3c\/li\x3e\n\x3cli\x3e如果没有提供 \x3ccode\x3eupdate\x3c\/code\x3e 函数，\x3ccode\x3eMustache\x3c\/code\x3e 表达式只会被求值一次，并将该值赋给 \x3ccode\x3ethis.expression\x3c\/code\x3e 。不会对表达式进行数据监视。\x3c\/li\x3e\n\x3cli\x3e如果提供了 \x3ccode\x3eupdate\x3c\/code\x3e 函数，指令将会为表达式建立一个数据监视，并且在计算结果变化的时候调用 \x3ccode\x3eupdate\x3c\/code\x3e。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader13\x22\x3e双向指令\x3c\/h2\x3e\n\x3cp\x3e如果你的指令想向 Vue 实例写回数据，你需要传入 \x3ccode\x3etwoWay: true\x3c\/code\x3e 。该选项允许在指令中使用 \x3ccode\x3ethis.set(value)\x3c\/code\x3e。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  twoWay: true,\n  bind: function () {\n    this.handler = function () {\n      \/\/ 把数据写回 vm\n      \/\/ 如果指令这样绑定 v-example=\x26quot;a.b.c\x26quot;,\n      \/\/ 这里将会给 `vm.a.b.c` 赋值\n      this.set(this.el.value)\n    }.bind(this)\n    this.el.addEventListener(\x27input\x27, this.handler)\n  },\n  unbind: function () {\n    this.el.removeEventListener(\x27input\x27, this.handler)\n  }\n})```\n\n## 内联语句\n\n传入 `acceptStatement: true` 可以让自定义指令像 `v-on` 一样接受内联语句：\n\n`\x3cdiv v-my-directive=\x26quot;a\x2b\x2b\x26quot;\x3e\x3c\/div\x3e`\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e  twoWay: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3ebind\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handler = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把数据写回 vm\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果指令这样绑定 v-example=\x22a.b.c\x22,\x3c\/span\x3e\n      \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里将会给 `vm.a.b.c` 赋值\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.set(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.el.value)\n    }.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.el.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handler)\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eunbind\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.el.removeEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27input\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handler)\n  }\n})\x3cspan class=\x22hljs-string\x22\x3e``\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e`\n\n## 内联语句\n\n传入 `\x3c\/span\x3eacceptStatement: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e` 可以让自定义指令像 `\x3c\/span\x3ev-on\x3cspan class=\x22hljs-string\x22\x3e` 一样接受内联语句：\n\n`\x3c\/span\x3e\x26lt;div v-my-directive=\x3cspan class=\x22hljs-string\x22\x3e\x22a\x2b\x2b\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-string\x22\x3e`\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eacceptStatement: true,\x3cbr\x3e  update: function (fn) {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ the passed in value is a function which when called,\n\/\/ will execute the \x26quot;a\x2b\x2b\x26quot; statement in the owner vm\x27s\n\/\/ scope.\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs livecodeserver\x22\x3e\x3ccode\x3e\/\/ \x3cspan class=\x22hljs-keyword\x22\x3ethe\x3c\/span\x3e passed \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3evalue\x3c\/span\x3e is \x3cspan class=\x22hljs-keyword\x22\x3ea\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewhich\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewhen\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecalled\x3c\/span\x3e,\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\n\/\/ will execute the \x22a\x2b\x2b\x22 statement in the owner vm\x27s\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e\n\/\/ scope.\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3ccode\x3e`\x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e但是请明智地使用此功能，因为通常我们希望避免在模板中产生副作用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader14\x22\x3e深度数据观察\x3c\/h2\x3e\n\x3cp\x3e如果你希望在一个对象上使用自定义指令，并且当对象内部嵌套的属性发生变化时也能够触发指令的 \x3ccode\x3eupdate\x3c\/code\x3e 函数，那么你就要在指令的定义中传入 \x3ccode\x3edeep: true\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3e\x26lt;div v-my-directive=\x22obj\x22\x26gt;\x26lt;\/div\x26gt;\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  deep: true,\n  update: function (obj) {\n    \/\/ 当 obj 内部嵌套的属性变化时也会调用此函数\n  }\n})```\n\n## 指令优先级\n\n你可以选择给指令提供一个优先级数（默认是 0）。同一个元素上优先级越高的指令会比其他的指令处理得早一些。优先级一样的指令会按照其在元素特性列表中出现的顺序依次处理，但是不能保证这个顺序在不同的浏览器中是一致的。\n\n通常来说作为用户，你并不需要关心内置指令的优先级，如果你感兴趣的话，可以参阅源码。逻辑控制指令 `v-repeat`， `v-if` 被视为 “终结性指令”，它们在编译过程中始终拥有最高的优先级。\n\n## 元素指令\n\n有时候，我们可能想要我们的指令可以以自定义元素的形式被使用，而不是作为一个特性。这与 `Angular` 的 `E` 类指令的概念非常相似。元素指令可以看做是一个轻量的自定义组件（后面会讲到）。你可以像下面这样注册一个自定义的元素指令：\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs clean\x22\x3e\x3ccode\x3e  deep: true,\n  update: function (obj) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当 obj 内部嵌套的属性变化时也会调用此函数\x3c\/span\x3e\n  }\n})```\n\n## 指令优先级\n\n你可以选择给指令提供一个优先级数（默认是 \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e）。同一个元素上优先级越高的指令会比其他的指令处理得早一些。优先级一样的指令会按照其在元素特性列表中出现的顺序依次处理，但是不能保证这个顺序在不同的浏览器中是一致的。\n\n通常来说作为用户，你并不需要关心内置指令的优先级，如果你感兴趣的话，可以参阅源码。逻辑控制指令 `v-repeat`， `v-\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e` 被视为 “终结性指令”，它们在编译过程中始终拥有最高的优先级。\n\n## 元素指令\n\n有时候，我们可能想要我们的指令可以以自定义元素的形式被使用，而不是作为一个特性。这与 `Angular` 的 `E` 类指令的概念非常相似。元素指令可以看做是一个轻量的自定义组件（后面会讲到）。你可以像下面这样注册一个自定义的元素指令：\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\/\/ 和普通指令的 API 一致\x3cbr\x3e  bind: function () {\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 对 this.el 进行操作...\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs 1c\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对 this.el 进行操作...\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e}\x3cbr\x3e})\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3evuejs vs angularjs\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Angular Modules\nangular.module(\x27myModule\x27, [...]);\nComponents\nVue.extend({\n  data: function(){ return {...} },\n  created: function() {...},\n  ready: function() {...},\n  components: {...},\n  methods: {...},\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eAngular\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eModules\x3c\/span\x3e\nangular.module(\x27myModule\x27, [...]);\n\x3cspan class=\x22hljs-type\x22\x3eComponents\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e.extend({\n  data: function(){ \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e },\n  created: function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,\n  ready: function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,\n  components: \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,\n  methods: \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e总体来说\x3cbr\x3e对于Angular来说module就是一个容器,而对Vue来说一个component里面会有逻辑代码\x3cbr\x3e在Vue里面会放进许多代码细节,并且有固定的属性\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Directives\nAngular\nmyModule.directive(\x27directiveName\x27, function (injectables) {\n  return {\n    restrict: \x27A\x27,\n    template: \x27\x3cdiv\x3e\x3c\/div\x3e\x27,\n    controller: function() { ... },\n    compile: function() {...},\n    link: function() { ... }\n    \/\/(other props excluded)\n  };\n});\nVue\nVue.directive(\x27my-directive\x27, {\n  bind: function () {...},\n  update: function (newValue, oldValue) {...},\n  unbind: function () {...}\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eDirectives\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eAngular\x3c\/span\x3e\nmyModule.directive(\x27directiveName\x27, function (injectables) {\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n    restrict: \x27A\x27,\n    \x3cspan class=\x22hljs-keyword\x22\x3etemplate\x3c\/span\x3e: \x27\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;\x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;\x27,\n    controller: function() { ... },\n    compile: function() \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,\n    link: function() { ... }\n    \/\/(other props excluded)\n  };\n});\n\x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e.directive(\x27my-directive\x27, {\n  \x3cspan class=\x22hljs-keyword\x22\x3ebind\x3c\/span\x3e: function () \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,\n  update: function (newValue, oldValue) \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e,\n  unbind: function () \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVue的指令比Angular的简单,而Angular的指令类似Vue的component\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Filters\nAngular\nmyModule.angular.module(‘filterName\x27, [])\n.filter(\x27reverse\x27, function() {\nreturn function(input) {...};\n});\nVue\nVue.filter(\x27reverse\x27, function (value) {\nreturn function(value){...};\n});\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs nimrod\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-type\x22\x3eFilters\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eAngular\x3c\/span\x3e\nmyModule.angular.module(‘filterName\x27, [])\n.filter(\x27reverse\x27, function() {\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e function(input) \x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e;\n});\n\x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e\n\x3cspan class=\x22hljs-type\x22\x3eVue\x3c\/span\x3e.filter(\x27reverse\x27, function (value) {\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e function(value)\x3cspan class=\x22hljs-meta\x22\x3e{...}\x3c\/span\x3e;\n});\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3efilters都是类似的,但是Vue提供了read\/wirte功能\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Templating\nInterpolation\n\x22{{\x22myVariable\x22}}\x22\nInterpolation\n\x22{{\x22myVariable\x22}}\x22\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mathematica\x22\x3e\x3ccode\x3eTemplating\n\x3cspan class=\x22hljs-keyword\x22\x3eInterpolation\x3c\/span\x3e\n\x22{{\x22myVariable\x22}}\x22\n\x3cspan class=\x22hljs-keyword\x22\x3eInterpolation\x3c\/span\x3e\n\x22{{\x22myVariable\x22}}\x22\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e当输出是一个对象的时候\x3cbr\x3eVue:[Object]\x3cbr\x3eAngular :{[attr:value]}\x3cbr\x3eVue可以使用filters得到正常输出 \x22{{\x22someObject|json\x22}}\x22\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Model binding\nAngular\n\x3cinput type=\x26quot;text\x26quot; ng-model=\x26quot;myVar\x26quot;\x3e\n\x3cp ng-bind=\x26quot;myVar\x26quot;\x3e\x3c\/p\x3e\nVue\n\x3cinput type=\x26quot;text\x26quot; v-model=\x26quot;myVar\x26quot;\x3e\n\x3cp v-model=\x26quot;myVar\x26quot;\x3e\x3c\/p\x3e\n\nLoops\nAngular\n\x3cli ng-repeat=\x26quot;item in items\x26quot; class=\x26quot;item-\x22{{\x22$index\x22}}\x22\x26quot;\x3e\n  \x22{{\x22item.myProperty\x22}}\x22\n\x3c\/li\x3e\nVue\n\x3cli v-for=\x26quot;items\x26quot; class=\x26quot;item-\x22{{\x22$index\x22}}\x22\x26quot;\x3e\n  \x22{{\x22myProperty\x22}}\x22\n\x3c\/li\x3e\n\nConditionals\nAngular\n\x3cdiv ng-if=\x26quot;myVar\x26quot;\x3e\x3c\/div\x3e\n\x3cdiv ng-show=\x26quot;myVar\x26quot;\x3e\x3c\/div\x3e\nVue\n\x3cdiv v-if=\x26quot;myVar\x26quot;\x3e\x3c\/div\x3e\n\x3cdiv v-show=\x26quot;myVar\x26quot;\x3e\x3c\/div\x3e\n\nConditional classes\nAngular\n\x3cdiv ng-class=\x26quot;{‘active’: myVar}\x26quot;\x3e\x3c\/div\x3e\nVue\n\x3cdiv v-class=\x26quot;active: myVar\x26quot;\x3e\x3c\/div\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dust\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3eModel binding\nAngular\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-model\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22myVar\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-bind\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22myVar\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\nVue\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3einput\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3etype\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22text\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-model\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22myVar\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-model\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22myVar\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\nLoops\nAngular\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-repeat\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22item in items\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22item-\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22$index}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e}\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22item.myProperty}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e}\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\nVue\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-for\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22items\x22\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eclass\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22item-\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22$index}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e}\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22myProperty}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e}\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\nConditionals\nAngular\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-if\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22myVar\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-show\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22myVar\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\nVue\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-if\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22myVar\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-show\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22myVar\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\nConditional classes\nAngular\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-class\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22\x3c\/span\x3e\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{‘active’: myVar}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x3cspan class=\x22hljs-string\x22\x3e\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\nVue\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3ev-class\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22active: myVar\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eVue也可以这样写v-repeat=\x27item: items\x27\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Event binding\nAngular\n\x3cdiv ng-click=\x26quot;myMethod($event)\x26quot;\x3e\x3c\/div\x3e\nVue\n\x3cdiv v-on=\x26quot;click: myMethod($event)\x26quot;\x3e\x3c\/div\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs applescript\x22\x3e\x3ccode\x3eEvent binding\nAngular\n\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e ng-click=\x3cspan class=\x22hljs-string\x22\x3e\x22myMethod($event)\x22\x3c\/span\x3e\x26gt;\x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;\nVue\n\x26lt;\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e v-\x3cspan class=\x22hljs-keyword\x22\x3eon\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22click: myMethod($event)\x22\x3c\/span\x3e\x26gt;\x26lt;\/\x3cspan class=\x22hljs-keyword\x22\x3ediv\x3c\/span\x3e\x26gt;\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通用v-on指令使事件更加一致\x3c\/p\x3e\n\x3ch4\x3e脏值检查\x3c\/h4\x3e\n\x3cp\x3e一个电话列表应用的例子，在其中我们会将一个phones数组中的值（在JavaScript中定义）绑定到一个列表项目中以便于我们的数据和UI保持同步：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3ccode\x3e\x3chtml ng-app\x3e\n  \x3chead\x3e\n...\n\x3cscript src=\x26quot;angular.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript src=\x26quot;controller.js\x26quot;\x3e\x3c\/script\x3e\n  \x3c\/head\x3e\n  \x3cbody ng-controller=\x26quot;PhoneListCtrl\x26quot;\x3e\n\x3cul\x3e\n  \x3cli ng-repeat=\x26quot;phone in phones\x26quot;\x3e\n\x22{{\x22phone.name\x22}}\x22\n\x3cp\x3e\x22{{\x22phone.snippet\x22}}\x22\x3c\/p\x3e\n  \x3c\/li\x3e\n\x3c\/ul\x3e\n  \x3c\/body\x3e\n\x3c\/html\x3e\n\x3c\/code\x3e\n\n\x3ccode\x3evar phonecatApp = angular.module(\x27phonecatApp\x27, []);\n\nphonecatApp.controller(\x27PhoneListCtrl\x27, function($scope) {\n  $scope.phones = [\n{\x27name\x27: \x27Nexus S\x27,\n \x27snippet\x27: \x27Fast just got faster with Nexus S.\x27},\n{\x27name\x27: \x27Motorola XOOM with Wi-Fi\x27,\n \x27snippet\x27: \x27The Next, Next Generation tablet.\x27},\n{\x27name\x27: \x27MOTOROLA XOOM\x27,\n \x27snippet\x27: \x27The Next, Next Generation tablet.\x27}\n  ];\n});  \n\x3c\/code\x3e\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs dust\x22\x3e\x3ccode\x3e\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ecode\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-app\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n...\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22angular.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3esrc\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22controller.js\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3cspan class=\x22undefined\x22\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehead\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-controller\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22PhoneListCtrl\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e \x3cspan class=\x22hljs-attr\x22\x3eng-repeat\x3c\/span\x3e=\x3cspan class=\x22hljs-string\x22\x3e\x22phone in phones\x22\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22phone.name}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e}\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e\x22{{\x22phone.snippet}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e}\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ep\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eli\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3eul\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ebody\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ehtml\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ecode\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ecode\x3c\/span\x3e\x26gt;\x3c\/span\x3evar phonecatApp = angular.module(\x27phonecatApp\x27, []);\n\nphonecatApp.controller(\x27PhoneListCtrl\x27, function($scope) \x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{\n  $scope.phones = [\n{\x27name\x27: \x27Nexus S\x27,\n \x27snippet\x27: \x27Fast just got faster with Nexus S.\x27}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e,\n\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{\x27name\x27: \x27Motorola XOOM with Wi-Fi\x27,\n \x27snippet\x27: \x27The Next, Next Generation tablet.\x27}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e,\n\x3c\/span\x3e\x3cspan class=\x22hljs-template-variable\x22\x3e{\x27name\x27: \x27MOTOROLA XOOM\x27,\n \x27snippet\x27: \x27The Next, Next Generation tablet.\x27}\x3c\/span\x3e\x3cspan class=\x22xml\x22\x3e\n  ];\n});  \n\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ecode\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e任何时候只要是底层的model数据发生了变化，我们在DOM中的列表也会跟着更新。\x3c\/p\x3e\n\x3cp\x3e脏值检查的基本原理就是只要任何时候数据发生了变化，这个库都会通过一个digest或者change cycle去检查变化是否发生了。在Angular中，一个digest循环意味着所有所有被监视的表达式都会被循环一遍以便查看其中是否有变化发生。它智斗一个模型之前的值因此当变化发生时，一个change事件将会被触发。对于开发者来说，这带来的一大好处就是你可以使用原生的JavaScript对象数据，它易于使用及整合。下面的图片展示的是一个非常糟糕的算法，它的开销非常大。\x3c\/p\x3e\n\x3cp\x3e这个操作的开销和被监视的对象的数量是成正比的。我可能需要做很多的脏治检查。同时当数据发生改变时,我也需要一种方式去触发脏值检查.\x3c\/p\x3e\n\x3cp\x3e相比Angular的脏值检查,Vue的setter\/getter方案使数据和DOM更新的时间复杂度降低,数据的更新只发生在数据发生改变时,数据更新的时间复杂度只和数据的观察者有关,\x22它们拥有一些存取器去获取数据并且能够在你设置或者获取对象时捕获到这些行为并在内部进行广播\x22.\x3c\/p\x3e\n\x3ch4\x3evue的约束的模型系统\x3c\/h4\x3e\n\x3cp\x3e而且相比Object.observer()[在es7标准中],Vue的存取方式可以做到比较好的兼容性.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3eVue实现简单的watcher\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x221.实现observer\n2.Vue消息-订阅器\n3.Watcher的实现\n4.实现一个Vue\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lsl\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-number\x22\x3e1.\x3c\/span\x3e实现observer\n\x3cspan class=\x22hljs-number\x22\x3e2.\x3c\/span\x3eVue消息-订阅器\n\x3cspan class=\x22hljs-number\x22\x3e3.\x3c\/span\x3eWatcher的实现\n\x3cspan class=\x22hljs-number\x22\x3e4.\x3c\/span\x3e实现一个Vue\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e实现一个 $wacth\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const v = new Vue({\n  data:{\n    a:1,\n    b:2\n  }\n})\nv.$watch(\x26quot;a\x26quot;,()=\x3econsole.log(\x26quot;哈哈，$watch成功\x26quot;))\nsetTimeout(()=\x3e{\n  v.a = 5\n},2000) \/\/打印 哈哈，$watch成功\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3econst v = new Vue({\n  data:{\n    \x3cspan class=\x22hljs-selector-tag\x22\x3ea\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-selector-tag\x22\x3eb\x3c\/span\x3e:\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e\n  }\n})\nv.\x3cspan class=\x22hljs-variable\x22\x3e$watch\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22a\x22\x3c\/span\x3e,()=\x26gt;console.log(\x3cspan class=\x22hljs-string\x22\x3e\x22哈哈，$watch成功\x22\x3c\/span\x3e))\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3esetTimeout\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(()\x3c\/span\x3e\x3c\/span\x3e=\x26gt;{\n  v\x3cspan class=\x22hljs-selector-class\x22\x3e.a\x3c\/span\x3e = \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e\n},\x3cspan class=\x22hljs-number\x22\x3e2000\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/打印 哈哈，$watch成功\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为了帮助大家理清思路。。我们就做最简单的实现。。只考虑对象不考虑数组\x3c\/p\x3e\n\x3ch5\x3e实现obserer\x3c\/h5\x3e\n\x3cp\x3e将要observe的对象， 通过递归，将它所有的属性，包括子属性的属性，都给加上set和get， 这样的话，给这个对象的某个属性赋值，就会触发set。就给每个属性（包括子属性）都加上get\/set， 这样的话，这个对象的，有任何赋值，就会触发set方法。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class  Observer{\n  constructor(value) {\n    this.value = value\n    this.walk(value)\n  }\n  \/\/递归。。让每个字属性可以observe\n  walk(value){\n    Object.keys(value).forEach(key=\x3ethis.convert(key,value[key]))\n  }\n  convert(key, val){\n    defineReactive(this.value, key, val)\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3eexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e  \x3cspan class=\x22hljs-title\x22\x3eObserver\x3c\/span\x3e{\n  constructor(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.walk(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/递归。。让每个字属性可以observe\x3c\/span\x3e\n  walk(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e){\n    Object.keys(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e).forEach(key=\x26gt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.convert(key,\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e[key]))\n  }\n  convert(key, val){\n    defineReactive(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e, key, val)\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function defineReactive (obj, key, val) {\n  var childOb = observe(val)\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: ()=\x3eval,\n    set:newVal=\x3e {      \n     childOb = observe(newVal)\/\/如果新赋值的值是个复杂类型。再递归它，加上set\/get。。\n     }\n  })\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineReactive\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eobj, key, val\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e childOb = observe(val)\n  \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n    enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3eval,\n    \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {      \n     childOb = observe(newVal)\x3cspan class=\x22hljs-comment\x22\x3e\/\/如果新赋值的值是个复杂类型。再递归它，加上set\/get。。\x3c\/span\x3e\n     }\n  })\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function observe (value, vm) {\n  if (!value || typeof value !== \x27object\x27) {\n    return\n  }\n  return new Observer(value)\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs cs\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3eexport function \x3cspan class=\x22hljs-title\x22\x3eobserve\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e, vm\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e || \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e !== \x3cspan class=\x22hljs-string\x22\x3e\x27object\x27\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Observer(\x3cspan class=\x22hljs-keyword\x22\x3evalue\x3c\/span\x3e)\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e消息－订阅器\x3c\/h5\x3e\n\x3cp\x3e维护一个数组，，这个数组，就放订阅着，一旦触发notify， 订阅者就调用自己的update方法\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Dep {\n  constructor() {\n    this.subs = []\n  }\n  addSub(sub){\n    this.subs.push(sub)\n  }\n  notify(){\n    this.subs.forEach(sub=\x3esub.update())\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs perl\x22\x3e\x3ccode\x3eexport default class Dep {\n  constructor() {\n    this.subs = []\n  }\n  addSub(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3esub\x3c\/span\x3e)\x3c\/span\x3e{\n    this.subs.push(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3esub\x3c\/span\x3e)\n  }\n  \x3cspan class=\x22hljs-title\x22\x3enotify\x3c\/span\x3e\x3c\/span\x3e(){\n    this.subs.forEach(\x3cspan class=\x22hljs-string\x22\x3esub=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3esub\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eupdate\x3c\/span\x3e())\n  }\n}\n\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e每次set函数，调用的时候，我们是不是应该，触发notify，对吧。所以 我们把代码补充完整\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function defineReactive (obj, key, val) {\n      var dep = new Dep()\n      var childOb = observe(val)\n      Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: ()=\x3eval,\n        set:newVal=\x3e {\n          var value =  val\n          if (newVal === value) {\n            return\n          }\n          val = newVal\n          childOb = observe(newVal)\n          dep.notify()\n        }\n      })\n    }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineReactive\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eobj, key, val\x3c\/span\x3e) \x3c\/span\x3e{\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep()\n      \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e childOb = observe(val)\n      \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n        enumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        configurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n        \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3eval,\n        \x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n          \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value =  val\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newVal === value) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n          }\n          val = newVal\n          childOb = observe(newVal)\n          dep.notify()\n        }\n      })\n    }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e实现一个Watcher\x3c\/h5\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22     v.$watch(\x26quot;a\x26quot;,()=\x3econsole.log(\x26quot;哈哈，$watch成功\x26quot;))\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs coffeescript\x22\x3e\x3ccode\x3e     v.$watch(\x3cspan class=\x22hljs-string\x22\x3e\x22a\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22哈哈，$watch成功\x22\x3c\/span\x3e))\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们想象这个Watcher，应该用什么东西。update方法，嗯这个毋庸置疑， 还有呢，\x3cbr\x3e对表达式（就是那个“a”） 和 回调函数，这是最基本的，所以我们简单写写\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Watcher {\n  constructor(vm, expOrFn, cb) {\n    this.cb = cb\n    this.vm = vm\n    \/\/此处简化.要区分fuction还是expression,只考虑最简单的expression\n    this.expOrFn = expOrFn\n    this.value = this.get()\n  }\n  update(){\n    this.run()\n  }\n  run(){\n    const  value = this.get()\n    if(value !==this.value){\n      this.value = value\n      this.cb.call(this.vm)\n    }\n  }\n  get(){\n    \/\/此处简化。。要区分fuction还是expression\n    const value = this.vm._data[this.expOrFn]\n    return value\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWatcher\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(vm, expOrFn, cb) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb = cb\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm = vm\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/此处简化.要区分fuction还是expression,只考虑最简单的expression\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expOrFn = expOrFn\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e()\n  }\n  update(){\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.run()\n  }\n  run(){\n    const  value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e()\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(value !==\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value){\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.value = value\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.cb.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm)\n    }\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(){\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/此处简化。。要区分fuction还是expression\x3c\/span\x3e\n    const value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm._data[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expOrFn]\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e怎样将通过addSub(),将Watcher加进去呢。 我们发现var dep = new Dep() 处于闭包当中， 我们又发现Watcher的构造函数里会调用this.get 所以，我们可以在上面动动手脚， 修改一下Object.defineProperty的get要调用的函数， 判断是不是Watcher的构造函数调用，如果是，说明他就是这个属性的订阅者 果断将他addSub()中去，那问题来了， 我怎样判断他是Watcher的this.get调用的，而不是我们普通调用的呢\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Watcher {\n  ....省略未改动代码....\n  get(){\n    Dep.target = this\n    \/\/此处简化。。要区分fuction还是expression\n    const value = this.vm._data[this.expOrFn]\n    Dep.target = null\n    return value\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWatcher\x3c\/span\x3e \x3c\/span\x3e{\n  ....省略未改动代码....\n  \x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e(){\n    Dep.target = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/此处简化。。要区分fuction还是expression\x3c\/span\x3e\n    const value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.vm._data[\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.expOrFn]\n    Dep.target = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样的话，我们只需要在Object.defineProperty的get要调用的函数里， 判断有没有值，就知道到底是Watcher 在get，还是我们自己在查看赋值，如果 是Watcher的话就addSub(),代码补充一下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export function defineReactive (obj, key, val) {\nvar dep = new Dep()\nvar childOb = observe(val)\n\nObject.defineProperty(obj, key, {\nenumerable: true,\nconfigurable: true,\nget: ()=\x3e{\n  \/\/ 说明这是watch 引起的\n  if(Dep.target){\n    dep.addSub(Dep.target)\n  }\n  return val\n},\nset:newVal=\x3e {\n  var value =  val\n  if (newVal === value) {\n    return\n  }\n  val = newVal\n  childOb = observe(newVal)\n  dep.notify()\n}\n})\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs typescript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edefineReactive\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eobj, key, val\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e dep = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Dep()\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e childOb = observe(val)\n\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\nenumerable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\nconfigurable: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n\x3cspan class=\x22hljs-keyword\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e=\x26gt;\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 说明这是watch 引起的\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e(Dep.target){\n    dep.addSub(Dep.target)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e val\n},\n\x3cspan class=\x22hljs-keyword\x22\x3eset\x3c\/span\x3e:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e=\x26gt;\x3c\/span\x3e {\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e value =  val\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (newVal === value) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n  val = newVal\n  childOb = observe(newVal)\n  dep.notify()\n}\n})\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e最后不要忘记，在Dep.js中加上这么一句\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Dep.target = null\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs aspectj\x22\x3e\x3ccode\x3eDep.\x3cspan class=\x22hljs-keyword\x22\x3etarget\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enull\x3c\/span\x3e\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch5\x3e实现一个Vue\x3c\/h5\x3e\n\x3cp\x3e我们要把以上代码配合Vue的$watch方法来用， 要watch Vue实例的属性:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import Watcher from \x27..\/watcher\x27\nimport {observe} from \x26quot;..\/observer\x26quot;\n\nexport default class Vue {\n  constructor (options={}) {\n    \/\/这里简化了。。其实要merge\n    this.$options=options\n    \/\/这里简化了。。其实要区分的\n    let data = this._data=this.$options.data\n    Object.keys(data).forEach(key=\x3ethis._proxy(key))\n    observe(data,this)\n  }\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e Watcher from \x3cspan class=\x22hljs-string\x22\x3e\x27..\/watcher\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {observe} from \x3cspan class=\x22hljs-string\x22\x3e\x22..\/observer\x22\x3c\/span\x3e\n\nexport \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eVue\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (options={}) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里简化了。。其实要merge\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options=options\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/这里简化了。。其实要区分的\x3c\/span\x3e\n    let \x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._data=\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.$options.\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e\n    Object.keys(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e).forEach(key=\x26gt;\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._proxy(key))\n    observe(\x3cspan class=\x22hljs-keyword\x22\x3edata\x3c\/span\x3e,\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n  }\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  $watch(expOrFn, cb, options){\n    new Watcher(this, expOrFn, cb)\n  }\n\n  _proxy(key) {\n    var self = this\n    Object.defineProperty(self, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return self._data[key]\n      },\n      set: function proxySetter (val) {\n        self._data[key] = val\n      }\n    })\n  }\n}\n\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs php\x22\x3e\x3ccode\x3e  $watch(expOrFn, cb, options){\n    \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(this, expOrFn, cb)\n  }\n\n  _proxy(key) {\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e = this\n    Object.defineProperty(\x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e, key, {\n      configurable: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e,\n      enumerable: \x3cspan class=\x22hljs-keyword\x22\x3etrue\x3c\/span\x3e,\n      get: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproxyGetter\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._data[key]\n      },\n      set: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eproxySetter\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(val)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eself\x3c\/span\x3e._data[key] = val\n      }\n    })\n  }\n}\n\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e两件事，observe自己的data，代理自己的data， 使访问自己的属性，就是访问子data的属性。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>深入解析Vue源码</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000010485232">https://segmentfault.com/a/1190000010485232</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/7lwstc7t1u9/" target="_blank">https://alili.tech/archive/7lwstc7t1u9/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5fmk2pl6rab/">2016年前端开发者深度调研，看看别人使用什么技术体系<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/stp6408xnu/">Bootstrap使用模态框modal实现表单提交弹出框<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/fu7a86e9uyh/">CSS水平垂直居中总结<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/r0w29esklr/">JS 里怎么给数组填充默认值<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/i00hiszlr1/">JavaScript - EventEmitter 背后的秘密<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/u2la0cn9do/">JavaScript 精度丢失问题<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/3txhfn3ejcb/">Nodejs进阶：如何玩转子进程（child_process）<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/yr7v8e9fao/">Promise介绍--规范篇<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/9lyxyz4wc6g/">QQ音乐API整理<aside class="dates">2019-01-30</aside></a></li><li><a href="/archive/84zzlljmes4/">SegmentFault 技术周刊 Vol.14 - 进阶 Vue 2.0<aside class="dates">2019-01-30</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>