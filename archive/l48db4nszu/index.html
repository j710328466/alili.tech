<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="一起理解 Virtual DOM"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>一起理解 Virtual DOM | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/l48db4nszu/",
				"appid": "1613049289050283", 
				"title": "一起理解 Virtual DOM | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-30T02:30:23"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ozixvh5k6qj/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/rd30jrzoprj/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f&text=%e4%b8%80%e8%b5%b7%e7%90%86%e8%a7%a3%20Virtual%20DOM"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f&text=%e4%b8%80%e8%b5%b7%e7%90%86%e8%a7%a3%20Virtual%20DOM"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f&title=%e4%b8%80%e8%b5%b7%e7%90%86%e8%a7%a3%20Virtual%20DOM"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f&is_video=false&description=%e4%b8%80%e8%b5%b7%e7%90%86%e8%a7%a3%20Virtual%20DOM"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%b8%80%e8%b5%b7%e7%90%86%e8%a7%a3%20Virtual%20DOM&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f&title=%e4%b8%80%e8%b5%b7%e7%90%86%e8%a7%a3%20Virtual%20DOM"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f&title=%e4%b8%80%e8%b5%b7%e7%90%86%e8%a7%a3%20Virtual%20DOM"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f&title=%e4%b8%80%e8%b5%b7%e7%90%86%e8%a7%a3%20Virtual%20DOM"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fl48db4nszu%2f&title=%e4%b8%80%e8%b5%b7%e7%90%86%e8%a7%a3%20Virtual%20DOM"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">一起理解 Virtual DOM</h1><div class="meta"><div class="postdate"><time datetime="2019-01-30" itemprop="datePublished">2019-01-30</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3eReact 好像已经火了很久很久，以致于我们对于 Virtual DOM 这个词都已经很熟悉了，网上也有非常多的介绍 React、Virtual DOM 的文章。但是直到前不久我专门花时间去学习 Virtual DOM，才让我对 Virtual DOM 有了一定的理解，以致于要怀疑起很久之前看过的那些文章来。倒不是这些文章讲得不对，而是现在在我看来角度不太好，说得越多，越说不清。\x3c\/p\x3e\n\x3cp\x3e让我能够有所开窍（自认为）的，是这篇文章：\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e\x3cstrong\x3eChange And Its Detection In JavaScript Frameworks\x3c\/strong\x3e\x3cbr\x3eMonday Mar 2, 2015 by Tero Parviainen\x3cbr\x3e\x3ca href=\x22http:\/\/teropa.info\/blog\/2015\/03\/02\/change-and-its-detection-in-javascript-frameworks.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/teropa.info\/blog\/2015\/...\x3c\/a\x3e\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e作者看问题的角度很棒，从数据变更与UI同步的角度来介绍各个典型框架，特别是对于 React 的 Virtual DOM，从这个角度理解起来更容易些。\x3c\/p\x3e\n\x3cp\x3e感兴趣的同学，如果没有读过这篇文章，推荐去看一看，不感兴趣就算了。不过接下来我要讲的东西，部分整理自这篇文章，特别是从这篇文章中引用的图片，非常棒。当然还有我自己的一些思考，以及一些对于目前 Virtual DOM 实现的开源库的分析。\x3c\/p\x3e\n\x3cp\x3e如果读了上面推荐的这篇文章，我倒是不介意你不再继续把本文读下去，因为有些东西你已经领会到了。当然，也不反对。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e变化这件事\x3c\/h2\x3e\n\x3cp\x3e谈论页面的变化之前，咱们先看下数据和页面（视觉层面的页面）的关系。数据是隐藏在页面底下，通过渲染展示给用户。同样的数据，按照不同的页面设计和实现，会以不同形式、样式的页面呈现出来。有时候在一个页面内的不同位置，也会有相同数据的不同表现。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007694391\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007694391\x22 alt=\x22Paste_Image.png\x22 title=\x22Paste_Image.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3eWeb 的早期，这些页面通常是静态的，页面内容不会变化。而如果数据发生了变化，通常需要重新请求页面，得到基于新的数据渲染出的新的页面。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007694392\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007694392\x22 alt=\x22Paste_Image.png\x22 title=\x22Paste_Image.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e至少，这个模式理解起来挺简单不是吗。\x3c\/p\x3e\n\x3cp\x3e直到 Web 应用复杂起来，开发者们开始关注用户体验，开始将大量的处理向前端迁移，页面变得动态、灵活起来。一个显著的特征是，数据发生变化之后，不再需要刷新页面就能看到页面上的内容随之更新了。\x3c\/p\x3e\n\x3cp\x3e前端需要做的事情变得多了起来，前端工程师们也就修炼了起来，各种前端技术也就出现了。\x3c\/p\x3e\n\x3cp\x3e首先，聪明的工程师们发现既然是在前端渲染页面，如果只是部分数据发生了变化，就要把页面整体或一大块区域重新渲染就有点笨了。为什么不把事情做得更极致些，只更新变化的数据对应的页面的内容呢？\x3c\/p\x3e\n\x3cp\x3e怎么做呢？操作 DOM 呗。DOM 就是浏览器提供给开发者用于操作页面的模型嘛，直接通过脚本来调用 DOM 的各种接口就 OK 了。而且我们还有了像 jQuery 这样的棒棒的工具，操作 DOM 变得 so easy。\x3c\/p\x3e\n\x3cp\x3e然而，页面越来越复杂，聪明的工程师们发现数据变化之后，老是需要手动编码去操作对应的 DOM 节点执行更新，有点烦，不够懒啊。于是各种框架如雨后春笋般出现了，纷纷表示可以简化这个过程。\x3c\/p\x3e\n\x3cp\x3e稍微早期的框架有这样的：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007694393\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007694393\x22 alt=\x22Paste_Image.png\x22 title=\x22Paste_Image.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e开发者借助框架，监听数据的变更，在数据变更后更新对应的 DOM 节点。虽然还是要写一些代码，但是写出来的代码好像很有条理的样子，至少更容易理解和维护了，也不错嘛。\x3c\/p\x3e\n\x3cp\x3e更进一步，MVVM 框架出现了，以 AngularJS 为代表：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007694394\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007694394\x22 alt=\x22Paste_Image.png\x22 title=\x22Paste_Image.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e仍然是数据变化后更新对应 DOM 节点的方式，但是建立这种绑定关系的过程被框架所处理，开发者要写的代码变少了，而且代码更易读和维护了。\x3c\/p\x3e\n\x3cp\x3e再然后呢，大家就在这个棒棒的模式上继续深耕，纷纷表示还可以在性能上做得更好，前端领域一片繁荣。\x3c\/p\x3e\n\x3cp\x3e再后来 React 出现了，它不仅不是 MVVM 框架，甚至连 MV\x3cem\x3e 框架都不是。这年头，不是个 MV\x3c\/em\x3e 框架还好意思出门？可 React 还真的带来了新的思路！\x3c\/p\x3e\n\x3cp\x3e什么思路呢？\x3c\/p\x3e\n\x3cp\x3e就是回到过去，回到那个简单而美好的时候。具体而言，就是每次数据发生变化，就重新执行一次整体渲染。的确这样更简单，不用去琢磨到底是数据的哪一部分变化了，需要更新页面的哪一部分。但是坏处太明显，体验不好啊。而 React 给出了解决方案，就是 Virtual DOM。\x3c\/p\x3e\n\x3cp\x3eVirtual DOM 概况来讲，就是在数据和真实 DOM 之间建立了一层缓冲。对于开发者而言，数据变化了就调用 React 的渲染方法，而 React 并不是直接得到新的 DOM 进行替换，而是先生成 Virtual DOM，与上一次渲染得到的 Virtual DOM 进行比对，在渲染得到的 Virtual DOM 上发现变化，然后将变化的地方更新到真实 DOM 上。\x3c\/p\x3e\n\x3cp\x3e简单来说，React 在提供给开发者简单的开发模式的情况下，借助 Virtual DOM 实现了性能上的优化，以致于敢说自己“不慢”。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eVirtual DOM\x3c\/h2\x3e\n\x3cp\x3eReact 基于 Virtual DOM 的数据更新与UI同步机制：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007694395\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007694395\x22 alt=\x22React - 初始渲染\x22 title=\x22React - 初始渲染\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e初始渲染时，首先将数据渲染为 Virtual DOM，然后由 Virtual DOM 生成 DOM。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/remote\/1460000007694396\x22 src=\x22https:\/\/static.alili.tech\/img\/remote\/1460000007694396\x22 alt=\x22React - 数据更新\x22 title=\x22React - 数据更新\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e数据更新时，渲染得到新的 Virtual DOM，与上一次得到的 Virtual DOM 进行 diff，得到所有需要在 DOM 上进行的变更，然后在 patch 过程中应用到 DOM 上实现UI的同步更新。\x3c\/p\x3e\n\x3cp\x3eVirtual DOM 作为数据结构，需要能准确地转换为真实 DOM，并且方便进行对比。除了 Virtual DOM 外，React 还实现了其他的特性，为了专注于 Virtual DOM，我另外找了两个比较 Virtual DOM 来学习：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/Matt-Esch\/virtual-dom\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evirtual-dom\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/paldepind\/snabbdom\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eSnabbdom\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e这里也推荐给感兴趣且还没有读过两个库源码的同学。\x3c\/p\x3e\n\x3cp\x3e由于只关注 Virtual DOM，通过阅读两个库的源码，对于 Virtual DOM 的定位有了更深一步的理解。\x3c\/p\x3e\n\x3cp\x3e首先看数据结构。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e Virtual DOM 数据结构 \x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3eDOM 通常被视为一棵树，元素则是这棵树上的节点（node），而 Virtual DOM 的基础，就是 Virtual Node 了。\x3c\/p\x3e\n\x3cp\x3e在 virtual-dom 中，给 Virtual Node 声明了对应的类 \x3ca href=\x22https:\/\/github.com\/Matt-Esch\/virtual-dom\/blob\/master\/vnode\/vnode.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eVirtualNode\x3c\/a\x3e，基本是用于存储数据，包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3etagName\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eproperties\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3echildren\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ekey\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3enamespace\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecount\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ehasWidgets\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ehasThunks\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ehooks\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3edescendantHooks\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eSnabbdom 的 Virtual Node 则是纯数据对象，通过 \x3ca href=\x22https:\/\/github.com\/snabbdom\/snabbdom\/blob\/master\/vnode.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3evnode\x3c\/a\x3e 模块来创建，对象属性包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3esel\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3edata\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3echildren\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3etext\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eelm\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ekey\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e虽然有所差别，除去实现上的差别和库本身的额外特性，可以看到 Virtual Node 用于创建真实节点的数据包括：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e元素类型\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e元素属性\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e元素的子节点\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e有了这些其实就可以创建对应的真实节点了。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e创建 Virtual DOM\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e嵌套 Virtual Node 就可以得到一棵树了。virtual-dom 和 Snabbdom 都提供了函数调用的方式来创建 Virtual Tree，这个过程就是渲染了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var vTree = h(\x27div\x27, [\n  h(\x27span\x27, \x27hello\x27),\n  h(\x27span\x27, \x27world\x27)\n])\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vTree = h(\x3cspan class=\x22hljs-string\x22\x3e\x27div\x27\x3c\/span\x3e, [\n  h(\x3cspan class=\x22hljs-string\x22\x3e\x27span\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27hello\x27\x3c\/span\x3e),\n  h(\x3cspan class=\x22hljs-string\x22\x3e\x27span\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-string\x22\x3e\x27world\x27\x3c\/span\x3e)\n])\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eReact 提供 JSX 这颗糖，使得我们可以用类似 HTML 的语法来编写，不过编译后实质还是通过函数调用来得到一棵嵌套的 Virtual Tree。而且这对于理解 Virtual DOM 机制来说不是特别重要，先不管这个。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e使用 Virtual DOM\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e首先来看初始化，virtual-dom 提供了 \x3ca href=\x22https:\/\/github.com\/Matt-Esch\/virtual-dom\/blob\/master\/vdom\/create-element.js#L12\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ecreateElement\x3c\/a\x3e 函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var rootNode = createElement(tree)\ndocument.body.appendChild(rootNode)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e rootNode = createElement(tree)\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.body.appendChild(rootNode)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e根据 Virtual Node 创建真实 DOM 元素，然后再追加到页面上。\x3c\/p\x3e\n\x3cp\x3e再来看更新。virtual-dom 有明确的两步操作，首先 diff，然后 patch：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var newTree = render(count)\nvar patches = diff(tree, newTree)\nrootNode = patch(rootNode, patches)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e newTree = render(count)\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e patches = diff(tree, newTree)\nrootNode = patch(rootNode, patches)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而 Snabbdom 则简单些，只有一个 patch 函数，内部在进行比对的同时将更新应用到了真实 DOM 上，而且初始化也是用的 patch 函数：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var vnode = render(data)\nvar container = document.getElementById(\x27container\x27)\npatch(container, vnode)\n\n\/\/ after data changed\nvar newVnode = render(data)\npatch(vnode, newVnode)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e vnode = render(data)\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e container = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementById(\x3cspan class=\x22hljs-string\x22\x3e\x27container\x27\x3c\/span\x3e)\npatch(container, vnode)\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ after data changed\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e newVnode = render(data)\npatch(vnode, newVnode)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3e性能优化\x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e关于性能优化，除了 Virtual DOM 机制本身提供的特性以外，再就是不同的 Virtual DOM 库自身的优化方案了，这个可以看上面两个库的文档，不再赘述。\x3c\/p\x3e\n\x3cp\x3e其实提到 Virtual DOM 的差异比对，有人会对其内部如何处理数组感兴趣。的确，如果数组元素的位置发生了改变，这个要识别起来是有点麻烦。为此，上面两个库和 React 其实都在 Virtual Node 上额外记录了一个属性“\x3cstrong\x3ekey\x3c\/strong\x3e”，就是用来辅助进行 Virtual Node 的比对的。\x3c\/p\x3e\n\x3cp\x3e简单来说，如果两个 Virtual Node 的位置不同，但是 key 属性相同，那么会将这两个节点视为由相同数据渲染得到的，然后进一步进行差异分析。所以，并不是仅仅按照位置进行比对，具体的实现可以查看各个库的源码。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e小结\x3c\/h2\x3e\n\x3cp\x3eOK，以上就是我要讲的全部所有内容了。\x3c\/p\x3e\n\x3cp\x3e相信很多同学之前对 Virtual DOM 已经很熟悉了，比我理解得更深入的同学相信也不会少。不过从“数据变化与UI同步更新”这个角度来理解 Virtual DOM，在我看来是比较好的，所以整理在这里了。\x3c\/p\x3e\n\x3cp\x3e有个问题挺常见，AngularJS 和 React 哪个更好？\x3c\/p\x3e\n\x3cp\x3e如果说各有千秋的话，估计大家就“呵呵”了。但是这两个框架\/库从“数据变化与UI同步更新”的角度来看，的确都解决了问题，而且解决问题的方式大家都挺认可（至少在喜欢它们的同学眼里是这样的）。\x3c\/p\x3e\n\x3cp\x3e而且，如果大家关注 Vue 的话，可以看到，这个 MVVM 框架已经发布了 2.0，其中就采用了 Virtual DOM 实现其UI同步更新！所以，这的确不矛盾啊。\x3c\/p\x3e\n\x3cp\x3e第二个而且，技术本身不是目的，能够更好地解决问题才是王道嘛。\x3c\/p\x3e\n\x3chr\x3e\n\x3cp\x3e原文：\x3ca href=\x22http:\/\/www.jianshu.com\/p\/bef1c1ee5a0e\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e一起理解 Virtual DOM\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>一起理解 Virtual DOM</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007694388">https://segmentfault.com/a/1190000007694388</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/l48db4nszu/" target="_blank">https://alili.tech/archive/l48db4nszu/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>