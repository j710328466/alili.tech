<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="cordova研习笔记(二) —— cordova 6.X 源码解读（上）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>cordova研习笔记(二) —— cordova 6.X 源码解读（上） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/5cu03holh/",
				"appid": "1613049289050283", 
				"title": "cordova研习笔记(二) —— cordova 6.X 源码解读（上） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-15T02:30:12"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/r09faqj1cye/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/hofbklzxw3e/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f&text=cordova%e7%a0%94%e4%b9%a0%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20%e2%80%94%e2%80%94%20cordova%206.X%20%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f&text=cordova%e7%a0%94%e4%b9%a0%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20%e2%80%94%e2%80%94%20cordova%206.X%20%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f&title=cordova%e7%a0%94%e4%b9%a0%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20%e2%80%94%e2%80%94%20cordova%206.X%20%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f&is_video=false&description=cordova%e7%a0%94%e4%b9%a0%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20%e2%80%94%e2%80%94%20cordova%206.X%20%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=cordova%e7%a0%94%e4%b9%a0%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20%e2%80%94%e2%80%94%20cordova%206.X%20%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%8a%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f&title=cordova%e7%a0%94%e4%b9%a0%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20%e2%80%94%e2%80%94%20cordova%206.X%20%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f&title=cordova%e7%a0%94%e4%b9%a0%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20%e2%80%94%e2%80%94%20cordova%206.X%20%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f&title=cordova%e7%a0%94%e4%b9%a0%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20%e2%80%94%e2%80%94%20cordova%206.X%20%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f5cu03holh%2f&title=cordova%e7%a0%94%e4%b9%a0%e7%ac%94%e8%ae%b0%28%e4%ba%8c%29%20%e2%80%94%e2%80%94%20cordova%206.X%20%e6%ba%90%e7%a0%81%e8%a7%a3%e8%af%bb%ef%bc%88%e4%b8%8a%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">cordova研习笔记(二) —— cordova 6.X 源码解读（上）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-15" itemprop="datePublished">2019-01-15</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cp\x3ecordova(PhoneGap) 是一个优秀的经典的中间件框架，网上对其源代码解读的文章确实不多，本系列文章试着解读一下，以便对cordova 框架的原理理解得更深入。本文源码为cordova android版本\x3ccode\x3e6.1.2\x3c\/code\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e源码结构\x3c\/h2\x3e\n\x3cp\x3e我们使用IDE的代码折叠功能先从整体上把握代码结构。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/*\n* 版权申明及注释部分\n*\/\n;(function() {\n  ...\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/*\n* 版权申明及注释部分\n*\/\x3c\/span\x3e\n;(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  ...\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e;\x3c\/code\x3e是保证导入的其它js脚本，使用工具压缩js文件时不出错。一个自执行匿名函数包裹，防止内部变量污染到外部命名空间。阅读过jQuery源码的人都知道，jQuery的也是相同的结构，只是jQuery定义的匿名函数多了两个参数window和undefined，然后调用的时候只传入window，这样，window可以在jQuery内部安全使用，而undefined也的确表示未定义（有些浏览器实现允许重定义undefined）。\x3c\/p\x3e\n\x3cp\x3e继续展开代码，可以看到如下的结构：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22;(function() {\nvar PLATFORM_VERSION_BUILD_LABEL = \x276.1.2\x27;\n\n\/\/ 模块化系统\n\/* ------------------------------------------------------------- *\/\nvar require, \/\/ 加载使用module\n    define;  \/\/ 定义注册module\n\n\/\/ require|define 的逻辑\n(function () {\n  ...\n})();\n\n\/\/ Export for use in node\nif (typeof module === \x26quot;object\x26quot; \x26amp;\x26amp; typeof require === \x26quot;function\x26quot;) {\n    module.exports.require = require;\n    module.exports.define = define;\n}\n\/* ------------------------------------------------------------- *\/\n\n\/\/ 事件的处理和回调，外部访问cordova.js的入口\ndefine(\x26quot;cordova\x26quot;, function(require, exports, module) { ... }\n\n\/\/ JS-\x3eNative的具体交互形式\ndefine(\x26quot;cordova\/android\/nativeapiprovider\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 通过prompt()和Native交互\ndefine(\x26quot;cordova\/android\/promptbasednativeapi\x26quot;, function(require, exports, module)  { ... }\n\n\/\/ 用于plugin中校验参数，比如argscheck.checkArgs(\x27fFO\x27, \x27Camera.getPicture\x27, arguments); 参数应该是2个函数1个对象\ndefine(\x26quot;cordova\/argscheck\x26quot;, function(require, exports, module) { ... }\n\n\/\/ JS-\x3eNative交互时对ArrayBuffer进行uint8ToBase64（WebSockets二进制流）\ndefine(\x26quot;cordova\/base64\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 对象属性操作，比如把一个对象的属性Merge到另外一个对象\ndefine(\x26quot;cordova\/builder\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 事件通道\ndefine(\x26quot;cordova\/channel\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 执行JS-\x3eNative交互\ndefine(\x26quot;cordova\/exec\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 用于Plugin中往已经有的模块上添加方法\ndefine(\x26quot;cordova\/exec\/proxy\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 初始化处理\ndefine(\x26quot;cordova\/init\x26quot;, function(require, exports, module) { ... }\ndefine(\x26quot;cordova\/init_b\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 把定义的模块clobber到一个对象，在初始化的时候会赋给window\ndefine(\x26quot;cordova\/modulemapper\x26quot;, function(require, exports, module) { ... }\ndefine(\x26quot;cordova\/modulemapper_b\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 平台启动处理\ndefine(\x26quot;cordova\/platform\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 清缓存、loadUrl、退出程序等\ndefine(\x26quot;cordova\/plugin\/android\/app\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 载所有cordova_plugins.js中定义的模块，执行完成后会触发\ndefine(\x26quot;cordova\/pluginloader\x26quot;, function(require, exports, module) { ... }\ndefine(\x26quot;cordova\/pluginloader_b\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 获取绝对URL，InAppBrowser中会用到\ndefine(\x26quot;cordova\/urlutil\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 工具类\ndefine(\x26quot;cordova\/utils\x26quot;, function(require, exports, module) { ... }\n\n\/\/ 所有模块注册完之后，导入cordova至全局环境中\nwindow.cordova = require(\x27cordova\x27);\n\n\/\/ 初始化启动\nrequire(\x27cordova\/init\x27);\n\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e;(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e PLATFORM_VERSION_BUILD_LABEL = \x3cspan class=\x22hljs-string\x22\x3e\x276.1.2\x27\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块化系统\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/* ------------------------------------------------------------- *\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e, \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载使用module\x3c\/span\x3e\n    define;  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义注册module\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ require|define 的逻辑\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  ...\n})();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ Export for use in node\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e === \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports.require = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports.define = define;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/* ------------------------------------------------------------- *\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件的处理和回调，外部访问cordova.js的入口\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ JS-\x26gt;Native的具体交互形式\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/android\/nativeapiprovider\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通过prompt()和Native交互\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/android\/promptbasednativeapi\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e)  \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于plugin中校验参数，比如argscheck.checkArgs(\x27fFO\x27, \x27Camera.getPicture\x27, arguments); 参数应该是2个函数1个对象\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/argscheck\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ JS-\x26gt;Native交互时对ArrayBuffer进行uint8ToBase64（WebSockets二进制流）\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/base64\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对象属性操作，比如把一个对象的属性Merge到另外一个对象\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/builder\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件通道\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/channel\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行JS-\x26gt;Native交互\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/exec\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 用于Plugin中往已经有的模块上添加方法\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/exec\/proxy\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化处理\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/init\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/init_b\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把定义的模块clobber到一个对象，在初始化的时候会赋给window\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/modulemapper\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/modulemapper_b\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 平台启动处理\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/platform\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 清缓存、loadUrl、退出程序等\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/plugin\/android\/app\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 载所有cordova_plugins.js中定义的模块，执行完成后会触发\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/pluginloader\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/pluginloader_b\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 获取绝对URL，InAppBrowser中会用到\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/urlutil\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 工具类\x3c\/span\x3e\ndefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/utils\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{ ... }\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 所有模块注册完之后，导入cordova至全局环境中\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.cordova = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cordova\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化启动\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cordova\/init\x27\x3c\/span\x3e);\n\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e从上可以清晰的看出，在cordova内部，首先是定义了两个公共的require和define函数，然后是使用define注册所有模块，再通过window.cordova=require(\x27cordova\x27)导入库文件至全局执行环境中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e模块机制\x3c\/h2\x3e\n\x3cp\x3e类似于Java的package\/import，在JavaScript中也有类似的define\/require，它用来异步加载module化的js，从而提高运行效率。模块化加载的必要性，起源于nodejs的出现。但是JavaScript并没有内置模块系统，所以就出现了很多规范。\x26nbsp;主要有2种：\x3ca href=\x22http:\/\/wiki.commonjs.org\/wiki\/Modules\/1.1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCommonJS\x3c\/a\x3e 和 \x3ca href=\x22http:\/\/en.wikipedia.org\/wiki\/Asynchronous_module_definition\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eAMD（Asynchronous Module Definition）\x3c\/a\x3e。还有国内兴起的\x3ca href=\x22https:\/\/github.com\/cmdjs\/specification\/blob\/master\/draft\/module.md\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCMD（Common Module Definition）\x3c\/a\x3e\x26nbsp;。CommonJS主要面对的是服务器，代表是\x3ca href=\x22http:\/\/nodejs.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNode.js\x3c\/a\x3e；AMD针对浏览器进行了优化，主要实现\x3ca href=\x22http:\/\/www.requirejs.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3erequire.js\x3c\/a\x3e；CMD是\x3ca href=\x22http:\/\/seajs.org\/docs\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eseajs\x3c\/a\x3e。\x26nbsp;\x3c\/p\x3e\n\x3cp\x3ecordova-js最开始采用的是require.js作者写的\x3ca href=\x22http:\/\/github.com\/jrburke\/almond\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ealmond.js\x3c\/a\x3e（兼容AMD和CommonJS），但之后由于特殊需求（比如模块不存在的时候要throw异常），最终从almond.js fork过来实现了一个简易CommonJS风格的模块系统，同时提供了和nodejs之间很好的交互。在cordova.js中可以直接使用define()和require()，在其他文件可以通过cordova.define()和cordova.require()来调用。所以src\/scripts\/require.js中定义的就是一个精简的JavaScript模块系统。\x26nbsp;\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ cordova.js内部使用的全局函数require\/define\nvar require,\n    define;\n\n(function () {\n    \/\/ 初始化一个空对象，缓存所有的模块\n    var modules = {},\n    \/\/ 正在build中的模块ID的栈\n        requireStack = [],\n    \/\/ 标示正在build中模块ID的Map\n        inProgressModules = {},\n        SEPARATOR = \x26quot;.\x26quot;;\n\n    \/\/ 模块build\n    function build(module) {\n        \/\/ 备份工厂方法\n        var factory = module.factory,\n        \/\/ 对require对象进行特殊处理 \n            localRequire = function (id) {\n                var resultantId = id;\n                \/\/Its a relative path, so lop off the last portion and add the id (minus \x26quot;.\/\x26quot;)\n                if (id.charAt(0) === \x26quot;.\x26quot;) {\n                    resultantId = module.id.slice(0, module.id.lastIndexOf(SEPARATOR)) \x2b SEPARATOR \x2b id.slice(2);\n                }\n                return require(resultantId);\n            };\n        \/\/ 给模块定义一个空的exports对象，防止工厂类方法中的空引用\n        module.exports = {};\n        \/\/ 删除工厂方法\n        delete module.factory;\n        \/\/ 调用备份的工厂方法（参数必须是require,exports,module）  \n        factory(localRequire, module.exports, module);\n        \/\/ 返回工厂方法中实现的module.exports对象\n        return module.exports;\n    }\n    \n    \/\/ 加载使用模块\n    require = function (id) {\n        \/\/ 如果模块不存在抛出异常 \n        if (!modules[id]) {\n            throw \x26quot;module \x26quot; \x2b id \x2b \x26quot; not found\x26quot;;\n        \/\/ 如果模块正在build中抛出异常\n        } else if (id in inProgressModules) {\n            var cycle = requireStack.slice(inProgressModules[id]).join(\x27-\x3e\x27) \x2b \x27-\x3e\x27 \x2b id;\n            throw \x26quot;Cycle in require graph: \x26quot; \x2b cycle;\n        }\n        \/\/ 如果模块存在工厂方法说明还未进行build（require嵌套）\n        if (modules[id].factory) {\n            try {\n                \/\/ 标示该模块正在build\n                inProgressModules[id] = requireStack.length;\n                \/\/ 将该模块压入请求栈\n                requireStack.push(id);\n                \/\/ 模块build，成功后返回module.exports\n                return build(modules[id]);\n            } finally {\n                \/\/ build完成后删除当前请求\n                delete inProgressModules[id];\n                requireStack.pop();\n            }\n        }\n        \/\/ build完的模块直接返回module.exports  \n        return modules[id].exports;\n    };\n    \n    \/\/ 定义注册模块\n    define = function (id, factory) {\n        \/\/ 如果已经存在抛出异常\n        if (modules[id]) {\n            throw \x26quot;module \x26quot; \x2b id \x2b \x26quot; already defined\x26quot;;\n        }\n        \/\/ 模块以ID为索引包含ID和工厂方法\n        modules[id] = {\n            id: id,\n            factory: factory\n        };\n    };\n    \n    \/\/ 移除模块\n    define.remove = function (id) {\n        delete modules[id];\n    };\n    \n    \/\/ 返回所有模块\n    define.moduleMap = modules;\n})();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ cordova.js内部使用的全局函数require\/define\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e,\n    define;\n\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化一个空对象，缓存所有的模块\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e modules = {},\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 正在build中的模块ID的栈\x3c\/span\x3e\n        requireStack = [],\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 标示正在build中模块ID的Map\x3c\/span\x3e\n        inProgressModules = {},\n        SEPARATOR = \x3cspan class=\x22hljs-string\x22\x3e\x22.\x22\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块build\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebuild\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emodule\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 备份工厂方法\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e factory = \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.factory,\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对require对象进行特殊处理 \x3c\/span\x3e\n            localRequire = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e resultantId = id;\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/Its a relative path, so lop off the last portion and add the id (minus \x22.\/\x22)\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (id.charAt(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) === \x3cspan class=\x22hljs-string\x22\x3e\x22.\x22\x3c\/span\x3e) {\n                    resultantId = \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.id.slice(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.id.lastIndexOf(SEPARATOR)) \x2b SEPARATOR \x2b id.slice(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n                }\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(resultantId);\n            };\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 给模块定义一个空的exports对象，防止工厂类方法中的空引用\x3c\/span\x3e\n        \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {};\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除工厂方法\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.factory;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用备份的工厂方法（参数必须是require,exports,module）  \x3c\/span\x3e\n        factory(localRequire, \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports, \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e);\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回工厂方法中实现的module.exports对象\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports;\n    }\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载使用模块\x3c\/span\x3e\n    \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果模块不存在抛出异常 \x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!modules[id]) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22module \x22\x3c\/span\x3e \x2b id \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 not found\x22\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果模块正在build中抛出异常\x3c\/span\x3e\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (id \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e inProgressModules) {\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cycle = requireStack.slice(inProgressModules[id]).join(\x3cspan class=\x22hljs-string\x22\x3e\x27-\x26gt;\x27\x3c\/span\x3e) \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27-\x26gt;\x27\x3c\/span\x3e \x2b id;\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22Cycle in require graph: \x22\x3c\/span\x3e \x2b cycle;\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果模块存在工厂方法说明还未进行build（require嵌套）\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (modules[id].factory) {\n            \x3cspan class=\x22hljs-keyword\x22\x3etry\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 标示该模块正在build\x3c\/span\x3e\n                inProgressModules[id] = requireStack.length;\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将该模块压入请求栈\x3c\/span\x3e\n                requireStack.push(id);\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块build，成功后返回module.exports\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e build(modules[id]);\n            } \x3cspan class=\x22hljs-keyword\x22\x3efinally\x3c\/span\x3e {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ build完成后删除当前请求\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e inProgressModules[id];\n                requireStack.pop();\n            }\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ build完的模块直接返回module.exports  \x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e modules[id].exports;\n    };\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义注册模块\x3c\/span\x3e\n    define = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eid, factory\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果已经存在抛出异常\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (modules[id]) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22module \x22\x3c\/span\x3e \x2b id \x2b \x3cspan class=\x22hljs-string\x22\x3e\x22 already defined\x22\x3c\/span\x3e;\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 模块以ID为索引包含ID和工厂方法\x3c\/span\x3e\n        modules[id] = {\n            \x3cspan class=\x22hljs-attr\x22\x3eid\x3c\/span\x3e: id,\n            \x3cspan class=\x22hljs-attr\x22\x3efactory\x3c\/span\x3e: factory\n        };\n    };\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 移除模块\x3c\/span\x3e\n    define.remove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eid\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e modules[id];\n    };\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 返回所有模块\x3c\/span\x3e\n    define.moduleMap = modules;\n})();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先在外部cordova环境中定义require和define两个变量，用来存储实现导入功能的函数和实现注册功能的函数。然后用一个立即调用的匿名函数来实例化这两个变量，在这个匿名函数内部，缓存了所有的功能模块。注册模块时，如果已经注册了，就直接抛出异常，防止无意中重定义，如确实需要重定义，可先调用define.remove。\x3c\/p\x3e\n\x3cp\x3e从内部私有函数build中，可以看出，调用工厂函数时， \x3ccode\x3efactory(localRequire, module.exports, module); \x3c\/code\x3e第一个参数\x3ccode\x3elocalRequire\x3c\/code\x3e实质还是调用全局的\x3ccode\x3erequire()\x3c\/code\x3e函数，只是把ID稍微加工了一下支持相对路径。cordova.js没有用到相对路径的require，但在一些Plugin的js中有，比如\x3ccode\x3eContact.js\x3c\/code\x3e 中 \x3ccode\x3eContactError = require(\x27.\/ContactError\x27); \x3c\/code\x3e\x3c\/p\x3e\n\x3cp\x3e这里我们写个测试用例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript src=\x26quot;module.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript type=\x26quot;text\/javascript\x26quot;\x3e\n    define(\x27plugin.first\x27, function (require, exports, module) {\n        module.exports = {\n            name: \x27first plugin\x27,\n            show: function () {\n                console.log(\x26quot;call \x26quot;\x2bthis.name);\n            }\n        }\n    });\n\n    define(\x27plugin.second\x27, function (require, exports, module) {\n        var first = require(\x26quot;plugin.first\x26quot;);\n        first.show();\n    });\n\n    require(\x26quot;plugin.second\x26quot;); \n    \/\/ call first plugin\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x26lt;script src=\x3cspan class=\x22hljs-string\x22\x3e\x22module.js\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x26lt;script type=\x3cspan class=\x22hljs-string\x22\x3e\x22text\/javascript\x22\x3c\/span\x3e\x26gt;\n    define(\x3cspan class=\x22hljs-string\x22\x3e\x27plugin.first\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = {\n            \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27first plugin\x27\x3c\/span\x3e,\n            \x3cspan class=\x22hljs-attr\x22\x3eshow\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x22call \x22\x3c\/span\x3e\x2b\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name);\n            }\n        }\n    });\n\n    define(\x3cspan class=\x22hljs-string\x22\x3e\x27plugin.second\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e first = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22plugin.first\x22\x3c\/span\x3e);\n        first.show();\n    });\n\n    \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22plugin.second\x22\x3c\/span\x3e); \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ call first plugin\x3c\/span\x3e\n\x26lt;\x3cspan class=\x22hljs-regexp\x22\x3e\/script\x26gt;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e注：module.js为上述cordova的模块代码。\x3c\/p\x3e\n\x3cp\x3e上面例子中我们定义了两个模块，这里是写在同一个页面下，在实际中我们自然希望写在两个不同的文件中，然后按需加载。我们上一篇文章中说明了cordova的插件使用方法，我们会发现\x3ccode\x3ecordova_plugins.js\x3c\/code\x3e中定义了cordova插件的id、路径等变量，并且该文件定义了一个id为\x3ccode\x3ecordova\/plugin_list\x3c\/code\x3e的模块，我们在cordova.js中可以看到有这个模块的引用。\x3c\/p\x3e\n\x3cp\x3e定义了require和define并赋值后，是将cordova所有模块一一注册，例如：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22define(\x26quot;cordova\x26quot;,function(require,exports,module){\n  \/\/ 工厂函数内部实现代码\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3edefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\x22\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire,exports,module\x3c\/span\x3e)\x3c\/span\x3e{\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 工厂函数内部实现代码\x3c\/span\x3e\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里需要注意的是，\x3cstrong\x3edefine只是注册模块，不会调用其factory。\x3c\/strong\x3efactory函数在这个时候并没有实际执行，而只是定义，并作为一个参数传递给define函数。所有模块注册完之后，通过：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22window.cordova = require(\x27cordova\x27);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.cordova = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cordova\x27\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e导入至全局环境。\x3c\/p\x3e\n\x3cp\x3e因为是注册后第一次导入，所以在执行\x3ccode\x3erequire(\x27cordova\x27)\x3c\/code\x3e时，\x3ccode\x3emodules[\x27cordova\x27].factory\x3c\/code\x3e的值是注册时的工厂函数，转变为boolean值时为true，从而在这里会通过build调用这个工厂函数，并将这个工厂函数从注册缓存里面删除，接下来的就是去执行cordova的这个factory函数了。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e事件通道\x3c\/h2\x3e\n\x3cp\x3e作为观察者模式(Observer)的一种变形，很多MV*框架（比如：Vue.js、Backbone.js）中都提供发布\/订阅模型来对代码进行解耦。cordova.js中也提供了一个自定义的pub-sub模型，基于该模型提供了一些事件通道，用来控制通道中的事件什么时候以什么样的顺序被调用，以及各个事件通道的调用。\x3c\/p\x3e\n\x3cp\x3esrc\/common\/channel.js的代码结构也是一个很经典的定义结构（构造函数、实例、修改函数原型共享实例方法），它提供事件通道上事件的订阅（subscribe）、撤消订阅（unsubscribe）、调用（fire）。pub-sub模型用于定义和控制对cordova初始化的事件的触发以及此后的自定义事件。\x3c\/p\x3e\n\x3cp\x3e页面加载和Cordova启动期间的事件顺序如下：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\n\x3cstrong\x3eonDOMContentLoaded\x3c\/strong\x3e ——（内部事件通道）页面加载后DOM解析完成\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eonNativeReady\x3c\/strong\x3e ——（内部事件通道）Cordova的native准备完成\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eonCordovaReady\x3c\/strong\x3e ——（内部事件通道）所有Cordova的JavaScript对象被创建完成可以开始加载插件\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eonDeviceReady\x3c\/strong\x3e —— Cordova全部准备完成\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eonResume\x3c\/strong\x3e —— 应用重新返回前台\x3c\/li\x3e\n\x3cli\x3e\n\x3cstrong\x3eonPause\x3c\/strong\x3e —— 应用暂停退到后台\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e可以通过下面的事件进行监听：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22document.addEventListener(\x26quot;deviceready\x26quot;, myDeviceReadyListener, false);\ndocument.addEventListener(\x26quot;resume\x26quot;, myResumeListener, false);\ndocument.addEventListener(\x26quot;pause\x26quot;, myPauseListener, false);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22deviceready\x22\x3c\/span\x3e, myDeviceReadyListener, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22resume\x22\x3c\/span\x3e, myResumeListener, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x22pause\x22\x3c\/span\x3e, myPauseListener, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eDOM生命周期事件应用于保存和恢复状态：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3ewindow.onload\x3c\/li\x3e\n\x3cli\x3ewindow.onunload\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22define(\x26quot;cordova\/channel\x26quot;, function(require, exports, module) {\n\n    var utils = require(\x27cordova\/utils\x27),\n        nextGuid = 1;\n\n    \/\/ 事件通道的构造函数\n    var Channel = function(type, sticky) {\n        \/\/ 通道名称\n        this.type = type;\n        \/\/ 通道上的所有事件处理函数Map（索引为guid）\n        this.handlers = {};\n        \/\/ 通道的状态（0：非sticky, 1:sticky但未调用, 2:sticky已调用）  \n        this.state = sticky ? 1 : 0;\n        \/\/ 对于sticky事件通道备份传给fire()的参数 \n        this.fireArgs = null;\n        \/\/ 当前通道上的事件处理函数的个数\n        this.numHandlers = 0;\n        \/\/ 订阅第一个事件或者取消订阅最后一个事件时调用自定义的处理\n        this.onHasSubscribersChange = null;\n    },\n    \/\/ 事件通道外部接口\n    channel = {\n        \/\/ 把指定的函数h订阅到c的各个通道上，保证h在每个通道的最后被执行  \n        join: function(h, c) {\n            var len = c.length,\n                i = len,\n                f = function() {\n                    if (!(--i)) h();\n                };\n            for (var j=0; j\x3clen; j\x2b\x2b) {\n                if (c[j].state === 0) {\n                    throw Error(\x27Can only use join with sticky channels.\x27);\n                }\n                c[j].subscribe(f);\n            }\n            if (!len) h();\n        },\n        \/\/ 创建事件通道\n        create: function(type) {\n            return channel[type] = new Channel(type, false);\n        },\n        \/\/ 创建sticky事件通道\n        createSticky: function(type) {\n            return channel[type] = new Channel(type, true);\n        },\n    \n        \/\/ 保存deviceready事件之前要调用的事件\n        deviceReadyChannelsArray: [],\n        deviceReadyChannelsMap: {},\n    \n        \/\/ 设置deviceready事件之前必须要完成的事件\n        waitForInitialization: function(feature) {\n            if (feature) {\n                var c = channel[feature] || this.createSticky(feature);\n                this.deviceReadyChannelsMap[feature] = c;\n                this.deviceReadyChannelsArray.push(c);\n            }\n        },\n    \n        \/\/ 初始化代码已经完成\n        initializationComplete: function(feature) {\n            var c = this.deviceReadyChannelsMap[feature];\n            if (c) {\n                c.fire();\n            }\n        }\n    };\n\n    \/\/ 校验事件处理函数\n    function checkSubscriptionArgument(argument) {\n        if (typeof argument !== \x26quot;function\x26quot; \x26amp;\x26amp; typeof argument.handleEvent !== \x26quot;function\x26quot;) {\n            throw new Error(\n                \x26quot;Must provide a function or an EventListener object \x26quot; \x2b\n                \x26quot;implementing the handleEvent interface.\x26quot;\n            );\n        }\n    }\n\n    \/**\n     * 向事件通道订阅事件处理函数(subscribe部分）  \n     * f:事件处理函数 c:事件的上下文\n     *\/\n    Channel.prototype.subscribe = function(eventListenerOrFunction, eventListener) {\n        \/\/ 校验事件处理函数\n        checkSubscriptionArgument(eventListenerOrFunction);\n        \n        var handleEvent, guid;\n    \n        if (eventListenerOrFunction \x26amp;\x26amp; typeof eventListenerOrFunction === \x26quot;object\x26quot;) {\n            \/\/ 接收到一个实现handleEvent接口的EventListener对象\n            handleEvent = eventListenerOrFunction.handleEvent;\n            eventListener = eventListenerOrFunction;\n        } else {\n            \/\/ 接收到处理事件的回调函数\n            handleEvent = eventListenerOrFunction;\n        }\n        \n        \/\/ 如果是被订阅过的sticky事件，就直接调用\n        if (this.state == 2) {\n            handleEvent.apply(eventListener || this, this.fireArgs);\n            return;\n        }\n    \n        guid = eventListenerOrFunction.observer_guid;\n        \/\/ 如果事件有上下文，要先把事件函数包装一下带上上下文\n        if (typeof eventListener === \x26quot;object\x26quot;) {\n            handleEvent = utils.close(eventListener, handleEvent);\n        }\n        \n        \/\/ 自增长的ID\n        if (!guid) {\n            guid = \x27\x27 \x2b nextGuid\x2b\x2b;\n        }\n        \/\/ 把自增长的ID反向设置给函数，以后撤消订阅或内部查找用\n        handleEvent.observer_guid = guid;\n        eventListenerOrFunction.observer_guid = guid;\n    \n        \/\/ 判断该guid索引的事件处理函数是否存在（保证订阅一次）\n        if (!this.handlers[guid]) {\n            \/\/ 订阅到该通道上（索引为guid）\n            this.handlers[guid] = handleEvent;\n            \/\/ 通道上的事件处理函数的个数增1 \n            this.numHandlers\x2b\x2b;\n            if (this.numHandlers == 1) {\n                \/\/ 订阅第一个事件时调用自定义的处理（比如：第一次按下返回按钮提示“再按一次...”） \n                this.onHasSubscribersChange \x26amp;\x26amp; this.onHasSubscribersChange();\n            }\n        }\n    };\n\n    \/**\n     * 撤消订阅通道上的某个函数（guid）\n     *\/\n    Channel.prototype.unsubscribe = function(eventListenerOrFunction) {\n         \/\/ 事件处理函数校验\n        checkSubscriptionArgument(eventListenerOrFunction);\n\n        var handleEvent, guid, handler;\n    \n        if (eventListenerOrFunction \x26amp;\x26amp; typeof eventListenerOrFunction === \x26quot;object\x26quot;) {\n            \/\/ 接收到一个实现handleEvent接口的EventListener对象\n            handleEvent = eventListenerOrFunction.handleEvent;\n        } else {\n            \/\/ 接收到处理事件的回调函数\n            handleEvent = eventListenerOrFunction;\n        }\n\n        \/\/ 事件处理函数的guid索引\n        guid = handleEvent.observer_guid;\n        \/\/ 事件处理函数\n        handler = this.handlers[guid];\n        if (handler) {\n            \/\/ 从该通道上撤消订阅（索引为guid）\n            delete this.handlers[guid];\n            \/\/ 通道上的事件处理函数的个数减1\n            this.numHandlers--;\n            if (this.numHandlers === 0) {\n                \/\/ 撤消订阅最后一个事件时调用自定义的处理\n                this.onHasSubscribersChange \x26amp;\x26amp; this.onHasSubscribersChange();\n            }\n        }\n    };\n\n    \/**\n     * 调用所有被发布到该通道上的函数\n     *\/\n    Channel.prototype.fire = function(e) {\n        var fail = false,\n            fireArgs = Array.prototype.slice.call(arguments);\n\n        \/\/ sticky事件被调用时，标示为已经调用过\n        if (this.state == 1) {\n            this.state = 2;\n            this.fireArgs = fireArgs;\n        }\n        if (this.numHandlers) {\n            \/\/ 把该通道上的所有事件处理函数拿出来放到一个数组中\n            var toCall = [];\n            for (var item in this.handlers) {\n                toCall.push(this.handlers[item]);\n            }\n            \/\/ 依次调用通道上的所有事件处理函数\n            for (var i = 0; i \x3c toCall.length; \x2b\x2bi) {\n                toCall[i].apply(this, fireArgs);\n            }\n            \/\/ sticky事件是一次性全部被调用的，调用完成后就清空\n            if (this.state == 2 \x26amp;\x26amp; this.numHandlers) {\n                this.numHandlers = 0;\n                this.handlers = {};\n                this.onHasSubscribersChange \x26amp;\x26amp; this.onHasSubscribersChange();\n            }\n        }\n    };\n\n    \/**\n     * 创建事件通道（publish部分）\n     *\/\n    \/\/（内部事件通道）页面加载后DOM解析完成\n    channel.createSticky(\x27onDOMContentLoaded\x27);\n    \n    \/\/（内部事件通道）Cordova的native准备完成\n    channel.createSticky(\x27onNativeReady\x27);\n    \n    \/\/（内部事件通道）所有Cordova的JavaScript对象被创建完成可以开始加载插件  \n    channel.createSticky(\x27onCordovaReady\x27);\n    \n    \/\/（内部事件通道）所有自动load的插件js已经被加载完成（待删除）\n    channel.createSticky(\x27onPluginsReady\x27);\n    \n    \/\/ Cordova全部准备完成\n    channel.createSticky(\x27onDeviceReady\x27);\n    \n    \/\/ 应用重新返回前台\n    channel.create(\x27onResume\x27);\n    \n    \/\/ 应用暂停退到后台\n    channel.create(\x27onPause\x27);\n    \n    \/\/ 设置deviceready事件之前必须要完成的事件\n    channel.waitForInitialization(\x27onCordovaReady\x27);\n    channel.waitForInitialization(\x27onDOMContentLoaded\x27);\n    \n    module.exports = channel;\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3edefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/channel\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e utils = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cordova\/utils\x27\x3c\/span\x3e),\n        nextGuid = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件通道的构造函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Channel = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype, sticky\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通道名称\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.type = type;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通道上的所有事件处理函数Map（索引为guid）\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handlers = {};\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通道的状态（0：非sticky, 1:sticky但未调用, 2:sticky已调用）  \x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = sticky ? \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e : \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对于sticky事件通道备份传给fire()的参数 \x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fireArgs = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当前通道上的事件处理函数的个数\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numHandlers = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅第一个事件或者取消订阅最后一个事件时调用自定义的处理\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHasSubscribersChange = \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e;\n    },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件通道外部接口\x3c\/span\x3e\n    channel = {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把指定的函数h订阅到c的各个通道上，保证h在每个通道的最后被执行  \x3c\/span\x3e\n        join: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eh, c\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e len = c.length,\n                i = len,\n                f = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!(--i)) h();\n                };\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e j=\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; j\x26lt;len; j\x2b\x2b) {\n                \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (c[j].state === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27Can only use join with sticky channels.\x27\x3c\/span\x3e);\n                }\n                c[j].subscribe(f);\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!len) h();\n        },\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建事件通道\x3c\/span\x3e\n        create: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e channel[type] = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Channel(type, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n        },\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建sticky事件通道\x3c\/span\x3e\n        createSticky: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e channel[type] = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Channel(type, \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e);\n        },\n    \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存deviceready事件之前要调用的事件\x3c\/span\x3e\n        deviceReadyChannelsArray: [],\n        \x3cspan class=\x22hljs-attr\x22\x3edeviceReadyChannelsMap\x3c\/span\x3e: {},\n    \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置deviceready事件之前必须要完成的事件\x3c\/span\x3e\n        waitForInitialization: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efeature\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (feature) {\n                \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e c = channel[feature] || \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.createSticky(feature);\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deviceReadyChannelsMap[feature] = c;\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deviceReadyChannelsArray.push(c);\n            }\n        },\n    \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化代码已经完成\x3c\/span\x3e\n        initializationComplete: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efeature\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e c = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.deviceReadyChannelsMap[feature];\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (c) {\n                c.fire();\n            }\n        }\n    };\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 校验事件处理函数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3echeckSubscriptionArgument\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eargument\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e argument !== \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e argument.handleEvent !== \x3cspan class=\x22hljs-string\x22\x3e\x22function\x22\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\n                \x3cspan class=\x22hljs-string\x22\x3e\x22Must provide a function or an EventListener object \x22\x3c\/span\x3e \x2b\n                \x3cspan class=\x22hljs-string\x22\x3e\x22implementing the handleEvent interface.\x22\x3c\/span\x3e\n            );\n        }\n    }\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * 向事件通道订阅事件处理函数(subscribe部分）  \n     * f:事件处理函数 c:事件的上下文\n     *\/\x3c\/span\x3e\n    Channel.prototype.subscribe = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eeventListenerOrFunction, eventListener\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 校验事件处理函数\x3c\/span\x3e\n        checkSubscriptionArgument(eventListenerOrFunction);\n        \n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e handleEvent, guid;\n    \n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (eventListenerOrFunction \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e eventListenerOrFunction === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接收到一个实现handleEvent接口的EventListener对象\x3c\/span\x3e\n            handleEvent = eventListenerOrFunction.handleEvent;\n            eventListener = eventListenerOrFunction;\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接收到处理事件的回调函数\x3c\/span\x3e\n            handleEvent = eventListenerOrFunction;\n        }\n        \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果是被订阅过的sticky事件，就直接调用\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state == \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e) {\n            handleEvent.apply(eventListener || \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fireArgs);\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e;\n        }\n    \n        guid = eventListenerOrFunction.observer_guid;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果事件有上下文，要先把事件函数包装一下带上上下文\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e eventListener === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e) {\n            handleEvent = utils.close(eventListener, handleEvent);\n        }\n        \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 自增长的ID\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!guid) {\n            guid = \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e \x2b nextGuid\x2b\x2b;\n        }\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把自增长的ID反向设置给函数，以后撤消订阅或内部查找用\x3c\/span\x3e\n        handleEvent.observer_guid = guid;\n        eventListenerOrFunction.observer_guid = guid;\n    \n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 判断该guid索引的事件处理函数是否存在（保证订阅一次）\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handlers[guid]) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅到该通道上（索引为guid）\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handlers[guid] = handleEvent;\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通道上的事件处理函数的个数增1 \x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numHandlers\x2b\x2b;\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numHandlers == \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅第一个事件时调用自定义的处理（比如：第一次按下返回按钮提示“再按一次...”） \x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHasSubscribersChange \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHasSubscribersChange();\n            }\n        }\n    };\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * 撤消订阅通道上的某个函数（guid）\n     *\/\x3c\/span\x3e\n    Channel.prototype.unsubscribe = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eeventListenerOrFunction\x3c\/span\x3e) \x3c\/span\x3e{\n         \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件处理函数校验\x3c\/span\x3e\n        checkSubscriptionArgument(eventListenerOrFunction);\n\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e handleEvent, guid, handler;\n    \n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (eventListenerOrFunction \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e eventListenerOrFunction === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接收到一个实现handleEvent接口的EventListener对象\x3c\/span\x3e\n            handleEvent = eventListenerOrFunction.handleEvent;\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接收到处理事件的回调函数\x3c\/span\x3e\n            handleEvent = eventListenerOrFunction;\n        }\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件处理函数的guid索引\x3c\/span\x3e\n        guid = handleEvent.observer_guid;\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 事件处理函数\x3c\/span\x3e\n        handler = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handlers[guid];\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (handler) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 从该通道上撤消订阅（索引为guid）\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handlers[guid];\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通道上的事件处理函数的个数减1\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numHandlers--;\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numHandlers === \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) {\n                \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 撤消订阅最后一个事件时调用自定义的处理\x3c\/span\x3e\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHasSubscribersChange \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHasSubscribersChange();\n            }\n        }\n    };\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * 调用所有被发布到该通道上的函数\n     *\/\x3c\/span\x3e\n    Channel.prototype.fire = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fail = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e,\n            fireArgs = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.prototype.slice.call(\x3cspan class=\x22hljs-built_in\x22\x3earguments\x3c\/span\x3e);\n\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/ sticky事件被调用时，标示为已经调用过\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state == \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.fireArgs = fireArgs;\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numHandlers) {\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 把该通道上的所有事件处理函数拿出来放到一个数组中\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e toCall = [];\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e item \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handlers) {\n                toCall.push(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handlers[item]);\n            }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 依次调用通道上的所有事件处理函数\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; toCall.length; \x2b\x2bi) {\n                toCall[i].apply(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, fireArgs);\n            }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ sticky事件是一次性全部被调用的，调用完成后就清空\x3c\/span\x3e\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state == \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numHandlers) {\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.numHandlers = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.handlers = {};\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHasSubscribersChange \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onHasSubscribersChange();\n            }\n        }\n    };\n\n    \x3cspan class=\x22hljs-comment\x22\x3e\/**\n     * 创建事件通道（publish部分）\n     *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/（内部事件通道）页面加载后DOM解析完成\x3c\/span\x3e\n    channel.createSticky(\x3cspan class=\x22hljs-string\x22\x3e\x27onDOMContentLoaded\x27\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/（内部事件通道）Cordova的native准备完成\x3c\/span\x3e\n    channel.createSticky(\x3cspan class=\x22hljs-string\x22\x3e\x27onNativeReady\x27\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/（内部事件通道）所有Cordova的JavaScript对象被创建完成可以开始加载插件  \x3c\/span\x3e\n    channel.createSticky(\x3cspan class=\x22hljs-string\x22\x3e\x27onCordovaReady\x27\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/（内部事件通道）所有自动load的插件js已经被加载完成（待删除）\x3c\/span\x3e\n    channel.createSticky(\x3cspan class=\x22hljs-string\x22\x3e\x27onPluginsReady\x27\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Cordova全部准备完成\x3c\/span\x3e\n    channel.createSticky(\x3cspan class=\x22hljs-string\x22\x3e\x27onDeviceReady\x27\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 应用重新返回前台\x3c\/span\x3e\n    channel.create(\x3cspan class=\x22hljs-string\x22\x3e\x27onResume\x27\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 应用暂停退到后台\x3c\/span\x3e\n    channel.create(\x3cspan class=\x22hljs-string\x22\x3e\x27onPause\x27\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置deviceready事件之前必须要完成的事件\x3c\/span\x3e\n    channel.waitForInitialization(\x3cspan class=\x22hljs-string\x22\x3e\x27onCordovaReady\x27\x3c\/span\x3e);\n    channel.waitForInitialization(\x3cspan class=\x22hljs-string\x22\x3e\x27onDOMContentLoaded\x27\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = channel;\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们可以写一个测试用例：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\x3cscript src=\x26quot;channel.js\x26quot;\x3e\x3c\/script\x3e\n\x3cscript type=\x26quot;text\/javascript\x26quot;\x3e\n    var test = channel.create(\x27onTest\x27);\n    \/\/ 订阅事件（此处test = channel.onTest）\n    test.subscribe(function () {\n        console.log(\x27test fire\x27);\n    });\n    \/\/ 触发事件（此处test = channel.onTest）\n    test.fire();\n\x3c\/script\x3e\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x26lt;script src=\x3cspan class=\x22hljs-string\x22\x3e\x22channel.js\x22\x3c\/span\x3e\x26gt;\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n\x26lt;script type=\x3cspan class=\x22hljs-string\x22\x3e\x22text\/javascript\x22\x3c\/span\x3e\x26gt;\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e test = channel.create(\x3cspan class=\x22hljs-string\x22\x3e\x27onTest\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅事件（此处test = channel.onTest）\x3c\/span\x3e\n    test.subscribe(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27test fire\x27\x3c\/span\x3e);\n    });\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 触发事件（此处test = channel.onTest）\x3c\/span\x3e\n    test.fire();\n\x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3escript\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但是很多时候我们希望能够传递参数，通过阅读上面的源码可以得知：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (eventListenerOrFunction \x26amp;\x26amp; typeof eventListenerOrFunction === \x26quot;object\x26quot;) {\n    \/\/ 接收到一个实现handleEvent接口的EventListener对象\n    handleEvent = eventListenerOrFunction.handleEvent;\n   eventListener = eventListenerOrFunction;\n} else {\n   \/\/ 接收到处理事件的回调函数\n   handleEvent = eventListenerOrFunction;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (eventListenerOrFunction \x26amp;\x26amp; \x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e eventListenerOrFunction === \x3cspan class=\x22hljs-string\x22\x3e\x22object\x22\x3c\/span\x3e) {\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接收到一个实现handleEvent接口的EventListener对象\x3c\/span\x3e\n    handleEvent = eventListenerOrFunction.handleEvent;\n   eventListener = eventListenerOrFunction;\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 接收到处理事件的回调函数\x3c\/span\x3e\n   handleEvent = eventListenerOrFunction;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们上面的例子中我们传递的是一个方法，这里我们也可以传递一个EventListener对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建事件通道\nchannel.create(\x27onTest\x27);\n\n\/\/ 订阅事件\nchannel.onTest.subscribe(function (event) {\n  console.log(event);\n  console.log(event.data.name\x2b\x27 fire\x27);\n});\n\n\/\/ 创建 Event 对象\nvar event = document.createEvent(\x27Events\x27);\n\/\/ 初始化事件\nevent.initEvent(\x27onTest\x27, false, false);\n\/\/ 绑定数据\nevent.data = {name: \x27test\x27};\n\/\/ 触发事件\nchannel.onTest.fire(event);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建事件通道\x3c\/span\x3e\nchannel.create(\x3cspan class=\x22hljs-string\x22\x3e\x27onTest\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅事件\x3c\/span\x3e\nchannel.onTest.subscribe(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(event);\n  \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(event.data.name\x2b\x3cspan class=\x22hljs-string\x22\x3e\x27 fire\x27\x3c\/span\x3e);\n});\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建 Event 对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e event = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27Events\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 初始化事件\x3c\/span\x3e\nevent.initEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27onTest\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绑定数据\x3c\/span\x3e\nevent.data = {\x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27test\x27\x3c\/span\x3e};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 触发事件\x3c\/span\x3e\nchannel.onTest.fire(event);\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e工具模块\x3c\/h2\x3e\n\x3cp\x3e我们在写插件的时候如果熟悉cordova自带的工具函数，可以更加方便的拓展自己的插件。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22define(\x26quot;cordova\/utils\x26quot;, function(require, exports, module) {\n    var utils = exports;\n    \/\/ 定义对象属性（或方法）的setter\/getter\n    utils.defineGetterSetter = function(obj, key, getFunc, opt_setFunc) {...}\n    \/\/ 定义对象属性（或方法）的getter\n    utils.defineGetter = utils.defineGetterSetter;\n    \/\/ Array IndexOf 方法\n    utils.arrayIndexOf = function(a, item) {...}\n    \/\/ Array remove 方法\n    utils.arrayRemove = function(a, item) {...}\n    \/\/ 类型判断\n    utils.typeName = function(val) {...}\n    \/\/ 数组判断\n    utils.isArray = Array.isArray ||\n        function(a) {return utils.typeName(a) == \x27Array\x27;};\n    \/\/ Date判断\n    utils.isDate = function(d) {...}\n    \/\/ 深度拷贝\n    utils.clone = function(obj) {...}\n    \/\/ 函数包装调用\n    utils.close = function(context, func, params) {...}\n    \/\/ 内部私有函数，产生随机数\n    function UUIDcreatePart(length) {...}\n    \/\/ 创建 UUID (通用唯一识别码)\n    utils.createUUID = function() {...}\n    \/\/ 继承\n    utils.extend = function() {...}\n    \/\/ 调试\n    utils.alert = function(msg) {...}\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3edefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\/utils\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e utils = exports;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义对象属性（或方法）的setter\/getter\x3c\/span\x3e\n    utils.defineGetterSetter = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj, key, getFunc, opt_setFunc\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 定义对象属性（或方法）的getter\x3c\/span\x3e\n    utils.defineGetter = utils.defineGetterSetter;\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Array IndexOf 方法\x3c\/span\x3e\n    utils.arrayIndexOf = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea, item\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Array remove 方法\x3c\/span\x3e\n    utils.arrayRemove = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea, item\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 类型判断\x3c\/span\x3e\n    utils.typeName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eval\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数组判断\x3c\/span\x3e\n    utils.isArray = \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e.isArray ||\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ea\x3c\/span\x3e) \x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e utils.typeName(a) == \x3cspan class=\x22hljs-string\x22\x3e\x27Array\x27\x3c\/span\x3e;};\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Date判断\x3c\/span\x3e\n    utils.isDate = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ed\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 深度拷贝\x3c\/span\x3e\n    utils.clone = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eobj\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 函数包装调用\x3c\/span\x3e\n    utils.close = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3econtext, func, params\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 内部私有函数，产生随机数\x3c\/span\x3e\n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eUUIDcreatePart\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elength\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建 UUID (通用唯一识别码)\x3c\/span\x3e\n    utils.createUUID = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 继承\x3c\/span\x3e\n    utils.extend = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{...}\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调试\x3c\/span\x3e\n    utils.alert = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emsg\x3c\/span\x3e) \x3c\/span\x3e{...}\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3eUUIDcreatePart函数用来随机产生一个16进制的号码，接受一个表示号码长度的参数（实际上是最终号码长度的一半），一般用途是做为元素的唯一ID。\x3c\/li\x3e\n\x3cli\x3eutils.isArray 在这里不使用instanceof来判断是不是Array类型，主要是考虑到跨域或者多个frame的情况，多个frame时每个frame都会有自己的Array构造函数，从而得出不正确的结论。使用\x27[object Array]\x27来判断是根据ECMA标准中的返回值来进行的，事实上，这里不需要类型转换，而可以用全等“===”来判断。\x3c\/li\x3e\n\x3cli\x3eutils.close函数，封装函数的调用，将执行环境作为一个参数，调用的函数为第二个参数，调用函数本身的参数为后续参数。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e\x3cstrong\x3e原型继承实现详解\x3c\/strong\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22utils.extend = (function() {\n    \/\/ proxy used to establish prototype chain\n    var F = function() {};\n    \/\/ extend Child from Parent\n    return function(Child, Parent) {\n        F.prototype = Parent.prototype;\n        Child.prototype = new F();\n        Child.__super__ = Parent.prototype;\n        Child.prototype.constructor = Child;\n    };\n}());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eutils.extend = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ proxy used to establish prototype chain\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e F = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{};\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ extend Child from Parent\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eChild, Parent\x3c\/span\x3e) \x3c\/span\x3e{\n        F.prototype = Parent.prototype;\n        Child.prototype = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\n        Child.__super__ = Parent.prototype;\n        Child.prototype.constructor = Child;\n    };\n}());\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里的继承是通过原型链的方式实现，我们可以通过下述方式调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var Parent = function () {\n    this.name = \x27Parent\x27;\n}\nParent.prototype.getName = function () {\n    return this.name;\n}\nvar Child = function () {\n    this.name = \x27Child\x27;\n}\n\nutils.extend(Child, Parent);\n\nvar child = new Child();\nconsole.log(child.getName())\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Parent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Parent\x27\x3c\/span\x3e;\n}\nParent.prototype.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Child = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Child\x27\x3c\/span\x3e;\n}\n\nutils.extend(Child, Parent);\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e child = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(child.getName())\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eES5中有一个\x3ca href=\x22https:\/\/developer.mozilla.org\/en\/JavaScript\/Reference\/Global_Objects\/Object\/create\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eObject.create\x3c\/a\x3e方法，我们可以使用这个函数实现继承：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建一个新的对象\nObject.create = Object.create || function (proto) {\n    var F = function () {};\n    F.prototype = proto;\n    return new F();\n}\n\n\/\/ 实现继承\nvar extend = function(Child, Parent) {\n    \/\/ 拷贝Parent原型对象\n    Child.prototype = Object.create(Parent.prototype);\n    \/\/ 将Child构造函数赋值给Child的原型对象\n    Child.prototype.constructor = Child;\n}\n\n\/\/ 实例\nvar Parent = function () {\n    this.name = \x27Parent\x27;\n}\nParent.prototype.getName = function () {\n    return this.name;\n}\nvar Child = function () {\n    this.name = \x27Child\x27;\n}\nextend(Child, Parent);\nvar child = new Child();\nconsole.log(child.getName())\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建一个新的对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create || \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eproto\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e F = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{};\n    F.prototype = proto;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实现继承\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e extend = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eChild, Parent\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 拷贝Parent原型对象\x3c\/span\x3e\n    Child.prototype = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create(Parent.prototype);\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 将Child构造函数赋值给Child的原型对象\x3c\/span\x3e\n    Child.prototype.constructor = Child;\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实例\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Parent = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Parent\x27\x3c\/span\x3e;\n}\nParent.prototype.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Child = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Child\x27\x3c\/span\x3e;\n}\nextend(Child, Parent);\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e child = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(child.getName())\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e原型链的概念对于初学者而言可能有点绕，但是我们把握\x3cstrong\x3e构造函数\x3c\/strong\x3e、\x3cstrong\x3e实例化对象\x3c\/strong\x3e、\x3cstrong\x3e原型对象\x3c\/strong\x3e三者的关系就很简单了。我们以此为例说明：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 构造函数\nvar Child = function () {\n    this.name = \x27Child\x27;\n}\n\/\/ 原型对象Child.prototype\nChild.prototype.getName = function () {\n    return this.name;\n}\n\/\/ 实例化对象\nvar child = new Child();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 构造函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e Child = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Child\x27\x3c\/span\x3e;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原型对象Child.prototype\x3c\/span\x3e\nChild.prototype.getName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实例化对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e child = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e原型对象是构造函数的prototype属性，是所有实例化对象共享属性和方法的原型对象。\x3c\/li\x3e\n\x3cli\x3e实例化对象通过new构造函数得到，都继承了原型对象的属性和方法。\x3c\/li\x3e\n\x3cli\x3e如何访（qiu）问（jie）原型对象？若已知构造函数Child，则可以通过\x3ccode\x3eChild.prototype\x3c\/code\x3e得到；若已知实例化对象child，则可以通过\x3ccode\x3echild.__proto__\x3c\/code\x3e或者\x3ccode\x3eObject.getPrototypeOf(child)\x3c\/code\x3e得到，也通过Object.setPrototypeOf方法来重写对象的原型。\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Child.prototype === child.__proto__  \/\/ true\nchild.__proto__ === Object.getPrototypeOf(child) \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eChild.prototype === child.__proto__  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\nchild.__proto__ === \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.getPrototypeOf(child) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cul\x3e\n\x3cli\x3e原型对象中有个隐式的constructor，指向了构造函数本身，也就是我们可以通过\x3ccode\x3eChild.prototype.constructor\x3c\/code\x3e（虽然看似多此一举，但是经常需要重新设置构造函数）或\x3ccode\x3echild.__proto__.constructor\x3c\/code\x3e或者\x3ccode\x3eObject.getPrototypeOf(child).constructor\x3c\/code\x3e得到构造函数。\x3c\/li\x3e\n\x3cli\x3einstanceof和Object.isPrototypeOf()可以判断两个对象是否是继承关系\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22child instanceof Child  \/\/ true\nChild.prototype.isPrototypeOf(child) \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3echild \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Child  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\nChild.prototype.isPrototypeOf(child) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e至此\x3cstrong\x3e构造函数\x3c\/strong\x3e、\x3cstrong\x3e实例化对象\x3c\/strong\x3e、\x3cstrong\x3e原型对象\x3c\/strong\x3e三者的关系我们已经很清除了，再回过头看看上面继承的实现就很简单了。\x3c\/p\x3e\n\x3cp\x3e我们可以通过\x3ccode\x3einstanceof\x3c\/code\x3e来检验是否满足继承关系：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22child instanceof Child \x26amp;\x26amp; child instanceof Parent  \/\/ true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22 style=\x22word-break: break-word; white-space: initial;\x22\x3echild \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Child \x26amp;\x26amp; child \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e Parent  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实上述继承的思路很简单：\x3cbr\x3e1.首先获得父类原型对象的方法，这里的F对象作为中间变量引用拷贝Parent.prototype对象（即和Parent.prototype共享同一内存空间）；例如我们修改上述的Object.create为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.create = function (proto) {\n    var F = function () {};\n    F.prototype = proto;\n    F.prototype.setName = function(name){\n        this.name = name;\n    }\n    return new F();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.create = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eproto\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e F = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{};\n    F.prototype = proto;\n    F.prototype.setName = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ename\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = name;\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e F();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e此时Parent.prototype、Child.prototype、child都拥有的setName方法，但是我们应当避免这样做，这也是为什么我们不直接通过\x3ccode\x3eChild.prototype = Parent.prototype\x3c\/code\x3e获得；通过实例化中间对象F间接得到Parent.prototype的方法，此时通过Object.create方法获得的对象和Parent.prototype不再是共享内存空间。Child通过\x3ccode\x3eextend(Child, Parent)\x3c\/code\x3e从Parent.prototype对象获得一份新的拷贝。实质是因为我们通过new一个构造函数获得的实例化对象是获得了一个新的内存空间，子对象互不影响；\x3cbr\x3e2.对子类进行修正，我们通过拷贝获得了父类的一个备份，此时子类原型对象下的constructor属性依然是父类的构造函数，显然不符合我们的要求，我们需要重置，同时有时候我们希望保留对父类的引用，如cordova这里用一个\x3ccode\x3e__super__\x3c\/code\x3e属性保存。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Child.__super__ = Parent.prototype;\nChild.prototype.constructor = Child;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eChild.__super__ = Parent.prototype;\nChild.prototype.constructor = Child;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实继承的本质我们是希望能实现以下功能：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e父类有的我都有，我也能重载，但不至于影响到父类的属性和方法\x3c\/li\x3e\n\x3cli\x3e除了继承之外，我也能添加自己的方法和属性\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我们可以利用es6新特性实现同样的效果：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22class Parent {\n    constructor () {\n        this.name = \x27Parent\x27;\n    }\n    getName () {\n        return this.name;\n    }\n}\n\nclass Child extends Parent {\n    constructor () {\n        super();\n        this.name = \x27Child\x27;\n    }\n}\n\nvar child = new Child();\nconsole.log(child.getName())\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Parent\x27\x3c\/span\x3e;\n    }\n    getName () {\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name;\n    }\n}\n\n\x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eChild\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eParent\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e () {\n        \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e();\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.name = \x3cspan class=\x22hljs-string\x22\x3e\x27Child\x27\x3c\/span\x3e;\n    }\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e child = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Child();\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(child.getName())\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3esuper关键字在这里表示父类的构造函数，用来新建父类的this对象。在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3ecordova 模块\x3c\/h2\x3e\n\x3cp\x3e本文最后一部分我们来看看cordova模块，cordova模块是事件的处理和回调，外部访问cordova.js的入口。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22define(\x26quot;cordova\x26quot;, function(require, exports, module) {\n  if (window.cordova \x26amp;\x26amp; !(window.cordova instanceof HTMLElement)) {\n    throw new Error(\x26quot;cordova already defined\x26quot;);\n  }\n  \/\/ 导入事件通道模块\n  var channel = require(\x27cordova\/channel\x27);\n  \/\/ 导入平台模块\n  var platform = require(\x27cordova\/platform\x27);\n  \/\/ 保存addEventListener、removeEventListener的原生实现\n  var m_document_addEventListener = document.addEventListener;\n  var m_document_removeEventListener = document.removeEventListener;\n  var m_window_addEventListener = window.addEventListener;\n  var m_window_removeEventListener = window.removeEventListener;\n\n  \/\/ 缓存所有的事件处理函数\n  var documentEventHandlers = {},\n      windowEventHandlers = {};\n  \n  \/\/ 重新定义addEventListener、removeEventListener，方便后面注册添加pause、resume、deviceReady等事件\n  document.addEventListener = function(evt, handler, capture) {...}\n  window.addEventListener = function(evt, handler, capture) {...}\n  document.removeEventListener = function(evt, handler, capture) {...}\n  window.removeEventListener = function(evt, handler, capture) {...}\n  function createEvent(type, data) {...}\n\n  var cordova = {\n    define: define,\n    require: require,\n    version: PLATFORM_VERSION_BUILD_LABEL,\n    platformVersion: PLATFORM_VERSION_BUILD_LABEL,\n    platformId: platform.id,\n    addWindowEventHandler: function(event) {...},\n    addStickyDocumentEventHandler: function(event) {...},\n    addDocumentEventHandler: function(event) {...},\n    removeWindowEventHandler: function(event) {...},\n    removeDocumentEventHandler: function(event) {...},\n    getOriginalHandlers: function() {...},\n    fireDocumentEvent: function(type, data, bNoDetach) {...},\n    fireWindowEvent: function(type, data) {...},\n    callbackId: Math.floor(Math.random() * 2000000000),\n    callbacks: {},\n    callbackStatus: {},\n    callbackSuccess: function(callbackId, args) {...},\n    callbackError: function(callbackId, args) {...},\n    callbackFromNative: function(callbackId, isSuccess, status, args, keepCallback) {...},\n    addConstructor: function(func) {...}\n  }\n  \/\/ 暴露cordova对象给外部\n  module.exports = cordova;\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3edefine(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova\x22\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3erequire, exports, module\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.cordova \x26amp;\x26amp; !(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.cordova \x3cspan class=\x22hljs-keyword\x22\x3einstanceof\x3c\/span\x3e HTMLElement)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethrow\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eError\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x22cordova already defined\x22\x3c\/span\x3e);\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 导入事件通道模块\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e channel = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cordova\/channel\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 导入平台模块\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e platform = \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cordova\/platform\x27\x3c\/span\x3e);\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存addEventListener、removeEventListener的原生实现\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m_document_addEventListener = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m_document_removeEventListener = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.removeEventListener;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m_window_addEventListener = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener;\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m_window_removeEventListener = \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.removeEventListener;\n\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 缓存所有的事件处理函数\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e documentEventHandlers = {},\n      windowEventHandlers = {};\n  \n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重新定义addEventListener、removeEventListener，方便后面注册添加pause、resume、deviceReady等事件\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevt, handler, capture\x3c\/span\x3e) \x3c\/span\x3e{...}\n  \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevt, handler, capture\x3c\/span\x3e) \x3c\/span\x3e{...}\n  \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.removeEventListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevt, handler, capture\x3c\/span\x3e) \x3c\/span\x3e{...}\n  \x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.removeEventListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevt, handler, capture\x3c\/span\x3e) \x3c\/span\x3e{...}\n  \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateEvent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype, data\x3c\/span\x3e) \x3c\/span\x3e{...}\n\n  \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cordova = {\n    \x3cspan class=\x22hljs-attr\x22\x3edefine\x3c\/span\x3e: define,\n    \x3cspan class=\x22hljs-attr\x22\x3erequire\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3eversion\x3c\/span\x3e: PLATFORM_VERSION_BUILD_LABEL,\n    \x3cspan class=\x22hljs-attr\x22\x3eplatformVersion\x3c\/span\x3e: PLATFORM_VERSION_BUILD_LABEL,\n    \x3cspan class=\x22hljs-attr\x22\x3eplatformId\x3c\/span\x3e: platform.id,\n    \x3cspan class=\x22hljs-attr\x22\x3eaddWindowEventHandler\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3eaddStickyDocumentEventHandler\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3eaddDocumentEventHandler\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3eremoveWindowEventHandler\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3eremoveDocumentEventHandler\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3egetOriginalHandlers\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3efireDocumentEvent\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype, data, bNoDetach\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3efireWindowEvent\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype, data\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3ecallbackId\x3c\/span\x3e: \x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.floor(\x3cspan class=\x22hljs-built_in\x22\x3eMath\x3c\/span\x3e.random() * \x3cspan class=\x22hljs-number\x22\x3e2000000000\x3c\/span\x3e),\n    \x3cspan class=\x22hljs-attr\x22\x3ecallbacks\x3c\/span\x3e: {},\n    \x3cspan class=\x22hljs-attr\x22\x3ecallbackStatus\x3c\/span\x3e: {},\n    \x3cspan class=\x22hljs-attr\x22\x3ecallbackSuccess\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallbackId, args\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3ecallbackError\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallbackId, args\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3ecallbackFromNative\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ecallbackId, isSuccess, status, args, keepCallback\x3c\/span\x3e) \x3c\/span\x3e{...},\n    \x3cspan class=\x22hljs-attr\x22\x3eaddConstructor\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efunc\x3c\/span\x3e) \x3c\/span\x3e{...}\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 暴露cordova对象给外部\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = cordova;\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里我们以document Event为例说明一下cordova模块中关于事件的处理：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 保存addEventListener、removeEventListener的原生实现\nvar m_document_addEventListener = document.addEventListener;\nvar m_document_removeEventListener = document.removeEventListener;\n\/\/ 缓存事件处理函数\nvar documentEventHandlers = {};\n\/\/ 重新定义addEventListener\ndocument.addEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    if (typeof documentEventHandlers[e] != \x27undefined\x27) {\n        documentEventHandlers[e].subscribe(handler);\n    } else {\n        m_document_addEventListener.call(document, evt, handler, capture);\n    }\n};\n\/\/ 重新定义removeEventListener\ndocument.removeEventListener = function(evt, handler, capture) {\n    var e = evt.toLowerCase();\n    \/\/ If unsubscribing from an event that is handled by a plugin\n    if (typeof documentEventHandlers[e] != \x26quot;undefined\x26quot;) {\n        documentEventHandlers[e].unsubscribe(handler);\n    } else {\n        m_document_removeEventListener.call(document, evt, handler, capture);\n    }\n};\n\/\/ 创建 Event 对象\nfunction createEvent(type, data) {\n    var event = document.createEvent(\x27Events\x27);\n    event.initEvent(type, false, false);\n    if (data) {\n        for (var i in data) {\n            if (data.hasOwnProperty(i)) {\n                event[i] = data[i];\n            }\n        }\n    }\n    return event;\n}\nvar codova = {\n    ...\n    \/\/ 创建事件通道\n    addStickyDocumentEventHandler:function(event) {\n        return (documentEventHandlers[event] = channel.createSticky(event));\n    },\n    addDocumentEventHandler:function(event) {\n        return (documentEventHandlers[event] = channel.create(event));\n    },\n    \/\/ 取消事件通道\n    removeDocumentEventHandler:function(event) {\n        delete documentEventHandlers[event];\n    },\n    \/\/ 发布事件消息\n    fireDocumentEvent: function(type, data, bNoDetach) {\n        var evt = createEvent(type, data);\n        if (typeof documentEventHandlers[type] != \x27undefined\x27) {\n            if( bNoDetach ) {\n                documentEventHandlers[type].fire(evt);\n            }\n            else {\n                setTimeout(function() {\n                    \/\/ Fire deviceready on listeners that were registered before cordova.js was loaded.\n                    if (type == \x27deviceready\x27) {\n                        document.dispatchEvent(evt);\n                    }\n                    documentEventHandlers[type].fire(evt);\n                }, 0);\n            }\n        } else {\n            document.dispatchEvent(evt);\n        }\n    },\n    ...\n}\nmodule.exports = cordova;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 保存addEventListener、removeEventListener的原生实现\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m_document_addEventListener = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m_document_removeEventListener = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.removeEventListener;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 缓存事件处理函数\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e documentEventHandlers = {};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重新定义addEventListener\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevt, handler, capture\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e e = evt.toLowerCase();\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e documentEventHandlers[e] != \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n        documentEventHandlers[e].subscribe(handler);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        m_document_addEventListener.call(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e, evt, handler, capture);\n    }\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 重新定义removeEventListener\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.removeEventListener = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevt, handler, capture\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e e = evt.toLowerCase();\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ If unsubscribing from an event that is handled by a plugin\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e documentEventHandlers[e] != \x3cspan class=\x22hljs-string\x22\x3e\x22undefined\x22\x3c\/span\x3e) {\n        documentEventHandlers[e].unsubscribe(handler);\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        m_document_removeEventListener.call(\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e, evt, handler, capture);\n    }\n};\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建 Event 对象\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateEvent\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype, data\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e event = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.createEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27Events\x27\x3c\/span\x3e);\n    event.initEvent(type, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (data) {\n        \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i \x3cspan class=\x22hljs-keyword\x22\x3ein\x3c\/span\x3e data) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (data.hasOwnProperty(i)) {\n                event[i] = data[i];\n            }\n        }\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e event;\n}\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e codova = {\n    ...\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建事件通道\x3c\/span\x3e\n    addStickyDocumentEventHandler:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (documentEventHandlers[event] = channel.createSticky(event));\n    },\n    \x3cspan class=\x22hljs-attr\x22\x3eaddDocumentEventHandler\x3c\/span\x3e:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e (documentEventHandlers[event] = channel.create(event));\n    },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 取消事件通道\x3c\/span\x3e\n    removeDocumentEventHandler:\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eevent\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3edelete\x3c\/span\x3e documentEventHandlers[event];\n    },\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发布事件消息\x3c\/span\x3e\n    fireDocumentEvent: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3etype, data, bNoDetach\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e evt = createEvent(type, data);\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e documentEventHandlers[type] != \x3cspan class=\x22hljs-string\x22\x3e\x27undefined\x27\x3c\/span\x3e) {\n            \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e( bNoDetach ) {\n                documentEventHandlers[type].fire(evt);\n            }\n            \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n                setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n                    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Fire deviceready on listeners that were registered before cordova.js was loaded.\x3c\/span\x3e\n                    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (type == \x3cspan class=\x22hljs-string\x22\x3e\x27deviceready\x27\x3c\/span\x3e) {\n                        \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.dispatchEvent(evt);\n                    }\n                    documentEventHandlers[type].fire(evt);\n                }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n            }\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n            \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.dispatchEvent(evt);\n        }\n    },\n    ...\n}\n\x3cspan class=\x22hljs-built_in\x22\x3emodule\x3c\/span\x3e.exports = cordova;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在初始化启动模块\x3ccode\x3ecordova\/init\x3c\/code\x3e中有这样的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 注册pause、resume、deviceReady事件\nchannel.onPause = cordova.addDocumentEventHandler(\x27pause\x27);\nchannel.onResume = cordova.addDocumentEventHandler(\x27resume\x27);\nchannel.onActivated = cordova.addDocumentEventHandler(\x27activated\x27);\nchannel.onDeviceReady = cordova.addStickyDocumentEventHandler(\x27deviceready\x27);\n\n\/\/ 监听DOMContentLoaded事件并发布事件消息\nif (document.readyState == \x27complete\x27 || document.readyState == \x27interactive\x27) {\n    channel.onDOMContentLoaded.fire();\n} else {\n    document.addEventListener(\x27DOMContentLoaded\x27, function() {\n        channel.onDOMContentLoaded.fire();\n    }, false);\n}\n\n\/\/ 原生层加载完成事件\nif (window._nativeReady) {\n    channel.onNativeReady.fire();\n}\n\n\/\/ 加载完成发布时间事件消息\nchannel.join(function() {\n    modulemapper.mapModules(window);\n    platform.initialize \x26amp;\x26amp; platform.initialize();\n    channel.onCordovaReady.fire();\n    channel.join(function() {\n        require(\x27cordova\x27).fireDocumentEvent(\x27deviceready\x27);\n    }, channel.deviceReadyChannelsArray);\n}, platformInitChannelsArray);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注册pause、resume、deviceReady事件\x3c\/span\x3e\nchannel.onPause = cordova.addDocumentEventHandler(\x3cspan class=\x22hljs-string\x22\x3e\x27pause\x27\x3c\/span\x3e);\nchannel.onResume = cordova.addDocumentEventHandler(\x3cspan class=\x22hljs-string\x22\x3e\x27resume\x27\x3c\/span\x3e);\nchannel.onActivated = cordova.addDocumentEventHandler(\x3cspan class=\x22hljs-string\x22\x3e\x27activated\x27\x3c\/span\x3e);\nchannel.onDeviceReady = cordova.addStickyDocumentEventHandler(\x3cspan class=\x22hljs-string\x22\x3e\x27deviceready\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 监听DOMContentLoaded事件并发布事件消息\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.readyState == \x3cspan class=\x22hljs-string\x22\x3e\x27complete\x27\x3c\/span\x3e || \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.readyState == \x3cspan class=\x22hljs-string\x22\x3e\x27interactive\x27\x3c\/span\x3e) {\n    channel.onDOMContentLoaded.fire();\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27DOMContentLoaded\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        channel.onDOMContentLoaded.fire();\n    }, \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 原生层加载完成事件\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e._nativeReady) {\n    channel.onNativeReady.fire();\n}\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 加载完成发布时间事件消息\x3c\/span\x3e\nchannel.join(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    modulemapper.mapModules(\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e);\n    platform.initialize \x26amp;\x26amp; platform.initialize();\n    channel.onCordovaReady.fire();\n    channel.join(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3erequire\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27cordova\x27\x3c\/span\x3e).fireDocumentEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27deviceready\x27\x3c\/span\x3e);\n    }, channel.deviceReadyChannelsArray);\n}, platformInitChannelsArray);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这里通过addDocumentEventHandler及addStickyDocumentEventHandler创建了事件通道，并通过fireDocumentEvent或者fire发布事件消息，这样我们就可以通过document.addEventListener订阅监听事件了。\x3c\/p\x3e\n\x3cp\x3e如果我们要创建一个自定义事件Test,我们可以这样做：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 创建事件通道\ncordova.addWindowEventHandler(\x27Test\x27);\n\n\/\/ 发布事件消息\ncordova.fireWindowEvent(\x27Test\x27, {\n    name: \x27test\x27,\n    data: {\n        time: new Date()\n    }\n})\n\n\/\/ 订阅事件消息\nwindow.addEventListener(\x27Test\x27, function (evt) {\n     console.log(evt);\n});\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建事件通道\x3c\/span\x3e\ncordova.addWindowEventHandler(\x3cspan class=\x22hljs-string\x22\x3e\x27Test\x27\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 发布事件消息\x3c\/span\x3e\ncordova.fireWindowEvent(\x3cspan class=\x22hljs-string\x22\x3e\x27Test\x27\x3c\/span\x3e, {\n    \x3cspan class=\x22hljs-attr\x22\x3ename\x3c\/span\x3e: \x3cspan class=\x22hljs-string\x22\x3e\x27test\x27\x3c\/span\x3e,\n    \x3cspan class=\x22hljs-attr\x22\x3edata\x3c\/span\x3e: {\n        \x3cspan class=\x22hljs-attr\x22\x3etime\x3c\/span\x3e: \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eDate\x3c\/span\x3e()\n    }\n})\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 订阅事件消息\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3ewindow\x3c\/span\x3e.addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27Test\x27\x3c\/span\x3e, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eevt\x3c\/span\x3e) \x3c\/span\x3e{\n     \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(evt);\n});\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e参考\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/rensanning.iteye.com\/blog\/2163892\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCordova 3.x 入门 - 目录\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/linjisong\/archive\/2012\/08\/16\/2642233.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ePhoneGap源码分析\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e写在后面\x3c\/h2\x3e\n\x3cp\x3e本文至此已经说完了cordova的模块机制和事件机制，已经cordova的工具模块，了解这些后写起插件来才能得心应手，对于原理实现部分不属于本文的范畴，下一篇会详细讲解cordova原理实现。敬请关注，不过近来在写毕设，估计一时半会儿也不会写完，本文前前后后已是拖了半个月。如果觉得本文对您有帮助，不妨打赏支持以此鼓励。\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVMMoV?w=612\x26amp;h=384\x22 src=\x22https:\/\/static.alili.tech\/img\/bVMMoV?w=612\x26amp;h=384\x22 alt=\x22clipboard.png\x22 title=\x22clipboard.png\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e转载需标注本文原始地址：\x3ca href=\x22https:\/\/zhaomenghuan.github.io\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/zhaomenghuan.github.io\/\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>cordova研习笔记(二) —— cordova 6.X 源码解读（上）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000009331330">https://segmentfault.com/a/1190000009331330</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/5cu03holh/" target="_blank">https://alili.tech/archive/5cu03holh/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>