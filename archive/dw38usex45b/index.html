<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="react-redux原理分析"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>react-redux原理分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/dw38usex45b/",
				"appid": "1613049289050283", 
				"title": "react-redux原理分析 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-31T02:31:16"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/98kdcr980mi/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/t4j60czx63/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f&text=react-redux%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f&text=react-redux%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f&title=react-redux%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f&is_video=false&description=react-redux%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=react-redux%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f&title=react-redux%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f&title=react-redux%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f&title=react-redux%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fdw38usex45b%2f&title=react-redux%e5%8e%9f%e7%90%86%e5%88%86%e6%9e%90"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">react-redux原理分析</h1><div class="meta"><div class="postdate"><time datetime="2019-01-31" itemprop="datePublished">2019-01-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch2 id=\x22articleHeader0\x22\x3e前言\x3c\/h2\x3e\n\x3cblockquote\x3e\n\x3cp\x3e\x3ccode\x3ereact\x3c\/code\x3e和\x3ccode\x3eredux\x3c\/code\x3e并没有什么直接的联系. \x3ccode\x3eredux\x3c\/code\x3e作为一个通用模块, 主要还是用来处理应用中的state的变更, 而展示层不一定是\x3ccode\x3ereact\x3c\/code\x3e.\x3c\/p\x3e\n\x3cp\x3e但当我们希望在React \x2b Redux的项目中将两者结合的更好，可以通过\x3ccode\x3ereact-redux\x3c\/code\x3e做连接。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e本文结合react-redux的使用，分析其实现原理。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3ereact-redux\x3c\/h2\x3e\n\x3cp\x3e\x3ccode\x3ereact-redux\x3c\/code\x3e是一个轻量级的封装库，核心方法只有两个：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eProvider\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3econnect\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e下面我们来逐个分析其作用\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3eProvider\x3c\/h2\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/github.com\/reactjs\/react-redux\/blob\/master\/src\/components\/Provider.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e完整源码请戳这里\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3eProvider模块的功能并不复杂, 主要分为以下两点:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e在原应用组件上包裹一层，使原来整个应用成为Provider的子组件\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e接收Redux的store作为props，通过context对象传递给子孙组件上的connect\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22import { Component, Children } from \x27react\x27\nimport PropTypes from \x27prop-types\x27\nimport { storeShape, subscriptionShape } from \x27..\/utils\/PropTypes\x27\nimport warning from \x27..\/utils\/warning\x27\n\nlet didWarnAboutReceivingStore = false\nfunction warnAboutReceivingStore() {\n  if (didWarnAboutReceivingStore) {\n    return\n  }\n  didWarnAboutReceivingStore = true\n}\n\nexport function createProvider(storeKey = \x27store\x27, subKey) {\n    const subscriptionKey = subKey || `${storeKey}Subscription`\n\n    class Provider extends Component {\n        getChildContext() {\n          return { [storeKey]: this[storeKey], [subscriptionKey]: null }\n        }\n\n        constructor(props, context) {\n          super(props, context)\n          this[storeKey] = props.store;\n        }\n\n        render() {\n          return Children.only(this.props.children)\n        }\n    }\n\n    if (process.env.NODE_ENV !== \x27production\x27) {\n      Provider.prototype.componentWillReceiveProps = function (nextProps) {\n        if (this[storeKey] !== nextProps.store) {\n          warnAboutReceivingStore()\n        }\n      }\n    }\n\n    return Provider\n}\n\nexport default createProvider()\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { Component, Children } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27react\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e PropTypes \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27prop-types\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { storeShape, subscriptionShape } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/utils\/PropTypes\x27\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e warning \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27..\/utils\/warning\x27\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e didWarnAboutReceivingStore = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewarnAboutReceivingStore\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (didWarnAboutReceivingStore) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e\n  }\n  didWarnAboutReceivingStore = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateProvider\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3estoreKey = \x3cspan class=\x22hljs-string\x22\x3e\x27store\x27\x3c\/span\x3e, subKey\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e subscriptionKey = subKey || \x3cspan class=\x22hljs-string\x22\x3e`\x3cspan class=\x22hljs-subst\x22\x3e${storeKey}\x3c\/span\x3eSubscription`\x3c\/span\x3e\n\n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eProvider\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n        getChildContext() {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e { [storeKey]: \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[storeKey], [subscriptionKey]: \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e }\n        }\n\n        \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props, context) {\n          \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props, context)\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[storeKey] = props.store;\n        }\n\n        render() {\n          \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Children.only(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.children)\n        }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n      Provider.prototype.componentWillReceiveProps = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enextProps\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e[storeKey] !== nextProps.store) {\n          warnAboutReceivingStore()\n        }\n      }\n    }\n\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e Provider\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e createProvider()\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader3\x22\x3e1.1 封装原应用\x3c\/h3\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3cstrong\x3erender\x3c\/strong\x3e方法中, 渲染了其子级元素, 使整个应用成为Provider的子组件.\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3ethis.props.children\x3c\/code\x3e是react内置在\x3ccode\x3ethis.props\x3c\/code\x3e上的对象, 用于获取当前组件的所有子组件.\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3eChildren\x3c\/code\x3e为react内部定义的顶级对象, 该对象封装了一些方便操作字组件的方法. \x3ccode\x3eChildren.only\x3c\/code\x3e用于获取仅有的一个子组件,\x3cbr\x3e   没有或者超过一个均会报错. \x3cstrong\x3e所以注意: 确保Provider组件的直接子级为单个封闭元素，切勿多个组件平行放置\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch3 id=\x22articleHeader4\x22\x3e1.2 传递\x3ccode\x3estore\x3c\/code\x3e\n\x3c\/h3\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3econstructor\x3c\/strong\x3e方法: Provider初始化时, 获取到props中的store对象;\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3egetChildContext\x3c\/strong\x3e方法: 将外部的\x3ccode\x3estore\x3c\/code\x3e对象放入\x3ccode\x3econtext\x3c\/code\x3e对象中，使子孙组件上的\x3ccode\x3econnect\x3c\/code\x3e可以直接访问到\x3ccode\x3econtext\x3c\/code\x3e对象中的store。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ccode\x3econtext\x3c\/code\x3e可以使子孙组件直接获取父级组件中的数据或方法，而无需一层一层通过props向下传递。\x3ccode\x3econtext\x3c\/code\x3e对象相当于一个独立的空间，父组件通过getChildContext()向该空间内写值；定义了\x3ccode\x3econtextTypes\x3c\/code\x3e验证的子孙组件可以通过\x3ccode\x3ethis.context.xxx\x3c\/code\x3e，从\x3ccode\x3econtext\x3c\/code\x3e对象中读取\x3ccode\x3exxx\x3c\/code\x3e字段的值\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch3 id=\x22articleHeader5\x22\x3e1.3 小结\x3c\/h3\x3e\n\x3cp\x3e总而言之，\x3ccode\x3eProvider\x3c\/code\x3e模块的功能很简单，从最外部封装了整个应用，并向\x3ccode\x3econnect\x3c\/code\x3e模块传递\x3ccode\x3estore\x3c\/code\x3e。\x3cbr\x3e而最核心的功能在\x3ccode\x3econnect\x3c\/code\x3e模块中。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3econnect\x3c\/h2\x3e\n\x3cblockquote\x3e\n\x3cp\x3e正如这个模块的命名，\x3ccode\x3econnect\x3c\/code\x3e模块才是真正连接了\x3ccode\x3eReact\x3c\/code\x3e和\x3ccode\x3eRedux\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e现在，我们可以先回想一下Redux是怎样运作的：首先需要注册一个全局唯一的store对象，用来维护整个应用的state；当要变更state时，我们会dispatch一个action，reducer根据action更新相应的state。\x3c\/p\x3e\n\x3c\/blockquote\x3e\n\x3cp\x3e下面我们再考虑一下使用react-redux时，我们做了什么：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    import React from \x26quot;react\x26quot;\n    import ReactDOM from \x26quot;react-dom\x26quot;\n    import { bindActionCreators } from \x26quot;redux\x26quot;\n    import {connect} from \x26quot;react-redux\x26quot;\n    \n    class xxxComponent extends React.Component{\n        constructor(props){\n            super(props)\n        }\n        componentDidMount(){\n            this.props.aActions.xxx1();\n        }\n        render (\n            \x3cdiv\x3e\n                {this.props.$$aProps}\n            \x3c\/div\x3e\n        )\n    }\n    \n    export default connect(\n        state =\x3e ({\n            $$aProps: state.$$aProps,\n            $$bProps: state.$$bProps,\n            \/\/ ...\n        }),\n        dispatch =\x3e ({\n            aActions: bindActionCreators(AActions,dispatch),\n            bActions: bindActionCreators(BActions,dispatch),\n            \/\/ ...\n        })\n    )(xxxComponent)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e React \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22react\x22\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e ReactDOM \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22react-dom\x22\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e { bindActionCreators } \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22redux\x22\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eimport\x3c\/span\x3e {connect} \x3cspan class=\x22hljs-keyword\x22\x3efrom\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x22react-redux\x22\x3c\/span\x3e\n    \n    \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3exxxComponent\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eReact\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props){\n            \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props)\n        }\n        componentDidMount(){\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.props.aActions.xxx1();\n        }\n        render (\n            \x3cspan class=\x22xml\x22\x3e\x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\n                {this.props.$$aProps}\n            \x3cspan class=\x22hljs-tag\x22\x3e\x26lt;\/\x3cspan class=\x22hljs-name\x22\x3ediv\x3c\/span\x3e\x26gt;\x3c\/span\x3e\x3c\/span\x3e\n        )\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e connect(\n        \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-params\x22\x3estate\x3c\/span\x3e =\x26gt;\x3c\/span\x3e ({\n            \x3cspan class=\x22hljs-attr\x22\x3e$$aProps\x3c\/span\x3e: state.$$aProps,\n            \x3cspan class=\x22hljs-attr\x22\x3e$$bProps\x3c\/span\x3e: state.$$bProps,\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n        }),\n        dispatch =\x26gt; ({\n            \x3cspan class=\x22hljs-attr\x22\x3eaActions\x3c\/span\x3e: bindActionCreators(AActions,dispatch),\n            \x3cspan class=\x22hljs-attr\x22\x3ebActions\x3c\/span\x3e: bindActionCreators(BActions,dispatch),\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n        })\n    )(xxxComponent)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e由export的component对象进行如下猜想:\x3cbr\x3e1、使用了\x3ccode\x3ereact-redux\x3c\/code\x3e的\x3ccode\x3econnect\x3c\/code\x3e后，我们导出的对象不再是原先定义的\x3ccode\x3exxx Component\x3c\/code\x3e，而是通过\x3ccode\x3econnect\x3c\/code\x3e包裹后的新\x3ccode\x3eReact.Component\x3c\/code\x3e对象。\x3cbr\x3e\x3ccode\x3econnect\x3c\/code\x3e执行后返回一个函数（wrapWithConnect），那么其内部势必形成了闭包。而\x3ccode\x3ewrapWithConnect\x3c\/code\x3e执行后，必须要返回一个\x3ccode\x3eReactComponent\x3c\/code\x3e对象，才能保证原代码逻辑可以正常运行，而这个\x3ccode\x3eReactComponent\x3c\/code\x3e对象通过\x3ccode\x3erender\x3c\/code\x3e原组件，形成对原组件的封装。\x3cbr\x3e2、渲染页面需要\x3ccode\x3estore tree\x3c\/code\x3e中的\x3ccode\x3estate\x3c\/code\x3e片段，变更\x3ccode\x3estate\x3c\/code\x3e需要\x3ccode\x3edispatch\x3c\/code\x3e一个\x3ccode\x3eaction\x3c\/code\x3e，而这两部分，都是从\x3ccode\x3ethis.props\x3c\/code\x3e获取。故在我们调用\x3ccode\x3econnect\x3c\/code\x3e时，作为参数传入的\x3ccode\x3estate\x3c\/code\x3e和\x3ccode\x3eaction\x3c\/code\x3e，便在\x3ccode\x3econnect\x3c\/code\x3e内部进行合并，通过props的方式传递给包裹后的\x3ccode\x3eReactComponent\x3c\/code\x3e。\x3cbr\x3e好了, 以上只是我们的猜测, 下面看具体实现, 完整代码\x3ca href=\x22https:\/\/github.com\/reactjs\/react-redux\/blob\/master\/src\/connect\/connect.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e请戳这里\x3c\/a\x3e.\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22connect(\n    mapStateToProps(state, ownProps) =\x3e stateProps: object,\n    mapDispatchToProps(dispatch, ownProps) =\x3e dispatchProps: object,\n    mergeProps(stateProps, dispatchProps, ownProps) =\x3e props: Object,\n    options: object\n) =\x3e (\n    component\n) =\x3e component\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs pf\x22\x3e\x3ccode\x3econnect(\n    mapStateToProps(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3e, ownProps) =\x26gt; \x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eProps: object,\n    mapDispatchToProps(dispatch, ownProps) =\x26gt; dispatchProps: object,\n    mergeProps(\x3cspan class=\x22hljs-keyword\x22\x3estate\x3c\/span\x3eProps, dispatchProps, ownProps) =\x26gt; props: Object,\n    options: object\n) =\x26gt; (\n    component\n) =\x26gt; component\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e再来看下connect函数体结构, 我们摘取核心步骤进行描述:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {\n    \/\/ 参数处理\n    \/\/ ...\n    return function wrapWithConnect(WrappedComponent) {\n        \n        class Connect extends Component {\n            constructor(props, context) {\n                super(props, context)\n                this.store = props.store || context.store;\n                const storeState = this.store.getState()\n                this.state = { storeState }\n            }\n            \/\/ 周期方法及操作方法\n            \/\/ ...\n            render(){\n                this.renderedElement = createElement(WrappedComponent,\n                    this.mergedProps \/\/mearge stateProps, dispatchProps, props\n                )\n                return this.renderedElement;\n            }\n        }\n        return hoistStatics(Connect, WrappedComponent);\n    }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3econnect\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3emapStateToProps, mapDispatchToProps, mergeProps, options = {}\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 参数处理\x3c\/span\x3e\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ewrapWithConnect\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eWrappedComponent\x3c\/span\x3e) \x3c\/span\x3e{\n        \n        \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eConnect\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eextends\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eComponent\x3c\/span\x3e \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e(props, context) {\n                \x3cspan class=\x22hljs-keyword\x22\x3esuper\x3c\/span\x3e(props, context)\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store = props.store || context.store;\n                \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e storeState = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store.getState()\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.state = { storeState }\n            }\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 周期方法及操作方法\x3c\/span\x3e\n            \x3cspan class=\x22hljs-comment\x22\x3e\/\/ ...\x3c\/span\x3e\n            render(){\n                \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderedElement = createElement(WrappedComponent,\n                    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.mergedProps \x3cspan class=\x22hljs-comment\x22\x3e\/\/mearge stateProps, dispatchProps, props\x3c\/span\x3e\n                )\n                \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.renderedElement;\n            }\n        }\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e hoistStatics(Connect, WrappedComponent);\n    }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其实已经基本印证了我们的猜测：\x3cbr\x3e1、\x3ccode\x3econnect\x3c\/code\x3e通过\x3ccode\x3econtext\x3c\/code\x3e获取\x3ccode\x3eProvider\x3c\/code\x3e中的\x3ccode\x3estore\x3c\/code\x3e，通过\x3ccode\x3estore.getState()\x3c\/code\x3e获取整个\x3ccode\x3estore tree\x3c\/code\x3e 上所有\x3ccode\x3estate\x3c\/code\x3e。\x3cbr\x3e2、\x3ccode\x3econnect\x3c\/code\x3e模块的返回值\x3ccode\x3ewrapWithConnect\x3c\/code\x3e为\x3ccode\x3efunction\x3c\/code\x3e。\x3cbr\x3e3、\x3ccode\x3ewrapWithConnect\x3c\/code\x3e返回一个\x3ccode\x3eReactComponent\x3c\/code\x3e对象\x3ccode\x3eConnect\x3c\/code\x3e，\x3ccode\x3eConnect\x3c\/code\x3e重新\x3ccode\x3erender\x3c\/code\x3e外部传入的原组件\x3ccode\x3eWrappedComponent\x3c\/code\x3e，并把\x3ccode\x3econnect\x3c\/code\x3e中传入的\x3ccode\x3emapStateToProps\x3c\/code\x3e, \x3ccode\x3emapDispatchToProps\x3c\/code\x3e与组件上原有的\x3ccode\x3eprops\x3c\/code\x3e合并后，通过属性的方式传给\x3ccode\x3eWrappedComponent\x3c\/code\x3e。\x3cbr\x3e下面我们结合代码进行分析一下每个函数的意义。\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader7\x22\x3emapStateToProps\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3emapStateToProps(state, props)\x3c\/code\x3e必须是一个函数.\x3cbr\x3e参数\x3ccode\x3estate\x3c\/code\x3e为\x3ccode\x3estore tree\x3c\/code\x3e中所有state, 参数\x3ccode\x3eprops\x3c\/code\x3e为通过组件\x3ccode\x3eConnect\x3c\/code\x3e传入的\x3ccode\x3eprops\x3c\/code\x3e.\x3cbr\x3e返回值表示需要\x3ccode\x3emerge\x3c\/code\x3e进\x3ccode\x3eprops\x3c\/code\x3e中的\x3ccode\x3estate\x3c\/code\x3e.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader8\x22\x3emapDispatchToProps\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3emapDispatchToProps(dispatch, props)\x3c\/code\x3e可以是一个函数, 也可以是一个对象.\x3cbr\x3e参数\x3ccode\x3edispatch\x3c\/code\x3e为\x3ccode\x3estore.dispatch\x3c\/code\x3e函数, 参数\x3ccode\x3eprops\x3c\/code\x3e为通过组件\x3ccode\x3eConnect\x3c\/code\x3e传入的\x3ccode\x3eprops\x3c\/code\x3e.\x3cbr\x3e返回值表示需要\x3ccode\x3emerge\x3c\/code\x3e进\x3ccode\x3eprops\x3c\/code\x3e中的\x3ccode\x3eaction\x3c\/code\x3e.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader9\x22\x3emergeProps(一般不用)\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3emergeProps\x3c\/code\x3e是一个函数，定义了\x3ccode\x3emapState\x3c\/code\x3e, \x3ccode\x3emapDispatch\x3c\/code\x3e及\x3ccode\x3ethis.props\x3c\/code\x3e的合并规则.\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader10\x22\x3eoptions(一般不用)\x3c\/h3\x3e\n\x3cp\x3e\x3ccode\x3eoptions\x3c\/code\x3e是一个对象，包含\x3ccode\x3epure\x3c\/code\x3e和\x3ccode\x3ewithRef\x3c\/code\x3e两个属性\x3cbr\x3e\x3ccode\x3epure\x3c\/code\x3e: 表示是否开启\x3ccode\x3epure\x3c\/code\x3e优化，默认值为true.\x3cbr\x3e\x3ccode\x3ewithRef\x3c\/code\x3e: \x3ccode\x3ewithRef\x3c\/code\x3e用来给包装在里面的组件一个\x3ccode\x3eref\x3c\/code\x3e，可以通过\x3ccode\x3egetWrappedInstance\x3c\/code\x3e方法来获取这个ref，默认为false。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader11\x22\x3eReact如何响应Store变化\x3c\/h2\x3e\n\x3cp\x3e文章一开始我们也提到React其实跟Redux没有直接联系, 也就是说, Redux中dispatch触发store中state变化, 并不会导致React重新渲染. react-redux才是真正触发React重新渲染的模块, 那么这一过程怎样实现的呢?\x3cbr\x3e刚刚提到connect模块返回一个wrapConnect函数, 此函数中又返回了一个Connect组件. Connect组件的功能有以下两点:\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e包装组件, 将state和action通过props的方式传入到原组件内部\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e监听store tree变化, 使其包装的原组件可以响应state变化\x3cbr\x3e下面我们主要分析下第二点\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch3 id=\x22articleHeader12\x22\x3e如何注册监听\x3c\/h3\x3e\n\x3cp\x3e在redux中, 可以通过store.subscribe(listener)注册一个监听器.listener会在store tree更新后执行.以下代码为Connect组件内部，向store tree注册listener的过程。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22  trySubscribe() {\n    if (!this.unsubscribe) {\n      this.unsubscribe = this.parentSub\n        ? this.parentSub.addNestedSub(this.onStateChange)\n        : this.store.subscribe(this.onStateChange)\n \n      this.listeners = createListenerCollection()\n    }\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e  trySubscribe() {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.unsubscribe) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.unsubscribe = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parentSub\n        ? \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.parentSub.addNestedSub(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onStateChange)\n        : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.store.subscribe(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.onStateChange)\n \n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.listeners = createListenerCollection()\n    }\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader13\x22\x3e何时注册\x3c\/h3\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22    componentDidMount() {\n        ...\n        this.subscription.trySubscribe()\n        ...\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e    componentDidMount() {\n        ...\n        this\x3cspan class=\x22hljs-selector-class\x22\x3e.subscription\x3c\/span\x3e\x3cspan class=\x22hljs-selector-class\x22\x3e.trySubscribe\x3c\/span\x3e()\n        ...\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到，当Connect组件加载到页面后，当前组件开始监听store tree变化\x3c\/p\x3e\n\x3ch3 id=\x22articleHeader14\x22\x3e何时注销\x3c\/h3\x3e\n\x3cp\x3e当前Connect组件销毁后，我们希望其中注册的listener也一并销毁，避免性能问题。此时可以在Connect的componentWillUnmount周期函数中执行这一过程。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      componentWillUnmount() {\n          if (this.subscription) this.subscription.tryUnsubscribe()\n          ...\n      }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e      componentWillUnmount() {\n          \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscription) \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.subscription.tryUnsubscribe()\n          ...\n      }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader15\x22\x3e变更处理逻辑\x3c\/h3\x3e\n\x3cp\x3e有了触发组件更新的时机，我们下面主要看下，组件是通过何种方式触发重新渲染\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22      onStateChange() {\n        ...\n        if (!this.selector.shouldComponentUpdate) {\n          ...\n        } else {\n          ...\n          this.setState(dummyState) \/\/ dummyState = {}, 仅仅是为了触发更新\n        }\n      }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3e      onStateChange() {\n        ...\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.selector.shouldComponentUpdate) {\n          ...\n        } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n          ...\n          \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.setState(dummyState) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ dummyState = {}, 仅仅是为了触发更新\x3c\/span\x3e\n        }\n      }\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch3 id=\x22articleHeader16\x22\x3e小结\x3c\/h3\x3e\n\x3cp\x3e可以看到，react-redux的核心功能都在connect模块中，理解好这个模块，有助于我们更好的使用react-redux处理业务问题，优化代码性能。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>react-redux原理分析</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007589792">https://segmentfault.com/a/1190000007589792</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/dw38usex45b/" target="_blank">https://alili.tech/archive/dw38usex45b/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/5x6tenwjeux/">ES6中的异步编程：Generators函数&#43;Promise:最强大的异步处理方式<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/nvtmua2a1hd/">GreenSock (TweenMax) 极简入门指南<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/7kt5s47oysx/">HTML5 中 canvas 的使用总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/41pgo3a2iyp/">JavaScript 开发者所需要知道的 V8（一）：V8 In NodeJS<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/krb1zm7x38j/">JavaScript 时间与日期处理实战:你肯定被坑过<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/yh2lq30d0x/">JavaScript中的各种宽高属性<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/eydwczesyv/">Muse UI — 基于 Vue2.0 的 Material Design UI 库<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/y62oejm8cr/">Nodejs基础：路径处理模块path总结<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/06cwh88ankmd/">PhantomJS &amp; NodeJS 在京东网站前端监控平台的最佳实践<aside class="dates">2019-01-31</aside></a></li><li><a href="/archive/z4ymvs0jz2h/">Promise 的链式调用与中止<aside class="dates">2019-01-31</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>