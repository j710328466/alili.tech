<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="浅谈对JavaScript闭包的理解"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>浅谈对JavaScript闭包的理解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/6yow8y6qofn/",
				"appid": "1613049289050283", 
				"title": "浅谈对JavaScript闭包的理解 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-03T02:30:40"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/mxcmlmakae/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/c8k8bsi368w/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f&text=%e6%b5%85%e8%b0%88%e5%af%b9JavaScript%e9%97%ad%e5%8c%85%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f&text=%e6%b5%85%e8%b0%88%e5%af%b9JavaScript%e9%97%ad%e5%8c%85%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f&title=%e6%b5%85%e8%b0%88%e5%af%b9JavaScript%e9%97%ad%e5%8c%85%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f&is_video=false&description=%e6%b5%85%e8%b0%88%e5%af%b9JavaScript%e9%97%ad%e5%8c%85%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%b5%85%e8%b0%88%e5%af%b9JavaScript%e9%97%ad%e5%8c%85%e7%9a%84%e7%90%86%e8%a7%a3&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f&title=%e6%b5%85%e8%b0%88%e5%af%b9JavaScript%e9%97%ad%e5%8c%85%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f&title=%e6%b5%85%e8%b0%88%e5%af%b9JavaScript%e9%97%ad%e5%8c%85%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f&title=%e6%b5%85%e8%b0%88%e5%af%b9JavaScript%e9%97%ad%e5%8c%85%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f6yow8y6qofn%2f&title=%e6%b5%85%e8%b0%88%e5%af%b9JavaScript%e9%97%ad%e5%8c%85%e7%9a%84%e7%90%86%e8%a7%a3"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">浅谈对JavaScript闭包的理解</h1><div class="meta"><div class="postdate"><time datetime="2019-02-03" itemprop="datePublished">2019-02-03</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e在谈闭包之前，我们首先要了解几个概念：\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e什么是函数表达式？ 与函数声明有何不同？\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eJavaScript查找标识符的机制\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eJavaScript的作用域是词法作用域\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eJavaScript的垃圾回收机制\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cblockquote\x3e\x3cp\x3e先来说说函数表达式\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e什么是函数表达式？  \x3cstrong\x3e如果function是声明中的第一个词，那么就是函数声明，否则就是函数表达式\x3c\/strong\x3e\x3cbr\x3e举个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var foo = function(){}; \/\/匿名函数表达式\n\n（function foo(){}）() \/\/函数表达式,因为function不是声明中的第一个词，前面还有一个“（”\n\nfunction foo(){} \/\/函数声明\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{}; \x3cspan class=\x22hljs-comment\x22\x3e\/\/匿名函数表达式\x3c\/span\x3e\n\n（\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{}）() \x3cspan class=\x22hljs-comment\x22\x3e\/\/函数表达式,因为function不是声明中的第一个词，前面还有一个“（”\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{} \x3cspan class=\x22hljs-comment\x22\x3e\/\/函数声明\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e函数表达式也分匿名函数表达式和具名函数表达式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var foo = function(){} \/\/匿名函数表达式\n\nvar foo = function bar(){} \/\/具名函数表达式\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{} \x3cspan class=\x22hljs-comment\x22\x3e\/\/匿名函数表达式\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{} \x3cspan class=\x22hljs-comment\x22\x3e\/\/具名函数表达式\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e具名函数表达式要注意一点：上例中的bar标识符 只在当前的函数作用域中存在，在全局作用域中是不存在的\x3c\/p\x3e\n\x3cp\x3e函数声明与函数表达式的重要区别有：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e函数声明具有\x3cstrong\x3e函数声明提升\x3c\/strong\x3e，函数表达式不会被提升\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e函数表达式可以在表达式后跟个括号来立即执行，函数声明不行\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22（function (){})() \/\/匿名函数表达式，且立即执行\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e（\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{})() \x3cspan class=\x22hljs-comment\x22\x3e\/\/匿名函数表达式，且立即执行\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种模式的函数，通常称为\x3cstrong\x3eIIFE\x3c\/strong\x3e（Immediately Invoked Function Expresstion）代表立即执行函数表达式。\x3cbr\x3e关于函数、变量声明的提升这里就不再多说了， 想了解的同学可以查阅一下相关资料\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e关于JavaScript执行函数时查找标识符的机制\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e不了解作用域链及变量对象的同学可以先查阅相关资料后再来看。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e作用域链本质上是一个由指向变量对象的指针列表，它只引用但不实际包含变量对象\x3c\/strong\x3e，变量，函数等等都存在各自作用域的变量对象中，通过访问变量对象来访问它们。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e只有在函数调用的时候，才会创建执行环境和作用域链，同时每个环境都只能逐级向上搜索作用域链，来查询变量和函数名等标识符\x3c\/strong\x3e\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eJavaScript的作用域\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e\x3cstrong\x3eJavaScript的作用域就是词法作用域而不是动态作用域\x3c\/strong\x3e\x3cbr\x3e词法作用域最重要的特征是它的定义过程发生在\x3ccode\x3e代码的书写阶段\x3c\/code\x3e\x3cbr\x3e动态作用域的作用域链是基于\x3ccode\x3e调用栈的\x3c\/code\x3e   词法作用域的作用域链是基于\x3ccode\x3e代码中的作用域嵌套\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo(){\n    console.log(num)\n}\n   \nfunction bar(){\n    var num = 2;\n    foo(); \/\/ 1\n}\n    \nvar num = 1;\nbar();    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(num)\n}\n   \n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ebar\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e num = \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e;\n    foo(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 1\x3c\/span\x3e\n}\n    \n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e num = \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\nbar();    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3ebar函数执行时，会执行foo函数，因为JavaScript是词法作用域，所以函数执行时，会沿着定义时的作用域链查找变量，而不是执行时，foo函数定义在全局中，所以查找到了全局的num，输出了1而不是2。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e下面来说闭包\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e关于什么是闭包，其实有很多种说法，这取决于各自的理解，最主要的有两种：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eNicolas C.Zakas：\x3cstrong\x3e闭包是指有权访问另一个函数作用域中的变量的\x3ccode\x3e函数\x3c\/code\x3e\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3eKYLE SIMPSON：\x3cstrong\x3e当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函数持有对该词法作用域的引用，这个\x3ccode\x3e引用\x3c\/code\x3e就叫做\x3ccode\x3e闭包\x3c\/code\x3e\x3c\/strong\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e我个人更倾向于后者对于闭包的定义，即闭包是一个引用。\x3cbr\x3e下面来看一些代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function foo() {\n    var a = 5;\n    return function() {\n    console.log(a);\n    }\n }\n\nvar bar = foo();\nbar();       \/\/ 5\n    \x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a = \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(a);\n    }\n }\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e bar = foo();\nbar();       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 5\x3c\/span\x3e\n    \x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这段代码里 foo执行时会返回一个匿名函数表达式，这个函数能够访问foo（）的作用域，并且引用能引用它，然后将这个匿名函数赋值给了变量bar，让bar能引用这个匿名函数并且可以调用它。\x3cbr\x3e这个例子，匿名函数在\x3cstrong\x3e自己定义的词法作用域以外的地方成功执行\x3c\/strong\x3e。\x3cbr\x3e这正是闭包强大的地方，比如通过闭包实现模块模式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function aModule() {\n\n    var sometext = \x26quot;module\x26quot;;\n    \n    function doSomething() {\n        console.log(sometext);\n    }\n    \n    return {\n        doSomething: doSomething\n        };\n}\n\nvar obj = aModule();\nobj.doSomething()   \/\/module\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eaModule\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e sometext = \x3cspan class=\x22hljs-string\x22\x3e\x22module\x22\x3c\/span\x3e;\n    \n    \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3edoSomething\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(sometext);\n    }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3edoSomething\x3c\/span\x3e: doSomething\n        };\n}\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e obj = aModule();\nobj.doSomething()   \x3cspan class=\x22hljs-comment\x22\x3e\/\/module\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们通过调用aModule函数创建了一个模块实例，函数返回的这个对象，实质上可以看做是这个模块的公告API，是不是有些像其它面向对象语言中的class？\x3c\/p\x3e\n\x3cp\x3e再来通过闭包实现一个单例模式：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var application = function() {\n    \n    var components = [];\n    \/*\n    一些初始化操作\n    *\/\n    return {              \/\/公共API\n        getComponentCount: function() {\n        return components.length;\n        },\n        registerComponent: function(component) {\n        components.push(component);\n        }\n    };\n}();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e application = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e components = [];\n    \x3cspan class=\x22hljs-comment\x22\x3e\/*\n    一些初始化操作\n    *\/\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {              \x3cspan class=\x22hljs-comment\x22\x3e\/\/公共API\x3c\/span\x3e\n        getComponentCount: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e components.length;\n        },\n        registerComponent: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(component)\x3c\/span\x3e \x3c\/span\x3e{\n        components.push(component);\n        }\n    };\n}();\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个例子通过IIFE创建了一个单例对象，函数里返回的对象字面量是这个单例模式的公共接口。\x3cbr\x3e通过闭包实现模块模式，可以做到很多强大的事情，模块模式能成功实现，最关键的是返回的API还能继续引用定义时所在的作用域，从而进行一些操作，也就是说，\x3cstrong\x3e作用域并没有因为函数执行后被销毁，也就是没有被内存回收\x3c\/strong\x3e，之所以没有被回收是因为闭包的存在和JavaScript的垃圾回收机制。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eJavaScript的垃圾回收机制\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3eJavaScript最常用的垃圾收集方式是标记清除，垃圾收集器会给存储在内存中的所有变量都加上标记，然后去除环境中的变量，以及被环境中的变量引用的变量的标记，说明这些变量还有作用，暂时不能被删除，然后在此之后被加上标记的变量就是要删除的变量了，等待垃圾收集器对他们完成清除工作。\x3c\/p\x3e\n\x3cp\x3e对函数来说，函数执行完毕后，会自动释放掉里面的变量，可是如果函数内部存在闭包，它们就不会被删除，因为这个函数还在被内部的函数所引用，所以他不会被加上标记，不会被清除，而是会\x3ccode\x3e一直存在内存中得不到释放！\x3c\/code\x3e除非使用闭包的那个内部函数被销毁，外部函数才能得到释放\x3c\/p\x3e\n\x3cp\x3e所以，虽然闭包强大，但是我们不能滥用它，且在没有必要的情况下尽量不要创建闭包，不然将会有大量的变量对象得不到释放，过度占用内存。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e关于循环和闭包\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e当循环和闭包结合在一起时，经常会产生让初学者觉得匪夷所思的问题。\x3cbr\x3e来看一段Nicolas C.Zakas 在《JavaScript高级程序设计》中的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createFunction() {\n    var result = [];\n    for (var i = 0; i \x3c 10; i\x2b\x2b) {\n        result[i] = function() {\n            return i;\n        };\n    }\n    return result;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateFunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; i\x2b\x2b) {\n        result[i] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e i;\n        };\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个函数执行后，会创建一个\x3ccode\x3e由十个函数组成的数组\x3c\/code\x3e，\x3ccode\x3e并且产生十个互不相干的函数作用域\x3c\/code\x3e，表面上看调用第几个函数就会输出几，但是结果并不是这样\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var result = createFunction();\nresult[0]();  \/\/ 10\nresult[9]();  \/\/ 10\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs markdown\x22\x3e\x3ccode\x3evar result = createFunction();\nresult[\x3cspan class=\x22hljs-string\x22\x3e0\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3e\x3c\/span\x3e);  \/\/ 10\nresult[\x3cspan class=\x22hljs-string\x22\x3e9\x3c\/span\x3e](\x3cspan class=\x22hljs-link\x22\x3e\x3c\/span\x3e);  \/\/ 10\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e产生这种奇怪的现象的原因就是之前说的，createFunction的变量对象因为闭包的存在没有被释放，注意\x3ccode\x3e闭包保存的是整个变量对象，而不是只保存只被引用的变量\x3c\/code\x3e，在createFunction执行后，创建了十个函数，同时变量 i 没有被释放，依然保存在内存中，所以此时它的值保留为停止循环后的10。\x3c\/p\x3e\n\x3cp\x3e当我们在外部调用函数时，函数沿着它的作用域链开始搜索所需要的变量，前面说过，JavaScript的作用域链是基于定义时的作用域嵌套，所以当我们调用某个函数比如 \x3ccode\x3eresult[0]\x3c\/code\x3e 它就会首先在自己的作用域里通过RSH搜索 i ，显然 i 不存在这个作用域中，于是它又沿着作用域链向上一级作用域中搜索 i ，然后找到了 i ，但是此时createFunction函数已经执行，循环也已经执行完毕了， i 的值为10，所以获取到的i，值就为10，同理，其他的函数执行时，查找的i 也会是10， 所以每个函数执行结果都是输出10。\x3cbr\x3e关键所在就是\x3cstrong\x3e尽管循环中的十个函数是在各自的迭代中分别定义的，但是它们都处于一个共享的上一级作用域中，所以它们获取到的都是一个 i \x3c\/strong\x3e\x3c\/p\x3e\n\x3cp\x3e所以解决此类问题的关键就是让\x3cstrong\x3e函数查找i时，不找到createFunction的变量对象那一级\x3c\/strong\x3e ，因为一旦向上搜索到createFunction那里，得到的就是10。所以我们可以通过一些方法在中间来截断本该搜索到createFunction变量对象的一次查找。\x3c\/p\x3e\n\x3cp\x3e首先我们可以这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createFunction() {\n    var result = [];\n    for (var i = 0; i \x3c 10; i\x2b\x2b) {\n    (function (){\n        result[i] = function() {\n            return i;\n        };})();\n    }\n    return result;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateFunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; i\x2b\x2b) {\n    (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e{\n        result[i] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e i;\n        };})();\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们通过定义一个立即执行函数表达式，在result[i]函数上一级创建了一个块级作用域，如果我们把这个块级作用域叫做\x3ccode\x3ea\x3c\/code\x3e，那么它查找i时是这样一条链 \x3ccode\x3eresult[i]-\x26gt;a-\x26gt;createFunction\x3c\/code\x3e，之所以还会查找到createFunction中，是因为\x3ccode\x3ea\x3c\/code\x3e中没有\x3ccode\x3ei\x3c\/code\x3e这个变量，所以我们需要做些什么，让它搜索到\x3ccode\x3ea\x3c\/code\x3e时就停下\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createFunctions() {\n    var result = new Array();\n    for (var i = 0; i \x3c 10; i\x2b\x2b) {\n        (function(i){\n        result[i] = function() {\n            return i;\n        };})(i);\n        }\n    \n    return result;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateFunctions\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eArray\x3c\/span\x3e();\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; i\x2b\x2b) {\n        (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ei\x3c\/span\x3e)\x3c\/span\x3e{\n        result[i] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e i;\n        };})(i);\n        }\n    \n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在a这个块级作用域里定义了一个变量 i ，这个 i 与上级的 i 不会互相影响，因为它们存在各自的作用域里， 同时我们将该次迭代时的 i 值赋给了 a这个块级作用域里的 i ，即a中的 i 保存了当次迭代的 i ，result[i]在外部执行时，是这样的调用链\x3ccode\x3eresult i -\x26gt; a\x3c\/code\x3e在a中就能找到需要的变量，不需要再向上搜索，也不会查找到值为10的 i ，所以调用哪个result[i]函数，就会输出哪个 i 。\x3c\/p\x3e\n\x3cp\x3e在 \x3ccode\x3eES6\x3c\/code\x3e 中我们还可以使用 \x3ccode\x3elet\x3c\/code\x3e 来解决此类问题\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createFunction() {\n    var result = [];\n    for (var i = 0; i \x3c 10; i\x2b\x2b) {\n        let j = i;\n        result[i] = function() {\n            return j;\n        };\n    }\n    return result;\n}\n\/\/输出一下\nconsole.log(createFunction()[2]());  \/\/2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e j = i;\n        result[i] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e j;\n        };\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/输出一下\x3c\/span\x3e\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(createFunction()[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]());  \x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3elet会创建一个块级作用域，并在这个作用域中声明一个变量。所以我们相当于在result[i]上套了一层块级作用域\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createFunction() {\n    var result = [];\n    for (var i = 0; i \x3c 10; i\x2b\x2b) {\n        \/\/块的开始\n        let j = i;\n        result[i] = function() {\n            return j;\n        };\n        \/\/块的结束\n    }\n    return result;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; i\x2b\x2b) {\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/块的开始\x3c\/span\x3e\n        \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e j = i;\n        result[i] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e j;\n        };\n        \x3cspan class=\x22hljs-comment\x22\x3e\/\/块的结束\x3c\/span\x3e\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这种方式解决此类问题，与前面没有多大分别，总之就是为了不让函数调用时去查找到最上级的那个 i 。\x3c\/p\x3e\n\x3cp\x3e其实，如果在for循环头部来进行\x3ccode\x3elet\x3c\/code\x3e声明还会有一个有趣的行为：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function createFunction() {\n    var result = [];\n    for (let i = 0; i \x3c 10; i\x2b\x2b) {    \/\/每次迭代，都会声明一次i，总共声明10次\n        result[i] = function() {\n            return i;\n        };\n    }\n    return result;\n}\nconsole.log(createFunction()[2]());  \/\/2\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ecreateFunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e result = [];\n    \x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e; i\x2b\x2b) {    \x3cspan class=\x22hljs-comment\x22\x3e\/\/每次迭代，都会声明一次i，总共声明10次\x3c\/span\x3e\n        result[i] = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e i;\n        };\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e result;\n}\n\x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(createFunction()[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e]());  \x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样在for头部使用\x3ccode\x3elet\x3c\/code\x3e声明， 每次迭代都会进行声明，随后每次迭代都会使用上一个迭代结束时的值来初始化这个变量。\x3c\/p\x3e\n\x3cp\x3e事实上当函数当做值类型并到处传递时， 基本都会使用闭包，如\x3cstrong\x3e定时器，跨窗口通信，事件监听，ajax等等\x3c\/strong\x3e 基本只要使用了\x3ccode\x3e回调函数\x3c\/code\x3e， 实际上就是在使用闭包。\x3c\/p\x3e\n\x3cp\x3e闭包是一把双刃剑 是JavaScript比较难以理解和掌握的部分， 它十分强大，却也有很大的缺陷，如何使用它完全取决于你自己。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e以上皆为个人观点 如若有误 还望指正\x3c\/strong\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e参考书籍\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e《JavaScript高级程序设计》\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e《你不知道的JavaScript 上卷》\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>浅谈对JavaScript闭包的理解</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000006918275">https://segmentfault.com/a/1190000006918275</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/6yow8y6qofn/" target="_blank">https://alili.tech/archive/6yow8y6qofn/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/sj57jxyoook/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（上）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/qsw902j95k/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（下）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/nnpmjlot58j/">IndexedDB使用与出坑指南<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/alvlbas9oai/">JS事件模型<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/u0pzym8k36o/">JS练习实例--编写经典小游戏俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/khwpyk5yz8q/">JavaScript 事件代理和委托<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/kuocl6lc3n/">JavaScript 版俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/n8bk54lyrf/">Promise学习:基础入门<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/7bk7u30qncb/">Redux 入坑进阶 - 源码解析<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/853kqfmqmf7/">Snap.svg 基本知识入门<aside class="dates">2019-02-03</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>