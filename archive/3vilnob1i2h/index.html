<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="我所理解的正则表达式"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>我所理解的正则表达式 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/3vilnob1i2h/",
				"appid": "1613049289050283", 
				"title": "我所理解的正则表达式 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-02-01T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/p3hn1t2978p/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/dzymu0gmks/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f&text=%e6%88%91%e6%89%80%e7%90%86%e8%a7%a3%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f&text=%e6%88%91%e6%89%80%e7%90%86%e8%a7%a3%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f&title=%e6%88%91%e6%89%80%e7%90%86%e8%a7%a3%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f&is_video=false&description=%e6%88%91%e6%89%80%e7%90%86%e8%a7%a3%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e6%88%91%e6%89%80%e7%90%86%e8%a7%a3%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f&title=%e6%88%91%e6%89%80%e7%90%86%e8%a7%a3%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f&title=%e6%88%91%e6%89%80%e7%90%86%e8%a7%a3%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f&title=%e6%88%91%e6%89%80%e7%90%86%e8%a7%a3%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3vilnob1i2h%2f&title=%e6%88%91%e6%89%80%e7%90%86%e8%a7%a3%e7%9a%84%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">我所理解的正则表达式</h1><div class="meta"><div class="postdate"><time datetime="2019-02-01" itemprop="datePublished">2019-02-01</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e学习了半年的正则表达式，也不能说一直学习吧，就是和它一直在打交道，如何用正则表达式解决自己的问题，并且还要考虑如何在匹配大量的文本时去优化它。慢慢的觉得正则已经成为自己的一项技能，逐渐的从一个正则表达式小白变成一个伪精通者。\x3c\/p\x3e\n\x3cp\x3e那么，我不打算详细介绍正则表达式的使用，或者说这篇文章并不是入门教程，所以如果你对正则表达式一无所知或者处于入门阶段，建议你还是先去看看下面这些正则表达式入门的文章。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22http:\/\/javascript.ruanyifeng.com\/stdlib\/regexp.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阮一峰老师的正则教程\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/zh-CN\/docs\/Web\/JavaScript\/Guide\/Regular_Expressions\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMDN 正则介绍\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/www.cnblogs.com\/hustskyking\/archive\/2013\/06\/04\/RegExp.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e胡子哥正则表达式 30 分钟入门\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/es6.ruanyifeng.com\/#docs\/regex\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e阮一峰 ES6 正则表达式扩展\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/baike.baidu.com\/link?url=_pjiVQXmw6yiub_Nx6wvXuOMxqTOE78gOEnYgEq7IPjCw1ht40LeQwfKI0cIwpS44d7gLX5LagnJQ3bh6oL2ua\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e百度百科 正则表达式\x3c\/a\x3e 很详细，可以当作手册参考\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e当然正则的教程很多，不限于此，如果你对正则已经了解了，那么可以开始下面的内容了，\x3cstrong\x3e文章中可能还会涉及一些效率的问题\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3enew RegExp 和 \/\/ 正则对象创建区别\x3c\/h2\x3e\n\x3cp\x3e如果写过 Python 的同学，都一定会知道 Python 中可以在字符串前面加个小写的 r ，来表示防止转义。防止转义的意思就是说：str = r\x22\\t\x27 等价于 str = \x27\\\\t\x27，加了 r 会防止 \\ 被转义。\x3c\/p\x3e\n\x3cp\x3e为什么要介绍这个，因为这就是 \x3ccode\x3enew RegExp\x3c\/code\x3e 和 \x3ccode\x3e\/\/\x3c\/code\x3e 的区别，因为我们知道在正则表达式中会频繁的使用转义字符 \\w\\s\\d 等，但是它们在内存中的是以 \\\\w\\\\s\\\\d 存储的，看个例子：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/推荐写法\nvar regex1 = \/\\w\x2b\/g;\nregex1 \/\/ \/\\w\x2b\/g\n\/\/RegExp 写法\nvar regex2 = new RegExp(\x27\\\\w\x2b\x27,\x27g\x27);\nregex2 \/\/ \/\\w\x2b\/g\n\/\/错误写法\nvar regex3 = new RegExp(\x27\\w\x2b\x27,\x27g\x27);\nregex3 \/\/ \/w\x2b\/g\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/推荐写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex1 = \x3cspan class=\x22hljs-regexp\x22\x3e\/\\w\x2b\/g\x3c\/span\x3e;\nregex1 \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \/\\w\x2b\/g\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/RegExp 写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex2 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\\\\w\x2b\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27g\x27\x3c\/span\x3e);\nregex2 \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \/\\w\x2b\/g\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/错误写法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex3 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27\\w\x2b\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-string\x22\x3e\x27g\x27\x3c\/span\x3e);\nregex3 \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \/w\x2b\/g\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e你也看出来了，错误写法只能匹配 \x3ccode\x3ewwwww\x3c\/code\x3e 这样的字符串，曾经我就见过有人把他们弄混了，还说第一个第三个没有区别。第二种方法的输出，还是 \/\\w\x2b\/g，中间还是要转换，所以推荐第一种写法。\x3c\/p\x3e\n\x3cp\x3e当然，还有比较奇葩的：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var regex4 = new RegExp(\/\\w\x2b\/g);\nregex4 \/\/ \/\\w\x2b\/g\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex4 = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-built_in\x22\x3eRegExp\x3c\/span\x3e(\x3cspan class=\x22hljs-regexp\x22\x3e\/\\w\x2b\/g\x3c\/span\x3e);\nregex4 \x3cspan class=\x22hljs-comment\x22\x3e\/\/ \/\\w\x2b\/g\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eMSDN 上关于 \x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/RegExp\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRegExp\x3c\/a\x3e 的介绍。\x3c\/p\x3e\n\x3cp\x3e那么，如何能像 Python 的 \x3ccode\x3er\x27\x27\x3c\/code\x3e 那样，实现一个防转义的功能呢？我这里有一种很蹩脚的方法(\x3cdel\x3e仅供娱乐！\x3c\/del\x3e)：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str1 = \x27\\d\\w\\s\x27;\nstr1; \/\/ \x26quot;dws\x26quot;\nvar str2 = \/\\d\\w\\s\/;\nstr2.source; \/\/ \x26quot;\\d\\w\\s\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs taggerscript\x22\x3e\x3ccode\x3evar str1 = \x27\x3cspan class=\x22hljs-symbol\x22\x3e\\d\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\\w\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\\s\x3c\/span\x3e\x27;\nstr1; \/\/ \x22dws\x22\nvar str2 = \/\x3cspan class=\x22hljs-symbol\x22\x3e\\d\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\\w\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\\s\x3c\/span\x3e\/;\nstr2.source; \/\/ \x22\x3cspan class=\x22hljs-symbol\x22\x3e\\d\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\\w\x3c\/span\x3e\x3cspan class=\x22hljs-symbol\x22\x3e\\s\x3c\/span\x3e\x22\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e没错，就是 \x3ccode\x3esrouce\x3c\/code\x3e，不知道 source 的同学快去面壁吧。(这方法确实很抠脚！)\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3ei、g、m 修饰符\x3c\/h2\x3e\n\x3cp\x3e这几个修饰符只是针对 JS 来说的，像 Python 中还有 \x3ccode\x3ere.S\x3c\/code\x3e 表示 . 可以匹配换行符。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e对于 i 表示忽略字母大小写\x3c\/strong\x3e，不是很常用，因为它有很多替代品，比如：\x3ccode\x3e\/[a-zA-Z]\/\x3c\/code\x3e 可以用来替代 \x3ccode\x3e\/[a-z]\/i\x3c\/code\x3e，至于两者处理长文本的时间效率，我自己没有研究过，不下定论。\x3c\/p\x3e\n\x3cp\x3e使用 i 需要注意的地方，就是 i 会对正则表达式的每一个字母都忽略大小写，当我们需要部分单词的时候，可以考虑一下\x3ccode\x3e\/(?:t|T)he boy\/\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3eg 表示全局匹配\x3c\/strong\x3e，在印象中，可能很多人会觉得全局匹配就是当使用 match 的时候，把所有符合正则表达式的文本全部匹配出来，这个用途确实很广泛，不过 g 还有其他更有意思的用途，那就是 \x3ccode\x3elastIndex\x3c\/code\x3e 参数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x271a2b3c4d5e6f\x27,\n    reg = \/\\d\\w\\d\/g;\nstr.match(reg); \/\/[\x26quot;1a2\x26quot;, \x26quot;3c4\x26quot;, \x26quot;5e6\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x271a2b3c4d5e6f\x27\x3c\/span\x3e,\n    reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/\\d\\w\\d\/g\x3c\/span\x3e;\nstr.match(reg); \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x221a2\x22, \x223c4\x22, \x225e6\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e为什么不包括\x3ccode\x3e2b3,4d5\x3c\/code\x3e，因为正则表达式匹配的时候，会用 \x3ccode\x3elastIndex\x3c\/code\x3e 来标记上次匹配的位置，正常情况下，已经匹配过的内容是不会参与到下次匹配中的。带有 g 修饰符时，可以通过正则对象的 lastIndex 属性指定开始搜索的位置，当然这仅仅局限于函数 exec 和 test(replace 没研究过，没听说过可以控制 lastIndex，match 返回的是数组，无法控制 lastIndex)，针对这个题目修改如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x271a2b3c4d5e6f\x27,\n  reg = \/\\d\\w\\d\/g;\nvar a;\nvar arr = [];\nwhile(a = reg.exec(str)){\n  arr.push(a[0]);\n  reg.lastIndex -= 1;\n}\narr \/\/[\x26quot;1a2\x26quot;, \x26quot;2b3\x26quot;, \x26quot;3c4\x26quot;, \x26quot;4d5\x26quot;, \x26quot;5e6\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x271a2b3c4d5e6f\x27\x3c\/span\x3e,\n  reg = \x3cspan class=\x22hljs-regexp\x22\x3e\/\\d\\w\\d\/g\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e a;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e arr = [];\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(a = reg.exec(str)){\n  arr.push(a[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e]);\n  reg.lastIndex -= \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e;\n}\narr \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x221a2\x22, \x222b3\x22, \x223c4\x22, \x224d5\x22, \x225e6\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3cstrong\x3em 表示多行匹配\x3c\/strong\x3e，我发现很多人介绍 m 都只是一行略过，其实关于 m 还是很有意思的。首先，来了解一下单行模式，我们知道 JavaScript 正则表达式中的 \x3ccode\x3e.\x3c\/code\x3e 是无法匹配 \\r\\n (换行，各个系统使用不一样) 的，像 Python 提供 re.S 表示 \x3ccode\x3e.\x3c\/code\x3e 可以匹配任意字符，包括 \\r\\n，在 JS 中如果想要表示匹配任意字符，只能用[\\s\\S] 这种蹩脚的方式了（还有更蹩脚的 [\\d\\D],[.\\s]）。这种模式叫做开启或关闭单行模式，可惜 JS 中无法来控制。\x3c\/p\x3e\n\x3cp\x3e多行模式跟 \x3ccode\x3e^ $\x3c\/code\x3e 两兄弟有关，如果你的正则表达式没有 ^$,即时你开启多行模式也是没用的。正常的理解\x3ccode\x3e\/^123$\/\x3c\/code\x3e只能匹配字符串\x3ccode\x3e123\x3c\/code\x3e，而开启多行模式\x3ccode\x3e\/^123$\/g\x3c\/code\x3e能匹配[\x27123\x27,\x27\\n123\x27,\x27123\\n\x27,\x27\\n123\\n\x27]，相对于 ^$ 可以匹配 \\r\\n 了。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x27\\na\x27;\n\/^a\/.test(str); \/\/false\n\/^a\/m.test(str); \/\/true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x27\\na\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-regexp\x22\x3e\/^a\/\x3c\/span\x3e.test(str); \x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\n\/^a\/m.test(str); \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e有人说，m 没用。其实在某些特殊的格式下，你知道你要匹配的内容会紧接着 \\r\\n 或以 \\r\\n 结尾，这个时候 m 就非常有用，比如 HTTP 协议中的请求和响应，都是以 \\r\\n 划分每一行的，响应头和响应体之间以 \\r\\n\\r\\n 来划分，我们需要匹配的内容就在开头，通过多行匹配，可以很明显的提高匹配效率。\x3c\/p\x3e\n\x3cp\x3e原理性的东西，我们还是要知道的，万一以后会用到。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e(?:) 和 (?=) 区别\x3c\/h2\x3e\n\x3cp\x3e在正则表达式中，括号不能乱用，因为括号就代表分组，在最终的匹配结果中，会被算入字匹配中，而 (?:) 就是来解决这个问题的，它的别名叫做非捕获分组。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x27Hello world!\x27;\nvar regex = \/Hello (\\w\x2b)\/;\nregex.exec(str); \/\/[\x26quot;Hello world\x26quot;, \x26quot;world\x26quot;]\nvar regex2 = \/Hello (?:\\w\x2b)\/;\nregex2.exec(str); \/\/[\x26quot;Hello world\x26quot;]\n\/\/replace 也一样\nvar regex3 = \/(?:ab)(cd)\/\n\x27abcd\x27.replace(regex3,\x27$1\x27) \/\/\x26quot;cd\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x27Hello world!\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex = \x3cspan class=\x22hljs-regexp\x22\x3e\/Hello (\\w\x2b)\/\x3c\/span\x3e;\nregex.exec(str); \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22Hello world\x22, \x22world\x22]\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex2 = \x3cspan class=\x22hljs-regexp\x22\x3e\/Hello (?:\\w\x2b)\/\x3c\/span\x3e;\nregex2.exec(str); \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22Hello world\x22]\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/replace 也一样\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex3 = \x3cspan class=\x22hljs-regexp\x22\x3e\/(?:ab)(cd)\/\x3c\/span\x3e\n\x3cspan class=\x22hljs-string\x22\x3e\x27abcd\x27\x3c\/span\x3e.replace(regex3,\x3cspan class=\x22hljs-string\x22\x3e\x27$1\x27\x3c\/span\x3e) \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x22cd\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到 (?:) 并不会把括号里的内容计入到子分组中。\x3c\/p\x3e\n\x3cp\x3e关于 (?=)，新手理解起来可能比较困难，尤其是一些很牛逼的预查正则表达式。其实还有个 (?!)，不过它和 (?=) 是属于一类的，叫做\x3cstrong\x3e正向肯定(否定)预查\x3c\/strong\x3e，它还有很多别名比如零宽度正预测先行断言。但我觉得最重要的只要记住这两点，预查和非捕获。\x3c\/p\x3e\n\x3cp\x3e预查的意思就是在之前匹配成功的基础上，在向后预查，看看是否符合预查的内容。正因为是预查，lastIndex 不会改变，且不会被捕获到总分组，更不会被捕获到子分组。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x27Hello world!\x27;\nvar regex = \/Hello (?=\\w\x2b)\/;\nregex.exec(str); \/\/[\x26quot;Hello \x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x27Hello world!\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex = \x3cspan class=\x22hljs-regexp\x22\x3e\/Hello (?=\\w\x2b)\/\x3c\/span\x3e;\nregex.exec(str); \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22Hello \x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和 (?:) 区别是：\x3cstrong\x3e我习惯的会把匹配的总结果叫做总分组\x3c\/strong\x3e，match 函数返回数组每一项都是总分组，exec 函数的返回数组的第一项是总分组。(?:) 会把括号里的内容计入总分组，(?=) 不会把括号里的内容计入总分组。\x3c\/p\x3e\n\x3cp\x3e说白了，还是强大的 lastIndex 在起作用。(?:) 和 (?=) 差别是有的，使用的时候要合适的取舍。\x3c\/p\x3e\n\x3cp\x3e说了这么多关于 (?=) 的内容，下面来点进阶吧！现在的需求是一串数字表示钱 \x2210000000\x22，但是在国际化的表示方法中，应该是隔三位有个逗号 \x2210,000,000\x22，给你一串没有逗号的，替换成有逗号的。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x26quot;10000000\x26quot;;\nvar regex = \/\\d(?=(\\d{3})\x2b$)\/g;\nstr.replace(regex, \x27$\x26amp;,\x27); \/\/\x26quot;10,000,000\x26quot;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x2210000000\x22\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex = \x3cspan class=\x22hljs-regexp\x22\x3e\/\\d(?=(\\d{3})\x2b$)\/g\x3c\/span\x3e;\nstr.replace(regex, \x3cspan class=\x22hljs-string\x22\x3e\x27$\x26amp;,\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/\x2210,000,000\x22\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我们分析一下 regex，\/\\d(?=(\\d{3})\x2b$)\/g 它是全局 g，实际上它匹配的内容只有一个 \\d，(?=(\\d{3})\x2b$) 是预判的内容，之前说过，预判的内容不计入匹配结果，lastIndex 还是停留在 \\d 的位置。(?=(\\d{3})\x2b$) 到结尾有至少一组 3 个在一起的数字，才算预判成功。\x3c\/p\x3e\n\x3cp\x3e\\d = 1 的时候，不满足预判，向后移一位，\\d = 0，满足预判，replace。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e(?!) 前瞻判断\x3c\/h2\x3e\n\x3cp\x3e(?=) 和 (?!) 叫做正向预查，但往往是正向这个词把我们的思维给束缚住了。正向给人的感觉是只能在正则表达式后面来预判，那么\x3cstrong\x3e预判为什么不能放在前面呢\x3c\/strong\x3e。下面这个例子也非常有意思。\x3c\/p\x3e\n\x3cp\x3e一个简单密码的验证，要保证至少包含大写字母、小写字母、数字中的两种，且长度 8~20。\x3c\/p\x3e\n\x3cp\x3e如果可以写多个正则，这个题目很简单，思路就是：\/^[a-zA-Z\\d]{8,20}$\/ \x26amp;\x26amp; !(\/[a-z]\x2b\/) \x26amp;\x26amp; !(\/[A-Z]\x2b\/) \x26amp;\x26amp; !(\/\\d\x2b\/)，看着眼都花了，好长一串。\x3c\/p\x3e\n\x3cp\x3e下面用 (?!) 前瞻判断来实现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var regex = \/^(?![a-z]\x2b$)(?![A-Z]\x2b$)(?!\\d\x2b$)[a-zA-Z\\d]{8,12}$\/;\nregex.test(\x2712345678\x27); \/\/false\nregex.test(\x271234567a\x27); \/\/true\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex = \x3cspan class=\x22hljs-regexp\x22\x3e\/^(?![a-z]\x2b$)(?![A-Z]\x2b$)(?!\\d\x2b$)[a-zA-Z\\d]{8,12}$\/\x3c\/span\x3e;\nregex.test(\x3cspan class=\x22hljs-string\x22\x3e\x2712345678\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/false\x3c\/span\x3e\nregex.test(\x3cspan class=\x22hljs-string\x22\x3e\x271234567a\x27\x3c\/span\x3e); \x3cspan class=\x22hljs-comment\x22\x3e\/\/true\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e分析一下，因为像 (?!) 预判不消耗 lastIndex，完全可以放到前面进行前瞻。\x3ccode\x3e(?![a-z]\x2b$)\x3c\/code\x3e 的意思就是从当前 lastIndex (就是^)开始一直到 $，不能全是小写字母，\x3ccode\x3e(?![A-Z]\x2b$)\x3c\/code\x3e 不能全是大写字母，(?!\\d\x2b$) 不能全是数字，[a-zA-Z\\d]{8,12}$ 这个是主体，判断到这里的时候，\x3cstrong\x3elastIndex\x3c\/strong\x3e 的位置仍然是 0，这就是 (?!) 前瞻带来的效率。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e对 JS 正则不支持 (?\x26lt;=) 个人看法\x3c\/h2\x3e\n\x3cp\x3e我们都知道，JS 中的正则表达式是不支持正回顾后发断言的 \x3ccode\x3e(?\x26lt;=)\x3c\/code\x3e，当然也不支持 \x3ccode\x3e(?\x26lt;!)\x3c\/code\x3e。有时候会觉得这种正回顾后发断言确实很有帮助，它可以让我们的思维更清晰，哪些是真正匹配的正则，哪些是断言的正则。在 Python 中我们就可以轻松的使用 (?\x26lt;=)，但是在 JS 中不行。\x3c\/p\x3e\n\x3cp\x3e原因可能是采用的正则引擎不一样导致，既然不支持，那我们也只能通过现有的条件来改进我们所写的正则，下面就说一说我的理解。\x3c\/p\x3e\n\x3cp\x3e对于一个非全局匹配的正则表达式，完全可以通过 \x3ccode\x3e(?:)\x3c\/code\x3e 来实现。比如对于 \x3ccode\x3e\/(?\x26lt;=Hello) (.*)$\/\x3c\/code\x3e(这个在 JS 中是不支持的)，可以使用 \x3ccode\x3e\/(?:Hello) (.*)$\/\x3c\/code\x3e作为一个简单的替代，这两个正则的差别就在于最终的匹配分组上面，总分组略有不同，但总有办法可以解决。\x3cstrong\x3e但要注意，这是非全局匹配，\x3c\/strong\x3e反正只匹配一次。\x3c\/p\x3e\n\x3cp\x3e那如果是全局匹配呢？又该如何实现 \x3ccode\x3e(?\x26lt;=)\x3c\/code\x3e?\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x27a1b2c3d\x27;\n\/\/var regex = \/(?\x3c=\\w)\\d\\w\/g\n\/\/str.match(regex) =\x3e [\x271b\x27,\x272c\x27,\x273d\x27]\nvar regex2 = \/(?:\\w)\\d\\w\/g\nstr.match(regex2); \/\/[\x26quot;a1b\x26quot;, \x26quot;c3d\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x27a1b2c3d\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/var regex = \/(?\x26lt;=\\w)\\d\\w\/g\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/str.match(regex) =\x26gt; [\x271b\x27,\x272c\x27,\x273d\x27]\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex2 = \x3cspan class=\x22hljs-regexp\x22\x3e\/(?:\\w)\\d\\w\/g\x3c\/span\x3e\nstr.match(regex2); \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x22a1b\x22, \x22c3d\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e很明显，只通过 \x3ccode\x3e(?:)\x3c\/code\x3e 就显得有点力不从心了，我们想要的结果是 \x3ccode\x3e[\x271b\x27,\x272c\x27,\x273d\x27]\x3c\/code\x3e，却返回其中的第一和第三个，少了第二个。\x3c\/p\x3e\n\x3cp\x3e这时候，又要拿出强大的 \x3ccode\x3elastIndex\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var str = \x27a1b2c3d\x27;\nvar regex = \/(?:\\w)(\\d\\w)\/g;\nvar m,arr = [];\nwhile(m = regex.exec(str)){\n  arr.push(m[1]);\n  regex.lastIndex --;\n}\narr; \/\/[\x26quot;1b\x26quot;, \x26quot;2c\x26quot;, \x26quot;3d\x26quot;]\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e str = \x3cspan class=\x22hljs-string\x22\x3e\x27a1b2c3d\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e regex = \x3cspan class=\x22hljs-regexp\x22\x3e\/(?:\\w)(\\d\\w)\/g\x3c\/span\x3e;\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e m,arr = [];\n\x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e(m = regex.exec(str)){\n  arr.push(m[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e]);\n  regex.lastIndex --;\n}\narr; \x3cspan class=\x22hljs-comment\x22\x3e\/\/[\x221b\x22, \x222c\x22, \x223d\x22]\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e和前面的例子很类似，通过重写 lastIndex 的值，达到模仿 \x3ccode\x3e(?\x26lt;=)\x3c\/code\x3e 的作用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e非贪婪与贪婪的问题\x3c\/h2\x3e\n\x3cp\x3e贪婪出现在 \x3ccode\x3e\x2b * {1,}\x3c\/code\x3e 这种不确定数量的匹配中，所谓的贪婪，表示正则表达式在匹配的时候，尽可能多的匹配符合条件的内容。比如 \x3ccode\x3e\/hello.*world\/\x3c\/code\x3e 匹配\x3ccode\x3e\x27hello world,nice world\x27\x3c\/code\x3e会匹配到第二个 world 结束。\x3c\/p\x3e\n\x3cp\x3e鉴于上面的情况，可以使用 ? 来实现非贪婪匹配。? 在正则表达式中用途很多，正常情况下，它表示前面那个字符匹配 0 或 1 次，就是简化版的 \x3ccode\x3e{0,1}\x3c\/code\x3e，如果在一些不确定次数的限制符后面出现，表示非贪婪匹配。\x3ccode\x3e\/hello.*?world\/\x3c\/code\x3e 匹配\x3ccode\x3e\x27hello world,nice world\x27\x3c\/code\x3e 的结果是 \x3ccode\x3ehello world\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e我刚开始写正则的时候，写出来的正则都是贪婪模式的，往往得到的结果和预想的有些偏差，就是因为少了 ? 的原因。\x3c\/p\x3e\n\x3cp\x3e我初入正则的时候，非贪婪模式还给我一种错觉。还是前面的那个例子，被匹配的内容换一下，用\x3ccode\x3e\/hello.*?world\/\x3c\/code\x3e 匹配\x3ccode\x3e\x27hello word,nice world\x27\x3c\/code\x3e，因为 word 不等于 world，在第一次尝试匹配失败之后，应该返回失败，但结果却是成功的，返回的是 \x3ccode\x3e\x27hello word,nice world\x27\x3c\/code\x3e。\x3c\/p\x3e\n\x3cp\x3e一开始我对于这种情况是不理解的，但仔细想想也对，这本来就应该返回成功。至于如何在第一次尝试匹配失败之后，后面就不再继续匹配，只能通过优化 \x3ccode\x3e.*\x3c\/code\x3e。如果我们把 \x3ccode\x3e.*?end\x3c\/code\x3e 这样子来看，\x3ccode\x3e.*\x3c\/code\x3e 会把所有字符都吞进去，慢慢吐出最后几个字符，和 end 比较，如果是贪婪，吐到第一个满足条件的就停止，如果是非贪婪，一直吐到不能吐为止，把离自己最近的结果返回。\x3c\/p\x3e\n\x3cp\x3e所以，\x3cstrong\x3e贪婪是返回最近的一次成功匹配，而不是第一次尝试\x3c\/strong\x3e。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e避免回溯失控\x3c\/h2\x3e\n\x3cp\x3e回溯可以杀死一个正则表达式，这一点都不假。关于正则表达式回溯也很好理解，就是正则引擎发现有两条路可以走时，它会选择其中的一条，把另一条路保存以便回溯时候用。\x3c\/p\x3e\n\x3cp\x3e比如正则 \x3ccode\x3e\/ab?c\/\x3c\/code\x3e 在成功匹配到 a 之后，后面可以有 b，也可以没有 b，这时候要提供两种选择。还有其他类型的回溯，比如 \x3ccode\x3e\/to(night|do)\/\x3c\/code\x3e。当然影响性能的回溯就要和 \x3ccode\x3e.* .\x2b .{m}\x3c\/code\x3e 有关。\x3c\/p\x3e\n\x3cp\x3e所谓的回溯失控，就是可供选择的路径太多，看一个常见回溯失控的例子，正则 \x3ccode\x3e\/(A\x2bA\x2b)\x2bB\/\x3c\/code\x3e ，如果匹配成功，会很快返回，那么匹配失败，非常可怕。比如来匹配 10 个 A \x3ccode\x3eAAAAAAAAAA\x3c\/code\x3e，假设第一个 A\x2b 吞了 9 个 A，整个正则吐出最后一个字符发现不是 B，这一轮吐完，还不能返回 false，因为还有其他路可以选择；第一个 A\x2b 吞 8 个 A，....一直这样回溯下去，回溯次数的复杂度大概是 2 的 n 次方吧。\x3c\/p\x3e\n\x3cp\x3e当然你可能会说，自己不会写这样傻的正则表达式。真的吗？我们来看一个匹配 html 标签的正则表达式，\/\x26lt;html\x26gt;[\\s\\S]*?\x26lt;head\x26gt;[\\s\\S]*?\x26lt;\/head\x26gt;[\\s\\S]*?\x26lt;body\x26gt;[\\s\\S]*?\x26lt;\/body\x26gt;[\\s\\S]*?\x26lt;\/html\x26gt; (感觉这样写也很傻)。如果一切都 OK，匹配一个正常的 HTML 页面，工作良好。但是如果不是以 \x3ccode\x3e\x26lt;\/html\x26gt;\x3c\/code\x3e结尾，每一个 [\\s\\S]*? 就会扩大其范围，一次一次回溯查找满足的一个字符串，这个时候可怕的回溯就来了。\x3c\/p\x3e\n\x3cp\x3e在说到回溯的同时，有时候还是要考虑一下 \x3ccode\x3e. * {}\x3c\/code\x3e 查询集合的问题，反正我的建议是尽量避免使用匹配任何字符的 [\\s\\S]，这真的是有点太暴力了。因为我们写正则的时候，都是以正确匹配的思路去写的，同时还需要考虑如果匹配不成功，该如何尽快的让 \x3ccode\x3e[a-zA-Z]*\x3c\/code\x3e 集合尽快停止。比如通常在匹配 HTML 标签的时候正则如果这样写 \/\x26lt;([^\x26gt;]\x2b)\x26gt;[sS]*?\x26lt;\\\/\\1\x26gt;\/ (匹配一个不带 class 等属性的标签)，匹配成功时，一切都好说，如果匹配失败，或者匹配的文本中恰好只有左半个 \x26lt; ，由于范围 [^\x26gt;] 范围太大，根本停不下来，相比来说 \/\x26lt;(\\w\x2b)\x26gt;[\\s\\S]*?\x26lt;\\\/\\1\x26gt;\/` 要好一些。又比如 [^\\r\\n]* 在匹配单行时效果不错，即时匹配失败也可以快速停止。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e总结\x3c\/h2\x3e\n\x3cp\x3e感觉这篇文章写的很乱，东扯西扯的，大概把我这几个月以来所学到的正则表达式知识都写在了这里，当然这并不包括一些基础的知识。我觉得学习正则最主要的还是去练习，只有在实际项目中总结出来的正则经验，才算自己正在掌握的，如果只是简单的扫一眼，时间久了，终究会忘记。共勉！\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e参考\x3c\/h2\x3e\n\x3cblockquote\x3e\x3cp\x3e\x3ca href=\x22http:\/\/javascript.ruanyifeng.com\/stdlib\/regexp.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eRegExp对象 - 阮一峰\x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Global_Objects\/RegExp\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eMSDN RegExp \x3c\/a\x3e\x3cbr\x3e\x3ca href=\x22http:\/\/div.io\/topic\/764?page=1\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e进阶正则表达式\x3c\/a\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e如何找出文件名为 \x22.js\x22 的文件，但要过滤掉 \x22.min.js\x22 的文件。\x3c\/p\x3e\n\x3cp\x3e代码如下：\x3c\/p\x3e\n\x3cp\x3e欢迎来\x3ca href=\x22http:\/\/yuren.space\/blog\/2016\/11\/05\/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e我的博客\x3c\/a\x3e参考代码。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>我所理解的正则表达式</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007422601">https://segmentfault.com/a/1190000007422601</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/3vilnob1i2h/" target="_blank">https://alili.tech/archive/3vilnob1i2h/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/sj57jxyoook/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（上）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/qsw902j95k/">ES6 &#43; Webpack &#43; React &#43; Babel 如何在低版本浏览器上愉快的玩耍（下）<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/nnpmjlot58j/">IndexedDB使用与出坑指南<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/alvlbas9oai/">JS事件模型<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/u0pzym8k36o/">JS练习实例--编写经典小游戏俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/khwpyk5yz8q/">JavaScript 事件代理和委托<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/kuocl6lc3n/">JavaScript 版俄罗斯方块<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/n8bk54lyrf/">Promise学习:基础入门<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/7bk7u30qncb/">Redux 入坑进阶 - 源码解析<aside class="dates">2019-02-03</aside></a></li><li><a href="/archive/853kqfmqmf7/">Snap.svg 基本知识入门<aside class="dates">2019-02-03</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>