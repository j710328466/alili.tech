<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="JavaScript 中如何实现函数队列？（一）"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>JavaScript 中如何实现函数队列？（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/ujljiit481c/",
				"appid": "1613049289050283", 
				"title": "JavaScript 中如何实现函数队列？（一） | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-27T02:30:59"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/jtod8y10sf/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/1k98mcmz3w3/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f&text=JavaScript%20%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e9%98%9f%e5%88%97%ef%bc%9f%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f&text=JavaScript%20%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e9%98%9f%e5%88%97%ef%bc%9f%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f&title=JavaScript%20%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e9%98%9f%e5%88%97%ef%bc%9f%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f&is_video=false&description=JavaScript%20%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e9%98%9f%e5%88%97%ef%bc%9f%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=JavaScript%20%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e9%98%9f%e5%88%97%ef%bc%9f%ef%bc%88%e4%b8%80%ef%bc%89&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f&title=JavaScript%20%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e9%98%9f%e5%88%97%ef%bc%9f%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f&title=JavaScript%20%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e9%98%9f%e5%88%97%ef%bc%9f%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f&title=JavaScript%20%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e9%98%9f%e5%88%97%ef%bc%9f%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fujljiit481c%2f&title=JavaScript%20%e4%b8%ad%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%87%bd%e6%95%b0%e9%98%9f%e5%88%97%ef%bc%9f%ef%bc%88%e4%b8%80%ef%bc%89"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">JavaScript 中如何实现函数队列？（一）</h1><div class="meta"><div class="postdate"><time datetime="2019-01-27" itemprop="datePublished">2019-01-27</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cp\x3e假设你有几个函数\x3ccode\x3efn1\x3c\/code\x3e、\x3ccode\x3efn2\x3c\/code\x3e和\x3ccode\x3efn3\x3c\/code\x3e需要按顺序调用，最简单的方式当然是：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22fn1();\nfn2();\nfn3();\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs gcode\x22\x3e\x3ccode\x3ef\x3cspan class=\x22hljs-symbol\x22\x3en1\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e()\x3c\/span\x3e;\nf\x3cspan class=\x22hljs-symbol\x22\x3en2\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e()\x3c\/span\x3e;\nf\x3cspan class=\x22hljs-symbol\x22\x3en3\x3c\/span\x3e\x3cspan class=\x22hljs-comment\x22\x3e()\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但有时候这些函数是运行时一个个添加进来的，调用的时候并不知道都有些什么函数；这个时候可以预先定义一个数组，添加函数的时候把函数push 进去，需要的时候从数组中按顺序一个个取出来，依次调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var stack = [];\n\/\/ 执行其他操作，定义fn1\nstack.push(fn1);\n\/\/ 执行其他操作，定义fn2、fn3\nstack.push(fn2, fn3);\n\/\/ 调用的时候\nstack.forEach(function(fn) { fn() });\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stata\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3estack\x3c\/span\x3e = [];\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行其他操作，定义fn1\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3estack\x3c\/span\x3e.push(fn1);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 执行其他操作，定义fn2、fn3\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3estack\x3c\/span\x3e.push(fn2, fn3);\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 调用的时候\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3estack\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eforEach\x3c\/span\x3e(function(fn) { fn() });\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样函数有没名字也不重要，直接把匿名函数传进去也可以。来测试一下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var stack = [];\n\nfunction fn1() {\n    console.log(\x27第一个调用\x27);\n}\nstack.push(fn1);\n\nfunction fn2() {\n    console.log(\x27第二个调用\x27);\n}\nstack.push(fn2, function() { console.log(\x27第三个调用\x27) });\n\nstack.forEach(function(fn) { fn() }); \/\/ 按顺序输出\x27第一个调用\x27、\x27第二个调用\x27、\x27第三个调用\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stack = [];\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第一个调用\x27\x3c\/span\x3e);\n}\nstack.push(fn1);\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第二个调用\x27\x3c\/span\x3e);\n}\nstack.push(fn2, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第三个调用\x27\x3c\/span\x3e) });\n\nstack.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{ fn() }); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 按顺序输出\x27第一个调用\x27、\x27第二个调用\x27、\x27第三个调用\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个实现目前为止工作正常，但我们忽略了一个情况，就是异步函数的调用。异步是JavaScript 中无法避免的一个话题，这里不打算探讨JavaScript 中有关异步的各种术语和概念，请读者自行查阅（例如某篇著名的\x3ca href=\x22http:\/\/blog.csdn.net\/lin_credible\/article\/details\/40143961\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e评注\x3c\/a\x3e）。如果你知道下面代码会输出1、3、2，那请继续往下看：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22console.log(1);\n\nsetTimeout(function() {\n    console.log(2);\n}, 0);\n\nconsole.log(3);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs fortran\x22\x3e\x3ccode\x3econsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n\nsetTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e);\n}, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n\nconsole.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e假如stack 队列中有某个函数是类似的异步函数，我们的实现就乱套了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var stack = [];\n\nfunction fn1() { console.log(\x27第一个调用\x27) };\nstack.push(fn1);\n\nfunction fn2() {\n    setTimeout(function fn2Timeout() {\n         console.log(\x27第二个调用\x27);\n    }, 0);\n}\nstack.push(fn2, function() { console.log(\x27第三个调用\x27) });\n\nstack.forEach(function(fn) { fn() }); \/\/ 输出\x27第一个调用\x27、\x27第三个调用\x27、\x27第二个调用\x27\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e stack = [];\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn1\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第一个调用\x27\x3c\/span\x3e) };\nstack.push(fn1);\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2Timeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n         \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第二个调用\x27\x3c\/span\x3e);\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\nstack.push(fn2, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{ \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第三个调用\x27\x3c\/span\x3e) });\n\nstack.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3efn\x3c\/span\x3e) \x3c\/span\x3e{ fn() }); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 输出\x27第一个调用\x27、\x27第三个调用\x27、\x27第二个调用\x27\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e问题很明显，\x3ccode\x3efn2\x3c\/code\x3e确实按顺序调用了，但\x3ccode\x3esetTimeout\x3c\/code\x3e里的\x3ccode\x3efunction fn2Timeout() { console.log(\x27第二个调用\x27) }\x3c\/code\x3e却不是立即执行的（即使把timeout 设为0）；\x3ccode\x3efn2\x3c\/code\x3e调用之后马上返回，接着执行\x3ccode\x3efn3\x3c\/code\x3e，\x3ccode\x3efn3\x3c\/code\x3e执行完了然才真正轮到\x3ccode\x3efn2Timeout\x3c\/code\x3e。\x3cbr\x3e怎么解决？我们分析下，这里的关键在于\x3ccode\x3efn2Timeout\x3c\/code\x3e，我们必须等到它真正执行完才调用\x3ccode\x3efn3\x3c\/code\x3e，理想情况下大概像这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fn2() {\n    setTimeout(function() {\n        fn2Timeout();\n        fn3();\n    }, 0);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n        fn2Timeout();\n        fn3();\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e但这样做相当于把原来的\x3ccode\x3efn2Timeout\x3c\/code\x3e整个拿掉换成一个新函数，再把原来的\x3ccode\x3efn2Timeout\x3c\/code\x3e和\x3ccode\x3efn3\x3c\/code\x3e插进去。这种动态改掉原函数的写法有个专门的名词叫\x3cstrong\x3eMonkey Patch\x3c\/strong\x3e。按我们程序员的口头禅：“做肯定是能做”，但写起来有点拧巴，而且容易把自己绕进去。有没更好的做法？\x3cbr\x3e我们退一步，不强求等\x3ccode\x3efn2Timeout\x3c\/code\x3e完全执行完才去执行\x3ccode\x3efn3\x3c\/code\x3e，而是在\x3ccode\x3efn2Timeout\x3c\/code\x3e函数体的最后一行去调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fn2() {\n    setTimeout(function fn2Timeout() {\n        console.log(\x27第二个调用\x27);\n        fn3();       \/\/ 注{1}\n    }, 0);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2Timeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第二个调用\x27\x3c\/span\x3e);\n        fn3();       \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 注{1}\x3c\/span\x3e\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样看起来好了点，不过定义\x3ccode\x3efn2\x3c\/code\x3e的时候都还没有\x3ccode\x3efn3\x3c\/code\x3e，这\x3ccode\x3efn3\x3c\/code\x3e哪来的？\x3c\/p\x3e\n\x3cp\x3e还有一个问题，\x3ccode\x3efn2\x3c\/code\x3e里既然要调用\x3ccode\x3efn3\x3c\/code\x3e，那我们就不能通过\x3ccode\x3estack.forEach\x3c\/code\x3e去调用\x3ccode\x3efn3\x3c\/code\x3e了,否则\x3ccode\x3efn3\x3c\/code\x3e会重复调用两次。\x3c\/p\x3e\n\x3cp\x3e我们不能把\x3ccode\x3efn3\x3c\/code\x3e写死在\x3ccode\x3efn2\x3c\/code\x3e里。相反，我们只需要在\x3ccode\x3efn2Timeout\x3c\/code\x3e末尾里找出\x3ccode\x3estack\x3c\/code\x3e中\x3ccode\x3efn2\x3c\/code\x3e的下一个函数，再调用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fn2() {\n    setTimeout(function fn2Timeout() {\n        console.log(\x27第二个调用\x27);\n        next();\n    }, 0);\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs javascript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2Timeout\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第二个调用\x27\x3c\/span\x3e);\n        next();\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个\x3ccode\x3enext\x3c\/code\x3e函数负责找出stack 中的下一个函数并执行。我们现在来实现\x3ccode\x3enext\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var index = 0;\n\nfunction next() {\n    var fn = stack[index];\n    index = index \x2b 1; \/\/ 其实也可以用shift 把fn 拿出来\n    if (typeof fn === \x27function\x27) fn();\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e index = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3enext\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e fn = stack[index];\n    index = index \x2b \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e; \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 其实也可以用shift 把fn 拿出来\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e fn === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) fn();\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3enext\x3c\/code\x3e通过\x3ccode\x3estack[index]\x3c\/code\x3e去获取\x3ccode\x3estack\x3c\/code\x3e中的函数，每调用\x3ccode\x3enext\x3c\/code\x3e一次\x3ccode\x3eindex\x3c\/code\x3e会加1，从而达到取出下一个函数的目的。\x3c\/p\x3e\n\x3cp\x3e\x3ccode\x3enext\x3c\/code\x3e这样使用：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var stack = [];\n\n\/\/ 定义index 和next\n\nfunction fn1() {\n    console.log(\x27第一个调用\x27);\n    next();  \/\/ stack 中每一个函数都必须调用`next`\n};\nstack.push(fn1);\n\nfunction fn2() {\n    setTimeout(function fn2Timeout() {\n         console.log(\x27第二个调用\x27);\n         next();  \/\/ 调用`next`\n    }, 0);\n}\nstack.push(fn2, function() {\n    console.log(\x27第三个调用\x27);\n    next(); \/\/ 最后一个可以不调用，调用也没用。\n});\n\nnext(); \/\/ 调用next，最终按顺序输出\x27第一个调用\x27、\x27第二个调用\x27、\x27第三个调用\x27。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs lua\x22\x3e\x3ccode\x3evar stack = [];\n\n\/\/ 定义index 和\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn1\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n    console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第一个调用\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e();  \/\/ stack 中每一个函数都必须调用`\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e`\n};\nstack.push(fn1);\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n    setTimeout(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn2Timeout\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n         console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第二个调用\x27\x3c\/span\x3e);\n         \x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e();  \/\/ 调用`\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e`\n    }, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e);\n}\nstack.push(fn2, \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e\x3c\/span\x3e {\n    console.log(\x3cspan class=\x22hljs-string\x22\x3e\x27第三个调用\x27\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e(); \/\/ 最后一个可以不调用，调用也没用。\n});\n\n\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e(); \/\/ 调用\x3cspan class=\x22hljs-built_in\x22\x3enext\x3c\/span\x3e，最终按顺序输出\x3cspan class=\x22hljs-string\x22\x3e\x27第一个调用\x27\x3c\/span\x3e、\x3cspan class=\x22hljs-string\x22\x3e\x27第二个调用\x27\x3c\/span\x3e、\x3cspan class=\x22hljs-string\x22\x3e\x27第三个调用\x27\x3c\/span\x3e。\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e现在\x3ccode\x3estack.forEach\x3c\/code\x3e一行已经删掉了，我们自行调用一次\x3ccode\x3enext\x3c\/code\x3e，\x3ccode\x3enext\x3c\/code\x3e会找出\x3ccode\x3estack\x3c\/code\x3e中的第一个函数\x3ccode\x3efn1\x3c\/code\x3e执行，\x3ccode\x3efn1\x3c\/code\x3e 里调用\x3ccode\x3enext\x3c\/code\x3e，去找出下一个函数\x3ccode\x3efn2\x3c\/code\x3e并执行，\x3ccode\x3efn2\x3c\/code\x3e里再调用\x3ccode\x3enext\x3c\/code\x3e，依此类推。\x3c\/p\x3e\n\x3cp\x3e每一个函数里都必须调用\x3ccode\x3enext\x3c\/code\x3e，如果某个函数里不写，执行完该函数后程序就会直接结束，没有任何机制继续。\x3c\/p\x3e\n\x3cp\x3e了解了函数队列的这个实现后，你应该可以解决下面这道面试题了：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ 实现一个LazyMan，可以按照以下方式调用:\nLazyMan(“Hank”)\n\/* 输出: \nHi! This is Hank!\n*\/\n\nLazyMan(“Hank”).sleep(10).eat(“dinner”)输出\n\/* 输出: \nHi! This is Hank!\n\/\/ 等待10秒..\nWake up after 10\nEat dinner~\n*\/\n\nLazyMan(“Hank”).eat(“dinner”).eat(“supper”)\n\/* 输出: \nHi This is Hank!\nEat dinner~\nEat supper~\n*\/\n\nLazyMan(“Hank”).sleepFirst(5).eat(“supper”)\n\/* 等待5秒，输出\nWake up after 5\nHi This is Hank!\nEat supper\n*\/\n\n\/\/ 以此类推。\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs stylus\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 实现一个LazyMan，可以按照以下方式调用:\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eLazyMan\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(“Hank”)\x3c\/span\x3e\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 输出: \nHi! This is Hank!\n*\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eLazyMan\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(“Hank”)\x3c\/span\x3e\x3c\/span\x3e.sleep(\x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e).eat(“dinner”)输出\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 输出: \nHi! This is Hank!\n\/\/ 等待10秒..\nWake up after 10\nEat dinner~\n*\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eLazyMan\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(“Hank”)\x3c\/span\x3e\x3c\/span\x3e.eat(“dinner”).eat(“supper”)\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 输出: \nHi This is Hank!\nEat dinner~\nEat supper~\n*\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-title\x22\x3eLazyMan\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e(“Hank”)\x3c\/span\x3e\x3c\/span\x3e.sleepFirst(\x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e).eat(“supper”)\n\x3cspan class=\x22hljs-comment\x22\x3e\/* 等待5秒，输出\nWake up after 5\nHi This is Hank!\nEat supper\n*\/\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 以此类推。\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eNode.js 中大名鼎鼎的\x3ccode\x3econnect\x3c\/code\x3e框架正是这样实现中间件队列的。有兴趣可以去看看它的\x3ca href=\x22https:\/\/github.com\/senchalabs\/connect\/blob\/master\/index.js\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e源码\x3c\/a\x3e或者这篇解读\x3ca href=\x22https:\/\/github.com\/alsotang\/node-lessons\/tree\/master\/lesson18\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e《何为 connect 中间件》\x3c\/a\x3e。\x3c\/p\x3e\n\x3cp\x3e细心的你可能看出来，这个\x3ccode\x3enext\x3c\/code\x3e暂时只能放在函数的末尾，如果放在中间，原来的问题还会出现：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function fn() {\n    console.log(1);\n    next();\n    console.log(2); \/\/ next()如果调用了异步函数，console.log(2)就会先执行\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs monkey\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efn\x3c\/span\x3e(\x3c\/span\x3e) {\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\n    \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e();\n    console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e); \/\/ \x3cspan class=\x22hljs-keyword\x22\x3enext\x3c\/span\x3e()如果调用了异步函数，console.\x3cspan class=\x22hljs-built_in\x22\x3elog\x3c\/span\x3e(\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e)就会先执行\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ca href=\x22http:\/\/redux.js.org\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eredux\x3c\/a\x3e 和\x3ca href=\x22http:\/\/koajs.com\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ekoa\x3c\/a\x3e 通过不同的实现，可以让\x3ccode\x3enext\x3c\/code\x3e放在函数中间，执行完后面的函数再折回来执行\x3ccode\x3enext\x3c\/code\x3e下面的代码，非常巧妙。有空再写写。\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>JavaScript 中如何实现函数队列？（一）</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000008320677">https://segmentfault.com/a/1190000008320677</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/ujljiit481c/" target="_blank">https://alili.tech/archive/ujljiit481c/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>