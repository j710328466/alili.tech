<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="使用CANVAS实现交互性圆形马赛克效果"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>使用CANVAS实现交互性圆形马赛克效果 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/uj12mb7thp/",
				"appid": "1613049289050283", 
				"title": "使用CANVAS实现交互性圆形马赛克效果 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-28T02:30:10"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/ja636h8hcxa/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/3vhoe2mo09k/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f&text=%e4%bd%bf%e7%94%a8CANVAS%e5%ae%9e%e7%8e%b0%e4%ba%a4%e4%ba%92%e6%80%a7%e5%9c%86%e5%bd%a2%e9%a9%ac%e8%b5%9b%e5%85%8b%e6%95%88%e6%9e%9c"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f&text=%e4%bd%bf%e7%94%a8CANVAS%e5%ae%9e%e7%8e%b0%e4%ba%a4%e4%ba%92%e6%80%a7%e5%9c%86%e5%bd%a2%e9%a9%ac%e8%b5%9b%e5%85%8b%e6%95%88%e6%9e%9c"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f&title=%e4%bd%bf%e7%94%a8CANVAS%e5%ae%9e%e7%8e%b0%e4%ba%a4%e4%ba%92%e6%80%a7%e5%9c%86%e5%bd%a2%e9%a9%ac%e8%b5%9b%e5%85%8b%e6%95%88%e6%9e%9c"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f&is_video=false&description=%e4%bd%bf%e7%94%a8CANVAS%e5%ae%9e%e7%8e%b0%e4%ba%a4%e4%ba%92%e6%80%a7%e5%9c%86%e5%bd%a2%e9%a9%ac%e8%b5%9b%e5%85%8b%e6%95%88%e6%9e%9c"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e4%bd%bf%e7%94%a8CANVAS%e5%ae%9e%e7%8e%b0%e4%ba%a4%e4%ba%92%e6%80%a7%e5%9c%86%e5%bd%a2%e9%a9%ac%e8%b5%9b%e5%85%8b%e6%95%88%e6%9e%9c&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f&title=%e4%bd%bf%e7%94%a8CANVAS%e5%ae%9e%e7%8e%b0%e4%ba%a4%e4%ba%92%e6%80%a7%e5%9c%86%e5%bd%a2%e9%a9%ac%e8%b5%9b%e5%85%8b%e6%95%88%e6%9e%9c"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f&title=%e4%bd%bf%e7%94%a8CANVAS%e5%ae%9e%e7%8e%b0%e4%ba%a4%e4%ba%92%e6%80%a7%e5%9c%86%e5%bd%a2%e9%a9%ac%e8%b5%9b%e5%85%8b%e6%95%88%e6%9e%9c"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f&title=%e4%bd%bf%e7%94%a8CANVAS%e5%ae%9e%e7%8e%b0%e4%ba%a4%e4%ba%92%e6%80%a7%e5%9c%86%e5%bd%a2%e9%a9%ac%e8%b5%9b%e5%85%8b%e6%95%88%e6%9e%9c"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2fuj12mb7thp%2f&title=%e4%bd%bf%e7%94%a8CANVAS%e5%ae%9e%e7%8e%b0%e4%ba%a4%e4%ba%92%e6%80%a7%e5%9c%86%e5%bd%a2%e9%a9%ac%e8%b5%9b%e5%85%8b%e6%95%88%e6%9e%9c"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">使用CANVAS实现交互性圆形马赛克效果</h1><div class="meta"><div class="postdate"><time datetime="2019-01-28" itemprop="datePublished">2019-01-28</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e在看D3.js的时候，无意间看到了一个\x3ca href=\x22http:\/\/bl.ocks.org\/nswamy14\/df13d67b6efeb19eb640\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e例子\x3c\/a\x3e，觉得很有趣，像是会分裂的圆形马赛克。看了下代码，使用svg完成的，但是具体实现方式使得在手机端无法把玩，于是就自己实现了一个canvas版本的。代码很简单，canvas初学者可以自己试试当做练笔，还是挺有趣的一个效果。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3eOnline Demo\x3c\/h2\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVHGaZ\x22 src=\x22https:\/\/static.alili.tech\/img\/bVHGaZ\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e\x3ca href=\x22https:\/\/jackgit.github.io\/circle-split\/index.html\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eonline demo\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e在demo中任意从本地选择一张图片，然后通过鼠标移动或者移动端touchmove就能实现圆形分裂的效果。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e使用\x3c\/h2\x3e\n\x3cp\x3e如果觉得用得着，你可以在自己的项目中安装使用这个效果。\x3ccode\x3enpm i circle-split -S\x3c\/code\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e难点\x3c\/h2\x3e\n\x3cp\x3e说是难点，其实根本不难。一开始看到的时候会好奇大大小小的圆形的颜色是怎么计算的，计算该面积下的平均值？其实很简单，就是从绘制了图片的canvas上获取圆心坐标在图片对应位置上的颜色值。这样的算法在圆形半径较大的时候，对被遮盖的图片区域颜色代表性其实不好，但是从整个分裂过程来看，这个取色方案的效果还不错。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e关键技术点\x3c\/h2\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3ecanvas绘图：\x3ca href=\x22https:\/\/developer.mozilla.org\/en\/docs\/Web\/API\/CanvasRenderingContext2D\/drawImage\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCanvasRenderingContext2D.drawImage()\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecanvas绘制圆形：\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/CanvasRenderingContext2D\/arc\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCanvasRenderingContext2D.arc()\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3ecanvas上取指定坐标上的颜色值：\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/API\/CanvasRenderingContext2D\/getImageData\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCanvasRenderingContext2D.getImageData()\x3c\/a\x3e\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e思路\x3c\/h2\x3e\n\x3col\x3e\n\x3cli\x3e\x3cp\x3e将图片绘制在一个offline（即不用挂在DOM树上）的canvas上，为了在指定位置获取颜色用\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e创建另一个canvas，用来绘制圆。两个canvas尺寸保持一致（而且都是方形），方便无需坐标转换获取颜色\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e绘制第一个圆形，以canvas中心为圆心，使用对应offline canvas坐标上的颜色填充\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e维持一个\x3ccode\x3ecircles\x3c\/code\x3e数组，代表所有的圆，每个元素有坐标（x, y），半径（r）和是否标记分裂（readyToSplit）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e需要一个渲染循环（rendering loop），不断的找出被标记需要分裂（readyToSplit）的圆，拿去做分裂绘制\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e事件处理：当mousemove或者touchmove发生在圆上时，该圆被标记\x3ccode\x3ereadyToSplit = true\x3c\/code\x3e，后面的则有渲染循环去处理\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ol\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e测试驱动\x3c\/h2\x3e\n\x3cp\x3e在我自己做这样的编程时，会以测试驱动的方式开始代码。因此会脑子里先写下自己的类将被如何使用，怎么样能够简单易用。\x3c\/p\x3e\n\x3cp\x3e我打算把这个效果封装成一个类，它将在使用时被实例化。最终的效果肯定是要在DOM树上显示的，所以这里在实例化时肯定需要指定一个mount节点，所有的事情在其内部进行。而且，按照通常的习惯，开放一些配置，使得使用者可以做一些简单的定制化。但是目前还没有想好哪些内部的配置拿出来比较合适，所以第二个参数\x3ccode\x3eoptions\x3c\/code\x3e可以后面再考虑。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var cs = new CircleSplit(\x27#mountNode\x27, options);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs haxe\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e cs = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-type\x22\x3eCircleSplit\x3c\/span\x3e(\x3cspan class=\x22hljs-string\x22\x3e\x27#mountNode\x27\x3c\/span\x3e, options);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e我希望能够动态的切换显示的图片内容，所以想提供一个\x3ccode\x3esetImage\x3c\/code\x3e的方法，它应该能接受图片路径，或者\x3ccode\x3eImage\x3c\/code\x3e元素对象。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22cs.setImage(image);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs abnf\x22\x3e\x3ccode style=\x22word-break: break-word; white-space: initial;\x22\x3ecs.setImage(image)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3eOK，这就是目前我希望的实例化方式，和想要提供的接口。后面再具体实现过程中，可以再继续添加或者修改。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e试想内部\x3c\/h2\x3e\n\x3cp\x3e结合前面谈到的实现思路，考虑\x3ccode\x3eCircleSplit\x3c\/code\x3e类里面该如果定义属性和私有共有方法。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e从构造函数入手\x3c\/strong\x3e。个人习惯在构造函数最后加上init方法，init方法里做一些准备工作，完成\x3ccode\x3esetImage\x3c\/code\x3e前的一些必要的事情。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function CircleSplit (el, options) {\n        ...\n        this._init();\n}\n\nCircleSplit.prototype._init = function () {\n    this._createSourceCanvas(); \/\/ 创建源canvas，用来绘制图片，作为offline canvas，提供坐标颜色使用\n    this._createTargetCanvas(); \/\/ 创建目标canvas，用来绘制看到的大大小小的圆\n    this._render(); \/\/ 开启渲染循环\n    this.bindEvent(); \/\/ 绑定事件，touchmove mousemove这些\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eCircleSplit\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eel, options\x3c\/span\x3e) \x3c\/span\x3e{\n        ...\n        \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._init();\n}\n\nCircleSplit.prototype._init = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._createSourceCanvas(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建源canvas，用来绘制图片，作为offline canvas，提供坐标颜色使用\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._createTargetCanvas(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 创建目标canvas，用来绘制看到的大大小小的圆\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._render(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 开启渲染循环\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.bindEvent(); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 绑定事件，touchmove mousemove这些\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这样我们一下子多了好几个函数，而且目的都很明确，因此可以很容易的判断需要那些实例属性和该如何实现各自函数体。这里可能需要多注意一下\x3ccode\x3e_render()\x3c\/code\x3e，思路中谈到在这里应该去绘制需要分裂的圆，那么大致应该像下面这样：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22CircleSplit.prototype._render = function () {\n    \/\/ 循环体\n    this.circles.forEach(function (circle) {\n        if (circle.readyToSplit) {\n            this._splitCircle(circle);\n            circle.readyToSplit = false;\n        }\n    }, this);\n    \n    \/\/ 下一个循环\n    requestAnimationFrame(this._render.bind(this));\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3eCircleSplit.prototype._render = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 循环体\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.circles.forEach(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e(circle)\x3c\/span\x3e \x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (circle.readyToSplit) {\n            \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._splitCircle(circle);\n            circle.readyToSplit = \x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e;\n        }\n    }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e);\n    \n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 下一个循环\x3c\/span\x3e\n    requestAnimationFrame(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._render.bind(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e));\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e而什么时候设置\x3ccode\x3ecircle.readyToSplit\x3c\/code\x3e呢？就是在\x3ccode\x3ebindEvent()\x3c\/code\x3e的事件处理函数里面。这里会通过\x3ccode\x3e_tagCircle()\x3c\/code\x3e遍历circles，找到能hit到事件坐标的一个圆，将其标记（tag）上readyToSplit。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e从共有方法入手\x3c\/strong\x3e。\x3ccode\x3esetImage\x3c\/code\x3e之后，相当于将整个CircleSplit中的状态都重置了下，\x3ccode\x3ecircles\x3c\/code\x3e数组得重置，两个canvas得重置等。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22CircleSplit.prototype.setImage = function (image) {\n    this._resetCanvas(this.sourceCanvas); \/\/ clear source canvas\n    this._drawSourceImage(image); \/\/ draw source canvas\n    this._resetCanvas(this.targetCanvas); \/\/ clear target canvas\n    this._drawCircle(x, y, r) \/\/ draw target canvas。绘制第一个，也是最大的一个圆形。圆心为canvas中心，半径为canvas的一半\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs kotlin\x22\x3e\x3ccode\x3eCircleSplit.prototype.setImage = function (image) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._resetCanvas(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sourceCanvas); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ clear source canvas\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._drawSourceImage(image); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ draw source canvas\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._resetCanvas(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.targetCanvas); \x3cspan class=\x22hljs-comment\x22\x3e\/\/ clear target canvas\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e._drawCircle(x, y, r) \x3cspan class=\x22hljs-comment\x22\x3e\/\/ draw target canvas。绘制第一个，也是最大的一个圆形。圆心为canvas中心，半径为canvas的一半\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3e_drawSourceImage()\x3c\/code\x3e里面就是调用了\x3ccode\x3eCanvasRenderingContext2D.drawImage()\x3c\/code\x3e进行图片绘制。这个API函数有3种传参形式，我这里选择了5参数的形式，使用了自己写的简易的居中库\x3ca href=\x22https:\/\/www.npmjs.com\/package\/center-it\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eCenterIt\x3c\/a\x3e，来解决图片居中绘制问题：无论图片尺寸，都可以轻易的居中覆盖填充（cover）或者居中包含（contain）填充。\x3c\/p\x3e\n\x3cp\x3e这里的\x3ccode\x3e_drawCircle(x, y, r)\x3c\/code\x3e应该能重用，后面每次圆形分裂的时候都能调用。初步给它3个参数，圆心坐标和半径。在其内部应该能够自己去获取坐标对应的颜色值。所以简单想象一下它的内部：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22CircleSplit.prototype._drawCircle = function (x, y, r) {\n    ...\n    context.fillStyle = this._getColor(x, y); \/\/ 获取坐标颜色\n  context.beginPath();\n  context.arc(x, y, r, 0, 2 * Math.PI);\n  context.closePath();\n  context.fill();\n    ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs mipsasm\x22\x3e\x3ccode\x3eCircleSplit.prototype._drawCircle = function (x, y, r) {\n    ...\n    \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e.fillStyle = this._getColor(x, y)\x3cspan class=\x22hljs-comment\x22\x3e; \/\/ 获取坐标颜色\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3ebeginPath();\n\x3c\/span\x3e  \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e.arc(x, y, r, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e * Math.PI)\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n  \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e.\x3cspan class=\x22hljs-keyword\x22\x3eclosePath();\n\x3c\/span\x3e  \x3cspan class=\x22hljs-built_in\x22\x3econtext\x3c\/span\x3e.fill()\x3cspan class=\x22hljs-comment\x22\x3e;\x3c\/span\x3e\n    ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e绘制圆时使用\x3ccode\x3eCanvasRenderingContext2D.arc()\x3c\/code\x3eAPI，使用起来不算简单明了，每次还需要begin和close Path。相比而下，一些canvas的游戏库或者图形库，则简单直观的多：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ create.js\nvar circle = new createjs.Shape();\ncircle.graphics.beginFill(\x26quot;DeepSkyBlue\x26quot;).drawCircle(0, 0, 50);\n\n\/\/ two.js\nvar circle = two.makeCircle(72, 100, 50);\ncircle.fill = \x27#FF8000\x27;\ncircle.stroke = \x27orangered\x27;\ncircle.linewidth = 5;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs arduino\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ create.js\x3c\/span\x3e\nvar \x3cspan class=\x22hljs-built_in\x22\x3ecircle\x3c\/span\x3e = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e createjs.Shape();\n\x3cspan class=\x22hljs-built_in\x22\x3ecircle\x3c\/span\x3e.graphics.beginFill(\x3cspan class=\x22hljs-string\x22\x3e\x22DeepSkyBlue\x22\x3c\/span\x3e).drawCircle(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e);\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ two.js\x3c\/span\x3e\nvar \x3cspan class=\x22hljs-built_in\x22\x3ecircle\x3c\/span\x3e = two.makeCircle(\x3cspan class=\x22hljs-number\x22\x3e72\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e100\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e50\x3c\/span\x3e);\n\x3cspan class=\x22hljs-built_in\x22\x3ecircle\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3efill\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27#FF8000\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3ecircle\x3c\/span\x3e.\x3cspan class=\x22hljs-built_in\x22\x3estroke\x3c\/span\x3e = \x3cspan class=\x22hljs-string\x22\x3e\x27orangered\x27\x3c\/span\x3e;\n\x3cspan class=\x22hljs-built_in\x22\x3ecircle\x3c\/span\x3e.linewidth = \x3cspan class=\x22hljs-number\x22\x3e5\x3c\/span\x3e;\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e因此，如果要做比较复杂的绘制操作，推荐找一个适合自己的canvas库，会使得工作变得容易的多。\x3c\/p\x3e\n\x3cp\x3e关于\x3ccode\x3e_getColor()\x3c\/code\x3e函数，这里使用了\x3ccode\x3eCanvasRenderingContext2D.getImageData()\x3c\/code\x3e：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22CircleSplit.prototype._getColor = function (x, y) {\n    ...\n    var pixelData = this.sourceCanvas.getContext(\x272d\x27).getImageData(parseInt(x), parseInt(y), 1, 1).data;\n  return \x27rgb(\x27 \x2b pixelData[0] \x2b \x27,\x27 \x2b pixelData[1] \x2b \x27,\x27 \x2b pixelData[2] \x2b \x27)\x27;\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs qml\x22\x3e\x3ccode\x3eCircleSplit.prototype._getColor = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3ex, y\x3c\/span\x3e) \x3c\/span\x3e{\n    ...\n    \x3cspan class=\x22hljs-built_in\x22\x3evar\x3c\/span\x3e pixelData = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sourceCanvas.getContext(\x3cspan class=\x22hljs-string\x22\x3e\x272d\x27\x3c\/span\x3e).getImageData(\x3cspan class=\x22hljs-built_in\x22\x3eparseInt\x3c\/span\x3e(x), \x3cspan class=\x22hljs-built_in\x22\x3eparseInt\x3c\/span\x3e(y), \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e).data;\n  \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-string\x22\x3e\x27rgb(\x27\x3c\/span\x3e \x2b pixelData[\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27,\x27\x3c\/span\x3e \x2b pixelData[\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27,\x27\x3c\/span\x3e \x2b pixelData[\x3cspan class=\x22hljs-number\x22\x3e2\x3c\/span\x3e] \x2b \x3cspan class=\x22hljs-string\x22\x3e\x27)\x27\x3c\/span\x3e;\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e如下图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1b5db3ehq1knbvs6knr1jfdal0m.jpeg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1b5db3ehq1knbvs6knr1jfdal0m.jpeg\x22 alt=\x22getImageData illustration\x22 title=\x22getImageData illustration\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e假设左上角起始点为(x, y)，一个方格为一个像素，那么\x3ccode\x3egetImageData(x, y, 1, 1).data\x3c\/code\x3e就会返回\x3ccode\x3e[255,0,0,255]\x3c\/code\x3e，代表Red=255，Alpha=255。如果\x3ccode\x3egetImageData(x, y, 2, 2).data\x3c\/code\x3e就会返回\x3ccode\x3e[255,0,0,255, 255,0,0,255, 255,0,0,255, 255,0,0,255]\x3c\/code\x3e 长度为16的数组，每4个为一组代表一个像素上的rgba值。\x3ccode\x3egetImageData()\x3c\/code\x3e就是一个能帮助我们对canvas进行像素级别操作的API函数。\x3c\/p\x3e\n\x3cp\x3e一些基于canvas的“刮刮卡”插件，也是\x3ccode\x3egetImageData()\x3c\/code\x3e的应用：在图片上绝对定位一个灰色的canvas，代表刮刮卡蒙层；通过对手指触摸的像素点的alpha值进行修改来实现被“刮“开的效果。当然这里的修改需要使用到配套的\x3ccode\x3eputImageData()\x3c\/code\x3e函数；同时对整个canvas像素中alpha值为0的像素点的百分比 进行统计，可以完成刮开了80%就展示全部图片的效果。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e实现\x3c\/h2\x3e\n\x3cp\x3e上面是大致的实现思路，和编码的思想过程。为了表达出我自己在完成一个功能的时候，是如何从无到有，定义属性，定义API的。只是自己的一点经验，希望有帮助。\x3c\/p\x3e\n\x3cp\x3e如果你对这些知识不熟悉，却也感兴趣的话，可以参考该\x3ca href=\x22https:\/\/github.com\/JackGit\/circle-split\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3egithub项目代码\x3c\/a\x3e\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e问题与优化\x3c\/h2\x3e\n\x3cp\x3egithub上的代码与上面讲的思路一致，但是会有些不一样，主要是在功能实现之后，发现了一个需要优化的地方。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e渲染速度\x3c\/strong\x3e 在\x3ccode\x3e_render()\x3c\/code\x3e渲染循环中，我们对所有的circles进行遍历。但是当整副图片分裂次数很彻底时，会有上万个圆，会导致每个渲染循环里的计算时间过长，导致下一个渲染循环在理想的时间后才执行，从而导致了卡顿的感觉。于是为了解决这个问题，引入了\x3ccode\x3erenderingCircles\x3c\/code\x3e数组，将被标记的circle全部插入这个数组中，渲染循环中只关心这里的值，用额外的存储空间换更短的计算时间。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e显示模糊\x3c\/strong\x3e 最先的实现中，两个canvas得尺寸是根据mountNode决定的，\x3ccode\x3ecanvas.width\x3c\/code\x3e \x3ccode\x3ecanvas.height\x3c\/code\x3e被设为和mountNode一样的维度值。于是在一些设备上显示出明显的边缘锯齿。这里的解决方案就是设置canvas的宽和高为两倍于mountNode的宽高，然后通过style去设置canvas显示成和mountNode一样的尺寸。这里就是canvas的自身的宽高属性和canvas style的宽高之前的区别的理解和应用。\x3c\/p\x3e\n\x3cp\x3e\x3cstrong\x3e图片跨域问题\x3c\/strong\x3e 在canvas操作图片时，可能会碰到这样的错误信息：Unable to get image data from canvas because the canvas has been tainted by cross-origin data.\x3c\/p\x3e\n\x3cp\x3e关于这个的\x3ca href=\x22https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/HTML\/CORS_enabled_image\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e官方解释\x3c\/a\x3e是：\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e在canvas上可以绘制没有跨域许可的图片资源（images without CORS approval），但是这样做会“感染（taints）”的canvas，而在感染的（tainted）canvas上调用\x3ccode\x3etoBlog()\x3c\/code\x3e，\x3ccode\x3etoDataURL()\x3c\/code\x3e，\x3ccode\x3egetImageData()\x3c\/code\x3e会抛出上面的安全方面的错误。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e在\x3ccode\x3eCircleSplit.setImage(imageUrl)\x3c\/code\x3e时，可能就会碰到这个问题。\x3cbr\x3e解决方案，首先需要图片有跨域许可。这个需要在提供图片服务的server上进行配置。这里不多介绍，有跨域许可的图片被加载时，在控制台上应该能看到：（这里我使用的七牛的图片）\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1b5dd4jcm1migj6asdc1cq11jqp10.jpeg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/ofkyhrvda.bkt.clouddn.com\/post\/image\/o_1b5dd4jcm1migj6asdc1cq11jqp10.jpeg\x22 alt=\x22access-control-allow-origin\x22 title=\x22access-control-allow-origin\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e其次，需要在加载图片时，设置crossOrigin属性：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var image = new Image();\nimage.crossOrigin = \x27anonymous\x27;\nimage.onload = function () {};\nimage.src = imageUrl;\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs actionscript\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e image = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Image();\nimage.crossOrigin = \x3cspan class=\x22hljs-string\x22\x3e\x27anonymous\x27\x3c\/span\x3e;\nimage.onload = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e \x3c\/span\x3e{};\nimage.src = imageUrl;\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader9\x22\x3e应用\x3c\/h2\x3e\n\x3cp\x3e其实个人很喜欢最后完成的交互效果（有点强迫症，喜欢不断的戳掉泡泡），于是将这个小效果做了一个简单的H5页面，在年底这个时间点里，讲述和回顾在2016年的大事件。你也可以来体验下：\x3ca href=\x22https:\/\/jackyang-me.github.io\/2016-recap.jackyang.me\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e2016-recap\x3c\/a\x3e\x3c\/p\x3e\n\x3cp\x3e原文地址：\x3ca href=\x22http:\/\/blog.jackyang.me\/blog\/index.html#\/post\/5863182161ff4b006cf3f5f5\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttp:\/\/blog.jackyang.me\/blog\/...\x3c\/a\x3e\x3c\/p\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>使用CANVAS实现交互性圆形马赛克效果</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007983811">https://segmentfault.com/a/1190000007983811</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/uj12mb7thp/" target="_blank">https://alili.tech/archive/uj12mb7thp/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>