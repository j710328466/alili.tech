<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="Vue 2.0源码学习"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>Vue 2.0源码学习 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/3v2of4ensgc/",
				"appid": "1613049289050283", 
				"title": "Vue 2.0源码学习 | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-31T02:31:16"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/rfe7raqg58o/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/672s4hjh70k/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f&text=Vue%202.0%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f&text=Vue%202.0%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f&title=Vue%202.0%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f&is_video=false&description=Vue%202.0%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=Vue%202.0%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f&title=Vue%202.0%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f&title=Vue%202.0%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f&title=Vue%202.0%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f3v2of4ensgc%2f&title=Vue%202.0%e6%ba%90%e7%a0%81%e5%ad%a6%e4%b9%a0"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">Vue 2.0源码学习</h1><div class="meta"><div class="postdate"><time datetime="2019-01-31" itemprop="datePublished">2019-01-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3ch1 id=\x22articleHeader0\x22\x3eVue2.0介绍\x3c\/h1\x3e\n\x3cp\x3e从去年9月份了解到Vue后，就被他简洁的API所吸引。1.0版本正式发布后，就在业务中开始使用，将原先jQuery的功能逐步的进行迁移。   \x3cbr\x3e今年的10月1日，Vue的2.0版本正式发布了，其中核心代码都进行了重写，于是就专门花时间，对Vue 2.0的源码进行了学习。本篇文章就是2.0源码学习的总结。    \x3c\/p\x3e\n\x3cp\x3e先对Vue 2.0的新特性做一个简单的介绍：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3e大小 \x26amp; 性能\x3c\/strong\x3e。Vue 2.0的线上包gzip后只有12Kb，而1.0需要22Kb，react需要44Kb。而且，Vue 2.0的性能在react等几个框架中，性能是最快的。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eVDOM\x3c\/strong\x3e。实现了Virtual DOM, 并且将静态子树进行了提取，减少界面重绘时的对比。与1.0对比性能有明显提升。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3etemplate \x26amp; JSX\x3c\/strong\x3e。众所周知，Vue 1.0使用的是template来实现模板，而React使用了JSX实现模板。关于template和JSX的争论也很多，很多人不使用React就是因为没有支持template写法。Vue 2.0对template和JSX写法都做了支持。使用时，可以根据具体业务细节进行选择，可以很好的发挥两者的优势。就这一点，Vue已经超过React了。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eServer Render\x3c\/strong\x3e。2.0还对了Server Render做了支持。这一点并没有在业务中使用，不做评价。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3eVue的最新源码可以去 \x3ca href=\x22https:\/\/github.com\/vuejs\/vue\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/vuejs\/vue\x3c\/a\x3e 获得。本文讲的是 2.0.3版本，2.0.3可以去 \x3ca href=\x22https:\/\/github.com\/vuejs\/vue\/tree\/v2.0.3\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3ehttps:\/\/github.com\/vuejs\/vue\/...\x3c\/a\x3e 这里获得。   \x3c\/p\x3e\n\x3cp\x3e下面开始进入正题。首先从生命周期开始。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader1\x22\x3e生命周期\x3c\/h1\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22\/img\/bVEs9r\x22 src=\x22https:\/\/static.alili.tech\/img\/bVEs9r\x22 alt=\x22图片描述\x22 title=\x22图片描述\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e上图就是官方给出的Vue 2.0的生命周期图，其中包含了Vue对象生命周期过程中的几个核心步骤。了解了这几个过程，可以很好的帮助我们理解Vue的创建与销毁过程。\x3cbr\x3e从图中我们可以看出，生命周期主要分为4个过程：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3ecreate\x3c\/strong\x3e。\x3ccode\x3enew Vue\x3c\/code\x3e时，会先进行create，创建出Vue对象。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3emount\x3c\/strong\x3e。根据el, template, render方法等属性，会生成DOM，并添加到对应位置。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eupdate\x3c\/strong\x3e。当数据发生变化后，会重新渲染DOM，并进行替换。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3edestory\x3c\/strong\x3e。销毁时运行。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e那么这4个过程在源码中是怎么实现的呢？我们从\x3ccode\x3enew Vue\x3c\/code\x3e开始。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader2\x22\x3enew Vue\x3c\/h1\x3e\n\x3cp\x3e为了更好的理解new的过程，我整理了一个序列图：    \x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/img.alicdn.com\/tps\/TB1KBdBOXXXXXcFXFXXXXXXXXXX-559-668.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/img.alicdn.com\/tps\/TB1KBdBOXXXXXcFXFXXXXXXXXXX-559-668.jpg\x22 alt=\x22new Vue序列图\x22 title=\x22new Vue序列图\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3enew Vue的过程主要涉及到三个对象：vm、compiler、watcher。其中，vm表示Vue的具体对象；compiler负责将template解析为AST render方法；watcher用于观察数据变化，以实现数据变化后进行re-render。    \x3c\/p\x3e\n\x3cp\x3e下面来分析下具体的过程和代码：   \x3cbr\x3e首先，运行\x3ccode\x3enew Vue()\x3c\/code\x3e的时候，会进入代码\x3ccode\x3esrc\/core\/instance\/index.js\x3c\/code\x3e的Vue构造方法中，并执行\x3ccode\x3ethis._init()\x3c\/code\x3e方法。在\x3ccode\x3e_init\x3c\/code\x3e中，会对各个功能进行初始化，并执行\x3ccode\x3ebeforeCreate\x3c\/code\x3e和\x3ccode\x3ecreated\x3c\/code\x3e两个生命周期方法。核心代码如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22initLifecycle(vm)\ninitEvents(vm)\ncallHook(vm, \x27beforeCreate\x27)\ninitState(vm)\ncallHook(vm, \x27created\x27)\ninitRender(vm)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3einitLifecycle(vm)\ninitEvents(vm)\ncallHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27beforeCreate\x27\x3c\/span\x3e)\ninitState(vm)\ncallHook(vm, \x3cspan class=\x22hljs-string\x22\x3e\x27created\x27\x3c\/span\x3e)\ninitRender(vm)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e这个过程有一点需要注意：   \x3cbr\x3ebeforeCreate和created之间只有initState，和官方给出的生命周期图并不完全一样。这里的initState是用于初始化data,props等的监听的。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e在\x3ccode\x3e_init\x3c\/code\x3e的最后，会运行\x3ccode\x3einitRender\x3c\/code\x3e方法。在该方法中，会运行\x3ccode\x3evm.$mount\x3c\/code\x3e方法，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (vm.$options.el) {\n  vm.$mount(vm.$options.el)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (vm.$options.el) {\n  vm.$mount(vm.$options.el)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e这里的\x3ccode\x3evm.$mount\x3c\/code\x3e可以在业务代码中调用，这样，new 过程和 mount过程就可以根据业务情况进行分离。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e这里的\x3ccode\x3e$mount\x3c\/code\x3e在\x3ccode\x3esrc\/entries\/web-runtime-with-compiler.js\x3c\/code\x3e中，主要逻辑是根据el, template, render三个属性来获得AST render方法。代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22if (!options.render) {   \/\/ 如果有render方法，直接运行mount\n  let template = options.template\n  if (template) {  \/\/ 如果有template， 获取template参数对于的HTML作为模板\n    if (typeof template === \x27string\x27) {\n      if (template.charAt(0) === \x27#\x27) {\n        template = idToTemplate(template)\n      }\n    } else if (template.nodeType) {\n      template = template.innerHTML\n    } else {\n      if (process.env.NODE_ENV !== \x27production\x27) {\n        warn(\x27invalid template option:\x27 \x2b template, this)\n      }\n      return this\n    }\n  } else if (el) {  \/\/ 如果没有template, 且存在el，则获取el的outerHTML作为模板\n    template = getOuterHTML(el)\n  }\n  if (template) { \/\/ 如果获取到了模板，则将模板转化为render方法\n    const { render, staticRenderFns } = compileToFunctions(template, {\n      warn,\n      shouldDecodeNewlines,\n      delimiters: options.delimiters\n    }, this)\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n  }\n}\nreturn mount.call(this, el, hydrating)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!options.render) {   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果有render方法，直接运行mount\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e template = options.template\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (template) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果有template， 获取template参数对于的HTML作为模板\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e template === \x3cspan class=\x22hljs-string\x22\x3e\x27string\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (template.charAt(\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e) === \x3cspan class=\x22hljs-string\x22\x3e\x27#\x27\x3c\/span\x3e) {\n        template = idToTemplate(template)\n      }\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (template.nodeType) {\n      template = template.innerHTML\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (process.env.NODE_ENV !== \x3cspan class=\x22hljs-string\x22\x3e\x27production\x27\x3c\/span\x3e) {\n        warn(\x3cspan class=\x22hljs-string\x22\x3e\x27invalid template option:\x27\x3c\/span\x3e \x2b template, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n      }\n      \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (el) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果没有template, 且存在el，则获取el的outerHTML作为模板\x3c\/span\x3e\n    template = getOuterHTML(el)\n  }\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (template) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果获取到了模板，则将模板转化为render方法\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e { render, staticRenderFns } = compileToFunctions(template, {\n      warn,\n      shouldDecodeNewlines,\n      \x3cspan class=\x22hljs-attr\x22\x3edelimiters\x3c\/span\x3e: options.delimiters\n    }, \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n  }\n}\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e mount.call(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e, el, hydrating)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e这个过程有三点需要注意：   \x3cbr\x3ecompile时，将最大静态子树提取出来作为单独的AST渲染方法，以提升后面vNode对比时的性能。所以，当存在多个连续的静态标签时，可以在外边添加一个静态父节点，这样，staticRenderFns数目可以减少，从而提升性能。   \x3cbr\x3eVue 2.0中的模板有三种引用写法：el, template, render(JSX)。其中的优先级是render \x26gt; template \x26gt; el。   \x3cbr\x3eel, template两种写法，最后都会通过compiler转化为render(JSX)来运行，也就是说，直接写成render(JSX)是性能最优的。当然，如果使用了构建工具，最终生成的包就是使用的render(JSX)。这样子，在源码上就可以不用过多考虑这一块的性能了，直接用可维护性最好的方式就行。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e将模板转化为render，用到了\x3ccode\x3ecompileToFunctions方法\x3c\/code\x3e，该方法最后会通过\x3ccode\x3esrc\/compiler\/index.js\x3c\/code\x3e文件中的\x3ccode\x3ecompile\x3c\/code\x3e方法，将模板转化为AST语法结构的render方法，并对静态子树进行分离。   \x3c\/p\x3e\n\x3cp\x3e完成render方法的生成后，会进入\x3ccode\x3e_mount\x3c\/code\x3e（src\/core\/instance.lifecycle.js）中进行DOM更新。该方法的核心逻辑如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22vm._watcher = new Watcher(vm, () =\x3e {\n  vm._update(vm._render(), hydrating)\n}, noop)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3evm._watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(vm, () =\x26gt; {\n  vm._update(vm._render(), hydrating)\n}, noop)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首先会new一个watcher对象，在watcher对象创建后，会运行传入的方法\x3ccode\x3evm._update(vm._render(), hydrating)\x3c\/code\x3e（watcher的逻辑在下面的watcher小节中细讲）。其中的\x3ccode\x3evm._render()\x3c\/code\x3e主要作用就是运行前面compiler生成的render方法，并返回一个vNode对象。这里的vNode就是一个虚拟的DOM节点。\x3c\/p\x3e\n\x3cp\x3e拿到vNode后，传入\x3ccode\x3evm._update()\x3c\/code\x3e方法，进行DOM更新。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader3\x22\x3eVDOM\x3c\/h1\x3e\n\x3cp\x3e上面已经讲完了\x3ccode\x3enew Vue\x3c\/code\x3e过程中的主要步骤，其中涉及到template如何转化为DOM的过程，这里单独拿出来讲下。先上序列图：\x3c\/p\x3e\n\x3cp\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/img.alicdn.com\/tps\/TB1XVxdOXXXXXXsaFXXXXXXXXXX-630-646.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/img.alicdn.com\/tps\/TB1XVxdOXXXXXXsaFXXXXXXXXXX-630-646.jpg\x22 alt=\x22virtual DOM\x22 title=\x22virtual DOM\x22 style=\x22cursor: pointer;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e从图中可以看出，从template到DOM，有三个过程：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3etemplate -\x26gt; AST render\x3c\/strong\x3e （compiler解析template）\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3eAST render -\x26gt; vNode\x3c\/strong\x3e (render方法运行)\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3cstrong\x3evNode -\x26gt; DOM\x3c\/strong\x3e (vdom.patch)\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e首先是template在compiler中解析为AST render方法的过程。上一节中有说到，\x3ccode\x3einitRender\x3c\/code\x3e后，会调用到\x3ccode\x3esrc\/entries\/web-runtime-with-compiler.js\x3c\/code\x3e中的\x3ccode\x3eVue.prototype.$mount\x3c\/code\x3e方法。在\x3ccode\x3e$mount\x3c\/code\x3e中，会获取template，然后调用\x3ccode\x3esrc\/platforms\/web\/compiler\/index.js\x3c\/code\x3e的\x3ccode\x3ecompileToFunctions\x3c\/code\x3e方法。在该方法中，会运行\x3ccode\x3ecompile\x3c\/code\x3e将template解析为多个render方法，也就是AST render。这里的\x3ccode\x3ecompile\x3c\/code\x3e在文件\x3ccode\x3esrc\/compiler\/index.js\x3c\/code\x3e中，代码如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22const ast = parse(template.trim(), options)   \/\/ 解析template为AST\noptimize(ast, options)  \/\/ 提取static tree\nconst code = generate(ast, options)  \/\/ 生成render 方法\nreturn {\n  ast,\n  render: code.render,\n  staticRenderFns: code.staticRenderFns\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ast = parse(template.trim(), options)   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 解析template为AST\x3c\/span\x3e\noptimize(ast, options)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 提取static tree\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e code = generate(ast, options)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 生成render 方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n  ast,\n  \x3cspan class=\x22hljs-attr\x22\x3erender\x3c\/span\x3e: code.render,\n  \x3cspan class=\x22hljs-attr\x22\x3estaticRenderFns\x3c\/span\x3e: code.staticRenderFns\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看出，\x3ccode\x3ecompile\x3c\/code\x3e方法就是将template以AST的方式进行解析，并转化为render方法进行返回。\x3c\/p\x3e\n\x3cp\x3e再看第二个过程：AST render -\x26gt; vNode。这个过程很简单，就是将AST render方法进行运行，获得返回的vNode对象。   \x3c\/p\x3e\n\x3cp\x3e最后一步，vNode -\x26gt; DOM。该过程中，存在vNode的对比以及DOM的添加修改操作。   \x3cbr\x3e在上一节中，有讲到\x3ccode\x3evm._update()\x3c\/code\x3e方法中对DOM进行更新。\x3ccode\x3e_update\x3c\/code\x3e的主要代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/ src\/core\/instance\/lifecycle.js\nif (!prevVnode) {\n  \/\/ Vue.prototype.__patch__ is injected in entry points\n  \/\/ based on the rendering backend used.\n  vm.$el = vm.__patch__(vm.$el, vnode, hydrating)  \/\/ 首次添加\n} else {\n  vm.$el = vm.__patch__(prevVnode, vnode)  \/\/ 数据变化后触发的DOM更新\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/ src\/core\/instance\/lifecycle.js\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!prevVnode) {\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vue.prototype.__patch__ is injected in entry points\x3c\/span\x3e\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ based on the rendering backend used.\x3c\/span\x3e\n  vm.$el = vm.__patch__(vm.$el, vnode, hydrating)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 首次添加\x3c\/span\x3e\n} \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n  vm.$el = vm.__patch__(prevVnode, vnode)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 数据变化后触发的DOM更新\x3c\/span\x3e\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看出，无论是首次添加还是后期的update，都是通过\x3ccode\x3e__patch__\x3c\/code\x3e来更新的。这里的\x3ccode\x3e__patch__\x3c\/code\x3e核心步骤是在\x3ccode\x3esrc\/core\/vdom\/patch.js\x3c\/code\x3e中的\x3ccode\x3epatch\x3c\/code\x3e方法进行实现，源码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (!oldVnode) {\n      ...\n    } else {\n      ...\n      if (!isRealElement \x26amp;\x26amp; sameVnode(oldVnode, vnode)) {\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)  \/\/ diff并更新DOM。\n      } else {\n        elm = oldVnode.elm\n        parent = nodeOps.parentNode(elm)\n        ...\n        if (parent !== null) {\n          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm))  \/\/ 添加element到DOM。\n          removeVnodes(parent, [oldVnode], 0, 0)\n        }\n        ...\n      }\n    }\n    ...\n  }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epatch\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode, hydrating, removeOnly\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (!oldVnode) {\n      ...\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      ...\n      if (!isRealElement \x26amp;\x26amp; sameVnode(oldVnode, vnode)) {\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ diff并更新DOM。\x3c\/span\x3e\n      } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n        elm = oldVnode.elm\n        parent = nodeOps.parentNode(elm)\n        ...\n        if (parent !== \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e) {\n          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm))  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 添加element到DOM。\x3c\/span\x3e\n          removeVnodes(parent, [oldVnode], \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e)\n        }\n        ...\n      }\n    }\n    ...\n  }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e首次添加很简单，就是通过insertBefore将转化好的element添加到DOM中。如果是update，则会调动\x3ccode\x3epatchVnode()\x3c\/code\x3e。最后来看下\x3ccode\x3epatchVnode\x3c\/code\x3e的代码：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n  ...\n  const elm = vnode.elm = oldVnode.elm\n  const oldCh = oldVnode.children\n  const ch = vnode.children\n  ...\n  if (isUndef(vnode.text)) {\n    if (isDef(oldCh) \x26amp;\x26amp; isDef(ch)) {  \/\/ 当都存在时，更新Children\n      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    } else if (isDef(ch)) {  \/\/ 只存在新节点时，即添加节点\n      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, \x27\x27)\n      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)\n    } else if (isDef(oldCh)) {  \/\/ 只存在老节点时，即删除节点\n      removeVnodes(elm, oldCh, 0, oldCh.length - 1)\n    } else if (isDef(oldVnode.text)) {  \/\/ 删除了textContent\n      nodeOps.setTextContent(elm, \x27\x27)\n    }\n  } else if (oldVnode.text !== vnode.text) { \/\/ 修改了textContent\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3epatchVnode\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eoldVnode, vnode, insertedVnodeQueue, removeOnly\x3c\/span\x3e) \x3c\/span\x3e{\n  ...\n  const elm = vnode.elm = oldVnode.elm\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e oldCh = oldVnode.children\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e ch = vnode.children\n  ...\n  if (isUndef(vnode.text)) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldCh) \x26amp;\x26amp; isDef(ch)) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 当都存在时，更新Children\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(ch)) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只存在新节点时，即添加节点\x3c\/span\x3e\n      \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldVnode.text)) nodeOps.setTextContent(elm, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)\n      addVnodes(elm, \x3cspan class=\x22hljs-literal\x22\x3enull\x3c\/span\x3e, ch, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, ch.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e, insertedVnodeQueue)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldCh)) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只存在老节点时，即删除节点\x3c\/span\x3e\n      removeVnodes(elm, oldCh, \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e, oldCh.length - \x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isDef(oldVnode.text)) {  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 删除了textContent\x3c\/span\x3e\n      nodeOps.setTextContent(elm, \x3cspan class=\x22hljs-string\x22\x3e\x27\x27\x3c\/span\x3e)\n    }\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (oldVnode.text !== vnode.text) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 修改了textContent\x3c\/span\x3e\n    nodeOps.setTextContent(elm, vnode.text)\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e其中有调用了\x3ccode\x3eupdateChildren\x3c\/code\x3e来更新子节点，代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n  ...\n  while (oldStartIdx \x3c= oldEndIdx \x26amp;\x26amp; newStartIdx \x3c= newEndIdx) {\n    if (isUndef(oldStartVnode)) {\n      oldStartVnode = oldCh[\x2b\x2boldStartIdx] \/\/ Vnode has been moved left\n    } else if (isUndef(oldEndVnode)) {\n      oldEndVnode = oldCh[--oldEndIdx]\n    } else if (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n      oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n      newStartVnode = newCh[\x2b\x2bnewStartIdx]\n    } else if (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldStartVnode, newEndVnode)) { \/\/ Vnode moved right\n      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n      canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n      oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } else if (sameVnode(oldEndVnode, newStartVnode)) { \/\/ Vnode moved left\n      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n      canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[\x2b\x2bnewStartIdx]\n    } else {\n      ...\n    }\n  }\n  ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eupdateChildren\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3eparentElm, oldCh, newCh, insertedVnodeQueue, removeOnly\x3c\/span\x3e) \x3c\/span\x3e{\n  ...\n  while (oldStartIdx \x26lt;= oldEndIdx \x26amp;\x26amp; newStartIdx \x26lt;= newEndIdx) {\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldStartVnode)) {\n      oldStartVnode = oldCh[\x2b\x2boldStartIdx] \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode has been moved left\x3c\/span\x3e\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (isUndef(oldEndVnode)) {\n      oldEndVnode = oldCh[--oldEndIdx]\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newStartVnode)) {\n      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)\n      oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n      newStartVnode = newCh[\x2b\x2bnewStartIdx]\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newEndVnode)) {\n      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldStartVnode, newEndVnode)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode moved right\x3c\/span\x3e\n      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)\n      canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))\n      oldStartVnode = oldCh[\x2b\x2boldStartIdx]\n      newEndVnode = newCh[--newEndIdx]\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (sameVnode(oldEndVnode, newStartVnode)) { \x3cspan class=\x22hljs-comment\x22\x3e\/\/ Vnode moved left\x3c\/span\x3e\n      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)\n      canMove \x26amp;\x26amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)\n      oldEndVnode = oldCh[--oldEndIdx]\n      newStartVnode = newCh[\x2b\x2bnewStartIdx]\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      ...\n    }\n  }\n  ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看到\x3ccode\x3eupdateChildren\x3c\/code\x3e中，又通过\x3ccode\x3epatchVnode\x3c\/code\x3e来更新当前节点。梳理一下，\x3ccode\x3epatch\x3c\/code\x3e通过\x3ccode\x3epatchVnode\x3c\/code\x3e来更新根节点，然后通过\x3ccode\x3eupdateChildren\x3c\/code\x3e来更新子节点，具体子节点，又通过\x3ccode\x3epatchVnode\x3c\/code\x3e来更新，通过一个类似于递归的方式逐个节点的完成对比和更新。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3eVue 2.0中对如何去实现VDOM的思路是否清晰，通过4层结构，很好的实现了可维护性，也为实现server render, weex等功能提供了可能。拿server render举例，只需要将最后的\x3ccode\x3evNode -\x26gt; DOM\x3c\/code\x3e 改成 \x3ccode\x3evNode -\x26gt; String\x3c\/code\x3e 或者 \x3ccode\x3evNode -\x26gt; Stream\x3c\/code\x3e， 就可以实现server render。剩下的compiler和Vue的核心逻辑都不需要改。\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch1 id=\x22articleHeader4\x22\x3eWatcher\x3c\/h1\x3e\n\x3cp\x3e我们都知道MVVM框架的特征就是当数据发生变化后，会自动更新对应的DOM节点。使用MVVM之后，业务代码中就可以完全不写DOM操作代码，不仅可以将业务代码聚焦在业务逻辑上，还可以提高业务代码的可维护性和可测试性。那么Vue 2.0中是怎么实现对数据变化的监听的呢？照例，先看序列图：\x3cbr\x3e\x3cspan class=\x22img-wrap\x22\x3e\x3cimg data-src=\x22http:\/\/img.alicdn.com\/tps\/TB1oYxwOXXXXXbvXFXXXXXXXXXX-659-737.jpg\x22 src=\x22https:\/\/static.alili.techhttp:\/\/img.alicdn.com\/tps\/TB1oYxwOXXXXXbvXFXXXXXXXXXX-659-737.jpg\x22 alt=\x22watcher\x22 title=\x22watcher\x22 style=\x22cursor: pointer; display: inline;\x22\x3e\x3c\/span\x3e\x3c\/p\x3e\n\x3cp\x3e可以看出，整个Watcher的过程可以分为三个过程。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e对state设置setter\/getter\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e对vm设置好Watcher，添加好state 触发 setter时的执行方法\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3estate变化触发执行\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cp\x3e前面有说过，在生命周期函数\x3ccode\x3ebeforeCreate\x3c\/code\x3e和\x3ccode\x3ecreated\x3c\/code\x3e直接，会运行方法\x3ccode\x3einitState()\x3c\/code\x3e。在\x3ccode\x3einitState\x3c\/code\x3e中，会对Props, Data, Computed等属性添加Setter\/Getter。拿Data举例，设置setter\/getter的代码如下：\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22function initData (vm: Component) {\n  let data = vm.$options.data\n  ...\n  \/\/ proxy data on instance\n  const keys = Object.keys(data)\n  let i = keys.length\n  while (i--) {\n    ...\n    proxy(vm, keys[i])   \/\/ 设置vm._data为代理\n  }\n  \/\/ observe data\n  observe(data)\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3einitData\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3evm: Component\x3c\/span\x3e) \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e data = vm.$options.data\n  ...\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ proxy data on instance\x3c\/span\x3e\n  \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e keys = \x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.keys(data)\n  \x3cspan class=\x22hljs-keyword\x22\x3elet\x3c\/span\x3e i = keys.length\n  \x3cspan class=\x22hljs-keyword\x22\x3ewhile\x3c\/span\x3e (i--) {\n    ...\n    proxy(vm, keys[i])   \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 设置vm._data为代理\x3c\/span\x3e\n  }\n  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ observe data\x3c\/span\x3e\n  observe(data)\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e通过调用\x3ccode\x3eobserve\x3c\/code\x3e方法，会对data添加好观察者，核心代码为:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22Object.defineProperty(obj, key, {\n  enumerable: true,\n  configurable: true,\n  get: function reactiveGetter () {\n    const value = getter ? getter.call(obj) : val\n    if (Dep.target) {\n      dep.depend()  \/\/ 处理好依赖watcher\n      ...\n    }\n    return value\n  },\n  set: function reactiveSetter (newVal) {\n    ...\n    childOb = observe(newVal)  \/\/ 对新数据重新observe\n    dep.notify()  \/\/ 通知到dep进行数据更新\n  }\n})\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-built_in\x22\x3eObject\x3c\/span\x3e.defineProperty(obj, key, {\n  \x3cspan class=\x22hljs-attr\x22\x3eenumerable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3econfigurable\x3c\/span\x3e: \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e,\n  \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveGetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = getter ? getter.call(obj) : val\n    \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (Dep.target) {\n      dep.depend()  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 处理好依赖watcher\x3c\/span\x3e\n      ...\n    }\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e value\n  },\n  \x3cspan class=\x22hljs-attr\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3ereactiveSetter\x3c\/span\x3e (\x3cspan class=\x22hljs-params\x22\x3enewVal\x3c\/span\x3e) \x3c\/span\x3e{\n    ...\n    childOb = observe(newVal)  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 对新数据重新observe\x3c\/span\x3e\n    dep.notify()  \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 通知到dep进行数据更新\x3c\/span\x3e\n  }\n})\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e这个时候，对data的监听已经完成。可以看到，当data发生变化的时候，会运行\x3ccode\x3edep.notify()\x3c\/code\x3e。在\x3ccode\x3enotify\x3c\/code\x3e方法中，会去运行watcher的\x3ccode\x3eupdate\x3c\/code\x3e方法，内容如下:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22update () {\n  if (this.lazy) {\n    this.dirty = true\n  } else if (this.sync) {\n    this.run()\n  } else {\n    queueWatcher(this)\n  }\n}\nrun () {\n  if (this.active) {\n    const value = this.get()\n  }\n  ...\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3eupdate () {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.dirty = \x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.sync) {\n    \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.run()\n  } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n    queueWatcher(\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e)\n  }\n}\nrun () {\n  \x3cspan class=\x22hljs-keyword\x22\x3eif\x3c\/span\x3e (\x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.active) {\n    \x3cspan class=\x22hljs-keyword\x22\x3econst\x3c\/span\x3e value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\n  }\n  ...\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e\x3ccode\x3eupdate\x3c\/code\x3e方法中，queueWatcher方法的目的是通过\x3ccode\x3enextTicker\x3c\/code\x3e来执行\x3ccode\x3erun\x3c\/code\x3e方法，属于支线逻辑，就不分析了，这里直接看\x3ccode\x3erun\x3c\/code\x3e的实现。\x3ccode\x3erun\x3c\/code\x3e方法其实很简单，就是调用\x3ccode\x3eget\x3c\/code\x3e方法，而\x3ccode\x3eget\x3c\/code\x3e方法会通过执行\x3ccode\x3ethis.getter()\x3c\/code\x3e来更新DOM。   \x3c\/p\x3e\n\x3cp\x3e那么\x3ccode\x3ethis.getter\x3c\/code\x3e是什么呢？本文最开始分析\x3ccode\x3enew Vue\x3c\/code\x3e过程时，有讲到运行\x3ccode\x3e_mount\x3c\/code\x3e方法时，会运行如下代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22vm._watcher = new Watcher(vm, () =\x3e {\n  vm._update(vm._render(), hydrating)\n}, noop)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3evm._watcher = \x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e Watcher(vm, () =\x26gt; {\n  vm._update(vm._render(), hydrating)\n}, noop)\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e那么\x3ccode\x3ethis.getter\x3c\/code\x3e就是这里Watcher方法的第二个参数。来看下\x3ccode\x3enew Watcher\x3c\/code\x3e的代码:\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22export default class Watcher {\n  constructor (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object = {}\n  ) {\n    ...\n    if (typeof expOrFn === \x27function\x27) {\n      this.getter = expOrFn\n    } else {\n      this.getter = parsePath(expOrFn)\n    }\n    ...\n    this.value = this.lazy\n      ? undefined\n      : this.get()\n  }\n}\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22javascript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eexport\x3c\/span\x3e \x3cspan class=\x22hljs-keyword\x22\x3edefault\x3c\/span\x3e \x3cspan class=\x22hljs-class\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3eclass\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3eWatcher\x3c\/span\x3e \x3c\/span\x3e{\n  \x3cspan class=\x22hljs-keyword\x22\x3econstructor\x3c\/span\x3e (\n    vm: Component,\n    expOrFn: string | Function,\n    cb: Function,\n    options?: Object = {}\n  ) {\n    ...\n    if (\x3cspan class=\x22hljs-keyword\x22\x3etypeof\x3c\/span\x3e expOrFn === \x3cspan class=\x22hljs-string\x22\x3e\x27function\x27\x3c\/span\x3e) {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = expOrFn\n    } \x3cspan class=\x22hljs-keyword\x22\x3eelse\x3c\/span\x3e {\n      \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.getter = parsePath(expOrFn)\n    }\n    ...\n    this.value = \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.lazy\n      ? \x3cspan class=\x22hljs-literal\x22\x3eundefined\x3c\/span\x3e\n      : \x3cspan class=\x22hljs-keyword\x22\x3ethis\x3c\/span\x3e.get()\n  }\n}\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e可以看出，在\x3ccode\x3enew Vue\x3c\/code\x3e过程中，Watcher会在构造完成后主动调用\x3ccode\x3ethis.get()\x3c\/code\x3e来触发\x3ccode\x3ethis.getter()\x3c\/code\x3e方法的运行，以达到更新DOM节点。\x3c\/p\x3e\n\x3cp\x3e总结一下这个过程：首先\x3ccode\x3e_init\x3c\/code\x3e时，会对Data设置好setter方法，setter方法中会调用\x3ccode\x3edep.notify()\x3c\/code\x3e，以便数据变化时通知DOM进行更新。然后\x3ccode\x3enew Watcher\x3c\/code\x3e时，会将更新DOM的方法进行设置，也就是\x3ccode\x3eWatcher.getter\x3c\/code\x3e方法。最后，当Data发生变化的时候，\x3ccode\x3edep.notify()\x3c\/code\x3e运行，运行到\x3ccode\x3ewatcher.getter()\x3c\/code\x3e时，就会去运行render和update逻辑，最终达到DOM更新的目的。\x3c\/p\x3e\n\x3ch1 id=\x22articleHeader5\x22\x3e总结与收获\x3c\/h1\x3e\n\x3cp\x3e刚开始觉得看源码，是因为希望能了解下Vue 2.0的实现，看看能不能得到一些从文档中无法知道的细节，用于提升运行效率。把主要流程理清楚后，的确了解到一些，这里做个整理：\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3eel属性传入的如果不是element，最后会通过\x3ccode\x3edocument.querySelector\x3c\/code\x3e来获取的，这个接口性能较差，所以，el传入一个element性能会更好。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e$mount\x3c\/code\x3e方法中对\x3ccode\x3ehtml\x3c\/code\x3e，\x3ccode\x3ebody\x3c\/code\x3e标签做了过滤，这两个不能用来作为渲染的根节点。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e每一个组件都会从\x3ccode\x3e_init\x3c\/code\x3e开始重新运行，所以，当存在一个长列表时，将子节点作为一个组件，性能会较差。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ccode\x3e*.vue\x3c\/code\x3e文件会在构建时转化为\x3ccode\x3erender\x3c\/code\x3e方法，而\x3ccode\x3erender\x3c\/code\x3e方法的性能比指定\x3ccode\x3etemplate\x3c\/code\x3e更好。所以，源码使用\x3ccode\x3e*.vue\x3c\/code\x3e的方式，性能更好。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果需要自定义\x3ccode\x3edelimiters\x3c\/code\x3e，每一个组件都需要单独指定。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e如果是\x3ccode\x3e*.vue\x3c\/code\x3e文件，指定\x3ccode\x3edelimiters\x3c\/code\x3e是失效的，因为\x3ccode\x3evue-loader\x3c\/code\x3e对\x3ccode\x3e*.vue\x3c\/code\x3e文件进行解析时，并没有将\x3ccode\x3edelimiters\x3c\/code\x3e传递到\x3ccode\x3ecompiler.compile()\x3c\/code\x3e中。（这一点不确定是bug还是故意这样设计的）。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>Vue 2.0源码学习</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007484936">https://segmentfault.com/a/1190000007484936</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/3v2of4ensgc/" target="_blank">https://alili.tech/archive/3v2of4ensgc/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/dc9tmbt89lc/">CSS3 巧妙实现聊天气泡<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/awfhylei7vr/">Element 一套优雅的 Vue 2 组件库是如何开发的<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/5n6e7oj31zb/">Ionic2入坑基础教程和安装指南<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/k9uktrr2ck/">JavaScript arguments 对象全面介绍<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/d31ygsiurr7/">JavaScript 版俄罗斯方块——重构<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/f1goxj498pc/">JavaScript中this绑定详解<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/fpk9tyls8sb/">Markcook2.0，使用Vue2.0和Vuex2.0进行完全重构升级<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/rnj4z8l02t/">N3-components - 强劲的 Vue UI组件库<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/7njdijhy2um/">Node.js &#43; React Native 毕设：农业物联网监测系统的开发手记<aside class="dates">2019-02-02</aside></a></li><li><a href="/archive/f8zzbybr4tl/">Redux、Flux、Vuex<aside class="dates">2019-02-02</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>