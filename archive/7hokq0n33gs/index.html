<!DOCTYPE html><html lang="zh"><head><meta name="generator" content="Hugo 0.51"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="initial-scale=1,width=device-width,minimum-scale=1,maximum-scale=1,user-scalable=no"><meta name="wap-font-scale" content="no"><meta name="360-site-verification" content="0903ba33c82867d1f7bd8831e32a7e34"><meta name="sogou_site_verification" content="E8uWFBcf4a"><meta name="author" content="Fan"><meta name="description" itemprop="description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta name="keywords" content="Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js"><meta property="og:locale" content="en_US"><meta property="og:title" content="立即执行函数表达式(IIFE)"><meta property="og:image" content="https://alili.tech/images/logo2.png"><meta property="og:description" content="Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css"><meta property="og:site_name" content="Alili"><title>立即执行函数表达式(IIFE) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!</title><link rel="shortcut icon" href="https://alili.tech/images/favicon.ico"><link rel="manifest" href="/manifest.json"><link rel="stylesheet" href="https://alili.tech/lib/font-awesome/css/font-awesome.min.css"><link rel="stylesheet" href="https://alili.tech/lib/justified-gallery/justifiedGallery.min.css"><link rel="stylesheet" href="https://alili.tech/css/style.css"><script src="https://alili.tech/lib/highlight.min.js"></script><script>hljs.initHighlightingOnLoad();</script><script src="https://alili.tech/lib/jquery/jquery.min.js"></script><script>document.addEventListener("error", function (e) {
			  var elem = e.target;
			  if (elem.tagName.toLowerCase() == 'img') {
				elem.style.display='none'
			  }
			}, true);</script><script type="application/ld+json">{
				"@context": "https://ziyuan.baidu.com/contexts/cambrian.jsonld",
				"@id": "https://alili.tech/archive/7hokq0n33gs/",
				"appid": "1613049289050283", 
				"title": "立即执行函数表达式(IIFE) | 前端大爆炸! - WEB BANG! BANG!! BANG!!!", 
				"images": [],
				"pubDate": "2019-01-31T02:31:16"
			}</script></head><body><div id="header-post"><a id="menu-icon" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#"><i class="fa fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" href="https://alili.tech/archive/8k20276v9vo/"><i class="fa fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle();' onmouseout='$("#i-prev").toggle();'></i></a></li><li><a class="icon" href="https://alili.tech/archive/gpgerxmzcje/"><i class="fa fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle();' onmouseout='$("#i-next").toggle();'></i></a></li><li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle();' onmouseout='$("#i-top").toggle();'></i></a></li><li><a class="icon" href="#"><i class="fa fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle();' onmouseout='$("#i-share").toggle();' onclick='$("#share").toggle();return false;'></i></a></li></ul><span id="i-prev" class="info" style="display:none;">Previous post</span> <span id="i-next" class="info" style="display:none;">Next post</span> <span id="i-top" class="info" style="display:none;">Back to top</span> <span id="i-share" class="info" style="display:none;">Share post</span></span><br><div id="share" style="display: none"><ul><li><a class="icon" href="http://v.t.sina.com.cn/share/share.php?u=https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f&text=%e7%ab%8b%e5%8d%b3%e6%89%a7%e8%a1%8c%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f%28IIFE%29"><i class="fa fa-weibo" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.facebook.com/sharer.php?u=https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f"><i class="fa fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" href="https://twitter.com/share?url=https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f&text=%e7%ab%8b%e5%8d%b3%e6%89%a7%e8%a1%8c%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f%28IIFE%29"><i class="fa fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f&title=%e7%ab%8b%e5%8d%b3%e6%89%a7%e8%a1%8c%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f%28IIFE%29"><i class="fa fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f&is_video=false&description=%e7%ab%8b%e5%8d%b3%e6%89%a7%e8%a1%8c%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f%28IIFE%29"><i class="fa fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=%e7%ab%8b%e5%8d%b3%e6%89%a7%e8%a1%8c%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f%28IIFE%29&body=Check out this article: https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f"><i class="fa fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" href="https://getpocket.com/save?url=https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f&title=%e7%ab%8b%e5%8d%b3%e6%89%a7%e8%a1%8c%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f%28IIFE%29"><i class="fa fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" href="http://reddit.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f&title=%e7%ab%8b%e5%8d%b3%e6%89%a7%e8%a1%8c%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f%28IIFE%29"><i class="fa fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" href="http://www.stumbleupon.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f&title=%e7%ab%8b%e5%8d%b3%e6%89%a7%e8%a1%8c%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f%28IIFE%29"><i class="fa fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" href="http://digg.com/submit?url=https%3a%2f%2falili.tech%2farchive%2f7hokq0n33gs%2f&title=%e7%ab%8b%e5%8d%b3%e6%89%a7%e8%a1%8c%e5%87%bd%e6%95%b0%e8%a1%a8%e8%be%be%e5%bc%8f%28IIFE%29"><i class="fa fa-digg" aria-hidden="true"></i></a></li></ul></div><div id="toc"><nav id="TableOfContents"><ul><li><a href="#版权声明">版权声明</a><ul><li><a href="#原文标题">原文标题</a></li><li><a href="#原文链接">原文链接</a></li></ul></li></ul></nav></div></span></div><div class="content index width mx-auto px3 my3"><section id="wrapper" class="home"><article class="post" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle" itemprop="name headline">立即执行函数表达式(IIFE)</h1><div class="meta"><div class="postdate"><time datetime="2019-01-31" itemprop="datePublished">2019-01-31</time></div><div class="article-tag"><i class="fa fa-eye"></i> <span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span></span></div><div class="article-tag-box"></div></div></header><div class="content" itemprop="articleBody"><div id="raw"><p style="opacity: 0;">Alili | 前端大爆炸! - WEB BANG! BANG!! BANG!!! 前端大爆炸,一个前端技术博客.想到哪,学到哪,写到哪. 本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有， Alili, 前端大爆炸, WEB BANG BANG BANG, web前端博客, 前端模块化, 前端工程化, 前端数据监控, 性能优化, 网页制作, 前端, js, html5, css, 踩坑小报告, 微前端, 树莓派, 前端开发, 区块链, 网络, Mongodb, Vue.js, Angular.js, node.js</p><script>$(function () {
            var html = "\n\n                    \n\x3cblockquote\x3e\x3cp\x3e原文：\x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/chapter-5-functions\/#question-about-surrounding-parentheses\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eImmediately-Invoked Function Expression (IIFE)\x3c\/a\x3e \x3cstrong\x3eby\x3c\/strong\x3e Ben Alman\x3cbr\x3e原译：\x3ca href=\x22http:\/\/segmentfault.com\/a\/1190000003985390\x22\x3e立即执行函数\x3c\/a\x3e \x3cstrong\x3eby\x3c\/strong\x3e Murphywuwu\x3cbr\x3e改增内容： \x3cstrong\x3eby\x3c\/strong\x3e blanu\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cp\x3e也许你没有注意到，我是一个对于专业术语有一点强迫症的人。所以，当我多次听到流行却易产生误解的术语「自执行匿名函数」，我最终决定将我的想法写进这篇文章里。\x3c\/p\x3e\n\x3cp\x3e更进一步地说，除了提供关于该模式究竟是如何工作的全面信息，事实上我还建议了我们应该怎样称呼这种模式。另外，如果你想跳过这里，你可以直接跳到\x3cstrong\x3e\x3ca\x3e立即调用函数表达式\x3c\/a\x3e\x3c\/strong\x3e进行阅读，但是我建议你读完整篇文章。\x3c\/p\x3e\n\x3cp\x3e请理解这篇文章不是想说「我对了，你错了」。我发自真心地想帮助人们理解看似复杂的概念，并且我认为使用前后一致的精确术语是有助于人们理解的最简单的方式之一。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader0\x22\x3e它是什么\x3c\/h2\x3e\n\x3cp\x3e在JavaScript里，每个函数，当被调用时，都会创建一个新的执行上下文。因为在函数里定义的变量和函数只能在函数内部被访问，外部无法获取；当调用函数时，函数提供的上下文就提供了一个非常简单的方法创建私有变量。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/因为这个函数的返回值是另一个能访问私有变量i的函数，因此返回的函数实际上被提权(privileged)了\nfunction makeCounter() {\n    \/\/i只能从`makeConuter`内部访问\n    var i = 0;\n    return function(){\n        console.log(\x2b\x2bi);\n    };   \n}\n\/\/记住：`counter`和`counter2`都有他们自己作用域中的变量 `i`\nvar counter = makeCounter();\ncounter();\/\/1\ncounter();\/\/2\n\nvar counter2 = makeCounter();\ncounter2();\/\/1\ncounter2();\/\/2\n\ni;\/\/ReferenceError: i is not defined(它只存在于makeCounter里)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/因为这个函数的返回值是另一个能访问私有变量i的函数，因此返回的函数实际上被提权(privileged)了\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3emakeCounter\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e) \x3c\/span\x3e{\n    \x3cspan class=\x22hljs-comment\x22\x3e\/\/i只能从`makeConuter`内部访问\x3c\/span\x3e\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-built_in\x22\x3econsole\x3c\/span\x3e.log(\x2b\x2bi);\n    };   \n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/记住：`counter`和`counter2`都有他们自己作用域中的变量 `i`\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = makeCounter();\ncounter();\x3cspan class=\x22hljs-comment\x22\x3e\/\/1\x3c\/span\x3e\ncounter();\x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter2 = makeCounter();\ncounter2();\x3cspan class=\x22hljs-comment\x22\x3e\/\/1\x3c\/span\x3e\ncounter2();\x3cspan class=\x22hljs-comment\x22\x3e\/\/2\x3c\/span\x3e\n\ni;\x3cspan class=\x22hljs-comment\x22\x3e\/\/ReferenceError: i is not defined(它只存在于makeCounter里)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e在许多情况下，你可能并不需要\x3ccode\x3emakeWhatever\x3c\/code\x3e这样的函数返回多次累加值，并且可以只调用一次得到一个单一的值，在其他一些情况里，你甚至不需要明确的知道返回值。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader1\x22\x3e它的核心\x3c\/h2\x3e\n\x3cp\x3e现在，无论你定义一个函数像这样\x3ccode\x3efunction foo(){}\x3c\/code\x3e或者\x3ccode\x3evar foo = function(){}\x3c\/code\x3e，调用时，你都需要在后面加上一对圆括号，像这样\x3ccode\x3efoo()\x3c\/code\x3e\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/向下面这样定义的函数可以通过在函数名后加一对括号进行调用，像这样`foo()`，因为foo相对于函数表达式`function(){\/* code *\/}`只是一个引用变量\n\nvar foo = function(){\/* code *\/}\n\/\/那这可以说明函数表达式可以通过在其后加上一对括号自己调用自己吗？\nfunction(){ \/* code *\/}();\/\/SyntaxError: Unexpected token (\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/向下面这样定义的函数可以通过在函数名后加一对括号进行调用，像这样`foo()`，因为foo相对于函数表达式`function(){\/* code *\/}`只是一个引用变量\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/那这可以说明函数表达式可以通过在其后加上一对括号自己调用自己吗？\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e}();\x3cspan class=\x22hljs-comment\x22\x3e\/\/SyntaxError: Unexpected token (\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e正如你所看到的，这里捕获了一个错误。当圆括号为了调用函数出现在函数后面时，无论在全局环境或者局部环境里遇到了这样的\x3ccode\x3efunction\x3c\/code\x3e关键字，默认的，它会将它当作是一个函数声明，而不是函数表达式，如果你不明确的告诉圆括号它是一个表达式，它会将其当作没有名字的函数声明并且抛出一个错误，因为函数声明需要一个名字。\x3cbr\x3e\x3cstrong\x3e问题1：\x3c\/strong\x3e这里我么可以思考一个问题，我们是不是也可以像这样直接调用函数\x3ccode\x3evar foo = function(){console.log(1)}()\x3c\/code\x3e，答案是可以的。\x3cbr\x3e\x3cstrong\x3e问题2：\x3c\/strong\x3e同样的，我们还可以思考一个问题，像这样的函数声明在后面加上圆括号被直接调用，又会出现什么情况呢？请看下面的解答。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader2\x22\x3e题外话：函数、圆括号和错误\x3c\/h2\x3e\n\x3cp\x3e有趣的是，如果你为一个函数指定一个名字并在它后面放一对圆括号，同样的也会抛出错误，但这次是因为另外一个原因。当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号(用来控制运算优先的括号)。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式\nfunction foo(){ \/* code *\/ }();\/\/SyntaxError: Unexpected token\n\/\/现在，你把一个表达式放在圆括号里，没有抛出错误...但是函数也并没有执行，因为：\nfunction foo(){\/* code *\/}(1)\n\/\/它等同于如下，一个函数声明跟着一个完全没有关系的表达式:\nfunction foo(){\/* code *\/}\n(1);\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e }();\x3cspan class=\x22hljs-comment\x22\x3e\/\/SyntaxError: Unexpected token\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/现在，你把一个表达式放在圆括号里，没有抛出错误...但是函数也并没有执行，因为：\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e}(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e)\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/它等同于如下，一个函数声明跟着一个完全没有关系的表达式:\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e}\n(\x3cspan class=\x22hljs-number\x22\x3e1\x3c\/span\x3e);\x3c\/code\x3e\x3c\/pre\x3e\n\x3cblockquote\x3e\x3cp\x3e关于这个细节，你可以阅读Dmitry A. Soshnikov的文章：\x3cem\x3e\x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/chapter-5-functions\/#question-about-surrounding-parentheses\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eECMA-262-3 in detail. Chapter 5. Functions\x3c\/a\x3e \x3c\/em\x3e（\x3ca href=\x22http:\/\/goddyzhao.tumblr.com\/post\/11273713920\/functions\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3e中文版本\x3c\/a\x3e）\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader3\x22\x3e\n\x3ca\x3e\x3c\/a\x3e立即执行函数表达式(IIFE)\x3c\/h2\x3e\n\x3cp\x3e幸运的是，修正语法错误很简单。最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器去表达一个函数表达式，因为在JavaScript里，圆括号不能\x3cstrong\x3e包含\x3c\/strong\x3e声明。因为这点，当圆括号为了包裹函数碰上了 \x3ccode\x3efunction\x3c\/code\x3e关键词，它便知道将它作为一个函数表达式去解析而不是函数声明。\x3cstrong\x3e注意理解\x3c\/strong\x3e这里的圆括号和上面的圆括号遇到函数时的表现是不一样的，也就是说。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量\n(function(){\/* code *\/}());\/\/Crockford recommends this one\n(function(){\/* code *\/})();\/\/But this one works just as well\n\n\/\/ 因为括号的作用就是为了消除函数表达式和函数声明之间的差异\n\/\/ 如果解释器能预料到这是一个表达式，括号可以被省略\n\/\/ 不过请参见下面的「重要笔记」\nvar i = function(){return 10;}();\ntrue \x26amp;\x26amp; function(){\/*code*\/}();\n0,function(){}();\n\n\/\/如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节\n!function(){\/* code *\/}();\n~function(){\/* code *\/}();\n-function(){\/* code *\/}();\n\x2bfunction(){\/* code *\/}();\n\n\/\/ 这里是另外一种方法\n\/\/ 我（原文作者）不清楚new方法是否会影响性能\n\/\/ 但它却是奏效，参见http:\/\/twitter.com\/kuvos\/status\/18209252090847232\n\nnew function(){ \/* code *\/ }\nnew function(){ \/* code *\/ }() \/\/ 只有当传入参数时才需要加括号\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/这两种模式都可以被用来立即调用一个函数表达式，利用函数的执行来创造私有变量\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e}());\x3cspan class=\x22hljs-comment\x22\x3e\/\/Crockford recommends this one\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e})();\x3cspan class=\x22hljs-comment\x22\x3e\/\/But this one works just as well\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 因为括号的作用就是为了消除函数表达式和函数声明之间的差异\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 如果解释器能预料到这是一个表达式，括号可以被省略\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 不过请参见下面的「重要笔记」\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-number\x22\x3e10\x3c\/span\x3e;}();\n\x3cspan class=\x22hljs-literal\x22\x3etrue\x3c\/span\x3e \x26amp;\x26amp; \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/*code*\/\x3c\/span\x3e}();\n\x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{}();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/如果你并不关心返回值，或者让你的代码尽可能的易读，你可以通过在你的函数前面带上一个一元操作符来存储字节\x3c\/span\x3e\n!\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e}();\n~\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e}();\n-\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e}();\n\x2b\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e}();\n\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 这里是另外一种方法\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 我（原文作者）不清楚new方法是否会影响性能\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 但它却是奏效，参见http:\/\/twitter.com\/kuvos\/status\/18209252090847232\x3c\/span\x3e\n\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e }\n\x3cspan class=\x22hljs-keyword\x22\x3enew\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{ \x3cspan class=\x22hljs-comment\x22\x3e\/* code *\/\x3c\/span\x3e }() \x3cspan class=\x22hljs-comment\x22\x3e\/\/ 只有当传入参数时才需要加括号\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3ch2 id=\x22articleHeader4\x22\x3e关于括号的重要笔记\x3c\/h2\x3e\n\x3cp\x3e在一些情况下，当额外的带着歧义的括号围绕在函数表达式周围是没有必要的（因为这时候的括号已经将其作为一个表达式去表达），但当括号用于调用函数表达式时，这仍然是一个好主意。\x3c\/p\x3e\n\x3cp\x3e这样的括号指明函数表达式将会被立即调用，并且变量将会储存函数的结果，而不是函数本身。当这是一个非常长的函数表达式时，这可以节约其他人阅读你代码的时间，不用滚到页面底部去看这个函数是否被调用。\x3c\/p\x3e\n\x3cp\x3e作为规则，当你书写清楚明晰的代码时，有必要阻止JavaScript抛出错误的，同样也有必要阻止其他开发者对你抛出错误\x3ccode\x3eWTFError\x3c\/code\x3e!\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader5\x22\x3e保存闭包的状态\x3c\/h2\x3e\n\x3cp\x3e就像当函数通过他们的名字被调用时，参数会被传递，而当函数表达式被立即调用时，参数也会被传递。一个立即调用的函数表达式可以用来锁定值并且有效的保存此时的状态，因为任何定义在一个函数内的函数都可以使用外面函数传递进来的参数和变量（这种关系被叫做闭包）。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e关于闭包的更多信息，参见 \x3cem\x3e\x3ca href=\x22http:\/\/skilldrick.co.uk\/2011\/04\/closures-explained-with-javascript\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eClosures explained with JavaScript\x3c\/a\x3e\x3c\/em\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/它的运行原理可能并不像你想的那样，因为`i`的值从来没有被锁定。相反的，每个链接，当被点击时(循环已经被很好的执行完毕)，因此会弹出所有元素的总数，因为这是`i`此时的真实值。\nvar elems = document.getElementsByTagName(\x27a\x27);\nfor(var i = 0;i \x3c elems.length; i\x2b\x2b ) {\n    elems[i].addEventListener(\x27click\x27,function(e){\n        e.preventDefault();\n        alert(\x27I am link #\x27 \x2b i)\n        },false);\n}\n\/\/而像下面这样改写，便可以了，因为在IIFE里，`i`值被锁定在了`lockedInIndex`里。在循环结束执行时，尽管`i`值的数值是所有元素的总和，但每一次函数表达式被调用时，IIFE里的`lockedInIndex`值都是`i`传给它的值,所以当链接被点击时，正确的值被弹出。\nvar elems = document.getElementsByTagName(\x27a\x27);\nfor(var i = 0;i \x3c elems.length;i\x2b\x2b) {\n    (function(lockedInIndex){\n        elems[i].addEventListener(\x27click\x27,function(e){\n            e.preventDefault();\n            alert(\x27I am link #\x27 \x2b lockedInIndex);\n            },false)\n    })(i);\n}\n\/\/你同样可以像下面这样使用IIFE，仅仅只用括号包裹点击处理函数，并不包含整个`addEventListener`。无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子更可读\nvar elems = document.getElementsByTagName( \x27a\x27 );\n\nfor ( var i = 0; i \x3c elems.length; i\x2b\x2b ) {\n    elems[ i ].addEventListener( \x27click\x27, (function( lockedInIndex ){\n        return function(e){\n            e.preventDefault();\n            alert( \x27I am link #\x27 \x2b lockedInIndex );\n        };\n        })( i ),false);\n    }\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/它的运行原理可能并不像你想的那样，因为`i`的值从来没有被锁定。相反的，每个链接，当被点击时(循环已经被很好的执行完毕)，因此会弹出所有元素的总数，因为这是`i`此时的真实值。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e elems = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementsByTagName(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;i \x26lt; elems.length; i\x2b\x2b ) {\n    elems[i].addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n        e.preventDefault();\n        alert(\x3cspan class=\x22hljs-string\x22\x3e\x27I am link #\x27\x3c\/span\x3e \x2b i)\n        },\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/而像下面这样改写，便可以了，因为在IIFE里，`i`值被锁定在了`lockedInIndex`里。在循环结束执行时，尽管`i`值的数值是所有元素的总和，但每一次函数表达式被调用时，IIFE里的`lockedInIndex`值都是`i`传给它的值,所以当链接被点击时，正确的值被弹出。\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e elems = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementsByTagName(\x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e);\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e(\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;i \x26lt; elems.length;i\x2b\x2b) {\n    (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3elockedInIndex\x3c\/span\x3e)\x3c\/span\x3e{\n        elems[i].addEventListener(\x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e,\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n            e.preventDefault();\n            alert(\x3cspan class=\x22hljs-string\x22\x3e\x27I am link #\x27\x3c\/span\x3e \x2b lockedInIndex);\n            },\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e)\n    })(i);\n}\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/你同样可以像下面这样使用IIFE，仅仅只用括号包裹点击处理函数，并不包含整个`addEventListener`。无论用哪种方式，这两个例子都可以用IIFE将值锁定，不过我发现前面一个例子更可读\x3c\/span\x3e\n\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e elems = \x3cspan class=\x22hljs-built_in\x22\x3edocument\x3c\/span\x3e.getElementsByTagName( \x3cspan class=\x22hljs-string\x22\x3e\x27a\x27\x3c\/span\x3e );\n\n\x3cspan class=\x22hljs-keyword\x22\x3efor\x3c\/span\x3e ( \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e; i \x26lt; elems.length; i\x2b\x2b ) {\n    elems[ i ].addEventListener( \x3cspan class=\x22hljs-string\x22\x3e\x27click\x27\x3c\/span\x3e, (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e lockedInIndex \x3c\/span\x3e)\x3c\/span\x3e{\n        \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3ee\x3c\/span\x3e)\x3c\/span\x3e{\n            e.preventDefault();\n            alert( \x3cspan class=\x22hljs-string\x22\x3e\x27I am link #\x27\x3c\/span\x3e \x2b lockedInIndex );\n        };\n        })( i ),\x3cspan class=\x22hljs-literal\x22\x3efalse\x3c\/span\x3e);\n    }\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e记住，在这最后两个例子里，\x3ccode\x3elockedInIndex\x3c\/code\x3e可以没有任何问题的访问\x3ccode\x3ei\x3c\/code\x3e,但是作为函数的参数使用一个不同的命名标识符可以使概念更加容易的被解释。\x3c\/p\x3e\n\x3cp\x3e立即执行函数一个最显著的优势是就算它没有命名或者说是匿名，函数表达式也可以在没有使用标识符的情况下被立即调用，一个闭包也可以在没有当前变量污染的情况下被使用。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader6\x22\x3e「自执行匿名函数(Self-executing anonymous function)」有什么问题呢？\x3c\/h2\x3e\n\x3cp\x3e你看到它已经被提到好几次了，但它仍未被清楚地解释，我提议将术语改成\x3cstrong\x3e\x22Immediately-Invoked Function Expression\x22\x3c\/strong\x3e，或者，\x3cstrong\x3eIIFE\x3c\/strong\x3e，如果你喜欢缩写的话（发音类似“iffy”）。\x3c\/p\x3e\n\x3cp\x3e什么是\x3cstrong\x3eImmediately-Invoked Function Expression\x3c\/strong\x3e呢？顾名思义，它就是一个被立即调用的函数表达式。\x3c\/p\x3e\n\x3cp\x3e我想JavaScript社区的成员应该可以在他们的文章里或者陈述里接受术语\x3cstrong\x3eImmediately-Invoked Function Expression\x3c\/strong\x3e和\x3cstrong\x3eIIFE\x3c\/strong\x3e，因为我感觉这样更容易让这个概念被理解，并且术语\x22self-executing anonymous function\x22真的也不够精确。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22\/\/下面是个自执行函数，递归的调用自己本身\nfunction foo(){foo();};\n\/\/这是一个自执行匿名函数。因为它没有标识符，它必须是使用`arguments.callee`属性来调用它自己\nvar foo = function(){arguments.callee();};\n\/\/这也许算是一个自执行匿名函数，但是仅仅当`foo`标识符作为它的引用时，如果你将它换成用`foo`来调用同样可行\nvar foo = function(){foo();};\n\/\/有些人像这样叫\x27self-executing anonymous function\x27下面的函数,即使它不是自执行的，因为它并没有调用它自己。然后，它只是被立即调用了而已。\n(function(){ \/*code*\/ }());\n\/\/为函数表达式增加标识符(也就是说创造一个命名函数)对我们的调试会有很大帮助。一旦命名，函数将不再匿名。\n(function foo(){\/* code *\/}());\n\/\/IIFEs同样也可以自执行，尽管，也许他不是最有用的模式\n(function(){arguments.callee();}())\n(function foo(){foo();}())\n\/\/ 另外，下面这个表达式竟会在黑莓5上抛出错误，在一个被命名的函数中，该函数名是undefined。很奇妙吧…\n(function foo(){ foo(); }());\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22hljs scilab\x22\x3e\x3ccode\x3e\x3cspan class=\x22hljs-comment\x22\x3e\/\/下面是个自执行函数，递归的调用自己本身\x3c\/span\x3e\n\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{\x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;};\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/这是一个自执行匿名函数。因为它没有标识符，它必须是使用`arguments.callee`属性来调用它自己\x3c\/span\x3e\nvar foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{\x3cspan class=\x22hljs-title\x22\x3earguments\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ecallee\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;};\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/这也许算是一个自执行匿名函数，但是仅仅当`foo`标识符作为它的引用时，如果你将它换成用`foo`来调用同样可行\x3c\/span\x3e\nvar foo = \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{\x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;};\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/有些人像这样叫\x27self-executing anonymous function\x27下面的函数,即使它不是自执行的，因为它并没有调用它自己。然后，它只是被立即调用了而已。\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{ \/*\x3cspan class=\x22hljs-title\x22\x3ecode\x3c\/span\x3e*\/ }\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e);\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/为函数表达式增加标识符(也就是说创造一个命名函数)对我们的调试会有很大帮助。一旦命名，函数将不再匿名。\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{\/* \x3cspan class=\x22hljs-title\x22\x3ecode\x3c\/span\x3e *\/}\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e);\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/IIFEs同样也可以自执行，尽管，也许他不是最有用的模式\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{\x3cspan class=\x22hljs-title\x22\x3earguments\x3c\/span\x3e.\x3cspan class=\x22hljs-title\x22\x3ecallee\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;}\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e)\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{\x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e;}\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e)\x3c\/span\x3e\n\x3cspan class=\x22hljs-comment\x22\x3e\/\/ 另外，下面这个表达式竟会在黑莓5上抛出错误，在一个被命名的函数中，该函数名是undefined。很奇妙吧…\x3c\/span\x3e\n(\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e{ \x3cspan class=\x22hljs-title\x22\x3efoo\x3c\/span\x3e\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e; }\x3cspan class=\x22hljs-params\x22\x3e()\x3c\/span\x3e);\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e希望上面的例子可以让你更加清楚的知道术语\x27self-executing\x27是有一些误导的，因为他并不是执行自己的函数，尽管函数已经被执行。同样的，匿名函数也没用必要特别指出，因为，\x3cstrong\x3eImmediately Invoked Function Expression\x3c\/strong\x3e，既可以是命名函数也可以匿名函数。\x3c\/p\x3e\n\x3cblockquote\x3e\x3cp\x3e有趣的是：因为arguments.callee在\x3cem\x3eECMAScript 5 strict mode\x3c\/em\x3e中被\x3cem\x3edeprecated\x3c\/em\x3e了，所以在ES5的\x3ccode\x3estrict mode\x3c\/code\x3e中实际上不可能创建一个\x3ccode\x3eself-executing anonymous function\x3c\/code\x3e\x3c\/p\x3e\x3c\/blockquote\x3e\n\x3ch2 id=\x22articleHeader7\x22\x3e最后:模块模式\x3c\/h2\x3e\n\x3cp\x3e当我调用函数表达式时，如果我不至少一次的提醒我自己关于模块模式，我便很可能会忽略它。如果你并不熟悉JavaScript里的模块模式，它和我第一个例子很像，但是返回值用对象代替了函数。\x3c\/p\x3e\n\x3cdiv class=\x22widget-codetool\x22 style=\x22display:none;\x22\x3e\n      \x3cdiv class=\x22widget-codetool--inner\x22\x3e\n      \x3cspan class=\x22selectCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22全选\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22copyCode code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 data-clipboard-text=\x22var counter = (function(){\n    var i = 0;\n    return {\n        get: function(){\n            return i;\n        },\n        set: function(val){\n            i = val;\n        },\n        increment: function(){\n            return \x2b\x2bi;\n        }\n    }\n    }());\n    counter.get();\/\/0\n    counter.set(3);\n    counter.increment();\/\/4\n    counter.increment();\/\/5\n\n    conuter.i;\/\/undefined (`i` is not a property of the returned object)\n    i;\/\/ReferenceError: i is not defined (it only exists inside the closure)\x22 title=\x22\x22 data-original-title=\x22复制\x22\x3e\x3c\/span\x3e\n      \x3cspan type=\x22button\x22 class=\x22saveToNote code-tool\x22 data-toggle=\x22tooltip\x22 data-placement=\x22top\x22 title=\x22\x22 data-original-title=\x22放进笔记\x22\x3e\x3c\/span\x3e\n      \x3c\/div\x3e\n      \x3c\/div\x3e\x3cpre class=\x22javascript hljs\x22\x3e\x3ccode class=\x22JavaScript\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e counter = (\x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n    \x3cspan class=\x22hljs-keyword\x22\x3evar\x3c\/span\x3e i = \x3cspan class=\x22hljs-number\x22\x3e0\x3c\/span\x3e;\n    \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e {\n        \x3cspan class=\x22hljs-attr\x22\x3eget\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e i;\n        },\n        \x3cspan class=\x22hljs-attr\x22\x3eset\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3eval\x3c\/span\x3e)\x3c\/span\x3e{\n            i = val;\n        },\n        \x3cspan class=\x22hljs-attr\x22\x3eincrement\x3c\/span\x3e: \x3cspan class=\x22hljs-function\x22\x3e\x3cspan class=\x22hljs-keyword\x22\x3efunction\x3c\/span\x3e(\x3cspan class=\x22hljs-params\x22\x3e\x3c\/span\x3e)\x3c\/span\x3e{\n            \x3cspan class=\x22hljs-keyword\x22\x3ereturn\x3c\/span\x3e \x2b\x2bi;\n        }\n    }\n    }());\n    counter.get();\x3cspan class=\x22hljs-comment\x22\x3e\/\/0\x3c\/span\x3e\n    counter.set(\x3cspan class=\x22hljs-number\x22\x3e3\x3c\/span\x3e);\n    counter.increment();\x3cspan class=\x22hljs-comment\x22\x3e\/\/4\x3c\/span\x3e\n    counter.increment();\x3cspan class=\x22hljs-comment\x22\x3e\/\/5\x3c\/span\x3e\n\n    conuter.i;\x3cspan class=\x22hljs-comment\x22\x3e\/\/undefined (`i` is not a property of the returned object)\x3c\/span\x3e\n    i;\x3cspan class=\x22hljs-comment\x22\x3e\/\/ReferenceError: i is not defined (it only exists inside the closure)\x3c\/span\x3e\x3c\/code\x3e\x3c\/pre\x3e\n\x3cp\x3e模块模式方法不仅相当的厉害而且简单。非常少的代码，你可以有效的利用与方法和属性相关的命名，在一个对象里，组织全部的模块代码即最小化了全局变量的污染也创造了私人变量。\x3c\/p\x3e\n\x3ch2 id=\x22articleHeader8\x22\x3e延伸阅读\x3c\/h2\x3e\n\x3cp\x3e希望这篇文章可以为你答疑解惑。当然，如果你产生了更多疑惑，你可以阅读下面这些关于函数和模块模式的文章。\x3c\/p\x3e\n\x3cul\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/dmitrysoshnikov.com\/ecmascript\/chapter-5-functions\/#question-about-surrounding-parentheses\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eECMA-262-3 in detail. Chapter 5. Functions.\x3c\/a\x3e - Dmitry A. Soshnikov\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22https:\/\/developer.mozilla.org\/en\/JavaScript\/Reference\/Functions_and_function_scope\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eFunctions and function scope\x3c\/a\x3e - Mozilla Developer Network\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/kangax.github.com\/nfe\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eNamed function expressions\x3c\/a\x3e - Juriy “kangax” Zaytsev\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/www.adequatelygood.com\/2010\/3\/JavaScript-Module-Pattern-In-Depth\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eJavaScript Module Pattern: In-Depth\x3c\/a\x3e - Ben Cherry\x3c\/p\x3e\x3c\/li\x3e\n\x3cli\x3e\x3cp\x3e\x3ca href=\x22http:\/\/skilldrick.co.uk\/2011\/04\/closures-explained-with-javascript\/\x22 rel=\x22nofollow noreferrer\x22 target=\x22_blank\x22\x3eClosures explained with JavaScript\x3c\/a\x3e - Nick Morgan\x3c\/p\x3e\x3c\/li\x3e\n\x3c\/ul\x3e\n\n                \n"
            html = html.replace(/"{/g, "{")
            html = html.replace(/{"/g, "{")
            html = html.replace(/"}/g, "}")
            html = html.replace(/}"/g, "}")
            $('#raw').html(html);

            let postTitle =  $('.posttitle').text()
            let postContentTitle =  $('#raw > h1').text()
            if(postTitle === postContentTitle){
                $('#raw > h1').hide()
            }
            $('button.preview').hide()
        })</script></div><h1 id="版权声明">版权声明</h1><p>本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，</p><p>本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。</p><p>原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！</p><h2 id="原文标题">原文标题</h2><p>立即执行函数表达式(IIFE)</p><h2 id="原文链接">原文链接</h2><p><a href="https://segmentfault.com/a/1190000007569312">https://segmentfault.com/a/1190000007569312</a></p><h2>本文链接：</h2><a href="https://alili.tech/archive/7hokq0n33gs/" target="_blank">https://alili.tech/archive/7hokq0n33gs/</a></div></article><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><div class="blog-post-comments"></div><script>new Valine({
        el: '.blog-post-comments', 
        app_id: 'ItyOVb4I33bTwprf3cY6uqMc-gzGzoHsz', 
        app_key: 'hLhtmd4tT0qJbyO2SgQ8odya', 
        placeholder: '说点什么?', 
        avatar:'robohash',
        notify:true,
        verify:true
    });</script><ul id="more-post-list" class="archive readmore"><h3>其他推荐</h3><li><a href="/archive/z09muaar7j/">2年前端应该会哪些技能<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/ke982v6qrfg/">CSS 性能优化笔记<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/if1i2hs28ah/">H5打造3d场景不完全攻略（二）: Amazing CSS3D<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/s4apghsr7o/">JS原生一步步实现前端路由和单页面应用<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/hjgkntbgqek/">JavaScript 中对大量数据的多重过滤<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/h1hfvr2a2nj/">JavaScript 中的错误处理机制<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/a0ukpm125gm/">JavaScript 数组分组的实现<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/fwosouhbhmj/">JavaScript 类型转换深度学习<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/z193p9xv2p/">JavaScript设计模式之发布-订阅模式（观察者模式）-Part1<aside class="dates">2019-02-01</aside></a></li><li><a href="/archive/6i7sr0vgkxm/">Javascript中的时间<aside class="dates">2019-02-01</aside></a></li></ul></section></div><footer id="footer"><div class="footer-left">Copyright © 2019 Fan <a href="http://www.miitbeian.gov.cn" rel="external nofollow noopener noreferrer" target="_blank">浙ICP备18045521号</a></div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archive/">Archives</a></li><li><a href="/about/">About</a></li><li><a href="http://github.com/Fantasy9527" target="_blank">Github</a></li></ul></nav></div></footer><script src="https://alili.tech/lib/justified-gallery/jquery.justifiedGallery.min.js"></script><script src="https://alili.tech/lib/typed.js"></script><script src="https://alili.tech/js/main.js"></script><script async src=""></script><script>(function(){
  if(location.host!=='alili.tech')return;
  var ga = document.createElement('script');
  var curProtocol = window.location.protocol.split(':')[0];
  ga.src = 'https://www.googletagmanager.com/gtag/js?id=UA-129382678-1';       
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(ga, s);
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-129382678-1');
})()</script><script>(function(){
    if(location.host!=='alili.tech')return;
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script>if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
          navigator.serviceWorker
              .register('/sw.js')
              .then(registration => {
                  console.log('SW registered: ', registration);
              })
              .catch(registrationError => {
                  console.log('SW registration failed: ', registrationError);
              });
      });
  }</script></body></html>